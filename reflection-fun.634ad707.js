// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"70Ywo":[function(require,module,exports) {
"use strict";
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "f32d1f38634ad707";
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('ðŸš¨ [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] ðŸš¨ Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] âœ¨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>ðŸ’¡ ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                var oldDeps = modules[asset.id][1];
                for(var dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    var id = oldDeps[dep];
                    var parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    var modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        var deps = modules[id1][1];
        var orphans = [];
        for(var dep in deps){
            var parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach(function(id) {
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    var parents = getParents(module.bundle.root, id);
    var accepted = false;
    while(parents.length > 0){
        var v = parents.shift();
        var a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            var p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push.apply(parents, _toConsumableArray(p));
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"a6i2s":[function(require,module,exports) {
var _three = require("three");
var _orbitControls = require("three/examples/jsm/controls/OrbitControls");
var _reflector = require("./reflector");
var _rectAreaLightUniformsLib = require("three/examples/jsm/lights/RectAreaLightUniformsLib");
var _unrealBloomPass = require("three/examples/jsm/postprocessing/UnrealBloomPass");
var _effectComposer = require("three/examples/jsm/postprocessing/EffectComposer");
var _renderPass = require("three/examples/jsm/postprocessing/RenderPass");
var _shaderPass = require("three/examples/jsm/postprocessing/ShaderPass");
var _filmPass = require("three/examples/jsm/postprocessing/FilmPass");
let renderer, scene, bloomComposer, camera, finalComposer, groundMirror, rectLight1, rectLightHelper1;
const BLOOM_SCENE = 1;
const bloomLayer = new _three.Layers();
bloomLayer.set(BLOOM_SCENE);
init();
function init() {
    renderer = new _three.WebGLRenderer();
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setAnimationLoop(animation);
    document.body.appendChild(renderer.domElement);
    const textureLoader = new _three.TextureLoader();
    const concreteDiffuseMap = textureLoader.load("./assets/concrete/Concrete019_1K_Color.jpg");
    const concreteNormalMap = textureLoader.load("./assets/concrete/Concrete019_1K_NormalGL.jpg");
    concreteDiffuseMap.wrapS = concreteDiffuseMap.wrapT = _three.RepeatWrapping;
    concreteNormalMap.wrapS = concreteNormalMap.wrapT = _three.RepeatWrapping;
    concreteDiffuseMap.repeat.set(10, 10);
    concreteNormalMap.repeat.set(10, 10);
    camera = new _three.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.set(0, 15, -25);
    scene = new _three.Scene();
    _rectAreaLightUniformsLib.RectAreaLightUniformsLib.init();
    const lightWidth = 8;
    const lightHeight = 50;
    const lightColor = 16733440;
    rectLight1 = new _three.RectAreaLight(lightColor, 10, lightWidth, lightHeight);
    const areaLightPlaneGeometry = new _three.PlaneGeometry(lightWidth, lightHeight);
    const areaLightPlane = new _three.Mesh(areaLightPlaneGeometry, new _three.MeshBasicMaterial({
        color: lightColor
    }));
    areaLightPlane.rotateX(Math.PI);
    rectLight1.position.set(0, lightHeight / 2, 66.8);
    areaLightPlane.position.set(0, lightHeight / 2, 66.8);
    scene.add(rectLight1);
    scene.add(areaLightPlane);
    areaLightPlane.layers.enable(BLOOM_SCENE);
    const geoFloor = new _three.PlaneGeometry(100, 100);
    groundMirror = new _reflector.Reflector(geoFloor, {
        clipBias: 0.003,
        textureWidth: window.innerWidth * window.devicePixelRatio,
        textureHeight: window.innerHeight * window.devicePixelRatio,
        color: 16777215,
        transparent: true,
        opacity: 0.4,
        depthFunc: _three.EqualDepth
    });
    groundMirror.rotateX(-Math.PI / 2);
    groundMirror.rotateZ(Math.PI / 4);
    scene.add(groundMirror);
    const matStdFloor = new _three.MeshStandardMaterial({
        color: 16777215,
        roughness: 0.2,
        metalness: 0,
        normalMap: concreteNormalMap,
        map: concreteDiffuseMap
    });
    const mshStdFloor = new _three.Mesh(geoFloor, matStdFloor);
    mshStdFloor.rotateX(-Math.PI / 2);
    mshStdFloor.rotateZ(Math.PI / 4);
    scene.add(mshStdFloor);
    const geoKnot = new _three.TorusKnotGeometry(1.5, 0.5, 200, 16);
    const matKnot = new _three.MeshStandardMaterial({
        color: 16777215,
        roughness: 0,
        metalness: 0
    });
    const meshKnot = new _three.Mesh(geoKnot, matKnot);
    meshKnot.name = "meshKnot";
    meshKnot.position.set(0, 3, 24);
    scene.add(meshKnot);
    const controls = new _orbitControls.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 15, 100);
    controls.update();
    controls.enabled = false;
    window.addEventListener("resize", onWindowResize);
    // Add render passes
    const renderPass = new _renderPass.RenderPass(scene, camera);
    const bloomPass = new _unrealBloomPass.UnrealBloomPass(new _three.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    const params = {
        exposure: 1,
        bloomStrength: 1,
        bloomThreshold: 0,
        bloomRadius: 1
    };
    bloomPass.threshold = params.bloomThreshold;
    bloomPass.strength = params.bloomStrength;
    bloomPass.radius = params.bloomRadius;
    bloomComposer = new _effectComposer.EffectComposer(renderer);
    bloomComposer.renderToScreen = false;
    bloomComposer.addPass(renderPass); // We'll darken non-bloomy things
    bloomComposer.addPass(bloomPass);
    const finalPass = new _shaderPass.ShaderPass(new _three.ShaderMaterial({
        uniforms: {
            baseTexture: {
                value: null
            },
            bloomTexture: {
                value: bloomComposer.renderTarget2.texture
            }
        },
        vertexShader: `
				varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
        fragmentShader: `
				uniform sampler2D baseTexture;
				uniform sampler2D bloomTexture;

				varying vec2 vUv;

				void main() {
					gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );
				}`,
        defines: {}
    }), "baseTexture");
    finalPass.needsSwap = true;
    finalComposer = new _effectComposer.EffectComposer(renderer);
    finalComposer.addPass(renderPass);
    finalComposer.addPass(finalPass);
    finalComposer.addPass(new _filmPass.FilmPass(0.35, 0, 0, false));
}
function onWindowResize() {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
}
function animation(time) {
    const mesh = scene.getObjectByName("meshKnot");
    mesh.rotation.y = time / 1000;
    // Render bloom-enabled things to bloom texture
    renderBloom();
    finalComposer.render(0.01); // 0.01 is arbitrary for film pass
}
function renderBloom() {
    scene.traverse(darkenNonBloomed);
    groundMirror.visible = false;
    bloomComposer.render();
    scene.traverse(restoreDarkenedMaterial);
    groundMirror.visible = true;
}
const darkMaterial = new _three.MeshBasicMaterial({
    color: "black"
});
const materials = {};
function darkenNonBloomed(obj) {
    if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
        materials[obj.uuid] = obj.material;
        obj.material = darkMaterial;
    }
}
function restoreDarkenedMaterial(obj) {
    if (materials[obj.uuid]) {
        obj.material = materials[obj.uuid];
        delete materials[obj.uuid];
    }
}

},{"three":"ktPTu","three/examples/jsm/controls/OrbitControls":"7mqRv","./reflector":"aru41","three/examples/jsm/lights/RectAreaLightUniformsLib":"kWNzB","three/examples/jsm/postprocessing/UnrealBloomPass":"3iDYE","three/examples/jsm/postprocessing/EffectComposer":"e5jie","three/examples/jsm/postprocessing/RenderPass":"hXnUO","three/examples/jsm/postprocessing/ShaderPass":"5IxTN","three/examples/jsm/postprocessing/FilmPass":"31sSt"}],"ktPTu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ACESFilmicToneMapping", ()=>ACESFilmicToneMapping
);
parcelHelpers.export(exports, "AddEquation", ()=>AddEquation
);
parcelHelpers.export(exports, "AddOperation", ()=>AddOperation
);
parcelHelpers.export(exports, "AdditiveAnimationBlendMode", ()=>AdditiveAnimationBlendMode
);
parcelHelpers.export(exports, "AdditiveBlending", ()=>AdditiveBlending
);
parcelHelpers.export(exports, "AlphaFormat", ()=>AlphaFormat
);
parcelHelpers.export(exports, "AlwaysDepth", ()=>AlwaysDepth
);
parcelHelpers.export(exports, "AlwaysStencilFunc", ()=>AlwaysStencilFunc
);
parcelHelpers.export(exports, "AmbientLight", ()=>AmbientLight
);
parcelHelpers.export(exports, "AmbientLightProbe", ()=>AmbientLightProbe
);
parcelHelpers.export(exports, "AnimationClip", ()=>AnimationClip
);
parcelHelpers.export(exports, "AnimationLoader", ()=>AnimationLoader
);
parcelHelpers.export(exports, "AnimationMixer", ()=>AnimationMixer
);
parcelHelpers.export(exports, "AnimationObjectGroup", ()=>AnimationObjectGroup
);
parcelHelpers.export(exports, "AnimationUtils", ()=>AnimationUtils
);
parcelHelpers.export(exports, "ArcCurve", ()=>ArcCurve
);
parcelHelpers.export(exports, "ArrayCamera", ()=>ArrayCamera
);
parcelHelpers.export(exports, "ArrowHelper", ()=>ArrowHelper
);
parcelHelpers.export(exports, "Audio", ()=>Audio
);
parcelHelpers.export(exports, "AudioAnalyser", ()=>AudioAnalyser
);
parcelHelpers.export(exports, "AudioContext", ()=>AudioContext
);
parcelHelpers.export(exports, "AudioListener", ()=>AudioListener
);
parcelHelpers.export(exports, "AudioLoader", ()=>AudioLoader
);
parcelHelpers.export(exports, "AxesHelper", ()=>AxesHelper
);
parcelHelpers.export(exports, "AxisHelper", ()=>AxisHelper
);
parcelHelpers.export(exports, "BackSide", ()=>BackSide
);
parcelHelpers.export(exports, "BasicDepthPacking", ()=>BasicDepthPacking
);
parcelHelpers.export(exports, "BasicShadowMap", ()=>BasicShadowMap
);
parcelHelpers.export(exports, "BinaryTextureLoader", ()=>BinaryTextureLoader
);
parcelHelpers.export(exports, "Bone", ()=>Bone
);
parcelHelpers.export(exports, "BooleanKeyframeTrack", ()=>BooleanKeyframeTrack
);
parcelHelpers.export(exports, "BoundingBoxHelper", ()=>BoundingBoxHelper
);
parcelHelpers.export(exports, "Box2", ()=>Box2
);
parcelHelpers.export(exports, "Box3", ()=>Box3
);
parcelHelpers.export(exports, "Box3Helper", ()=>Box3Helper
);
parcelHelpers.export(exports, "BoxBufferGeometry", ()=>BoxGeometry
);
parcelHelpers.export(exports, "BoxGeometry", ()=>BoxGeometry
);
parcelHelpers.export(exports, "BoxHelper", ()=>BoxHelper
);
parcelHelpers.export(exports, "BufferAttribute", ()=>BufferAttribute
);
parcelHelpers.export(exports, "BufferGeometry", ()=>BufferGeometry
);
parcelHelpers.export(exports, "BufferGeometryLoader", ()=>BufferGeometryLoader
);
parcelHelpers.export(exports, "ByteType", ()=>ByteType
);
parcelHelpers.export(exports, "Cache", ()=>Cache
);
parcelHelpers.export(exports, "Camera", ()=>Camera
);
parcelHelpers.export(exports, "CameraHelper", ()=>CameraHelper
);
parcelHelpers.export(exports, "CanvasRenderer", ()=>CanvasRenderer
);
parcelHelpers.export(exports, "CanvasTexture", ()=>CanvasTexture
);
parcelHelpers.export(exports, "CatmullRomCurve3", ()=>CatmullRomCurve3
);
parcelHelpers.export(exports, "CineonToneMapping", ()=>CineonToneMapping
);
parcelHelpers.export(exports, "CircleBufferGeometry", ()=>CircleGeometry
);
parcelHelpers.export(exports, "CircleGeometry", ()=>CircleGeometry
);
parcelHelpers.export(exports, "ClampToEdgeWrapping", ()=>ClampToEdgeWrapping
);
parcelHelpers.export(exports, "Clock", ()=>Clock
);
parcelHelpers.export(exports, "Color", ()=>Color
);
parcelHelpers.export(exports, "ColorKeyframeTrack", ()=>ColorKeyframeTrack
);
parcelHelpers.export(exports, "CompressedTexture", ()=>CompressedTexture
);
parcelHelpers.export(exports, "CompressedTextureLoader", ()=>CompressedTextureLoader
);
parcelHelpers.export(exports, "ConeBufferGeometry", ()=>ConeGeometry
);
parcelHelpers.export(exports, "ConeGeometry", ()=>ConeGeometry
);
parcelHelpers.export(exports, "CubeCamera", ()=>CubeCamera
);
parcelHelpers.export(exports, "CubeReflectionMapping", ()=>CubeReflectionMapping
);
parcelHelpers.export(exports, "CubeRefractionMapping", ()=>CubeRefractionMapping
);
parcelHelpers.export(exports, "CubeTexture", ()=>CubeTexture
);
parcelHelpers.export(exports, "CubeTextureLoader", ()=>CubeTextureLoader
);
parcelHelpers.export(exports, "CubeUVReflectionMapping", ()=>CubeUVReflectionMapping
);
parcelHelpers.export(exports, "CubeUVRefractionMapping", ()=>CubeUVRefractionMapping
);
parcelHelpers.export(exports, "CubicBezierCurve", ()=>CubicBezierCurve
);
parcelHelpers.export(exports, "CubicBezierCurve3", ()=>CubicBezierCurve3
);
parcelHelpers.export(exports, "CubicInterpolant", ()=>CubicInterpolant
);
parcelHelpers.export(exports, "CullFaceBack", ()=>CullFaceBack
);
parcelHelpers.export(exports, "CullFaceFront", ()=>CullFaceFront
);
parcelHelpers.export(exports, "CullFaceFrontBack", ()=>CullFaceFrontBack
);
parcelHelpers.export(exports, "CullFaceNone", ()=>CullFaceNone
);
parcelHelpers.export(exports, "Curve", ()=>Curve
);
parcelHelpers.export(exports, "CurvePath", ()=>CurvePath
);
parcelHelpers.export(exports, "CustomBlending", ()=>CustomBlending
);
parcelHelpers.export(exports, "CustomToneMapping", ()=>CustomToneMapping
);
parcelHelpers.export(exports, "CylinderBufferGeometry", ()=>CylinderGeometry
);
parcelHelpers.export(exports, "CylinderGeometry", ()=>CylinderGeometry
);
parcelHelpers.export(exports, "Cylindrical", ()=>Cylindrical
);
parcelHelpers.export(exports, "DataTexture", ()=>DataTexture
);
parcelHelpers.export(exports, "DataTexture2DArray", ()=>DataTexture2DArray
);
parcelHelpers.export(exports, "DataTexture3D", ()=>DataTexture3D
);
parcelHelpers.export(exports, "DataTextureLoader", ()=>DataTextureLoader
);
parcelHelpers.export(exports, "DataUtils", ()=>DataUtils
);
parcelHelpers.export(exports, "DecrementStencilOp", ()=>DecrementStencilOp
);
parcelHelpers.export(exports, "DecrementWrapStencilOp", ()=>DecrementWrapStencilOp
);
parcelHelpers.export(exports, "DefaultLoadingManager", ()=>DefaultLoadingManager
);
parcelHelpers.export(exports, "DepthFormat", ()=>DepthFormat
);
parcelHelpers.export(exports, "DepthStencilFormat", ()=>DepthStencilFormat
);
parcelHelpers.export(exports, "DepthTexture", ()=>DepthTexture
);
parcelHelpers.export(exports, "DirectionalLight", ()=>DirectionalLight
);
parcelHelpers.export(exports, "DirectionalLightHelper", ()=>DirectionalLightHelper
);
parcelHelpers.export(exports, "DiscreteInterpolant", ()=>DiscreteInterpolant
);
parcelHelpers.export(exports, "DodecahedronBufferGeometry", ()=>DodecahedronGeometry
);
parcelHelpers.export(exports, "DodecahedronGeometry", ()=>DodecahedronGeometry
);
parcelHelpers.export(exports, "DoubleSide", ()=>DoubleSide
);
parcelHelpers.export(exports, "DstAlphaFactor", ()=>DstAlphaFactor
);
parcelHelpers.export(exports, "DstColorFactor", ()=>DstColorFactor
);
parcelHelpers.export(exports, "DynamicBufferAttribute", ()=>DynamicBufferAttribute
);
parcelHelpers.export(exports, "DynamicCopyUsage", ()=>DynamicCopyUsage
);
parcelHelpers.export(exports, "DynamicDrawUsage", ()=>DynamicDrawUsage
);
parcelHelpers.export(exports, "DynamicReadUsage", ()=>DynamicReadUsage
);
parcelHelpers.export(exports, "EdgesGeometry", ()=>EdgesGeometry
);
parcelHelpers.export(exports, "EdgesHelper", ()=>EdgesHelper
);
parcelHelpers.export(exports, "EllipseCurve", ()=>EllipseCurve
);
parcelHelpers.export(exports, "EqualDepth", ()=>EqualDepth
);
parcelHelpers.export(exports, "EqualStencilFunc", ()=>EqualStencilFunc
);
parcelHelpers.export(exports, "EquirectangularReflectionMapping", ()=>EquirectangularReflectionMapping
);
parcelHelpers.export(exports, "EquirectangularRefractionMapping", ()=>EquirectangularRefractionMapping
);
parcelHelpers.export(exports, "Euler", ()=>Euler
);
parcelHelpers.export(exports, "EventDispatcher", ()=>EventDispatcher
);
parcelHelpers.export(exports, "ExtrudeBufferGeometry", ()=>ExtrudeGeometry
);
parcelHelpers.export(exports, "ExtrudeGeometry", ()=>ExtrudeGeometry
);
parcelHelpers.export(exports, "FaceColors", ()=>FaceColors
);
parcelHelpers.export(exports, "FileLoader", ()=>FileLoader
);
parcelHelpers.export(exports, "FlatShading", ()=>FlatShading
);
parcelHelpers.export(exports, "Float16BufferAttribute", ()=>Float16BufferAttribute
);
parcelHelpers.export(exports, "Float32Attribute", ()=>Float32Attribute
);
parcelHelpers.export(exports, "Float32BufferAttribute", ()=>Float32BufferAttribute
);
parcelHelpers.export(exports, "Float64Attribute", ()=>Float64Attribute
);
parcelHelpers.export(exports, "Float64BufferAttribute", ()=>Float64BufferAttribute
);
parcelHelpers.export(exports, "FloatType", ()=>FloatType
);
parcelHelpers.export(exports, "Fog", ()=>Fog
);
parcelHelpers.export(exports, "FogExp2", ()=>FogExp2
);
parcelHelpers.export(exports, "Font", ()=>Font
);
parcelHelpers.export(exports, "FontLoader", ()=>FontLoader
);
parcelHelpers.export(exports, "FrontSide", ()=>FrontSide
);
parcelHelpers.export(exports, "Frustum", ()=>Frustum
);
parcelHelpers.export(exports, "GLBufferAttribute", ()=>GLBufferAttribute
);
parcelHelpers.export(exports, "GLSL1", ()=>GLSL1
);
parcelHelpers.export(exports, "GLSL3", ()=>GLSL3
);
parcelHelpers.export(exports, "GammaEncoding", ()=>GammaEncoding
);
parcelHelpers.export(exports, "GreaterDepth", ()=>GreaterDepth
);
parcelHelpers.export(exports, "GreaterEqualDepth", ()=>GreaterEqualDepth
);
parcelHelpers.export(exports, "GreaterEqualStencilFunc", ()=>GreaterEqualStencilFunc
);
parcelHelpers.export(exports, "GreaterStencilFunc", ()=>GreaterStencilFunc
);
parcelHelpers.export(exports, "GridHelper", ()=>GridHelper
);
parcelHelpers.export(exports, "Group", ()=>Group
);
parcelHelpers.export(exports, "HalfFloatType", ()=>HalfFloatType
);
parcelHelpers.export(exports, "HemisphereLight", ()=>HemisphereLight
);
parcelHelpers.export(exports, "HemisphereLightHelper", ()=>HemisphereLightHelper
);
parcelHelpers.export(exports, "HemisphereLightProbe", ()=>HemisphereLightProbe
);
parcelHelpers.export(exports, "IcosahedronBufferGeometry", ()=>IcosahedronGeometry
);
parcelHelpers.export(exports, "IcosahedronGeometry", ()=>IcosahedronGeometry
);
parcelHelpers.export(exports, "ImageBitmapLoader", ()=>ImageBitmapLoader
);
parcelHelpers.export(exports, "ImageLoader", ()=>ImageLoader
);
parcelHelpers.export(exports, "ImageUtils", ()=>ImageUtils
);
parcelHelpers.export(exports, "ImmediateRenderObject", ()=>ImmediateRenderObject
);
parcelHelpers.export(exports, "IncrementStencilOp", ()=>IncrementStencilOp
);
parcelHelpers.export(exports, "IncrementWrapStencilOp", ()=>IncrementWrapStencilOp
);
parcelHelpers.export(exports, "InstancedBufferAttribute", ()=>InstancedBufferAttribute
);
parcelHelpers.export(exports, "InstancedBufferGeometry", ()=>InstancedBufferGeometry
);
parcelHelpers.export(exports, "InstancedInterleavedBuffer", ()=>InstancedInterleavedBuffer
);
parcelHelpers.export(exports, "InstancedMesh", ()=>InstancedMesh
);
parcelHelpers.export(exports, "Int16Attribute", ()=>Int16Attribute
);
parcelHelpers.export(exports, "Int16BufferAttribute", ()=>Int16BufferAttribute
);
parcelHelpers.export(exports, "Int32Attribute", ()=>Int32Attribute
);
parcelHelpers.export(exports, "Int32BufferAttribute", ()=>Int32BufferAttribute
);
parcelHelpers.export(exports, "Int8Attribute", ()=>Int8Attribute
);
parcelHelpers.export(exports, "Int8BufferAttribute", ()=>Int8BufferAttribute
);
parcelHelpers.export(exports, "IntType", ()=>IntType
);
parcelHelpers.export(exports, "InterleavedBuffer", ()=>InterleavedBuffer
);
parcelHelpers.export(exports, "InterleavedBufferAttribute", ()=>InterleavedBufferAttribute
);
parcelHelpers.export(exports, "Interpolant", ()=>Interpolant
);
parcelHelpers.export(exports, "InterpolateDiscrete", ()=>InterpolateDiscrete
);
parcelHelpers.export(exports, "InterpolateLinear", ()=>InterpolateLinear
);
parcelHelpers.export(exports, "InterpolateSmooth", ()=>InterpolateSmooth
);
parcelHelpers.export(exports, "InvertStencilOp", ()=>InvertStencilOp
);
parcelHelpers.export(exports, "JSONLoader", ()=>JSONLoader
);
parcelHelpers.export(exports, "KeepStencilOp", ()=>KeepStencilOp
);
parcelHelpers.export(exports, "KeyframeTrack", ()=>KeyframeTrack
);
parcelHelpers.export(exports, "LOD", ()=>LOD
);
parcelHelpers.export(exports, "LatheBufferGeometry", ()=>LatheGeometry
);
parcelHelpers.export(exports, "LatheGeometry", ()=>LatheGeometry
);
parcelHelpers.export(exports, "Layers", ()=>Layers
);
parcelHelpers.export(exports, "LensFlare", ()=>LensFlare
);
parcelHelpers.export(exports, "LessDepth", ()=>LessDepth
);
parcelHelpers.export(exports, "LessEqualDepth", ()=>LessEqualDepth
);
parcelHelpers.export(exports, "LessEqualStencilFunc", ()=>LessEqualStencilFunc
);
parcelHelpers.export(exports, "LessStencilFunc", ()=>LessStencilFunc
);
parcelHelpers.export(exports, "Light", ()=>Light
);
parcelHelpers.export(exports, "LightProbe", ()=>LightProbe
);
parcelHelpers.export(exports, "Line", ()=>Line
);
parcelHelpers.export(exports, "Line3", ()=>Line3
);
parcelHelpers.export(exports, "LineBasicMaterial", ()=>LineBasicMaterial
);
parcelHelpers.export(exports, "LineCurve", ()=>LineCurve
);
parcelHelpers.export(exports, "LineCurve3", ()=>LineCurve3
);
parcelHelpers.export(exports, "LineDashedMaterial", ()=>LineDashedMaterial
);
parcelHelpers.export(exports, "LineLoop", ()=>LineLoop
);
parcelHelpers.export(exports, "LinePieces", ()=>LinePieces
);
parcelHelpers.export(exports, "LineSegments", ()=>LineSegments
);
parcelHelpers.export(exports, "LineStrip", ()=>LineStrip
);
parcelHelpers.export(exports, "LinearEncoding", ()=>LinearEncoding
);
parcelHelpers.export(exports, "LinearFilter", ()=>LinearFilter
);
parcelHelpers.export(exports, "LinearInterpolant", ()=>LinearInterpolant
);
parcelHelpers.export(exports, "LinearMipMapLinearFilter", ()=>LinearMipMapLinearFilter
);
parcelHelpers.export(exports, "LinearMipMapNearestFilter", ()=>LinearMipMapNearestFilter
);
parcelHelpers.export(exports, "LinearMipmapLinearFilter", ()=>LinearMipmapLinearFilter
);
parcelHelpers.export(exports, "LinearMipmapNearestFilter", ()=>LinearMipmapNearestFilter
);
parcelHelpers.export(exports, "LinearToneMapping", ()=>LinearToneMapping
);
parcelHelpers.export(exports, "Loader", ()=>Loader
);
parcelHelpers.export(exports, "LoaderUtils", ()=>LoaderUtils
);
parcelHelpers.export(exports, "LoadingManager", ()=>LoadingManager
);
parcelHelpers.export(exports, "LogLuvEncoding", ()=>LogLuvEncoding
);
parcelHelpers.export(exports, "LoopOnce", ()=>LoopOnce
);
parcelHelpers.export(exports, "LoopPingPong", ()=>LoopPingPong
);
parcelHelpers.export(exports, "LoopRepeat", ()=>LoopRepeat
);
parcelHelpers.export(exports, "LuminanceAlphaFormat", ()=>LuminanceAlphaFormat
);
parcelHelpers.export(exports, "LuminanceFormat", ()=>LuminanceFormat
);
parcelHelpers.export(exports, "MOUSE", ()=>MOUSE
);
parcelHelpers.export(exports, "Material", ()=>Material
);
parcelHelpers.export(exports, "MaterialLoader", ()=>MaterialLoader
);
parcelHelpers.export(exports, "Math", ()=>MathUtils
);
parcelHelpers.export(exports, "MathUtils", ()=>MathUtils
);
parcelHelpers.export(exports, "Matrix3", ()=>Matrix3
);
parcelHelpers.export(exports, "Matrix4", ()=>Matrix4
);
parcelHelpers.export(exports, "MaxEquation", ()=>MaxEquation
);
parcelHelpers.export(exports, "Mesh", ()=>Mesh
);
parcelHelpers.export(exports, "MeshBasicMaterial", ()=>MeshBasicMaterial
);
parcelHelpers.export(exports, "MeshDepthMaterial", ()=>MeshDepthMaterial
);
parcelHelpers.export(exports, "MeshDistanceMaterial", ()=>MeshDistanceMaterial
);
parcelHelpers.export(exports, "MeshFaceMaterial", ()=>MeshFaceMaterial
);
parcelHelpers.export(exports, "MeshLambertMaterial", ()=>MeshLambertMaterial
);
parcelHelpers.export(exports, "MeshMatcapMaterial", ()=>MeshMatcapMaterial
);
parcelHelpers.export(exports, "MeshNormalMaterial", ()=>MeshNormalMaterial
);
parcelHelpers.export(exports, "MeshPhongMaterial", ()=>MeshPhongMaterial
);
parcelHelpers.export(exports, "MeshPhysicalMaterial", ()=>MeshPhysicalMaterial
);
parcelHelpers.export(exports, "MeshStandardMaterial", ()=>MeshStandardMaterial
);
parcelHelpers.export(exports, "MeshToonMaterial", ()=>MeshToonMaterial
);
parcelHelpers.export(exports, "MinEquation", ()=>MinEquation
);
parcelHelpers.export(exports, "MirroredRepeatWrapping", ()=>MirroredRepeatWrapping
);
parcelHelpers.export(exports, "MixOperation", ()=>MixOperation
);
parcelHelpers.export(exports, "MultiMaterial", ()=>MultiMaterial
);
parcelHelpers.export(exports, "MultiplyBlending", ()=>MultiplyBlending
);
parcelHelpers.export(exports, "MultiplyOperation", ()=>MultiplyOperation
);
parcelHelpers.export(exports, "NearestFilter", ()=>NearestFilter
);
parcelHelpers.export(exports, "NearestMipMapLinearFilter", ()=>NearestMipMapLinearFilter
);
parcelHelpers.export(exports, "NearestMipMapNearestFilter", ()=>NearestMipMapNearestFilter
);
parcelHelpers.export(exports, "NearestMipmapLinearFilter", ()=>NearestMipmapLinearFilter
);
parcelHelpers.export(exports, "NearestMipmapNearestFilter", ()=>NearestMipmapNearestFilter
);
parcelHelpers.export(exports, "NeverDepth", ()=>NeverDepth
);
parcelHelpers.export(exports, "NeverStencilFunc", ()=>NeverStencilFunc
);
parcelHelpers.export(exports, "NoBlending", ()=>NoBlending
);
parcelHelpers.export(exports, "NoColors", ()=>NoColors
);
parcelHelpers.export(exports, "NoToneMapping", ()=>NoToneMapping
);
parcelHelpers.export(exports, "NormalAnimationBlendMode", ()=>NormalAnimationBlendMode
);
parcelHelpers.export(exports, "NormalBlending", ()=>NormalBlending
);
parcelHelpers.export(exports, "NotEqualDepth", ()=>NotEqualDepth
);
parcelHelpers.export(exports, "NotEqualStencilFunc", ()=>NotEqualStencilFunc
);
parcelHelpers.export(exports, "NumberKeyframeTrack", ()=>NumberKeyframeTrack
);
parcelHelpers.export(exports, "Object3D", ()=>Object3D
);
parcelHelpers.export(exports, "ObjectLoader", ()=>ObjectLoader
);
parcelHelpers.export(exports, "ObjectSpaceNormalMap", ()=>ObjectSpaceNormalMap
);
parcelHelpers.export(exports, "OctahedronBufferGeometry", ()=>OctahedronGeometry
);
parcelHelpers.export(exports, "OctahedronGeometry", ()=>OctahedronGeometry
);
parcelHelpers.export(exports, "OneFactor", ()=>OneFactor
);
parcelHelpers.export(exports, "OneMinusDstAlphaFactor", ()=>OneMinusDstAlphaFactor
);
parcelHelpers.export(exports, "OneMinusDstColorFactor", ()=>OneMinusDstColorFactor
);
parcelHelpers.export(exports, "OneMinusSrcAlphaFactor", ()=>OneMinusSrcAlphaFactor
);
parcelHelpers.export(exports, "OneMinusSrcColorFactor", ()=>OneMinusSrcColorFactor
);
parcelHelpers.export(exports, "OrthographicCamera", ()=>OrthographicCamera
);
parcelHelpers.export(exports, "PCFShadowMap", ()=>PCFShadowMap
);
parcelHelpers.export(exports, "PCFSoftShadowMap", ()=>PCFSoftShadowMap
);
parcelHelpers.export(exports, "PMREMGenerator", ()=>PMREMGenerator
);
parcelHelpers.export(exports, "ParametricBufferGeometry", ()=>ParametricGeometry
);
parcelHelpers.export(exports, "ParametricGeometry", ()=>ParametricGeometry
);
parcelHelpers.export(exports, "Particle", ()=>Particle
);
parcelHelpers.export(exports, "ParticleBasicMaterial", ()=>ParticleBasicMaterial
);
parcelHelpers.export(exports, "ParticleSystem", ()=>ParticleSystem
);
parcelHelpers.export(exports, "ParticleSystemMaterial", ()=>ParticleSystemMaterial
);
parcelHelpers.export(exports, "Path", ()=>Path
);
parcelHelpers.export(exports, "PerspectiveCamera", ()=>PerspectiveCamera
);
parcelHelpers.export(exports, "Plane", ()=>Plane
);
parcelHelpers.export(exports, "PlaneBufferGeometry", ()=>PlaneGeometry
);
parcelHelpers.export(exports, "PlaneGeometry", ()=>PlaneGeometry
);
parcelHelpers.export(exports, "PlaneHelper", ()=>PlaneHelper
);
parcelHelpers.export(exports, "PointCloud", ()=>PointCloud
);
parcelHelpers.export(exports, "PointCloudMaterial", ()=>PointCloudMaterial
);
parcelHelpers.export(exports, "PointLight", ()=>PointLight
);
parcelHelpers.export(exports, "PointLightHelper", ()=>PointLightHelper
);
parcelHelpers.export(exports, "Points", ()=>Points
);
parcelHelpers.export(exports, "PointsMaterial", ()=>PointsMaterial
);
parcelHelpers.export(exports, "PolarGridHelper", ()=>PolarGridHelper
);
parcelHelpers.export(exports, "PolyhedronBufferGeometry", ()=>PolyhedronGeometry
);
parcelHelpers.export(exports, "PolyhedronGeometry", ()=>PolyhedronGeometry
);
parcelHelpers.export(exports, "PositionalAudio", ()=>PositionalAudio
);
parcelHelpers.export(exports, "PropertyBinding", ()=>PropertyBinding
);
parcelHelpers.export(exports, "PropertyMixer", ()=>PropertyMixer
);
parcelHelpers.export(exports, "QuadraticBezierCurve", ()=>QuadraticBezierCurve
);
parcelHelpers.export(exports, "QuadraticBezierCurve3", ()=>QuadraticBezierCurve3
);
parcelHelpers.export(exports, "Quaternion", ()=>Quaternion
);
parcelHelpers.export(exports, "QuaternionKeyframeTrack", ()=>QuaternionKeyframeTrack
);
parcelHelpers.export(exports, "QuaternionLinearInterpolant", ()=>QuaternionLinearInterpolant
);
parcelHelpers.export(exports, "REVISION", ()=>REVISION
);
parcelHelpers.export(exports, "RGBADepthPacking", ()=>RGBADepthPacking
);
parcelHelpers.export(exports, "RGBAFormat", ()=>RGBAFormat
);
parcelHelpers.export(exports, "RGBAIntegerFormat", ()=>RGBAIntegerFormat
);
parcelHelpers.export(exports, "RGBA_ASTC_10x10_Format", ()=>RGBA_ASTC_10x10_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_10x5_Format", ()=>RGBA_ASTC_10x5_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_10x6_Format", ()=>RGBA_ASTC_10x6_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_10x8_Format", ()=>RGBA_ASTC_10x8_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_12x10_Format", ()=>RGBA_ASTC_12x10_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_12x12_Format", ()=>RGBA_ASTC_12x12_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_4x4_Format", ()=>RGBA_ASTC_4x4_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_5x4_Format", ()=>RGBA_ASTC_5x4_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_5x5_Format", ()=>RGBA_ASTC_5x5_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_6x5_Format", ()=>RGBA_ASTC_6x5_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_6x6_Format", ()=>RGBA_ASTC_6x6_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_8x5_Format", ()=>RGBA_ASTC_8x5_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_8x6_Format", ()=>RGBA_ASTC_8x6_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_8x8_Format", ()=>RGBA_ASTC_8x8_Format
);
parcelHelpers.export(exports, "RGBA_BPTC_Format", ()=>RGBA_BPTC_Format
);
parcelHelpers.export(exports, "RGBA_ETC2_EAC_Format", ()=>RGBA_ETC2_EAC_Format
);
parcelHelpers.export(exports, "RGBA_PVRTC_2BPPV1_Format", ()=>RGBA_PVRTC_2BPPV1_Format
);
parcelHelpers.export(exports, "RGBA_PVRTC_4BPPV1_Format", ()=>RGBA_PVRTC_4BPPV1_Format
);
parcelHelpers.export(exports, "RGBA_S3TC_DXT1_Format", ()=>RGBA_S3TC_DXT1_Format
);
parcelHelpers.export(exports, "RGBA_S3TC_DXT3_Format", ()=>RGBA_S3TC_DXT3_Format
);
parcelHelpers.export(exports, "RGBA_S3TC_DXT5_Format", ()=>RGBA_S3TC_DXT5_Format
);
parcelHelpers.export(exports, "RGBDEncoding", ()=>RGBDEncoding
);
parcelHelpers.export(exports, "RGBEEncoding", ()=>RGBEEncoding
);
parcelHelpers.export(exports, "RGBEFormat", ()=>RGBEFormat
);
parcelHelpers.export(exports, "RGBFormat", ()=>RGBFormat
);
parcelHelpers.export(exports, "RGBIntegerFormat", ()=>RGBIntegerFormat
);
parcelHelpers.export(exports, "RGBM16Encoding", ()=>RGBM16Encoding
);
parcelHelpers.export(exports, "RGBM7Encoding", ()=>RGBM7Encoding
);
parcelHelpers.export(exports, "RGB_ETC1_Format", ()=>RGB_ETC1_Format
);
parcelHelpers.export(exports, "RGB_ETC2_Format", ()=>RGB_ETC2_Format
);
parcelHelpers.export(exports, "RGB_PVRTC_2BPPV1_Format", ()=>RGB_PVRTC_2BPPV1_Format
);
parcelHelpers.export(exports, "RGB_PVRTC_4BPPV1_Format", ()=>RGB_PVRTC_4BPPV1_Format
);
parcelHelpers.export(exports, "RGB_S3TC_DXT1_Format", ()=>RGB_S3TC_DXT1_Format
);
parcelHelpers.export(exports, "RGFormat", ()=>RGFormat
);
parcelHelpers.export(exports, "RGIntegerFormat", ()=>RGIntegerFormat
);
parcelHelpers.export(exports, "RawShaderMaterial", ()=>RawShaderMaterial
);
parcelHelpers.export(exports, "Ray", ()=>Ray
);
parcelHelpers.export(exports, "Raycaster", ()=>Raycaster
);
parcelHelpers.export(exports, "RectAreaLight", ()=>RectAreaLight
);
parcelHelpers.export(exports, "RedFormat", ()=>RedFormat
);
parcelHelpers.export(exports, "RedIntegerFormat", ()=>RedIntegerFormat
);
parcelHelpers.export(exports, "ReinhardToneMapping", ()=>ReinhardToneMapping
);
parcelHelpers.export(exports, "RepeatWrapping", ()=>RepeatWrapping
);
parcelHelpers.export(exports, "ReplaceStencilOp", ()=>ReplaceStencilOp
);
parcelHelpers.export(exports, "ReverseSubtractEquation", ()=>ReverseSubtractEquation
);
parcelHelpers.export(exports, "RingBufferGeometry", ()=>RingGeometry
);
parcelHelpers.export(exports, "RingGeometry", ()=>RingGeometry
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_10x10_Format", ()=>SRGB8_ALPHA8_ASTC_10x10_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_10x5_Format", ()=>SRGB8_ALPHA8_ASTC_10x5_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_10x6_Format", ()=>SRGB8_ALPHA8_ASTC_10x6_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_10x8_Format", ()=>SRGB8_ALPHA8_ASTC_10x8_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_12x10_Format", ()=>SRGB8_ALPHA8_ASTC_12x10_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_12x12_Format", ()=>SRGB8_ALPHA8_ASTC_12x12_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_4x4_Format", ()=>SRGB8_ALPHA8_ASTC_4x4_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_5x4_Format", ()=>SRGB8_ALPHA8_ASTC_5x4_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_5x5_Format", ()=>SRGB8_ALPHA8_ASTC_5x5_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_6x5_Format", ()=>SRGB8_ALPHA8_ASTC_6x5_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_6x6_Format", ()=>SRGB8_ALPHA8_ASTC_6x6_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_8x5_Format", ()=>SRGB8_ALPHA8_ASTC_8x5_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_8x6_Format", ()=>SRGB8_ALPHA8_ASTC_8x6_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_8x8_Format", ()=>SRGB8_ALPHA8_ASTC_8x8_Format
);
parcelHelpers.export(exports, "Scene", ()=>Scene
);
parcelHelpers.export(exports, "SceneUtils", ()=>SceneUtils
);
parcelHelpers.export(exports, "ShaderChunk", ()=>ShaderChunk
);
parcelHelpers.export(exports, "ShaderLib", ()=>ShaderLib
);
parcelHelpers.export(exports, "ShaderMaterial", ()=>ShaderMaterial
);
parcelHelpers.export(exports, "ShadowMaterial", ()=>ShadowMaterial
);
parcelHelpers.export(exports, "Shape", ()=>Shape
);
parcelHelpers.export(exports, "ShapeBufferGeometry", ()=>ShapeGeometry
);
parcelHelpers.export(exports, "ShapeGeometry", ()=>ShapeGeometry
);
parcelHelpers.export(exports, "ShapePath", ()=>ShapePath
);
parcelHelpers.export(exports, "ShapeUtils", ()=>ShapeUtils
);
parcelHelpers.export(exports, "ShortType", ()=>ShortType
);
parcelHelpers.export(exports, "Skeleton", ()=>Skeleton
);
parcelHelpers.export(exports, "SkeletonHelper", ()=>SkeletonHelper
);
parcelHelpers.export(exports, "SkinnedMesh", ()=>SkinnedMesh
);
parcelHelpers.export(exports, "SmoothShading", ()=>SmoothShading
);
parcelHelpers.export(exports, "Sphere", ()=>Sphere
);
parcelHelpers.export(exports, "SphereBufferGeometry", ()=>SphereGeometry
);
parcelHelpers.export(exports, "SphereGeometry", ()=>SphereGeometry
);
parcelHelpers.export(exports, "Spherical", ()=>Spherical
);
parcelHelpers.export(exports, "SphericalHarmonics3", ()=>SphericalHarmonics3
);
parcelHelpers.export(exports, "SplineCurve", ()=>SplineCurve
);
parcelHelpers.export(exports, "SpotLight", ()=>SpotLight
);
parcelHelpers.export(exports, "SpotLightHelper", ()=>SpotLightHelper
);
parcelHelpers.export(exports, "Sprite", ()=>Sprite
);
parcelHelpers.export(exports, "SpriteMaterial", ()=>SpriteMaterial
);
parcelHelpers.export(exports, "SrcAlphaFactor", ()=>SrcAlphaFactor
);
parcelHelpers.export(exports, "SrcAlphaSaturateFactor", ()=>SrcAlphaSaturateFactor
);
parcelHelpers.export(exports, "SrcColorFactor", ()=>SrcColorFactor
);
parcelHelpers.export(exports, "StaticCopyUsage", ()=>StaticCopyUsage
);
parcelHelpers.export(exports, "StaticDrawUsage", ()=>StaticDrawUsage
);
parcelHelpers.export(exports, "StaticReadUsage", ()=>StaticReadUsage
);
parcelHelpers.export(exports, "StereoCamera", ()=>StereoCamera
);
parcelHelpers.export(exports, "StreamCopyUsage", ()=>StreamCopyUsage
);
parcelHelpers.export(exports, "StreamDrawUsage", ()=>StreamDrawUsage
);
parcelHelpers.export(exports, "StreamReadUsage", ()=>StreamReadUsage
);
parcelHelpers.export(exports, "StringKeyframeTrack", ()=>StringKeyframeTrack
);
parcelHelpers.export(exports, "SubtractEquation", ()=>SubtractEquation
);
parcelHelpers.export(exports, "SubtractiveBlending", ()=>SubtractiveBlending
);
parcelHelpers.export(exports, "TOUCH", ()=>TOUCH
);
parcelHelpers.export(exports, "TangentSpaceNormalMap", ()=>TangentSpaceNormalMap
);
parcelHelpers.export(exports, "TetrahedronBufferGeometry", ()=>TetrahedronGeometry
);
parcelHelpers.export(exports, "TetrahedronGeometry", ()=>TetrahedronGeometry
);
parcelHelpers.export(exports, "TextBufferGeometry", ()=>TextGeometry
);
parcelHelpers.export(exports, "TextGeometry", ()=>TextGeometry
);
parcelHelpers.export(exports, "Texture", ()=>Texture
);
parcelHelpers.export(exports, "TextureLoader", ()=>TextureLoader
);
parcelHelpers.export(exports, "TorusBufferGeometry", ()=>TorusGeometry
);
parcelHelpers.export(exports, "TorusGeometry", ()=>TorusGeometry
);
parcelHelpers.export(exports, "TorusKnotBufferGeometry", ()=>TorusKnotGeometry
);
parcelHelpers.export(exports, "TorusKnotGeometry", ()=>TorusKnotGeometry
);
parcelHelpers.export(exports, "Triangle", ()=>Triangle
);
parcelHelpers.export(exports, "TriangleFanDrawMode", ()=>TriangleFanDrawMode
);
parcelHelpers.export(exports, "TriangleStripDrawMode", ()=>TriangleStripDrawMode
);
parcelHelpers.export(exports, "TrianglesDrawMode", ()=>TrianglesDrawMode
);
parcelHelpers.export(exports, "TubeBufferGeometry", ()=>TubeGeometry
);
parcelHelpers.export(exports, "TubeGeometry", ()=>TubeGeometry
);
parcelHelpers.export(exports, "UVMapping", ()=>UVMapping
);
parcelHelpers.export(exports, "Uint16Attribute", ()=>Uint16Attribute
);
parcelHelpers.export(exports, "Uint16BufferAttribute", ()=>Uint16BufferAttribute
);
parcelHelpers.export(exports, "Uint32Attribute", ()=>Uint32Attribute
);
parcelHelpers.export(exports, "Uint32BufferAttribute", ()=>Uint32BufferAttribute
);
parcelHelpers.export(exports, "Uint8Attribute", ()=>Uint8Attribute
);
parcelHelpers.export(exports, "Uint8BufferAttribute", ()=>Uint8BufferAttribute
);
parcelHelpers.export(exports, "Uint8ClampedAttribute", ()=>Uint8ClampedAttribute
);
parcelHelpers.export(exports, "Uint8ClampedBufferAttribute", ()=>Uint8ClampedBufferAttribute
);
parcelHelpers.export(exports, "Uniform", ()=>Uniform
);
parcelHelpers.export(exports, "UniformsLib", ()=>UniformsLib
);
parcelHelpers.export(exports, "UniformsUtils", ()=>UniformsUtils
);
parcelHelpers.export(exports, "UnsignedByteType", ()=>UnsignedByteType
);
parcelHelpers.export(exports, "UnsignedInt248Type", ()=>UnsignedInt248Type
);
parcelHelpers.export(exports, "UnsignedIntType", ()=>UnsignedIntType
);
parcelHelpers.export(exports, "UnsignedShort4444Type", ()=>UnsignedShort4444Type
);
parcelHelpers.export(exports, "UnsignedShort5551Type", ()=>UnsignedShort5551Type
);
parcelHelpers.export(exports, "UnsignedShort565Type", ()=>UnsignedShort565Type
);
parcelHelpers.export(exports, "UnsignedShortType", ()=>UnsignedShortType
);
parcelHelpers.export(exports, "VSMShadowMap", ()=>VSMShadowMap
);
parcelHelpers.export(exports, "Vector2", ()=>Vector2
);
parcelHelpers.export(exports, "Vector3", ()=>Vector3
);
parcelHelpers.export(exports, "Vector4", ()=>Vector4
);
parcelHelpers.export(exports, "VectorKeyframeTrack", ()=>VectorKeyframeTrack
);
parcelHelpers.export(exports, "Vertex", ()=>Vertex
);
parcelHelpers.export(exports, "VertexColors", ()=>VertexColors
);
parcelHelpers.export(exports, "VideoTexture", ()=>VideoTexture
);
parcelHelpers.export(exports, "WebGL1Renderer", ()=>WebGL1Renderer
);
parcelHelpers.export(exports, "WebGLCubeRenderTarget", ()=>WebGLCubeRenderTarget
);
parcelHelpers.export(exports, "WebGLMultipleRenderTargets", ()=>WebGLMultipleRenderTargets
);
parcelHelpers.export(exports, "WebGLMultisampleRenderTarget", ()=>WebGLMultisampleRenderTarget
);
parcelHelpers.export(exports, "WebGLRenderTarget", ()=>WebGLRenderTarget
);
parcelHelpers.export(exports, "WebGLRenderTargetCube", ()=>WebGLRenderTargetCube
);
parcelHelpers.export(exports, "WebGLRenderer", ()=>WebGLRenderer
);
parcelHelpers.export(exports, "WebGLUtils", ()=>WebGLUtils
);
parcelHelpers.export(exports, "WireframeGeometry", ()=>WireframeGeometry
);
parcelHelpers.export(exports, "WireframeHelper", ()=>WireframeHelper
);
parcelHelpers.export(exports, "WrapAroundEnding", ()=>WrapAroundEnding
);
parcelHelpers.export(exports, "XHRLoader", ()=>XHRLoader
);
parcelHelpers.export(exports, "ZeroCurvatureEnding", ()=>ZeroCurvatureEnding
);
parcelHelpers.export(exports, "ZeroFactor", ()=>ZeroFactor
);
parcelHelpers.export(exports, "ZeroSlopeEnding", ()=>ZeroSlopeEnding
);
parcelHelpers.export(exports, "ZeroStencilOp", ()=>ZeroStencilOp
);
parcelHelpers.export(exports, "sRGBEncoding", ()=>sRGBEncoding
);
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const REVISION = '132';
const MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
};
const TOUCH = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
};
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const SmoothShading = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const CubeUVRefractionMapping = 307;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedShort565Type = 1019;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const RGBEFormat = RGBAFormat;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const GammaEncoding = 3007;
const RGBEEncoding = 3002;
const LogLuvEncoding = 3003;
const RGBM7Encoding = 3004;
const RGBM16Encoding = 3005;
const RGBDEncoding = 3006;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;
const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;
const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;
const GLSL1 = '100';
const GLSL3 = '300 es';
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */ class EventDispatcher {
    addEventListener(type, listener) {
        if (this._listeners === undefined) this._listeners = {};
        const listeners = this._listeners;
        if (listeners[type] === undefined) listeners[type] = [];
        if (listeners[type].indexOf(listener) === -1) listeners[type].push(listener);
    }
    hasEventListener(type, listener) {
        if (this._listeners === undefined) return false;
        const listeners = this._listeners;
        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
    }
    removeEventListener(type, listener) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== undefined) {
            const index = listenerArray.indexOf(listener);
            if (index !== -1) listenerArray.splice(index, 1);
        }
    }
    dispatchEvent(event) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            // Make a copy, in case listeners are removed while iterating.
            const array = listenerArray.slice(0);
            for(let i1 = 0, l = array.length; i1 < l; i1++)array[i1].call(this, event);
            event.target = null;
        }
    }
}
const _lut = [];
for(let i = 0; i < 256; i++)_lut[i] = (i < 16 ? '0' : '') + i.toString(16);
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + '-' + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + '-' + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + '-' + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + '-' + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
    // .toUpperCase() here flattens concatenated strings to save heap memory space.
    return uuid.toUpperCase();
}
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
// compute euclidian modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo(n, m) {
    return (n % m + m) % m;
}
// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear(x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}
// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp(x, y, value) {
    if (x !== y) return (value - x) / (y - x);
    else return 0;
}
// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp(x, y, t) {
    return (1 - t) * x + t * y;
}
// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp(x, y, lambda, dt) {
    return lerp(x, y, 1 - Math.exp(-lambda * dt));
}
// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong(x, length = 1) {
    return length - Math.abs(euclideanModulo(x, length * 2) - length);
}
// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep(x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
}
function smootherstep(x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
}
// Random integer from <low, high> interval
function randInt(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
}
// Random float from <low, high> interval
function randFloat(low, high) {
    return low + Math.random() * (high - low);
}
// Random float from <-range/2, range/2> interval
function randFloatSpread(range) {
    return range * (0.5 - Math.random());
}
// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom(s) {
    if (s !== undefined) _seed = s % 2147483647;
    // Park-Miller algorithm
    _seed = _seed * 16807 % 2147483647;
    return (_seed - 1) / 2147483646;
}
function degToRad(degrees) {
    return degrees * DEG2RAD;
}
function radToDeg(radians) {
    return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
    return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a, b, c, order) {
    // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
    // rotations are applied to the axes in the order specified by 'order'
    // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
    // angles are in radians
    const cos = Math.cos;
    const sin = Math.sin;
    const c2 = cos(b / 2);
    const s2 = sin(b / 2);
    const c13 = cos((a + c) / 2);
    const s13 = sin((a + c) / 2);
    const c1_3 = cos((a - c) / 2);
    const s1_3 = sin((a - c) / 2);
    const c3_1 = cos((c - a) / 2);
    const s3_1 = sin((c - a) / 2);
    switch(order){
        case 'XYX':
            q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
            break;
        case 'YZY':
            q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
            break;
        case 'ZXZ':
            q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
            break;
        case 'XZX':
            q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
            break;
        case 'YXY':
            q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
            break;
        case 'ZYZ':
            q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
            break;
        default:
            console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
    }
}
var MathUtils = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    DEG2RAD: DEG2RAD,
    RAD2DEG: RAD2DEG,
    generateUUID: generateUUID,
    clamp: clamp,
    euclideanModulo: euclideanModulo,
    mapLinear: mapLinear,
    inverseLerp: inverseLerp,
    lerp: lerp,
    damp: damp,
    pingpong: pingpong,
    smoothstep: smoothstep,
    smootherstep: smootherstep,
    randInt: randInt,
    randFloat: randFloat,
    randFloatSpread: randFloatSpread,
    seededRandom: seededRandom,
    degToRad: degToRad,
    radToDeg: radToDeg,
    isPowerOfTwo: isPowerOfTwo,
    ceilPowerOfTwo: ceilPowerOfTwo,
    floorPowerOfTwo: floorPowerOfTwo,
    setQuaternionFromProperEuler: setQuaternionFromProperEuler
});
class Vector2 {
    constructor(x = 0, y = 0){
        this.x = x;
        this.y = y;
    }
    get width() {
        return this.x;
    }
    set width(value) {
        this.x = value;
    }
    get height() {
        return this.y;
    }
    set height(value) {
        this.y = value;
    }
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error('index is out of range: ' + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
    }
    multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
    }
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m) {
        const x = this.x, y = this.y;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6];
        this.y = e[1] * x + e[4] * y + e[7];
        return this;
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
    }
    clamp(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    cross(v) {
        return this.x * v.y - this.y * v.x;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    angle() {
        // computes the angle in radians with respect to the positive x-axis
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
    }
    rotateAround(center, angle) {
        const c = Math.cos(angle), s = Math.sin(angle);
        const x = this.x - center.x;
        const y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
    }
}
Vector2.prototype.isVector2 = true;
class Matrix3 {
    constructor(){
        this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ];
        if (arguments.length > 0) console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
    }
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        const te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
    }
    identity() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
    }
    copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
    }
    setFromMatrix4(m) {
        const me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
    }
    multiply(m) {
        return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[3], a13 = ae[6];
        const a21 = ae[1], a22 = ae[4], a23 = ae[7];
        const a31 = ae[2], a32 = ae[5], a33 = ae[8];
        const b11 = be[0], b12 = be[3], b13 = be[6];
        const b21 = be[1], b22 = be[4], b23 = be[7];
        const b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
    }
    multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
    }
    determinant() {
        const te = this.elements;
        const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];
        return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;
    }
    invert() {
        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
    }
    transpose() {
        let tmp1;
        const m = this.elements;
        tmp1 = m[1];
        m[1] = m[3];
        m[3] = tmp1;
        tmp1 = m[2];
        m[2] = m[6];
        m[6] = tmp1;
        tmp1 = m[5];
        m[5] = m[7];
        m[7] = tmp1;
        return this;
    }
    getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).invert().transpose();
    }
    transposeIntoArray(r) {
        const m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        const c = Math.cos(rotation);
        const s = Math.sin(rotation);
        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
        return this;
    }
    scale(sx, sy) {
        const te = this.elements;
        te[0] *= sx;
        te[3] *= sx;
        te[6] *= sx;
        te[1] *= sy;
        te[4] *= sy;
        te[7] *= sy;
        return this;
    }
    rotate(theta) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        const te = this.elements;
        const a11 = te[0], a12 = te[3], a13 = te[6];
        const a21 = te[1], a22 = te[4], a23 = te[7];
        te[0] = c * a11 + s * a21;
        te[3] = c * a12 + s * a22;
        te[6] = c * a13 + s * a23;
        te[1] = -s * a11 + c * a21;
        te[4] = -s * a12 + c * a22;
        te[7] = -s * a13 + c * a23;
        return this;
    }
    translate(tx, ty) {
        const te = this.elements;
        te[0] += tx * te[2];
        te[3] += tx * te[5];
        te[6] += tx * te[8];
        te[1] += ty * te[2];
        te[4] += ty * te[5];
        te[7] += ty * te[8];
        return this;
    }
    equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i3 = 0; i3 < 9; i3++){
            if (te[i3] !== me[i3]) return false;
        }
        return true;
    }
    fromArray(array, offset = 0) {
        for(let i4 = 0; i4 < 9; i4++)this.elements[i4] = array[i4 + offset];
        return this;
    }
    toArray(array = [], offset = 0) {
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
    }
    clone() {
        return new this.constructor().fromArray(this.elements);
    }
}
Matrix3.prototype.isMatrix3 = true;
let _canvas;
class ImageUtils {
    static getDataURL(image) {
        if (/^data:/i.test(image.src)) return image.src;
        if (typeof HTMLCanvasElement == 'undefined') return image.src;
        let canvas;
        if (image instanceof HTMLCanvasElement) canvas = image;
        else {
            if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            _canvas.width = image.width;
            _canvas.height = image.height;
            const context = _canvas.getContext('2d');
            if (image instanceof ImageData) context.putImageData(image, 0, 0);
            else context.drawImage(image, 0, 0, image.width, image.height);
            canvas = _canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) {
            console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
            return canvas.toDataURL('image/jpeg', 0.6);
        } else return canvas.toDataURL('image/png');
    }
}
let textureId = 0;
class Texture extends EventDispatcher {
    constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding){
        super();
        Object.defineProperty(this, 'id', {
            value: textureId++
        });
        this.uuid = generateUUID();
        this.name = '';
        this.image = image;
        this.mipmaps = [];
        this.mapping = mapping;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.anisotropy = anisotropy;
        this.format = format;
        this.internalFormat = null;
        this.type = type;
        this.offset = new Vector2(0, 0);
        this.repeat = new Vector2(1, 1);
        this.center = new Vector2(0, 0);
        this.rotation = 0;
        this.matrixAutoUpdate = true;
        this.matrix = new Matrix3();
        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
        // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
        //
        // Also changing the encoding after already used by a Material will not automatically make the Material
        // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
        this.encoding = encoding;
        this.version = 0;
        this.onUpdate = null;
        this.isRenderTargetTexture = false;
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.name = source.name;
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        return this;
    }
    toJSON(meta) {
        const isRootObject = meta === undefined || typeof meta === 'string';
        if (!isRootObject && meta.textures[this.uuid] !== undefined) return meta.textures[this.uuid];
        const output = {
            metadata: {
                version: 4.5,
                type: 'Texture',
                generator: 'Texture.toJSON'
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [
                this.repeat.x,
                this.repeat.y
            ],
            offset: [
                this.offset.x,
                this.offset.y
            ],
            center: [
                this.center.x,
                this.center.y
            ],
            rotation: this.rotation,
            wrap: [
                this.wrapS,
                this.wrapT
            ],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        if (this.image !== undefined) {
            // TODO: Move to THREE.Image
            const image = this.image;
            if (image.uuid === undefined) image.uuid = generateUUID(); // UGH
            if (!isRootObject && meta.images[image.uuid] === undefined) {
                let url;
                if (Array.isArray(image)) {
                    // process array of images e.g. CubeTexture
                    url = [];
                    for(let i5 = 0, l = image.length; i5 < l; i5++)// check cube texture with data textures
                    if (image[i5].isDataTexture) url.push(serializeImage(image[i5].image));
                    else url.push(serializeImage(image[i5]));
                } else // process single image
                url = serializeImage(image);
                meta.images[image.uuid] = {
                    uuid: image.uuid,
                    url: url
                };
            }
            output.image = image.uuid;
        }
        if (!isRootObject) meta.textures[this.uuid] = output;
        return output;
    }
    dispose() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
    transformUv(uv) {
        if (this.mapping !== UVMapping) return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) switch(this.wrapS){
            case RepeatWrapping:
                uv.x = uv.x - Math.floor(uv.x);
                break;
            case ClampToEdgeWrapping:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) uv.x = Math.ceil(uv.x) - uv.x;
                else uv.x = uv.x - Math.floor(uv.x);
                break;
        }
        if (uv.y < 0 || uv.y > 1) switch(this.wrapT){
            case RepeatWrapping:
                uv.y = uv.y - Math.floor(uv.y);
                break;
            case ClampToEdgeWrapping:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) uv.y = Math.ceil(uv.y) - uv.y;
                else uv.y = uv.y - Math.floor(uv.y);
                break;
        }
        if (this.flipY) uv.y = 1 - uv.y;
        return uv;
    }
    set needsUpdate(value) {
        if (value === true) this.version++;
    }
}
Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;
function serializeImage(image) {
    if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) // default images
    return ImageUtils.getDataURL(image);
    else {
        if (image.data) // images of DataTexture
        return {
            data: Array.prototype.slice.call(image.data),
            width: image.width,
            height: image.height,
            type: image.data.constructor.name
        };
        else {
            console.warn('THREE.Texture: Unable to serialize Texture.');
            return {};
        }
    }
}
class Vector4 {
    constructor(x = 0, y = 0, z = 0, w = 1){
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    get width() {
        return this.z;
    }
    set width(value) {
        this.z = value;
    }
    get height() {
        return this.w;
    }
    set height(value) {
        this.w = value;
    }
    set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setZ(z) {
        this.z = z;
        return this;
    }
    setW(w) {
        this.w = w;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error('index is out of range: ' + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== undefined ? v.w : 1;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
    }
    multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        this.w *= v.w;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
    }
    applyMatrix4(m) {
        const x = this.x, y = this.y, z = this.z, w = this.w;
        const e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    setAxisAngleFromQuaternion(q) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
        // q is assumed to be normalized
        this.w = 2 * Math.acos(q.w);
        const s = Math.sqrt(1 - q.w * q.w);
        if (s < 0.0001) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
        } else {
            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;
        }
        return this;
    }
    setAxisAngleFromRotationMatrix(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        let angle, x, y, z; // variables for result
        const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            // singularity found
            // first check for identity matrix which must have +1 for all terms
            // in leading diagonal and zero in other terms
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                // this singularity is identity matrix so angle = 0
                this.set(1, 0, 0, 0);
                return this; // zero angle, arbitrary axis
            }
            // otherwise this singularity is angle = 180
            angle = Math.PI;
            const xx = (m11 + 1) / 2;
            const yy = (m22 + 1) / 2;
            const zz = (m33 + 1) / 2;
            const xy = (m12 + m21) / 4;
            const xz = (m13 + m31) / 4;
            const yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
                // m11 is the largest diagonal term
                if (xx < epsilon) {
                    x = 0;
                    y = 0.707106781;
                    z = 0.707106781;
                } else {
                    x = Math.sqrt(xx);
                    y = xy / x;
                    z = xz / x;
                }
            } else if (yy > zz) {
                // m22 is the largest diagonal term
                if (yy < epsilon) {
                    x = 0.707106781;
                    y = 0;
                    z = 0.707106781;
                } else {
                    y = Math.sqrt(yy);
                    x = xy / y;
                    z = yz / y;
                }
            } else // m33 is the largest diagonal term so base result on this
            if (zz < epsilon) {
                x = 0.707106781;
                y = 0.707106781;
                z = 0;
            } else {
                z = Math.sqrt(zz);
                x = xz / z;
                y = yz / z;
            }
            this.set(x, y, z, angle);
            return this; // return 180 deg rotation
        }
        // as we have reached here there are no singularities so we can handle normally
        let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize
        if (Math.abs(s) < 0.001) s = 1;
        // prevent divide by zero, should not happen if matrix is orthogonal and should be
        // caught by singularity test above, but I've left it in just in case
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
    }
    clamp(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        this.w = Math.max(minVal, Math.min(maxVal, this.w));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        this.w = attribute.getW(index);
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
    }
}
Vector4.prototype.isVector4 = true;
/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/ class WebGLRenderTarget extends EventDispatcher {
    constructor(width, height, options = {}){
        super();
        this.width = width;
        this.height = height;
        this.depth = 1;
        this.scissor = new Vector4(0, 0, width, height);
        this.scissorTest = false;
        this.viewport = new Vector4(0, 0, width, height);
        this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        this.texture.isRenderTargetTexture = true;
        this.texture.image = {
            width: width,
            height: height,
            depth: 1
        };
        this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
        this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
        this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
        this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
        this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
        this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
    }
    setTexture(texture) {
        texture.image = {
            width: this.width,
            height: this.height,
            depth: this.depth
        };
        this.texture = texture;
    }
    setSize(width, height, depth = 1) {
        if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            this.texture.image.width = width;
            this.texture.image.height = height;
            this.texture.image.depth = depth;
            this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.width = source.width;
        this.height = source.height;
        this.depth = source.depth;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.texture.image = {
            ...this.texture.image
        }; // See #20328.
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        return this;
    }
    dispose() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
}
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
class WebGLMultipleRenderTargets extends WebGLRenderTarget {
    constructor(width, height, count){
        super(width, height);
        const texture = this.texture;
        this.texture = [];
        for(let i6 = 0; i6 < count; i6++)this.texture[i6] = texture.clone();
    }
    setSize(width, height, depth = 1) {
        if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            for(let i7 = 0, il = this.texture.length; i7 < il; i7++){
                this.texture[i7].image.width = width;
                this.texture[i7].image.height = height;
                this.texture[i7].image.depth = depth;
            }
            this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
        return this;
    }
    copy(source) {
        this.dispose();
        this.width = source.width;
        this.height = source.height;
        this.depth = source.depth;
        this.viewport.set(0, 0, this.width, this.height);
        this.scissor.set(0, 0, this.width, this.height);
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        this.texture.length = 0;
        for(let i8 = 0, il = source.texture.length; i8 < il; i8++)this.texture[i8] = source.texture[i8].clone();
        return this;
    }
}
WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
    constructor(width, height, options){
        super(width, height, options);
        this.samples = 4;
    }
    copy(source) {
        super.copy.call(this, source);
        this.samples = source.samples;
        return this;
    }
}
WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
class Quaternion {
    constructor(x = 0, y = 0, z = 0, w = 1){
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
    }
    static slerp(qa, qb, qm, t) {
        console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');
        return qm.slerpQuaternions(qa, qb, t);
    }
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        // fuzz-free, array-based Quaternion SLERP operation
        let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
        if (t === 0) {
            dst[dstOffset + 0] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
            return;
        }
        if (t === 1) {
            dst[dstOffset + 0] = x1;
            dst[dstOffset + 1] = y1;
            dst[dstOffset + 2] = z1;
            dst[dstOffset + 3] = w1;
            return;
        }
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            let s = 1 - t;
            const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            // Skip the Slerp for tiny steps to avoid numeric problems:
            if (sqrSin > Number.EPSILON) {
                const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                s = Math.sin(s * len) / sin;
                t = Math.sin(t * len) / sin;
            }
            const tDir = t * dir;
            x0 = x0 * s + x1 * tDir;
            y0 = y0 * s + y1 * tDir;
            z0 = z0 * s + z1 * tDir;
            w0 = w0 * s + w1 * tDir;
            // Normalize in case we just did a lerp:
            if (s === 1 - t) {
                const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                x0 *= f;
                y0 *= f;
                z0 *= f;
                w0 *= f;
            }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
    }
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
        const x0 = src0[srcOffset0];
        const y0 = src0[srcOffset0 + 1];
        const z0 = src0[srcOffset0 + 2];
        const w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1];
        const y1 = src1[srcOffset1 + 1];
        const z1 = src1[srcOffset1 + 2];
        const w1 = src1[srcOffset1 + 3];
        dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
        dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
        dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
        dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
        return dst;
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(value) {
        this._z = value;
        this._onChangeCallback();
    }
    get w() {
        return this._w;
    }
    set w(value) {
        this._w = value;
        this._onChangeCallback();
    }
    set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onChangeCallback();
        return this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
    }
    setFromEuler(euler, update) {
        if (!(euler && euler.isEuler)) throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
        const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        //	content/SpinCalc.m
        const cos = Math.cos;
        const sin = Math.sin;
        const c1 = cos(x / 2);
        const c2 = cos(y / 2);
        const c3 = cos(z / 2);
        const s1 = sin(x / 2);
        const s2 = sin(y / 2);
        const s3 = sin(z / 2);
        switch(order){
            case 'XYZ':
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case 'YXZ':
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            case 'ZXY':
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case 'ZYX':
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            case 'YZX':
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case 'XZY':
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            default:
                console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
        }
        if (update !== false) this._onChangeCallback();
        return this;
    }
    setFromAxisAngle(axis, angle) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
        // assumes axis is normalized
        const halfAngle = angle / 2, s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
    }
    setFromRotationMatrix(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        if (trace > 0) {
            const s = 0.5 / Math.sqrt(trace + 1);
            this._w = 0.25 / s;
            this._x = (m32 - m23) * s;
            this._y = (m13 - m31) * s;
            this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
            const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this._w = (m32 - m23) / s;
            this._x = 0.25 * s;
            this._y = (m12 + m21) / s;
            this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
            const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this._w = (m13 - m31) / s;
            this._x = (m12 + m21) / s;
            this._y = 0.25 * s;
            this._z = (m23 + m32) / s;
        } else {
            const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this._w = (m21 - m12) / s;
            this._x = (m13 + m31) / s;
            this._y = (m23 + m32) / s;
            this._z = 0.25 * s;
        }
        this._onChangeCallback();
        return this;
    }
    setFromUnitVectors(vFrom, vTo) {
        // assumes direction vectors vFrom and vTo are normalized
        let r = vFrom.dot(vTo) + 1;
        if (r < Number.EPSILON) {
            // vFrom and vTo point in opposite directions
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                this._x = -vFrom.y;
                this._y = vFrom.x;
                this._z = 0;
                this._w = r;
            } else {
                this._x = 0;
                this._y = -vFrom.z;
                this._z = vFrom.y;
                this._w = r;
            }
        } else {
            // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
            this._w = r;
        }
        return this.normalize();
    }
    angleTo(q) {
        return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
    }
    rotateTowards(q, step) {
        const angle = this.angleTo(q);
        if (angle === 0) return this;
        const t = Math.min(1, step / angle);
        this.slerp(q, t);
        return this;
    }
    identity() {
        return this.set(0, 0, 0, 1);
    }
    invert() {
        // quaternion is assumed to have unit length
        return this.conjugate();
    }
    conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
    }
    dot(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
        let l = this.length();
        if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
        } else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
        }
        this._onChangeCallback();
        return this;
    }
    multiply(q, p) {
        if (p !== undefined) {
            console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
            return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
    }
    premultiply(q) {
        return this.multiplyQuaternions(q, this);
    }
    multiplyQuaternions(a, b) {
        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
        const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
    }
    slerp(qb, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(qb);
        const x = this._x, y = this._y, z = this._z, w = this._w;
        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
        let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
        } else this.copy(qb);
        if (cosHalfTheta >= 1) {
            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;
            return this;
        }
        const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
            const s = 1 - t;
            this._w = s * w + t * this._w;
            this._x = s * x + t * this._x;
            this._y = s * y + t * this._y;
            this._z = s * z + t * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
        }
        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = w * ratioA + this._w * ratioB;
        this._x = x * ratioA + this._x * ratioB;
        this._y = y * ratioA + this._y * ratioB;
        this._z = z * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
    }
    slerpQuaternions(qa, qb, t) {
        this.copy(qa).slerp(qb, t);
    }
    equals(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset = 0) {
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onChangeCallback();
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
    }
    fromBufferAttribute(attribute, index) {
        this._x = attribute.getX(index);
        this._y = attribute.getY(index);
        this._z = attribute.getZ(index);
        this._w = attribute.getW(index);
        return this;
    }
    _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
    }
    _onChangeCallback() {}
}
Quaternion.prototype.isQuaternion = true;
class Vector3 {
    constructor(x = 0, y = 0, z = 0){
        this.x = x;
        this.y = y;
        this.z = z;
    }
    set(x, y, z) {
        if (z === undefined) z = this.z; // sprite.scale.set(x,y)
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setZ(z) {
        this.z = z;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error('index is out of range: ' + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
    }
    multiply(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
            return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
    }
    multiplyVectors(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
    }
    applyEuler(euler) {
        if (!(euler && euler.isEuler)) console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
        return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
        return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m) {
        const x = this.x, y = this.y, z = this.z;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
    }
    applyNormalMatrix(m) {
        return this.applyMatrix3(m).normalize();
    }
    applyMatrix4(m) {
        const x = this.x, y = this.y, z = this.z;
        const e = m.elements;
        const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
        return this;
    }
    applyQuaternion(q) {
        const x = this.x, y = this.y, z = this.z;
        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        // calculate quat * vector
        const ix = qw * x + qy * z - qz * y;
        const iy = qw * y + qz * x - qx * z;
        const iz = qw * z + qx * y - qy * x;
        const iw = -qx * x - qy * y - qz * z;
        // calculate result * inverse quat
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
    }
    project(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
    unproject(camera) {
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
    transformDirection(m) {
        // input: THREE.Matrix4 affine matrix
        // vector interpreted as a direction
        const x = this.x, y = this.y, z = this.z;
        const e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        return this.normalize();
    }
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
    }
    clamp(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    // TODO lengthSquared?
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
    }
    cross(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
            return this.crossVectors(v, w);
        }
        return this.crossVectors(this, v);
    }
    crossVectors(a, b) {
        const ax = a.x, ay = a.y, az = a.z;
        const bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
    }
    projectOnVector(v) {
        const denominator = v.lengthSq();
        if (denominator === 0) return this.set(0, 0, 0);
        const scalar = v.dot(this) / denominator;
        return this.copy(v).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
        _vector$c.copy(this).projectOnVector(planeNormal);
        return this.sub(_vector$c);
    }
    reflect(normal) {
        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length
        return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    angleTo(v) {
        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0) return Math.PI / 2;
        const theta = this.dot(v) / denominator;
        // clamp, to handle numerical problems
        return Math.acos(clamp(theta, -1, 1));
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    setFromSpherical(s) {
        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
        const sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
    }
    setFromCylindrical(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
    setFromCylindricalCoords(radius, theta, y) {
        this.x = radius * Math.sin(theta);
        this.y = y;
        this.z = radius * Math.cos(theta);
        return this;
    }
    setFromMatrixPosition(m) {
        const e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        return this;
    }
    setFromMatrixScale(m) {
        const sx = this.setFromMatrixColumn(m, 0).length();
        const sy = this.setFromMatrixColumn(m, 1).length();
        const sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
    }
    setFromMatrixColumn(m, index) {
        return this.fromArray(m.elements, index * 4);
    }
    setFromMatrix3Column(m, index) {
        return this.fromArray(m.elements, index * 3);
    }
    equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
    }
}
Vector3.prototype.isVector3 = true;
const _vector$c = /*@__PURE__*/ new Vector3();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();
class Box3 {
    constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)){
        this.min = min;
        this.max = max;
    }
    set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    }
    setFromArray(array) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i9 = 0, l = array.length; i9 < l; i9 += 3){
            const x = array[i9];
            const y = array[i9 + 1];
            const z = array[i9 + 2];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (z < minZ) minZ = z;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            if (z > maxZ) maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    }
    setFromBufferAttribute(attribute) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i10 = 0, l = attribute.count; i10 < l; i10++){
            const x = attribute.getX(i10);
            const y = attribute.getY(i10);
            const z = attribute.getZ(i10);
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (z < minZ) minZ = z;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            if (z > maxZ) maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    }
    setFromPoints(points) {
        this.makeEmpty();
        for(let i11 = 0, il = points.length; i11 < il; i11++)this.expandByPoint(points[i11]);
        return this;
    }
    setFromCenterAndSize(center, size) {
        const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
    }
    setFromObject(object) {
        this.makeEmpty();
        return this.expandByObject(object);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    }
    makeEmpty() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
    }
    isEmpty() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    }
    expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    }
    expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    }
    expandByObject(object) {
        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms
        object.updateWorldMatrix(false, false);
        const geometry = object.geometry;
        if (geometry !== undefined) {
            if (geometry.boundingBox === null) geometry.computeBoundingBox();
            _box$3.copy(geometry.boundingBox);
            _box$3.applyMatrix4(object.matrixWorld);
            this.union(_box$3);
        }
        const children = object.children;
        for(let i12 = 0, l = children.length; i12 < l; i12++)this.expandByObject(children[i12]);
        return this;
    }
    containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    }
    containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    getParameter(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(box) {
        // using 6 splitting planes to rule out intersections.
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    }
    intersectsSphere(sphere) {
        // Find the point on the AABB closest to the sphere center.
        this.clampPoint(sphere.center, _vector$b);
        // If that point is inside the sphere, the AABB and sphere intersect.
        return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    intersectsPlane(plane) {
        // We compute the minimum and maximum dot product values. If those values
        // are on the same side (back or front) of the plane, then there is no intersection.
        let min, max;
        if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
        } else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
        } else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
        } else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
        }
        return min <= -plane.constant && max >= -plane.constant;
    }
    intersectsTriangle(triangle) {
        if (this.isEmpty()) return false;
        // compute box center and extents
        this.getCenter(_center);
        _extents.subVectors(this.max, _center);
        // translate triangle to aabb origin
        _v0$2.subVectors(triangle.a, _center);
        _v1$7.subVectors(triangle.b, _center);
        _v2$3.subVectors(triangle.c, _center);
        // compute edge vectors for triangle
        _f0.subVectors(_v1$7, _v0$2);
        _f1.subVectors(_v2$3, _v1$7);
        _f2.subVectors(_v0$2, _v2$3);
        // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
        // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
        // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
        let axes = [
            0,
            -_f0.z,
            _f0.y,
            0,
            -_f1.z,
            _f1.y,
            0,
            -_f2.z,
            _f2.y,
            _f0.z,
            0,
            -_f0.x,
            _f1.z,
            0,
            -_f1.x,
            _f2.z,
            0,
            -_f2.x,
            -_f0.y,
            _f0.x,
            0,
            -_f1.y,
            _f1.x,
            0,
            -_f2.y,
            _f2.x,
            0
        ];
        if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) return false;
        // test 3 face normals from the aabb
        axes = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ];
        if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) return false;
        // finally testing the face normal of the triangle
        // use already existing triangle edge vectors here
        _triangleNormal.crossVectors(_f0, _f1);
        axes = [
            _triangleNormal.x,
            _triangleNormal.y,
            _triangleNormal.z
        ];
        return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
    }
    clampPoint(point, target) {
        return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
        const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    }
    getBoundingSphere(target) {
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$b).length() * 0.5;
        return target;
    }
    intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
        if (this.isEmpty()) this.makeEmpty();
        return this;
    }
    union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    }
    applyMatrix4(matrix) {
        // transform of empty box is an empty box.
        if (this.isEmpty()) return this;
        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
        this.setFromPoints(_points);
        return this;
    }
    translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    }
    equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
}
Box3.prototype.isBox3 = true;
const _points = [
    /*@__PURE__*/ new Vector3(),
    /*@__PURE__*/ new Vector3(),
    /*@__PURE__*/ new Vector3(),
    /*@__PURE__*/ new Vector3(),
    /*@__PURE__*/ new Vector3(),
    /*@__PURE__*/ new Vector3(),
    /*@__PURE__*/ new Vector3(),
    /*@__PURE__*/ new Vector3()
];
const _vector$b = /*@__PURE__*/ new Vector3();
const _box$3 = /*@__PURE__*/ new Box3();
// triangle centered vertices
const _v0$2 = /*@__PURE__*/ new Vector3();
const _v1$7 = /*@__PURE__*/ new Vector3();
const _v2$3 = /*@__PURE__*/ new Vector3();
// triangle edge vectors
const _f0 = /*@__PURE__*/ new Vector3();
const _f1 = /*@__PURE__*/ new Vector3();
const _f2 = /*@__PURE__*/ new Vector3();
const _center = /*@__PURE__*/ new Vector3();
const _extents = /*@__PURE__*/ new Vector3();
const _triangleNormal = /*@__PURE__*/ new Vector3();
const _testAxis = /*@__PURE__*/ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
    for(let i13 = 0, j = axes.length - 3; i13 <= j; i13 += 3){
        _testAxis.fromArray(axes, i13);
        // project the aabb onto the seperating axis
        const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
        // project all 3 vertices of the triangle onto the seperating axis
        const p0 = v0.dot(_testAxis);
        const p1 = v1.dot(_testAxis);
        const p2 = v2.dot(_testAxis);
        // actual test, basically see if either of the most extreme of the triangle points intersects r
        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) // points of the projected triangle are outside the projected half-length of the aabb
        // the axis is seperating and we can exit
        return false;
    }
    return true;
}
const _box$2 = /*@__PURE__*/ new Box3();
const _v1$6 = /*@__PURE__*/ new Vector3();
const _toFarthestPoint = /*@__PURE__*/ new Vector3();
const _toPoint = /*@__PURE__*/ new Vector3();
class Sphere {
    constructor(center = new Vector3(), radius = -1){
        this.center = center;
        this.radius = radius;
    }
    set(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
    }
    setFromPoints(points, optionalCenter) {
        const center = this.center;
        if (optionalCenter !== undefined) center.copy(optionalCenter);
        else _box$2.setFromPoints(points).getCenter(center);
        let maxRadiusSq = 0;
        for(let i14 = 0, il = points.length; i14 < il; i14++)maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i14]));
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
    }
    copy(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
    }
    isEmpty() {
        return this.radius < 0;
    }
    makeEmpty() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
    }
    containsPoint(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(point) {
        return point.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(sphere) {
        const radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
    intersectsBox(box) {
        return box.intersectsSphere(this);
    }
    intersectsPlane(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(point, target) {
        const deltaLengthSq = this.center.distanceToSquared(point);
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
    }
    getBoundingBox(target) {
        if (this.isEmpty()) {
            // Empty sphere produces empty bounding box
            target.makeEmpty();
            return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
    }
    applyMatrix4(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
    }
    translate(offset) {
        this.center.add(offset);
        return this;
    }
    expandByPoint(point) {
        // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
        _toPoint.subVectors(point, this.center);
        const lengthSq = _toPoint.lengthSq();
        if (lengthSq > this.radius * this.radius) {
            const length = Math.sqrt(lengthSq);
            const missingRadiusHalf = (length - this.radius) * 0.5;
            // Nudge this sphere towards the target point. Add half the missing distance to radius,
            // and the other half to position. This gives a tighter enclosure, instead of if
            // the whole missing distance were just added to radius.
            this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
            this.radius += missingRadiusHalf;
        }
        return this;
    }
    union(sphere) {
        // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
        // To enclose another sphere into this sphere, we only need to enclose two points:
        // 1) Enclose the farthest point on the other sphere into this sphere.
        // 2) Enclose the opposite point of the farthest point into this sphere.
        _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
        this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
        this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
        return this;
    }
    equals(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const _vector$a = /*@__PURE__*/ new Vector3();
const _segCenter = /*@__PURE__*/ new Vector3();
const _segDir = /*@__PURE__*/ new Vector3();
const _diff = /*@__PURE__*/ new Vector3();
const _edge1 = /*@__PURE__*/ new Vector3();
const _edge2 = /*@__PURE__*/ new Vector3();
const _normal$1 = /*@__PURE__*/ new Vector3();
class Ray {
    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)){
        this.origin = origin;
        this.direction = direction;
    }
    set(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
    }
    copy(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
    }
    at(t, target) {
        return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
    }
    recast(t) {
        this.origin.copy(this.at(t, _vector$a));
        return this;
    }
    closestPointToPoint(point, target) {
        target.subVectors(point, this.origin);
        const directionDistance = target.dot(this.direction);
        if (directionDistance < 0) return target.copy(this.origin);
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    }
    distanceToPoint(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
        const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
        // point behind the ray
        if (directionDistance < 0) return this.origin.distanceToSquared(point);
        _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return _vector$a.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
        // It returns the min distance between the ray and the segment
        // defined by v0 and v1
        // It can also set two optional targets :
        // - The closest point on the ray
        // - The closest point on the segment
        _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        _segDir.copy(v1).sub(v0).normalize();
        _diff.copy(this.origin).sub(_segCenter);
        const segExtent = v0.distanceTo(v1) * 0.5;
        const a01 = -this.direction.dot(_segDir);
        const b0 = _diff.dot(this.direction);
        const b1 = -_diff.dot(_segDir);
        const c = _diff.lengthSq();
        const det = Math.abs(1 - a01 * a01);
        let s0, s1, sqrDist, extDet;
        if (det > 0) {
            // The ray and segment are not parallel.
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
                if (s1 >= -extDet) {
                    if (s1 <= extDet) {
                        // region 0
                        // Minimum at interior points of ray and segment.
                        const invDet = 1 / det;
                        s0 *= invDet;
                        s1 *= invDet;
                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                    } else {
                        // region 1
                        s1 = segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                } else {
                    // region 5
                    s1 = -segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            } else {
                if (s1 <= -extDet) {
                    // region 4
                    s0 = Math.max(0, -(-a01 * segExtent + b0));
                    s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                } else if (s1 <= extDet) {
                    // region 3
                    s0 = 0;
                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = s1 * (s1 + 2 * b1) + c;
                } else {
                    // region 2
                    s0 = Math.max(0, -(a01 * segExtent + b0));
                    s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            }
        } else {
            // Ray and segment are parallel.
            s1 = a01 > 0 ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        if (optionalPointOnSegment) optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
        return sqrDist;
    }
    intersectSphere(sphere, target) {
        _vector$a.subVectors(sphere.center, this.origin);
        const tca = _vector$a.dot(this.direction);
        const d2 = _vector$a.dot(_vector$a) - tca * tca;
        const radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2) return null;
        const thc = Math.sqrt(radius2 - d2);
        // t0 = first intersect point - entrance on front of sphere
        const t0 = tca - thc;
        // t1 = second intersect point - exit point on back of sphere
        const t1 = tca + thc;
        // test to see if both t0 and t1 are behind the ray - if so, return null
        if (t0 < 0 && t1 < 0) return null;
        // test to see if t0 is behind the ray:
        // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
        // in order to always return an intersect point that is in front of the ray.
        if (t0 < 0) return this.at(t1, target);
        // else t0 is in front of the ray, so return the first collision point scaled by t0
        return this.at(t0, target);
    }
    intersectsSphere(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
        const denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (plane.distanceToPoint(this.origin) === 0) return 0;
            // Null is preferable to undefined since undefined means.... it is undefined
            return null;
        }
        const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        // Return if the ray never intersects the plane
        return t >= 0 ? t : null;
    }
    intersectPlane(plane, target) {
        const t = this.distanceToPlane(plane);
        if (t === null) return null;
        return this.at(t, target);
    }
    intersectsPlane(plane) {
        // check if the ray lies on the plane first
        const distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) return true;
        const denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) return true;
        // ray origin is behind the plane (and is pointing behind it)
        return false;
    }
    intersectBox(box, target) {
        let tmin, tmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        const origin = this.origin;
        if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
        } else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
        } else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax) return null;
        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN
        if (tymin > tmin || tmin !== tmin) tmin = tymin;
        if (tymax < tmax || tmax !== tmax) tmax = tymax;
        if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
        } else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax) return null;
        if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
        //return point closest to the ray (positive side)
        if (tmax < 0) return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
    }
    intersectsBox(box) {
        return this.intersectBox(box, _vector$a) !== null;
    }
    intersectTriangle(a, b, c, backfaceCulling, target) {
        // Compute the offset origin, edges, and normal.
        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
        _edge1.subVectors(b, a);
        _edge2.subVectors(c, a);
        _normal$1.crossVectors(_edge1, _edge2);
        // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
        // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
        //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
        //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
        //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
        let DdN = this.direction.dot(_normal$1);
        let sign1;
        if (DdN > 0) {
            if (backfaceCulling) return null;
            sign1 = 1;
        } else if (DdN < 0) {
            sign1 = -1;
            DdN = -DdN;
        } else return null;
        _diff.subVectors(this.origin, a);
        const DdQxE2 = sign1 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        // b1 < 0, no intersection
        if (DdQxE2 < 0) return null;
        const DdE1xQ = sign1 * this.direction.dot(_edge1.cross(_diff));
        // b2 < 0, no intersection
        if (DdE1xQ < 0) return null;
        // b1+b2 > 1, no intersection
        if (DdQxE2 + DdE1xQ > DdN) return null;
        // Line intersects triangle, check if ray does.
        const QdN = -sign1 * _diff.dot(_normal$1);
        // t < 0, no intersection
        if (QdN < 0) return null;
        // Ray intersects triangle.
        return this.at(QdN / DdN, target);
    }
    applyMatrix4(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
    }
    equals(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
class Matrix4 {
    constructor(){
        this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ];
        if (arguments.length > 0) console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        const te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
    }
    identity() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }
    clone() {
        return new Matrix4().fromArray(this.elements);
    }
    copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
    }
    copyPosition(m) {
        const te = this.elements, me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
    }
    setFromMatrix3(m) {
        const me = m.elements;
        this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
        return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
    }
    extractRotation(m) {
        // this method does not support reflection matrices
        const te = this.elements;
        const me = m.elements;
        const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
        const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
        const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    }
    makeRotationFromEuler(euler) {
        if (!(euler && euler.isEuler)) console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        const te = this.elements;
        const x = euler.x, y = euler.y, z = euler.z;
        const a = Math.cos(x), b = Math.sin(x);
        const c = Math.cos(y), d = Math.sin(y);
        const e = Math.cos(z), f = Math.sin(z);
        if (euler.order === 'XYZ') {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
        } else if (euler.order === 'YXZ') {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
        } else if (euler.order === 'ZXY') {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce - df * b;
            te[4] = -a * f;
            te[8] = de + cf * b;
            te[1] = cf + de * b;
            te[5] = a * e;
            te[9] = df - ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
        } else if (euler.order === 'ZYX') {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c * f;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
        } else if (euler.order === 'YZX') {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
        } else if (euler.order === 'XZY') {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = ac * f + bd;
            te[5] = a * e;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b * e;
            te[10] = bd * f + ac;
        }
        // bottom row
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        // last column
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    }
    makeRotationFromQuaternion(q) {
        return this.compose(_zero, q, _one);
    }
    lookAt(eye, target, up) {
        const te = this.elements;
        _z.subVectors(eye, target);
        if (_z.lengthSq() === 0) // eye and target are in the same position
        _z.z = 1;
        _z.normalize();
        _x.crossVectors(up, _z);
        if (_x.lengthSq() === 0) {
            // up and z are parallel
            if (Math.abs(up.z) === 1) _z.x += 0.0001;
            else _z.z += 0.0001;
            _z.normalize();
            _x.crossVectors(up, _z);
        }
        _x.normalize();
        _y.crossVectors(_z, _x);
        te[0] = _x.x;
        te[4] = _y.x;
        te[8] = _z.x;
        te[1] = _x.y;
        te[5] = _y.y;
        te[9] = _z.y;
        te[2] = _x.z;
        te[6] = _y.z;
        te[10] = _z.z;
        return this;
    }
    multiply(m, n) {
        if (n !== undefined) {
            console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
            return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
    }
    multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
    }
    determinant() {
        const te = this.elements;
        const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        //TODO: make this more efficient
        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
        const te = this.elements;
        let tmp2;
        tmp2 = te[1];
        te[1] = te[4];
        te[4] = tmp2;
        tmp2 = te[2];
        te[2] = te[8];
        te[8] = tmp2;
        tmp2 = te[6];
        te[6] = te[9];
        te[9] = tmp2;
        tmp2 = te[3];
        te[3] = te[12];
        te[12] = tmp2;
        tmp2 = te[7];
        te[7] = te[13];
        te[13] = tmp2;
        tmp2 = te[11];
        te[11] = te[14];
        te[14] = tmp2;
        return this;
    }
    setPosition(x, y, z) {
        const te = this.elements;
        if (x.isVector3) {
            te[12] = x.x;
            te[13] = x.y;
            te[14] = x.z;
        } else {
            te[12] = x;
            te[13] = y;
            te[14] = z;
        }
        return this;
    }
    invert() {
        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
    }
    scale(v) {
        const te = this.elements;
        const x = v.x, y = v.y, z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        return this;
    }
    getMaxScaleOnAxis() {
        const te = this.elements;
        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
    }
    makeRotationX(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationY(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationZ(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationAxis(axis, angle) {
        // Based on http://www.gamedev.net/reference/articles/article1199.asp
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const t = 1 - c;
        const x = axis.x, y = axis.y, z = axis.z;
        const tx = t * x, ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
    }
    makeScale(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
    }
    makeShear(xy, xz, yx, yz, zx, zy) {
        this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
        return this;
    }
    compose(position, quaternion, scale) {
        const te = this.elements;
        const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        const x2 = x + x, y2 = y + y, z2 = z + z;
        const xx = x * x2, xy = x * y2, xz = x * z2;
        const yy = y * y2, yz = y * z2, zz = z * z2;
        const wx = w * x2, wy = w * y2, wz = w * z2;
        const sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
    }
    decompose(position, quaternion, scale) {
        const te = this.elements;
        let sx = _v1$5.set(te[0], te[1], te[2]).length();
        const sy = _v1$5.set(te[4], te[5], te[6]).length();
        const sz = _v1$5.set(te[8], te[9], te[10]).length();
        // if determine is negative, we need to invert one scale
        const det = this.determinant();
        if (det < 0) sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        // scale the rotation part
        _m1$2.copy(this);
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;
        _m1$2.elements[0] *= invSX;
        _m1$2.elements[1] *= invSX;
        _m1$2.elements[2] *= invSX;
        _m1$2.elements[4] *= invSY;
        _m1$2.elements[5] *= invSY;
        _m1$2.elements[6] *= invSY;
        _m1$2.elements[8] *= invSZ;
        _m1$2.elements[9] *= invSZ;
        _m1$2.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(_m1$2);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
    }
    makePerspective(left, right, top, bottom, near, far) {
        if (far === undefined) console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
        const te = this.elements;
        const x = 2 * near / (right - left);
        const y = 2 * near / (top - bottom);
        const a = (right + left) / (right - left);
        const b = (top + bottom) / (top - bottom);
        const c = -(far + near) / (far - near);
        const d = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
    }
    makeOrthographic(left, right, top, bottom, near, far) {
        const te = this.elements;
        const w = 1 / (right - left);
        const h = 1 / (top - bottom);
        const p = 1 / (far - near);
        const x = (right + left) * w;
        const y = (top + bottom) * h;
        const z = (far + near) * p;
        te[0] = 2 * w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
    }
    equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i15 = 0; i15 < 16; i15++){
            if (te[i15] !== me[i15]) return false;
        }
        return true;
    }
    fromArray(array, offset = 0) {
        for(let i16 = 0; i16 < 16; i16++)this.elements[i16] = array[i16 + offset];
        return this;
    }
    toArray(array = [], offset = 0) {
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
    }
}
Matrix4.prototype.isMatrix4 = true;
const _v1$5 = /*@__PURE__*/ new Vector3();
const _m1$2 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3(0, 0, 0);
const _one = /*@__PURE__*/ new Vector3(1, 1, 1);
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();
const _matrix$1 = /*@__PURE__*/ new Matrix4();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();
class Euler {
    constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder){
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order;
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(value) {
        this._z = value;
        this._onChangeCallback();
    }
    get order() {
        return this._order;
    }
    set order(value) {
        this._order = value;
        this._onChangeCallback();
    }
    set(x, y, z, order = this._order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order;
        this._onChangeCallback();
        return this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
    }
    setFromRotationMatrix(m, order = this._order, update = true) {
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        const te = m.elements;
        const m11 = te[0], m12 = te[4], m13 = te[8];
        const m21 = te[1], m22 = te[5], m23 = te[9];
        const m31 = te[2], m32 = te[6], m33 = te[10];
        switch(order){
            case 'XYZ':
                this._y = Math.asin(clamp(m13, -1, 1));
                if (Math.abs(m13) < 0.9999999) {
                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                } else {
                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                }
                break;
            case 'YXZ':
                this._x = Math.asin(-clamp(m23, -1, 1));
                if (Math.abs(m23) < 0.9999999) {
                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                } else {
                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                }
                break;
            case 'ZXY':
                this._x = Math.asin(clamp(m32, -1, 1));
                if (Math.abs(m32) < 0.9999999) {
                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                } else {
                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                }
                break;
            case 'ZYX':
                this._y = Math.asin(-clamp(m31, -1, 1));
                if (Math.abs(m31) < 0.9999999) {
                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                } else {
                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                }
                break;
            case 'YZX':
                this._z = Math.asin(clamp(m21, -1, 1));
                if (Math.abs(m21) < 0.9999999) {
                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                } else {
                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                }
                break;
            case 'XZY':
                this._z = Math.asin(-clamp(m12, -1, 1));
                if (Math.abs(m12) < 0.9999999) {
                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                } else {
                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                }
                break;
            default:
                console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
        }
        this._order = order;
        if (update === true) this._onChangeCallback();
        return this;
    }
    setFromQuaternion(q, order, update) {
        _matrix$1.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(_matrix$1, order, update);
    }
    setFromVector3(v, order = this._order) {
        return this.set(v.x, v.y, v.z, order);
    }
    reorder(newOrder) {
        // WARNING: this discards revolution information -bhouston
        _quaternion$3.setFromEuler(this);
        return this.setFromQuaternion(_quaternion$3, newOrder);
    }
    equals(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined) this._order = array[3];
        this._onChangeCallback();
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
    }
    toVector3(optionalResult) {
        if (optionalResult) return optionalResult.set(this._x, this._y, this._z);
        else return new Vector3(this._x, this._y, this._z);
    }
    _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
    }
    _onChangeCallback() {}
}
Euler.prototype.isEuler = true;
Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = [
    'XYZ',
    'YZX',
    'ZXY',
    'XZY',
    'YXZ',
    'ZYX'
];
class Layers {
    constructor(){
        this.mask = 1;
    }
    set(channel) {
        this.mask = 1 << channel | 0;
    }
    enable(channel) {
        this.mask |= 1 << channel | 0;
    }
    enableAll() {
        this.mask = -1;
    }
    toggle(channel) {
        this.mask ^= 1 << channel | 0;
    }
    disable(channel) {
        this.mask &= ~(1 << channel | 0);
    }
    disableAll() {
        this.mask = 0;
    }
    test(layers) {
        return (this.mask & layers.mask) !== 0;
    }
}
let _object3DId = 0;
const _v1$4 = /*@__PURE__*/ new Vector3();
const _q1 = /*@__PURE__*/ new Quaternion();
const _m1$1 = /*@__PURE__*/ new Matrix4();
const _target = /*@__PURE__*/ new Vector3();
const _position$3 = /*@__PURE__*/ new Vector3();
const _scale$2 = /*@__PURE__*/ new Vector3();
const _quaternion$2 = /*@__PURE__*/ new Quaternion();
const _xAxis = /*@__PURE__*/ new Vector3(1, 0, 0);
const _yAxis = /*@__PURE__*/ new Vector3(0, 1, 0);
const _zAxis = /*@__PURE__*/ new Vector3(0, 0, 1);
const _addedEvent = {
    type: 'added'
};
const _removedEvent = {
    type: 'removed'
};
class Object3D extends EventDispatcher {
    constructor(){
        super();
        Object.defineProperty(this, 'id', {
            value: _object3DId++
        });
        this.uuid = generateUUID();
        this.name = '';
        this.type = 'Object3D';
        this.parent = null;
        this.children = [];
        this.up = Object3D.DefaultUp.clone();
        const position = new Vector3();
        const rotation = new Euler();
        const quaternion = new Quaternion();
        const scale = new Vector3(1, 1, 1);
        function onRotationChange() {
            quaternion.setFromEuler(rotation, false);
        }
        function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, undefined, false);
        }
        rotation._onChange(onRotationChange);
        quaternion._onChange(onQuaternionChange);
        Object.defineProperties(this, {
            position: {
                configurable: true,
                enumerable: true,
                value: position
            },
            rotation: {
                configurable: true,
                enumerable: true,
                value: rotation
            },
            quaternion: {
                configurable: true,
                enumerable: true,
                value: quaternion
            },
            scale: {
                configurable: true,
                enumerable: true,
                value: scale
            },
            modelViewMatrix: {
                value: new Matrix4()
            },
            normalMatrix: {
                value: new Matrix3()
            }
        });
        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();
        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = false;
        this.layers = new Layers();
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.frustumCulled = true;
        this.renderOrder = 0;
        this.animations = [];
        this.userData = {};
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(matrix) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(q) {
        this.quaternion.premultiply(q);
        return this;
    }
    setRotationFromAxisAngle(axis, angle) {
        // assumes axis is normalized
        this.quaternion.setFromAxisAngle(axis, angle);
    }
    setRotationFromEuler(euler) {
        this.quaternion.setFromEuler(euler, true);
    }
    setRotationFromMatrix(m) {
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        this.quaternion.setFromRotationMatrix(m);
    }
    setRotationFromQuaternion(q) {
        // assumes q is normalized
        this.quaternion.copy(q);
    }
    rotateOnAxis(axis, angle) {
        // rotate object on axis in object space
        // axis is assumed to be normalized
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(_q1);
        return this;
    }
    rotateOnWorldAxis(axis, angle) {
        // rotate object on axis in world space
        // axis is assumed to be normalized
        // method assumes no rotated parent
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply(_q1);
        return this;
    }
    rotateX(angle) {
        return this.rotateOnAxis(_xAxis, angle);
    }
    rotateY(angle) {
        return this.rotateOnAxis(_yAxis, angle);
    }
    rotateZ(angle) {
        return this.rotateOnAxis(_zAxis, angle);
    }
    translateOnAxis(axis, distance) {
        // translate object by distance along axis in object space
        // axis is assumed to be normalized
        _v1$4.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(_v1$4.multiplyScalar(distance));
        return this;
    }
    translateX(distance) {
        return this.translateOnAxis(_xAxis, distance);
    }
    translateY(distance) {
        return this.translateOnAxis(_yAxis, distance);
    }
    translateZ(distance) {
        return this.translateOnAxis(_zAxis, distance);
    }
    localToWorld(vector) {
        return vector.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(vector) {
        return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
    }
    lookAt(x, y, z) {
        // This method does not support objects having non-uniformly-scaled parent(s)
        if (x.isVector3) _target.copy(x);
        else _target.set(x, y, z);
        const parent = this.parent;
        this.updateWorldMatrix(true, false);
        _position$3.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) _m1$1.lookAt(_position$3, _target, this.up);
        else _m1$1.lookAt(_target, _position$3, this.up);
        this.quaternion.setFromRotationMatrix(_m1$1);
        if (parent) {
            _m1$1.extractRotation(parent.matrixWorld);
            _q1.setFromRotationMatrix(_m1$1);
            this.quaternion.premultiply(_q1.invert());
        }
    }
    add(object) {
        if (arguments.length > 1) {
            for(let i17 = 0; i17 < arguments.length; i17++)this.add(arguments[i17]);
            return this;
        }
        if (object === this) {
            console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
            return this;
        }
        if (object && object.isObject3D) {
            if (object.parent !== null) object.parent.remove(object);
            object.parent = this;
            this.children.push(object);
            object.dispatchEvent(_addedEvent);
        } else console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
        return this;
    }
    remove(object) {
        if (arguments.length > 1) {
            for(let i18 = 0; i18 < arguments.length; i18++)this.remove(arguments[i18]);
            return this;
        }
        const index = this.children.indexOf(object);
        if (index !== -1) {
            object.parent = null;
            this.children.splice(index, 1);
            object.dispatchEvent(_removedEvent);
        }
        return this;
    }
    removeFromParent() {
        const parent = this.parent;
        if (parent !== null) parent.remove(this);
        return this;
    }
    clear() {
        for(let i19 = 0; i19 < this.children.length; i19++){
            const object = this.children[i19];
            object.parent = null;
            object.dispatchEvent(_removedEvent);
        }
        this.children.length = 0;
        return this;
    }
    attach(object) {
        // adds object as a child of this, while maintaining the object's world transform
        this.updateWorldMatrix(true, false);
        _m1$1.copy(this.matrixWorld).invert();
        if (object.parent !== null) {
            object.parent.updateWorldMatrix(true, false);
            _m1$1.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix4(_m1$1);
        this.add(object);
        object.updateWorldMatrix(false, true);
        return this;
    }
    getObjectById(id) {
        return this.getObjectByProperty('id', id);
    }
    getObjectByName(name) {
        return this.getObjectByProperty('name', name);
    }
    getObjectByProperty(name, value) {
        if (this[name] === value) return this;
        for(let i20 = 0, l = this.children.length; i20 < l; i20++){
            const child = this.children[i20];
            const object = child.getObjectByProperty(name, value);
            if (object !== undefined) return object;
        }
        return undefined;
    }
    getWorldPosition(target) {
        this.updateWorldMatrix(true, false);
        return target.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(target) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position$3, target, _scale$2);
        return target;
    }
    getWorldScale(target) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position$3, _quaternion$2, target);
        return target;
    }
    getWorldDirection(target) {
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return target.set(e[8], e[9], e[10]).normalize();
    }
    raycast() {}
    traverse(callback) {
        callback(this);
        const children = this.children;
        for(let i21 = 0, l = children.length; i21 < l; i21++)children[i21].traverse(callback);
    }
    traverseVisible(callback) {
        if (this.visible === false) return;
        callback(this);
        const children = this.children;
        for(let i22 = 0, l = children.length; i22 < l; i22++)children[i22].traverseVisible(callback);
    }
    traverseAncestors(callback) {
        const parent = this.parent;
        if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
        }
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(force) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) this.matrixWorld.copy(this.matrix);
            else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }
        // update children
        const children = this.children;
        for(let i23 = 0, l = children.length; i23 < l; i23++)children[i23].updateMatrixWorld(force);
    }
    updateWorldMatrix(updateParents, updateChildren) {
        const parent = this.parent;
        if (updateParents === true && parent !== null) parent.updateWorldMatrix(true, false);
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.parent === null) this.matrixWorld.copy(this.matrix);
        else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        // update children
        if (updateChildren === true) {
            const children = this.children;
            for(let i24 = 0, l = children.length; i24 < l; i24++)children[i24].updateWorldMatrix(false, true);
        }
    }
    toJSON(meta) {
        // meta is a string when called from JSON.stringify
        const isRootObject = meta === undefined || typeof meta === 'string';
        const output = {};
        // meta is a hash used to collect geometries, materials.
        // not providing it implies that this is the root object
        // being serialized.
        if (isRootObject) {
            // initialize meta obj
            meta = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {}
            };
            output.metadata = {
                version: 4.5,
                type: 'Object',
                generator: 'Object3D.toJSON'
            };
        }
        // standard Object3D serialization
        const object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== '') object.name = this.name;
        if (this.castShadow === true) object.castShadow = true;
        if (this.receiveShadow === true) object.receiveShadow = true;
        if (this.visible === false) object.visible = false;
        if (this.frustumCulled === false) object.frustumCulled = false;
        if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
        if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
        // object specific properties
        if (this.isInstancedMesh) {
            object.type = 'InstancedMesh';
            object.count = this.count;
            object.instanceMatrix = this.instanceMatrix.toJSON();
            if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
        }
        //
        function serialize(library, element) {
            if (library[element.uuid] === undefined) library[element.uuid] = element.toJSON(meta);
            return element.uuid;
        }
        if (this.isScene) {
            if (this.background) {
                if (this.background.isColor) object.background = this.background.toJSON();
                else if (this.background.isTexture) object.background = this.background.toJSON(meta).uuid;
            }
            if (this.environment && this.environment.isTexture) object.environment = this.environment.toJSON(meta).uuid;
        } else if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            const parameters = this.geometry.parameters;
            if (parameters !== undefined && parameters.shapes !== undefined) {
                const shapes = parameters.shapes;
                if (Array.isArray(shapes)) for(let i25 = 0, l = shapes.length; i25 < l; i25++){
                    const shape = shapes[i25];
                    serialize(meta.shapes, shape);
                }
                else serialize(meta.shapes, shapes);
            }
        }
        if (this.isSkinnedMesh) {
            object.bindMode = this.bindMode;
            object.bindMatrix = this.bindMatrix.toArray();
            if (this.skeleton !== undefined) {
                serialize(meta.skeletons, this.skeleton);
                object.skeleton = this.skeleton.uuid;
            }
        }
        if (this.material !== undefined) {
            if (Array.isArray(this.material)) {
                const uuids = [];
                for(let i26 = 0, l = this.material.length; i26 < l; i26++)uuids.push(serialize(meta.materials, this.material[i26]));
                object.material = uuids;
            } else object.material = serialize(meta.materials, this.material);
        }
        //
        if (this.children.length > 0) {
            object.children = [];
            for(let i27 = 0; i27 < this.children.length; i27++)object.children.push(this.children[i27].toJSON(meta).object);
        }
        //
        if (this.animations.length > 0) {
            object.animations = [];
            for(let i28 = 0; i28 < this.animations.length; i28++){
                const animation = this.animations[i28];
                object.animations.push(serialize(meta.animations, animation));
            }
        }
        if (isRootObject) {
            const geometries = extractFromCache(meta.geometries);
            const materials = extractFromCache(meta.materials);
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            const shapes = extractFromCache(meta.shapes);
            const skeletons = extractFromCache(meta.skeletons);
            const animations = extractFromCache(meta.animations);
            if (geometries.length > 0) output.geometries = geometries;
            if (materials.length > 0) output.materials = materials;
            if (textures.length > 0) output.textures = textures;
            if (images.length > 0) output.images = images;
            if (shapes.length > 0) output.shapes = shapes;
            if (skeletons.length > 0) output.skeletons = skeletons;
            if (animations.length > 0) output.animations = animations;
        }
        output.object = object;
        return output;
        // extract data from the cache hash
        // remove metadata on each item
        // and return as array
        function extractFromCache(cache) {
            const values = [];
            for(const key in cache){
                const data = cache[key];
                delete data.metadata;
                values.push(data);
            }
            return values;
        }
    }
    clone(recursive) {
        return new this.constructor().copy(this, recursive);
    }
    copy(source, recursive = true) {
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) for(let i29 = 0; i29 < source.children.length; i29++){
            const child = source.children[i29];
            this.add(child.clone());
        }
        return this;
    }
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype.isObject3D = true;
const _v0$1 = /*@__PURE__*/ new Vector3();
const _v1$3 = /*@__PURE__*/ new Vector3();
const _v2$2 = /*@__PURE__*/ new Vector3();
const _v3$1 = /*@__PURE__*/ new Vector3();
const _vab = /*@__PURE__*/ new Vector3();
const _vac = /*@__PURE__*/ new Vector3();
const _vbc = /*@__PURE__*/ new Vector3();
const _vap = /*@__PURE__*/ new Vector3();
const _vbp = /*@__PURE__*/ new Vector3();
const _vcp = /*@__PURE__*/ new Vector3();
class Triangle {
    constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()){
        this.a = a;
        this.b = b;
        this.c = c;
    }
    static getNormal(a, b, c, target) {
        target.subVectors(c, b);
        _v0$1.subVectors(a, b);
        target.cross(_v0$1);
        const targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        return target.set(0, 0, 0);
    }
    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    static getBarycoord(point, a, b, c, target) {
        _v0$1.subVectors(c, a);
        _v1$3.subVectors(b, a);
        _v2$2.subVectors(point, a);
        const dot00 = _v0$1.dot(_v0$1);
        const dot01 = _v0$1.dot(_v1$3);
        const dot02 = _v0$1.dot(_v2$2);
        const dot11 = _v1$3.dot(_v1$3);
        const dot12 = _v1$3.dot(_v2$2);
        const denom = dot00 * dot11 - dot01 * dot01;
        // collinear or singular triangle
        if (denom === 0) // arbitrary location outside of triangle?
        // not sure if this is the best idea, maybe should be returning undefined
        return target.set(-2, -1, -1);
        const invDenom = 1 / denom;
        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        // barycentric coordinates must always sum to 1
        return target.set(1 - u - v, v, u);
    }
    static containsPoint(point, a, b, c) {
        this.getBarycoord(point, a, b, c, _v3$1);
        return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
    }
    static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
        this.getBarycoord(point, p1, p2, p3, _v3$1);
        target.set(0, 0);
        target.addScaledVector(uv1, _v3$1.x);
        target.addScaledVector(uv2, _v3$1.y);
        target.addScaledVector(uv3, _v3$1.z);
        return target;
    }
    static isFrontFacing(a, b, c, direction) {
        _v0$1.subVectors(c, b);
        _v1$3.subVectors(a, b);
        // strictly front facing
        return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
    }
    set(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
    }
    setFromPointsAndIndices(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
    }
    getArea() {
        _v0$1.subVectors(this.c, this.b);
        _v1$3.subVectors(this.a, this.b);
        return _v0$1.cross(_v1$3).length() * 0.5;
    }
    getMidpoint(target) {
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(target) {
        return Triangle.getNormal(this.a, this.b, this.c, target);
    }
    getPlane(target) {
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(point, target) {
        return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    }
    getUV(point, uv1, uv2, uv3, target) {
        return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
    }
    containsPoint(point) {
        return Triangle.containsPoint(point, this.a, this.b, this.c);
    }
    isFrontFacing(direction) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    }
    intersectsBox(box) {
        return box.intersectsTriangle(this);
    }
    closestPointToPoint(p, target) {
        const a = this.a, b = this.b, c = this.c;
        let v, w;
        // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
        // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
        // under the accompanying license; see chapter 5.1.5 for detailed explanation.
        // basically, we're distinguishing which of the voronoi regions of the triangle
        // the point lies in with the minimum amount of redundant computation.
        _vab.subVectors(b, a);
        _vac.subVectors(c, a);
        _vap.subVectors(p, a);
        const d1 = _vab.dot(_vap);
        const d2 = _vac.dot(_vap);
        if (d1 <= 0 && d2 <= 0) // vertex region of A; barycentric coords (1, 0, 0)
        return target.copy(a);
        _vbp.subVectors(p, b);
        const d3 = _vab.dot(_vbp);
        const d4 = _vac.dot(_vbp);
        if (d3 >= 0 && d4 <= d3) // vertex region of B; barycentric coords (0, 1, 0)
        return target.copy(b);
        const vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
            v = d1 / (d1 - d3);
            // edge region of AB; barycentric coords (1-v, v, 0)
            return target.copy(a).addScaledVector(_vab, v);
        }
        _vcp.subVectors(p, c);
        const d5 = _vab.dot(_vcp);
        const d6 = _vac.dot(_vcp);
        if (d6 >= 0 && d5 <= d6) // vertex region of C; barycentric coords (0, 0, 1)
        return target.copy(c);
        const vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
            w = d2 / (d2 - d6);
            // edge region of AC; barycentric coords (1-w, 0, w)
            return target.copy(a).addScaledVector(_vac, w);
        }
        const va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
            _vbc.subVectors(c, b);
            w = (d4 - d3) / (d4 - d3 + (d5 - d6));
            // edge region of BC; barycentric coords (0, 1-w, w)
            return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
        }
        // face region
        const denom = 1 / (va + vb + vc);
        // u = va * denom
        v = vb * denom;
        w = vc * denom;
        return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
    }
    equals(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
}
let materialId = 0;
class Material extends EventDispatcher {
    constructor(){
        super();
        Object.defineProperty(this, 'id', {
            value: materialId++
        });
        this.uuid = generateUUID();
        this.name = '';
        this.type = 'Material';
        this.fog = true;
        this.blending = NormalBlending;
        this.side = FrontSide;
        this.vertexColors = false;
        this.opacity = 1;
        this.format = RGBAFormat;
        this.transparent = false;
        this.blendSrc = SrcAlphaFactor;
        this.blendDst = OneMinusSrcAlphaFactor;
        this.blendEquation = AddEquation;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
        this.depthFunc = LessEqualDepth;
        this.depthTest = true;
        this.depthWrite = true;
        this.stencilWriteMask = 255;
        this.stencilFunc = AlwaysStencilFunc;
        this.stencilRef = 0;
        this.stencilFuncMask = 255;
        this.stencilFail = KeepStencilOp;
        this.stencilZFail = KeepStencilOp;
        this.stencilZPass = KeepStencilOp;
        this.stencilWrite = false;
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
        this.shadowSide = null;
        this.colorWrite = true;
        this.precision = null; // override the renderer's default precision for this material
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.dithering = false;
        this.alphaToCoverage = false;
        this.premultipliedAlpha = false;
        this.visible = true;
        this.toneMapped = true;
        this.userData = {};
        this.version = 0;
        this._alphaTest = 0;
    }
    get alphaTest() {
        return this._alphaTest;
    }
    set alphaTest(value) {
        if (this._alphaTest > 0 !== value > 0) this.version++;
        this._alphaTest = value;
    }
    onBuild() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString();
    }
    setValues(values) {
        if (values === undefined) return;
        for(const key in values){
            const newValue = values[key];
            if (newValue === undefined) {
                console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
                continue;
            }
            // for backward compatability if shading is set in the constructor
            if (key === 'shading') {
                console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                this.flatShading = newValue === FlatShading ? true : false;
                continue;
            }
            const currentValue = this[key];
            if (currentValue === undefined) {
                console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
                continue;
            }
            if (currentValue && currentValue.isColor) currentValue.set(newValue);
            else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) currentValue.copy(newValue);
            else this[key] = newValue;
        }
    }
    toJSON(meta) {
        const isRoot = meta === undefined || typeof meta === 'string';
        if (isRoot) meta = {
            textures: {},
            images: {}
        };
        const data1 = {
            metadata: {
                version: 4.5,
                type: 'Material',
                generator: 'Material.toJSON'
            }
        };
        // standard Material serialization
        data1.uuid = this.uuid;
        data1.type = this.type;
        if (this.name !== '') data1.name = this.name;
        if (this.color && this.color.isColor) data1.color = this.color.getHex();
        if (this.roughness !== undefined) data1.roughness = this.roughness;
        if (this.metalness !== undefined) data1.metalness = this.metalness;
        if (this.sheenTint && this.sheenTint.isColor) data1.sheenTint = this.sheenTint.getHex();
        if (this.emissive && this.emissive.isColor) data1.emissive = this.emissive.getHex();
        if (this.emissiveIntensity && this.emissiveIntensity !== 1) data1.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor) data1.specular = this.specular.getHex();
        if (this.specularIntensity !== undefined) data1.specularIntensity = this.specularIntensity;
        if (this.specularTint && this.specularTint.isColor) data1.specularTint = this.specularTint.getHex();
        if (this.shininess !== undefined) data1.shininess = this.shininess;
        if (this.clearcoat !== undefined) data1.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== undefined) data1.clearcoatRoughness = this.clearcoatRoughness;
        if (this.clearcoatMap && this.clearcoatMap.isTexture) data1.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) data1.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            data1.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
            data1.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.map && this.map.isTexture) data1.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture) data1.matcap = this.matcap.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture) data1.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture) {
            data1.lightMap = this.lightMap.toJSON(meta).uuid;
            data1.lightMapIntensity = this.lightMapIntensity;
        }
        if (this.aoMap && this.aoMap.isTexture) {
            data1.aoMap = this.aoMap.toJSON(meta).uuid;
            data1.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
            data1.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data1.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
            data1.normalMap = this.normalMap.toJSON(meta).uuid;
            data1.normalMapType = this.normalMapType;
            data1.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
            data1.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data1.displacementScale = this.displacementScale;
            data1.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture) data1.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture) data1.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture) data1.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture) data1.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data1.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
        if (this.specularTintMap && this.specularTintMap.isTexture) data1.specularTintMap = this.specularTintMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
            data1.envMap = this.envMap.toJSON(meta).uuid;
            if (this.combine !== undefined) data1.combine = this.combine;
        }
        if (this.envMapIntensity !== undefined) data1.envMapIntensity = this.envMapIntensity;
        if (this.reflectivity !== undefined) data1.reflectivity = this.reflectivity;
        if (this.refractionRatio !== undefined) data1.refractionRatio = this.refractionRatio;
        if (this.gradientMap && this.gradientMap.isTexture) data1.gradientMap = this.gradientMap.toJSON(meta).uuid;
        if (this.transmission !== undefined) data1.transmission = this.transmission;
        if (this.transmissionMap && this.transmissionMap.isTexture) data1.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
        if (this.thickness !== undefined) data1.thickness = this.thickness;
        if (this.thicknessMap && this.thicknessMap.isTexture) data1.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
        if (this.attenuationDistance !== undefined) data1.attenuationDistance = this.attenuationDistance;
        if (this.attenuationTint !== undefined) data1.attenuationTint = this.attenuationTint.getHex();
        if (this.size !== undefined) data1.size = this.size;
        if (this.shadowSide !== null) data1.shadowSide = this.shadowSide;
        if (this.sizeAttenuation !== undefined) data1.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== NormalBlending) data1.blending = this.blending;
        if (this.side !== FrontSide) data1.side = this.side;
        if (this.vertexColors) data1.vertexColors = true;
        if (this.opacity < 1) data1.opacity = this.opacity;
        if (this.format !== RGBAFormat) data1.format = this.format;
        if (this.transparent === true) data1.transparent = this.transparent;
        data1.depthFunc = this.depthFunc;
        data1.depthTest = this.depthTest;
        data1.depthWrite = this.depthWrite;
        data1.colorWrite = this.colorWrite;
        data1.stencilWrite = this.stencilWrite;
        data1.stencilWriteMask = this.stencilWriteMask;
        data1.stencilFunc = this.stencilFunc;
        data1.stencilRef = this.stencilRef;
        data1.stencilFuncMask = this.stencilFuncMask;
        data1.stencilFail = this.stencilFail;
        data1.stencilZFail = this.stencilZFail;
        data1.stencilZPass = this.stencilZPass;
        // rotation (SpriteMaterial)
        if (this.rotation && this.rotation !== 0) data1.rotation = this.rotation;
        if (this.polygonOffset === true) data1.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0) data1.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0) data1.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth && this.linewidth !== 1) data1.linewidth = this.linewidth;
        if (this.dashSize !== undefined) data1.dashSize = this.dashSize;
        if (this.gapSize !== undefined) data1.gapSize = this.gapSize;
        if (this.scale !== undefined) data1.scale = this.scale;
        if (this.dithering === true) data1.dithering = true;
        if (this.alphaTest > 0) data1.alphaTest = this.alphaTest;
        if (this.alphaToCoverage === true) data1.alphaToCoverage = this.alphaToCoverage;
        if (this.premultipliedAlpha === true) data1.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true) data1.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1) data1.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== 'round') data1.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== 'round') data1.wireframeLinejoin = this.wireframeLinejoin;
        if (this.flatShading === true) data1.flatShading = this.flatShading;
        if (this.visible === false) data1.visible = false;
        if (this.toneMapped === false) data1.toneMapped = false;
        if (JSON.stringify(this.userData) !== '{}') data1.userData = this.userData;
        // TODO: Copied from Object3D.toJSON
        function extractFromCache(cache) {
            const values = [];
            for(const key in cache){
                const data = cache[key];
                delete data.metadata;
                values.push(data);
            }
            return values;
        }
        if (isRoot) {
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            if (textures.length > 0) data1.textures = textures;
            if (images.length > 0) data1.images = images;
        }
        return data1;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.name = source.name;
        this.fog = source.fog;
        this.blending = source.blending;
        this.side = source.side;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.format = source.format;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        const srcPlanes = source.clippingPlanes;
        let dstPlanes = null;
        if (srcPlanes !== null) {
            const n = srcPlanes.length;
            dstPlanes = new Array(n);
            for(let i30 = 0; i30 !== n; ++i30)dstPlanes[i30] = srcPlanes[i30].clone();
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.alphaToCoverage = source.alphaToCoverage;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
    }
    dispose() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
    set needsUpdate(value) {
        if (value === true) this.version++;
    }
}
Material.prototype.isMaterial = true;
const _colorKeywords = {
    'aliceblue': 15792383,
    'antiquewhite': 16444375,
    'aqua': 65535,
    'aquamarine': 8388564,
    'azure': 15794175,
    'beige': 16119260,
    'bisque': 16770244,
    'black': 0,
    'blanchedalmond': 16772045,
    'blue': 255,
    'blueviolet': 9055202,
    'brown': 10824234,
    'burlywood': 14596231,
    'cadetblue': 6266528,
    'chartreuse': 8388352,
    'chocolate': 13789470,
    'coral': 16744272,
    'cornflowerblue': 6591981,
    'cornsilk': 16775388,
    'crimson': 14423100,
    'cyan': 65535,
    'darkblue': 139,
    'darkcyan': 35723,
    'darkgoldenrod': 12092939,
    'darkgray': 11119017,
    'darkgreen': 25600,
    'darkgrey': 11119017,
    'darkkhaki': 12433259,
    'darkmagenta': 9109643,
    'darkolivegreen': 5597999,
    'darkorange': 16747520,
    'darkorchid': 10040012,
    'darkred': 9109504,
    'darksalmon': 15308410,
    'darkseagreen': 9419919,
    'darkslateblue': 4734347,
    'darkslategray': 3100495,
    'darkslategrey': 3100495,
    'darkturquoise': 52945,
    'darkviolet': 9699539,
    'deeppink': 16716947,
    'deepskyblue': 49151,
    'dimgray': 6908265,
    'dimgrey': 6908265,
    'dodgerblue': 2003199,
    'firebrick': 11674146,
    'floralwhite': 16775920,
    'forestgreen': 2263842,
    'fuchsia': 16711935,
    'gainsboro': 14474460,
    'ghostwhite': 16316671,
    'gold': 16766720,
    'goldenrod': 14329120,
    'gray': 8421504,
    'green': 32768,
    'greenyellow': 11403055,
    'grey': 8421504,
    'honeydew': 15794160,
    'hotpink': 16738740,
    'indianred': 13458524,
    'indigo': 4915330,
    'ivory': 16777200,
    'khaki': 15787660,
    'lavender': 15132410,
    'lavenderblush': 16773365,
    'lawngreen': 8190976,
    'lemonchiffon': 16775885,
    'lightblue': 11393254,
    'lightcoral': 15761536,
    'lightcyan': 14745599,
    'lightgoldenrodyellow': 16448210,
    'lightgray': 13882323,
    'lightgreen': 9498256,
    'lightgrey': 13882323,
    'lightpink': 16758465,
    'lightsalmon': 16752762,
    'lightseagreen': 2142890,
    'lightskyblue': 8900346,
    'lightslategray': 7833753,
    'lightslategrey': 7833753,
    'lightsteelblue': 11584734,
    'lightyellow': 16777184,
    'lime': 65280,
    'limegreen': 3329330,
    'linen': 16445670,
    'magenta': 16711935,
    'maroon': 8388608,
    'mediumaquamarine': 6737322,
    'mediumblue': 205,
    'mediumorchid': 12211667,
    'mediumpurple': 9662683,
    'mediumseagreen': 3978097,
    'mediumslateblue': 8087790,
    'mediumspringgreen': 64154,
    'mediumturquoise': 4772300,
    'mediumvioletred': 13047173,
    'midnightblue': 1644912,
    'mintcream': 16121850,
    'mistyrose': 16770273,
    'moccasin': 16770229,
    'navajowhite': 16768685,
    'navy': 128,
    'oldlace': 16643558,
    'olive': 8421376,
    'olivedrab': 7048739,
    'orange': 16753920,
    'orangered': 16729344,
    'orchid': 14315734,
    'palegoldenrod': 15657130,
    'palegreen': 10025880,
    'paleturquoise': 11529966,
    'palevioletred': 14381203,
    'papayawhip': 16773077,
    'peachpuff': 16767673,
    'peru': 13468991,
    'pink': 16761035,
    'plum': 14524637,
    'powderblue': 11591910,
    'purple': 8388736,
    'rebeccapurple': 6697881,
    'red': 16711680,
    'rosybrown': 12357519,
    'royalblue': 4286945,
    'saddlebrown': 9127187,
    'salmon': 16416882,
    'sandybrown': 16032864,
    'seagreen': 3050327,
    'seashell': 16774638,
    'sienna': 10506797,
    'silver': 12632256,
    'skyblue': 8900331,
    'slateblue': 6970061,
    'slategray': 7372944,
    'slategrey': 7372944,
    'snow': 16775930,
    'springgreen': 65407,
    'steelblue': 4620980,
    'tan': 13808780,
    'teal': 32896,
    'thistle': 14204888,
    'tomato': 16737095,
    'turquoise': 4251856,
    'violet': 15631086,
    'wheat': 16113331,
    'white': 16777215,
    'whitesmoke': 16119285,
    'yellow': 16776960,
    'yellowgreen': 10145074
};
const _hslA = {
    h: 0,
    s: 0,
    l: 0
};
const _hslB = {
    h: 0,
    s: 0,
    l: 0
};
function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 0.5) return q;
    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
    return p;
}
function SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
    return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
class Color {
    constructor(r, g, b){
        if (g === undefined && b === undefined) // r is THREE.Color, hex or string
        return this.set(r);
        return this.setRGB(r, g, b);
    }
    set(value) {
        if (value && value.isColor) this.copy(value);
        else if (typeof value === 'number') this.setHex(value);
        else if (typeof value === 'string') this.setStyle(value);
        return this;
    }
    setScalar(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
    }
    setHex(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
    }
    setRGB(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
    }
    setHSL(h, s, l) {
        // h,s,l ranges are in 0.0 - 1.0
        h = euclideanModulo(h, 1);
        s = clamp(s, 0, 1);
        l = clamp(l, 0, 1);
        if (s === 0) this.r = this.g = this.b = l;
        else {
            const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
            const q = 2 * l - p;
            this.r = hue2rgb(q, p, h + 1 / 3);
            this.g = hue2rgb(q, p, h);
            this.b = hue2rgb(q, p, h - 1 / 3);
        }
        return this;
    }
    setStyle(style) {
        function handleAlpha(string) {
            if (string === undefined) return;
            if (parseFloat(string) < 1) console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
        }
        let m;
        if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
            // rgb / hsl
            let color;
            const name = m[1];
            const components = m[2];
            switch(name){
                case 'rgb':
                case 'rgba':
                    if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                        // rgb(255,0,0) rgba(255,0,0,0.5)
                        this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                        this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                        this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                        handleAlpha(color[4]);
                        return this;
                    }
                    if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                        this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                        this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                        this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                        handleAlpha(color[4]);
                        return this;
                    }
                    break;
                case 'hsl':
                case 'hsla':
                    if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                        // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                        const h = parseFloat(color[1]) / 360;
                        const s = parseInt(color[2], 10) / 100;
                        const l = parseInt(color[3], 10) / 100;
                        handleAlpha(color[4]);
                        return this.setHSL(h, s, l);
                    }
                    break;
            }
        } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
            // hex color
            const hex = m[1];
            const size = hex.length;
            if (size === 3) {
                // #ff0
                this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                return this;
            } else if (size === 6) {
                // #ff0000
                this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                return this;
            }
        }
        if (style && style.length > 0) return this.setColorName(style);
        return this;
    }
    setColorName(style) {
        // color keywords
        const hex = _colorKeywords[style.toLowerCase()];
        if (hex !== undefined) // red
        this.setHex(hex);
        else // unknown color
        console.warn('THREE.Color: Unknown color ' + style);
        return this;
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b);
    }
    copy(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
    }
    copyGammaToLinear(color, gammaFactor = 2) {
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
    }
    copyLinearToGamma(color, gammaFactor = 2) {
        const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
    }
    convertGammaToLinear(gammaFactor) {
        this.copyGammaToLinear(this, gammaFactor);
        return this;
    }
    convertLinearToGamma(gammaFactor) {
        this.copyLinearToGamma(this, gammaFactor);
        return this;
    }
    copySRGBToLinear(color) {
        this.r = SRGBToLinear(color.r);
        this.g = SRGBToLinear(color.g);
        this.b = SRGBToLinear(color.b);
        return this;
    }
    copyLinearToSRGB(color) {
        this.r = LinearToSRGB(color.r);
        this.g = LinearToSRGB(color.g);
        this.b = LinearToSRGB(color.b);
        return this;
    }
    convertSRGBToLinear() {
        this.copySRGBToLinear(this);
        return this;
    }
    convertLinearToSRGB() {
        this.copyLinearToSRGB(this);
        return this;
    }
    getHex() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    }
    getHexString() {
        return ('000000' + this.getHex().toString(16)).slice(-6);
    }
    getHSL(target) {
        // h,s,l ranges are in 0.0 - 1.0
        const r = this.r, g = this.g, b = this.b;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let hue, saturation;
        const lightness = (min + max) / 2;
        if (min === max) {
            hue = 0;
            saturation = 0;
        } else {
            const delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch(max){
                case r:
                    hue = (g - b) / delta + (g < b ? 6 : 0);
                    break;
                case g:
                    hue = (b - r) / delta + 2;
                    break;
                case b:
                    hue = (r - g) / delta + 4;
                    break;
            }
            hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
    }
    getStyle() {
        return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
    }
    offsetHSL(h, s, l) {
        this.getHSL(_hslA);
        _hslA.h += h;
        _hslA.s += s;
        _hslA.l += l;
        this.setHSL(_hslA.h, _hslA.s, _hslA.l);
        return this;
    }
    add(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
    }
    addColors(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
    }
    addScalar(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
    }
    sub(color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
    }
    multiply(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
    }
    multiplyScalar(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
    }
    lerp(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
    }
    lerpColors(color1, color2, alpha) {
        this.r = color1.r + (color2.r - color1.r) * alpha;
        this.g = color1.g + (color2.g - color1.g) * alpha;
        this.b = color1.b + (color2.b - color1.b) * alpha;
        return this;
    }
    lerpHSL(color, alpha) {
        this.getHSL(_hslA);
        color.getHSL(_hslB);
        const h = lerp(_hslA.h, _hslB.h, alpha);
        const s = lerp(_hslA.s, _hslB.s, alpha);
        const l = lerp(_hslA.l, _hslB.l, alpha);
        this.setHSL(h, s, l);
        return this;
    }
    equals(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
    }
    fromArray(array, offset = 0) {
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
    }
    fromBufferAttribute(attribute, index) {
        this.r = attribute.getX(index);
        this.g = attribute.getY(index);
        this.b = attribute.getZ(index);
        if (attribute.normalized === true) {
            // assuming Uint8Array
            this.r /= 255;
            this.g /= 255;
            this.b /= 255;
        }
        return this;
    }
    toJSON() {
        return this.getHex();
    }
}
Color.NAMES = _colorKeywords;
Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 * }
 */ class MeshBasicMaterial extends Material {
    constructor(parameters){
        super();
        this.type = 'MeshBasicMaterial';
        this.color = new Color(16777215); // emissive
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        return this;
    }
}
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
const _vector$9 = /*@__PURE__*/ new Vector3();
const _vector2$1 = /*@__PURE__*/ new Vector2();
class BufferAttribute {
    constructor(array, itemSize, normalized){
        if (Array.isArray(array)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        this.name = '';
        this.array = array;
        this.itemSize = itemSize;
        this.count = array !== undefined ? array.length / itemSize : 0;
        this.normalized = normalized === true;
        this.usage = StaticDrawUsage;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.version = 0;
    }
    onUploadCallback() {}
    set needsUpdate(value) {
        if (value === true) this.version++;
    }
    setUsage(value) {
        this.usage = value;
        return this;
    }
    copy(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        return this;
    }
    copyAt(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for(let i31 = 0, l = this.itemSize; i31 < l; i31++)this.array[index1 + i31] = attribute.array[index2 + i31];
        return this;
    }
    copyArray(array) {
        this.array.set(array);
        return this;
    }
    copyColorsArray(colors) {
        const array = this.array;
        let offset = 0;
        for(let i32 = 0, l = colors.length; i32 < l; i32++){
            let color = colors[i32];
            if (color === undefined) {
                console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i32);
                color = new Color();
            }
            array[offset++] = color.r;
            array[offset++] = color.g;
            array[offset++] = color.b;
        }
        return this;
    }
    copyVector2sArray(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i33 = 0, l = vectors.length; i33 < l; i33++){
            let vector = vectors[i33];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i33);
                vector = new Vector2();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
        }
        return this;
    }
    copyVector3sArray(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i34 = 0, l = vectors.length; i34 < l; i34++){
            let vector = vectors[i34];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i34);
                vector = new Vector3();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
        }
        return this;
    }
    copyVector4sArray(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i35 = 0, l = vectors.length; i35 < l; i35++){
            let vector = vectors[i35];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i35);
                vector = new Vector4();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
            array[offset++] = vector.w;
        }
        return this;
    }
    applyMatrix3(m) {
        if (this.itemSize === 2) for(let i37 = 0, l = this.count; i37 < l; i37++){
            _vector2$1.fromBufferAttribute(this, i37);
            _vector2$1.applyMatrix3(m);
            this.setXY(i37, _vector2$1.x, _vector2$1.y);
        }
        else if (this.itemSize === 3) for(let i36 = 0, l1 = this.count; i36 < l1; i36++){
            _vector$9.fromBufferAttribute(this, i36);
            _vector$9.applyMatrix3(m);
            this.setXYZ(i36, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
    }
    applyMatrix4(m) {
        for(let i38 = 0, l = this.count; i38 < l; i38++){
            _vector$9.x = this.getX(i38);
            _vector$9.y = this.getY(i38);
            _vector$9.z = this.getZ(i38);
            _vector$9.applyMatrix4(m);
            this.setXYZ(i38, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
    }
    applyNormalMatrix(m) {
        for(let i39 = 0, l = this.count; i39 < l; i39++){
            _vector$9.x = this.getX(i39);
            _vector$9.y = this.getY(i39);
            _vector$9.z = this.getZ(i39);
            _vector$9.applyNormalMatrix(m);
            this.setXYZ(i39, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
    }
    transformDirection(m) {
        for(let i40 = 0, l = this.count; i40 < l; i40++){
            _vector$9.x = this.getX(i40);
            _vector$9.y = this.getY(i40);
            _vector$9.z = this.getZ(i40);
            _vector$9.transformDirection(m);
            this.setXYZ(i40, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
    }
    set(value, offset = 0) {
        this.array.set(value, offset);
        return this;
    }
    getX(index) {
        return this.array[index * this.itemSize];
    }
    setX(index, x) {
        this.array[index * this.itemSize] = x;
        return this;
    }
    getY(index) {
        return this.array[index * this.itemSize + 1];
    }
    setY(index, y) {
        this.array[index * this.itemSize + 1] = y;
        return this;
    }
    getZ(index) {
        return this.array[index * this.itemSize + 2];
    }
    setZ(index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
    }
    getW(index) {
        return this.array[index * this.itemSize + 3];
    }
    setW(index, w) {
        this.array[index * this.itemSize + 3] = w;
        return this;
    }
    setXY(index, x, y) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        return this;
    }
    setXYZ(index, x, y, z) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
    }
    setXYZW(index, x, y, z, w) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
    }
    onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
    }
    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
        const data = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
        };
        if (this.name !== '') data.name = this.name;
        if (this.usage !== StaticDrawUsage) data.usage = this.usage;
        if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
        return data;
    }
}
BufferAttribute.prototype.isBufferAttribute = true;
//
class Int8BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, normalized){
        super(new Int8Array(array), itemSize, normalized);
    }
}
class Uint8BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, normalized){
        super(new Uint8Array(array), itemSize, normalized);
    }
}
class Uint8ClampedBufferAttribute extends BufferAttribute {
    constructor(array, itemSize, normalized){
        super(new Uint8ClampedArray(array), itemSize, normalized);
    }
}
class Int16BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, normalized){
        super(new Int16Array(array), itemSize, normalized);
    }
}
class Uint16BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, normalized){
        super(new Uint16Array(array), itemSize, normalized);
    }
}
class Int32BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, normalized){
        super(new Int32Array(array), itemSize, normalized);
    }
}
class Uint32BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, normalized){
        super(new Uint32Array(array), itemSize, normalized);
    }
}
class Float16BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, normalized){
        super(new Uint16Array(array), itemSize, normalized);
    }
}
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
class Float32BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, normalized){
        super(new Float32Array(array), itemSize, normalized);
    }
}
class Float64BufferAttribute extends BufferAttribute {
    constructor(array, itemSize, normalized){
        super(new Float64Array(array), itemSize, normalized);
    }
}
function arrayMax(array) {
    if (array.length === 0) return -Infinity;
    let max = array[0];
    for(let i41 = 1, l = array.length; i41 < l; ++i41)if (array[i41] > max) max = array[i41];
    return max;
}
const TYPED_ARRAYS = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    Uint8ClampedArray: Uint8ClampedArray,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
};
function getTypedArray(type, buffer) {
    return new TYPED_ARRAYS[type](buffer);
}
let _id = 0;
const _m1 = /*@__PURE__*/ new Matrix4();
const _obj = /*@__PURE__*/ new Object3D();
const _offset = /*@__PURE__*/ new Vector3();
const _box$1 = /*@__PURE__*/ new Box3();
const _boxMorphTargets = /*@__PURE__*/ new Box3();
const _vector$8 = /*@__PURE__*/ new Vector3();
class BufferGeometry extends EventDispatcher {
    constructor(){
        super();
        Object.defineProperty(this, 'id', {
            value: _id++
        });
        this.uuid = generateUUID();
        this.name = '';
        this.type = 'BufferGeometry';
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.morphTargetsRelative = false;
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.drawRange = {
            start: 0,
            count: Infinity
        };
        this.userData = {};
    }
    getIndex() {
        return this.index;
    }
    setIndex(index) {
        if (Array.isArray(index)) this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
        else this.index = index;
        return this;
    }
    getAttribute(name) {
        return this.attributes[name];
    }
    setAttribute(name, attribute) {
        this.attributes[name] = attribute;
        return this;
    }
    deleteAttribute(name) {
        delete this.attributes[name];
        return this;
    }
    hasAttribute(name) {
        return this.attributes[name] !== undefined;
    }
    addGroup(start, count, materialIndex = 0) {
        this.groups.push({
            start: start,
            count: count,
            materialIndex: materialIndex
        });
    }
    clearGroups() {
        this.groups = [];
    }
    setDrawRange(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
    }
    applyMatrix4(matrix) {
        const position = this.attributes.position;
        if (position !== undefined) {
            position.applyMatrix4(matrix);
            position.needsUpdate = true;
        }
        const normal = this.attributes.normal;
        if (normal !== undefined) {
            const normalMatrix = new Matrix3().getNormalMatrix(matrix);
            normal.applyNormalMatrix(normalMatrix);
            normal.needsUpdate = true;
        }
        const tangent = this.attributes.tangent;
        if (tangent !== undefined) {
            tangent.transformDirection(matrix);
            tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) this.computeBoundingBox();
        if (this.boundingSphere !== null) this.computeBoundingSphere();
        return this;
    }
    applyQuaternion(q) {
        _m1.makeRotationFromQuaternion(q);
        this.applyMatrix4(_m1);
        return this;
    }
    rotateX(angle) {
        // rotate geometry around world x-axis
        _m1.makeRotationX(angle);
        this.applyMatrix4(_m1);
        return this;
    }
    rotateY(angle) {
        // rotate geometry around world y-axis
        _m1.makeRotationY(angle);
        this.applyMatrix4(_m1);
        return this;
    }
    rotateZ(angle) {
        // rotate geometry around world z-axis
        _m1.makeRotationZ(angle);
        this.applyMatrix4(_m1);
        return this;
    }
    translate(x, y, z) {
        // translate geometry
        _m1.makeTranslation(x, y, z);
        this.applyMatrix4(_m1);
        return this;
    }
    scale(x, y, z) {
        // scale geometry
        _m1.makeScale(x, y, z);
        this.applyMatrix4(_m1);
        return this;
    }
    lookAt(vector) {
        _obj.lookAt(vector);
        _obj.updateMatrix();
        this.applyMatrix4(_obj.matrix);
        return this;
    }
    center() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset).negate();
        this.translate(_offset.x, _offset.y, _offset.z);
        return this;
    }
    setFromPoints(points) {
        const position = [];
        for(let i42 = 0, l = points.length; i42 < l; i42++){
            const point = points[i42];
            position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute('position', new Float32BufferAttribute(position, 3));
        return this;
    }
    computeBoundingBox() {
        if (this.boundingBox === null) this.boundingBox = new Box3();
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
            return;
        }
        if (position !== undefined) {
            this.boundingBox.setFromBufferAttribute(position);
            // process morph attributes if present
            if (morphAttributesPosition) for(let i43 = 0, il = morphAttributesPosition.length; i43 < il; i43++){
                const morphAttribute = morphAttributesPosition[i43];
                _box$1.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                    _vector$8.addVectors(this.boundingBox.min, _box$1.min);
                    this.boundingBox.expandByPoint(_vector$8);
                    _vector$8.addVectors(this.boundingBox.max, _box$1.max);
                    this.boundingBox.expandByPoint(_vector$8);
                } else {
                    this.boundingBox.expandByPoint(_box$1.min);
                    this.boundingBox.expandByPoint(_box$1.max);
                }
            }
        } else this.boundingBox.makeEmpty();
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
        if (this.boundingSphere === null) this.boundingSphere = new Sphere();
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingSphere.set(new Vector3(), Infinity);
            return;
        }
        if (position) {
            // first, find the center of the bounding sphere
            const center = this.boundingSphere.center;
            _box$1.setFromBufferAttribute(position);
            // process morph attributes if present
            if (morphAttributesPosition) for(let i46 = 0, il = morphAttributesPosition.length; i46 < il; i46++){
                const morphAttribute = morphAttributesPosition[i46];
                _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                    _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
                    _box$1.expandByPoint(_vector$8);
                    _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
                    _box$1.expandByPoint(_vector$8);
                } else {
                    _box$1.expandByPoint(_boxMorphTargets.min);
                    _box$1.expandByPoint(_boxMorphTargets.max);
                }
            }
            _box$1.getCenter(center);
            // second, try to find a boundingSphere with a radius smaller than the
            // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
            let maxRadiusSq = 0;
            for(let i44 = 0, il1 = position.count; i44 < il1; i44++){
                _vector$8.fromBufferAttribute(position, i44);
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
            // process morph attributes if present
            if (morphAttributesPosition) for(let i45 = 0, il2 = morphAttributesPosition.length; i45 < il2; i45++){
                const morphAttribute = morphAttributesPosition[i45];
                const morphTargetsRelative = this.morphTargetsRelative;
                for(let j = 0, jl = morphAttribute.count; j < jl; j++){
                    _vector$8.fromBufferAttribute(morphAttribute, j);
                    if (morphTargetsRelative) {
                        _offset.fromBufferAttribute(position, j);
                        _vector$8.add(_offset);
                    }
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
                }
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
    }
    computeTangents() {
        const index = this.index;
        const attributes = this.attributes;
        // based on http://www.terathon.com/code/tangent.html
        // (per vertex tangents)
        if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
            console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
            return;
        }
        const indices = index.array;
        const positions = attributes.position.array;
        const normals = attributes.normal.array;
        const uvs = attributes.uv.array;
        const nVertices = positions.length / 3;
        if (attributes.tangent === undefined) this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
        const tangents = attributes.tangent.array;
        const tan1 = [], tan2 = [];
        for(let i49 = 0; i49 < nVertices; i49++){
            tan1[i49] = new Vector3();
            tan2[i49] = new Vector3();
        }
        const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
        function handleTriangle(a, b, c) {
            vA.fromArray(positions, a * 3);
            vB.fromArray(positions, b * 3);
            vC.fromArray(positions, c * 3);
            uvA.fromArray(uvs, a * 2);
            uvB.fromArray(uvs, b * 2);
            uvC.fromArray(uvs, c * 2);
            vB.sub(vA);
            vC.sub(vA);
            uvB.sub(uvA);
            uvC.sub(uvA);
            const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
            // silently ignore degenerate uv triangles having coincident or colinear vertices
            if (!isFinite(r)) return;
            sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
            tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
            tan1[a].add(sdir);
            tan1[b].add(sdir);
            tan1[c].add(sdir);
            tan2[a].add(tdir);
            tan2[b].add(tdir);
            tan2[c].add(tdir);
        }
        let groups = this.groups;
        if (groups.length === 0) groups = [
            {
                start: 0,
                count: indices.length
            }
        ];
        for(let i47 = 0, il = groups.length; i47 < il; ++i47){
            const group = groups[i47];
            const start = group.start;
            const count = group.count;
            for(let j = start, jl = start + count; j < jl; j += 3)handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
        }
        const tmp3 = new Vector3(), tmp2 = new Vector3();
        const n = new Vector3(), n2 = new Vector3();
        function handleVertex(v) {
            n.fromArray(normals, v * 3);
            n2.copy(n);
            const t = tan1[v];
            // Gram-Schmidt orthogonalize
            tmp3.copy(t);
            tmp3.sub(n.multiplyScalar(n.dot(t))).normalize();
            // Calculate handedness
            tmp2.crossVectors(n2, t);
            const test = tmp2.dot(tan2[v]);
            const w = test < 0 ? -1 : 1;
            tangents[v * 4] = tmp3.x;
            tangents[v * 4 + 1] = tmp3.y;
            tangents[v * 4 + 2] = tmp3.z;
            tangents[v * 4 + 3] = w;
        }
        for(let i48 = 0, il3 = groups.length; i48 < il3; ++i48){
            const group = groups[i48];
            const start = group.start;
            const count = group.count;
            for(let j = start, jl = start + count; j < jl; j += 3){
                handleVertex(indices[j + 0]);
                handleVertex(indices[j + 1]);
                handleVertex(indices[j + 2]);
            }
        }
    }
    computeVertexNormals() {
        const index = this.index;
        const positionAttribute = this.getAttribute('position');
        if (positionAttribute !== undefined) {
            let normalAttribute = this.getAttribute('normal');
            if (normalAttribute === undefined) {
                normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
                this.setAttribute('normal', normalAttribute);
            } else // reset existing normals to zero
            for(let i52 = 0, il = normalAttribute.count; i52 < il; i52++)normalAttribute.setXYZ(i52, 0, 0, 0);
            const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
            const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
            const cb = new Vector3(), ab = new Vector3();
            // indexed elements
            if (index) for(let i50 = 0, il4 = index.count; i50 < il4; i50 += 3){
                const vA = index.getX(i50 + 0);
                const vB = index.getX(i50 + 1);
                const vC = index.getX(i50 + 2);
                pA.fromBufferAttribute(positionAttribute, vA);
                pB.fromBufferAttribute(positionAttribute, vB);
                pC.fromBufferAttribute(positionAttribute, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                nA.fromBufferAttribute(normalAttribute, vA);
                nB.fromBufferAttribute(normalAttribute, vB);
                nC.fromBufferAttribute(normalAttribute, vC);
                nA.add(cb);
                nB.add(cb);
                nC.add(cb);
                normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
            }
            else // non-indexed elements (unconnected triangle soup)
            for(let i51 = 0, il5 = positionAttribute.count; i51 < il5; i51 += 3){
                pA.fromBufferAttribute(positionAttribute, i51 + 0);
                pB.fromBufferAttribute(positionAttribute, i51 + 1);
                pC.fromBufferAttribute(positionAttribute, i51 + 2);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normalAttribute.setXYZ(i51 + 0, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i51 + 1, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i51 + 2, cb.x, cb.y, cb.z);
            }
            this.normalizeNormals();
            normalAttribute.needsUpdate = true;
        }
    }
    merge(geometry, offset) {
        if (!(geometry && geometry.isBufferGeometry)) {
            console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
            return;
        }
        if (offset === undefined) {
            offset = 0;
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
        }
        const attributes = this.attributes;
        for(const key in attributes){
            if (geometry.attributes[key] === undefined) continue;
            const attribute1 = attributes[key];
            const attributeArray1 = attribute1.array;
            const attribute2 = geometry.attributes[key];
            const attributeArray2 = attribute2.array;
            const attributeOffset = attribute2.itemSize * offset;
            const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
            for(let i53 = 0, j = attributeOffset; i53 < length; i53++, j++)attributeArray1[j] = attributeArray2[i53];
        }
        return this;
    }
    normalizeNormals() {
        const normals = this.attributes.normal;
        for(let i54 = 0, il = normals.count; i54 < il; i54++){
            _vector$8.fromBufferAttribute(normals, i54);
            _vector$8.normalize();
            normals.setXYZ(i54, _vector$8.x, _vector$8.y, _vector$8.z);
        }
    }
    toNonIndexed() {
        function convertBufferAttribute(attribute, indices) {
            const array = attribute.array;
            const itemSize = attribute.itemSize;
            const normalized = attribute.normalized;
            const array2 = new array.constructor(indices.length * itemSize);
            let index = 0, index2 = 0;
            for(let i56 = 0, l = indices.length; i56 < l; i56++){
                if (attribute.isInterleavedBufferAttribute) index = indices[i56] * attribute.data.stride + attribute.offset;
                else index = indices[i56] * itemSize;
                for(let j = 0; j < itemSize; j++)array2[index2++] = array[index++];
            }
            return new BufferAttribute(array2, itemSize, normalized);
        }
        //
        if (this.index === null) {
            console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
            return this;
        }
        const geometry2 = new BufferGeometry();
        const indices1 = this.index.array;
        const attributes = this.attributes;
        // attributes
        for(const name in attributes){
            const attribute = attributes[name];
            const newAttribute = convertBufferAttribute(attribute, indices1);
            geometry2.setAttribute(name, newAttribute);
        }
        // morph attributes
        const morphAttributes = this.morphAttributes;
        for(const name1 in morphAttributes){
            const morphArray = [];
            const morphAttribute = morphAttributes[name1]; // morphAttribute: array of Float32BufferAttributes
            for(let i57 = 0, il = morphAttribute.length; i57 < il; i57++){
                const attribute = morphAttribute[i57];
                const newAttribute = convertBufferAttribute(attribute, indices1);
                morphArray.push(newAttribute);
            }
            geometry2.morphAttributes[name1] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;
        // groups
        const groups = this.groups;
        for(let i55 = 0, l2 = groups.length; i55 < l2; i55++){
            const group = groups[i55];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
    }
    toJSON() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'BufferGeometry',
                generator: 'BufferGeometry.toJSON'
            }
        };
        // standard BufferGeometry serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '') data.name = this.name;
        if (Object.keys(this.userData).length > 0) data.userData = this.userData;
        if (this.parameters !== undefined) {
            const parameters = this.parameters;
            for(const key in parameters)if (parameters[key] !== undefined) data[key] = parameters[key];
            return data;
        }
        // for simplicity the code assumes attributes are not shared across geometries, see #15811
        data.data = {
            attributes: {}
        };
        const index = this.index;
        if (index !== null) data.data.index = {
            type: index.array.constructor.name,
            array: Array.prototype.slice.call(index.array)
        };
        const attributes = this.attributes;
        for(const key in attributes){
            const attribute = attributes[key];
            data.data.attributes[key] = attribute.toJSON(data.data);
        }
        const morphAttributes = {};
        let hasMorphAttributes = false;
        for(const key1 in this.morphAttributes){
            const attributeArray = this.morphAttributes[key1];
            const array = [];
            for(let i58 = 0, il = attributeArray.length; i58 < il; i58++){
                const attribute = attributeArray[i58];
                array.push(attribute.toJSON(data.data));
            }
            if (array.length > 0) {
                morphAttributes[key1] = array;
                hasMorphAttributes = true;
            }
        }
        if (hasMorphAttributes) {
            data.data.morphAttributes = morphAttributes;
            data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        const groups = this.groups;
        if (groups.length > 0) data.data.groups = JSON.parse(JSON.stringify(groups));
        const boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
        };
        return data;
    }
    clone() {
        /*
		 // Handle primitives

		 const parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 const values = [];

		 for ( const key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 const geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */ return new BufferGeometry().copy(this);
    }
    copy(source) {
        // reset
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        // used for storing cloned, shared data
        const data = {};
        // name
        this.name = source.name;
        // index
        const index = source.index;
        if (index !== null) this.setIndex(index.clone(data));
        // attributes
        const attributes = source.attributes;
        for(const name in attributes){
            const attribute = attributes[name];
            this.setAttribute(name, attribute.clone(data));
        }
        // morph attributes
        const morphAttributes = source.morphAttributes;
        for(const name2 in morphAttributes){
            const array = [];
            const morphAttribute = morphAttributes[name2]; // morphAttribute: array of Float32BufferAttributes
            for(let i59 = 0, l = morphAttribute.length; i59 < l; i59++)array.push(morphAttribute[i59].clone(data));
            this.morphAttributes[name2] = array;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;
        // groups
        const groups = source.groups;
        for(let i60 = 0, l = groups.length; i60 < l; i60++){
            const group = groups[i60];
            this.addGroup(group.start, group.count, group.materialIndex);
        }
        // bounding box
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) this.boundingBox = boundingBox.clone();
        // bounding sphere
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) this.boundingSphere = boundingSphere.clone();
        // draw range
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        // user data
        this.userData = source.userData;
        return this;
    }
    dispose() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
}
BufferGeometry.prototype.isBufferGeometry = true;
const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
const _ray$2 = /*@__PURE__*/ new Ray();
const _sphere$3 = /*@__PURE__*/ new Sphere();
const _vA$1 = /*@__PURE__*/ new Vector3();
const _vB$1 = /*@__PURE__*/ new Vector3();
const _vC$1 = /*@__PURE__*/ new Vector3();
const _tempA = /*@__PURE__*/ new Vector3();
const _tempB = /*@__PURE__*/ new Vector3();
const _tempC = /*@__PURE__*/ new Vector3();
const _morphA = /*@__PURE__*/ new Vector3();
const _morphB = /*@__PURE__*/ new Vector3();
const _morphC = /*@__PURE__*/ new Vector3();
const _uvA$1 = /*@__PURE__*/ new Vector2();
const _uvB$1 = /*@__PURE__*/ new Vector2();
const _uvC$1 = /*@__PURE__*/ new Vector2();
const _intersectionPoint = /*@__PURE__*/ new Vector3();
const _intersectionPointWorld = /*@__PURE__*/ new Vector3();
class Mesh extends Object3D {
    constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()){
        super();
        this.type = 'Mesh';
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
    }
    copy(source) {
        super.copy(source);
        if (source.morphTargetInfluences !== undefined) this.morphTargetInfluences = source.morphTargetInfluences.slice();
        if (source.morphTargetDictionary !== undefined) this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    }
    updateMorphTargets() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    }
    raycast(raycaster, intersects1) {
        const geometry = this.geometry;
        const material = this.material;
        const matrixWorld = this.matrixWorld;
        if (material === undefined) return;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$3.copy(geometry.boundingSphere);
        _sphere$3.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;
        //
        _inverseMatrix$2.copy(matrixWorld).invert();
        _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
        // Check boundingBox before continuing
        if (geometry.boundingBox !== null) {
            if (_ray$2.intersectsBox(geometry.boundingBox) === false) return;
        }
        let intersection;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const position = geometry.attributes.position;
            const morphPosition = geometry.morphAttributes.position;
            const morphTargetsRelative = geometry.morphTargetsRelative;
            const uv = geometry.attributes.uv;
            const uv2 = geometry.attributes.uv2;
            const groups = geometry.groups;
            const drawRange = geometry.drawRange;
            if (index !== null) {
                // indexed buffer geometry
                if (Array.isArray(material)) for(let i61 = 0, il = groups.length; i61 < il; i61++){
                    const group = groups[i61];
                    const groupMaterial = material[group.materialIndex];
                    const start = Math.max(group.start, drawRange.start);
                    const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                    for(let j = start, jl = end; j < jl; j += 3){
                        const a = index.getX(j);
                        const b = index.getX(j + 1);
                        const c = index.getX(j + 2);
                        intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                            intersection.face.materialIndex = group.materialIndex;
                            intersects1.push(intersection);
                        }
                    }
                }
                else {
                    const start = Math.max(0, drawRange.start);
                    const end = Math.min(index.count, drawRange.start + drawRange.count);
                    for(let i62 = start, il = end; i62 < il; i62 += 3){
                        const a = index.getX(i62);
                        const b = index.getX(i62 + 1);
                        const c = index.getX(i62 + 2);
                        intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i62 / 3); // triangle number in indexed buffer semantics
                            intersects1.push(intersection);
                        }
                    }
                }
            } else if (position !== undefined) {
                // non-indexed buffer geometry
                if (Array.isArray(material)) for(let i63 = 0, il = groups.length; i63 < il; i63++){
                    const group = groups[i63];
                    const groupMaterial = material[group.materialIndex];
                    const start = Math.max(group.start, drawRange.start);
                    const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                    for(let j = start, jl = end; j < jl; j += 3){
                        const a = j;
                        const b = j + 1;
                        const c = j + 2;
                        intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
                            intersection.face.materialIndex = group.materialIndex;
                            intersects1.push(intersection);
                        }
                    }
                }
                else {
                    const start = Math.max(0, drawRange.start);
                    const end = Math.min(position.count, drawRange.start + drawRange.count);
                    for(let i64 = start, il = end; i64 < il; i64 += 3){
                        const a = i64;
                        const b = i64 + 1;
                        const c = i64 + 2;
                        intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i64 / 3); // triangle number in non-indexed buffer semantics
                            intersects1.push(intersection);
                        }
                    }
                }
            }
        } else if (geometry.isGeometry) console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
}
Mesh.prototype.isMesh = true;
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    else intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
    if (intersect === null) return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far) return null;
    return {
        distance: distance,
        point: _intersectionPointWorld.clone(),
        object: object
    };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
    _vA$1.fromBufferAttribute(position, a);
    _vB$1.fromBufferAttribute(position, b);
    _vC$1.fromBufferAttribute(position, c);
    const morphInfluences = object.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
        _morphA.set(0, 0, 0);
        _morphB.set(0, 0, 0);
        _morphC.set(0, 0, 0);
        for(let i65 = 0, il = morphPosition.length; i65 < il; i65++){
            const influence = morphInfluences[i65];
            const morphAttribute = morphPosition[i65];
            if (influence === 0) continue;
            _tempA.fromBufferAttribute(morphAttribute, a);
            _tempB.fromBufferAttribute(morphAttribute, b);
            _tempC.fromBufferAttribute(morphAttribute, c);
            if (morphTargetsRelative) {
                _morphA.addScaledVector(_tempA, influence);
                _morphB.addScaledVector(_tempB, influence);
                _morphC.addScaledVector(_tempC, influence);
            } else {
                _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
                _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
                _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
            }
        }
        _vA$1.add(_morphA);
        _vB$1.add(_morphB);
        _vC$1.add(_morphC);
    }
    if (object.isSkinnedMesh) {
        object.boneTransform(a, _vA$1);
        object.boneTransform(b, _vB$1);
        object.boneTransform(c, _vC$1);
    }
    const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (intersection) {
        if (uv) {
            _uvA$1.fromBufferAttribute(uv, a);
            _uvB$1.fromBufferAttribute(uv, b);
            _uvC$1.fromBufferAttribute(uv, c);
            intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
        }
        if (uv2) {
            _uvA$1.fromBufferAttribute(uv2, a);
            _uvB$1.fromBufferAttribute(uv2, b);
            _uvC$1.fromBufferAttribute(uv2, c);
            intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
        }
        const face = {
            a: a,
            b: b,
            c: c,
            normal: new Vector3(),
            materialIndex: 0
        };
        Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
        intersection.face = face;
    }
    return intersection;
}
class BoxGeometry extends BufferGeometry {
    constructor(width1 = 1, height1 = 1, depth1 = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1){
        super();
        this.type = 'BoxGeometry';
        this.parameters = {
            width: width1,
            height: height1,
            depth: depth1,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        const scope = this;
        // segments
        widthSegments = Math.floor(widthSegments);
        heightSegments = Math.floor(heightSegments);
        depthSegments = Math.floor(depthSegments);
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        let numberOfVertices = 0;
        let groupStart = 0;
        // build each side of the box geometry
        buildPlane('z', 'y', 'x', -1, -1, depth1, height1, width1, depthSegments, heightSegments, 0); // px
        buildPlane('z', 'y', 'x', 1, -1, depth1, height1, -width1, depthSegments, heightSegments, 1); // nx
        buildPlane('x', 'z', 'y', 1, 1, width1, depth1, height1, widthSegments, depthSegments, 2); // py
        buildPlane('x', 'z', 'y', 1, -1, width1, depth1, -height1, widthSegments, depthSegments, 3); // ny
        buildPlane('x', 'y', 'z', 1, -1, width1, height1, depth1, widthSegments, heightSegments, 4); // pz
        buildPlane('x', 'y', 'z', -1, -1, width1, height1, -depth1, widthSegments, heightSegments, 5); // nz
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
            const segmentWidth = width / gridX;
            const segmentHeight = height / gridY;
            const widthHalf = width / 2;
            const heightHalf = height / 2;
            const depthHalf = depth / 2;
            const gridX1 = gridX + 1;
            const gridY1 = gridY + 1;
            let vertexCounter = 0;
            let groupCount = 0;
            const vector = new Vector3();
            // generate vertices, normals and uvs
            for(let iy = 0; iy < gridY1; iy++){
                const y = iy * segmentHeight - heightHalf;
                for(let ix = 0; ix < gridX1; ix++){
                    const x = ix * segmentWidth - widthHalf;
                    // set values to correct vector component
                    vector[u] = x * udir;
                    vector[v] = y * vdir;
                    vector[w] = depthHalf;
                    // now apply vector to vertex buffer
                    vertices.push(vector.x, vector.y, vector.z);
                    // set values to correct vector component
                    vector[u] = 0;
                    vector[v] = 0;
                    vector[w] = depth > 0 ? 1 : -1;
                    // now apply vector to normal buffer
                    normals.push(vector.x, vector.y, vector.z);
                    // uvs
                    uvs.push(ix / gridX);
                    uvs.push(1 - iy / gridY);
                    // counters
                    vertexCounter += 1;
                }
            }
            // indices
            // 1. you need three indices to draw a single face
            // 2. a single segment consists of two faces
            // 3. so we need to generate six (2*3) indices per segment
            for(let iy1 = 0; iy1 < gridY; iy1++)for(let ix = 0; ix < gridX; ix++){
                const a = numberOfVertices + ix + gridX1 * iy1;
                const b = numberOfVertices + ix + gridX1 * (iy1 + 1);
                const c = numberOfVertices + (ix + 1) + gridX1 * (iy1 + 1);
                const d = numberOfVertices + (ix + 1) + gridX1 * iy1;
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
                // increase counter
                groupCount += 6;
            }
            // add a group to the geometry. this will ensure multi material support
            scope.addGroup(groupStart, groupCount, materialIndex);
            // calculate new start value for groups
            groupStart += groupCount;
            // update total number of vertices
            numberOfVertices += vertexCounter;
        }
    }
    static fromJSON(data) {
        return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
    }
}
/**
 * Uniform Utilities
 */ function cloneUniforms(src) {
    const dst = {};
    for(const u in src){
        dst[u] = {};
        for(const p in src[u]){
            const property = src[u][p];
            if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) dst[u][p] = property.clone();
            else if (Array.isArray(property)) dst[u][p] = property.slice();
            else dst[u][p] = property;
        }
    }
    return dst;
}
function mergeUniforms(uniforms) {
    const merged = {};
    for(let u = 0; u < uniforms.length; u++){
        const tmp4 = cloneUniforms(uniforms[u]);
        for(const p in tmp4)merged[p] = tmp4[p];
    }
    return merged;
}
// Legacy
const UniformsUtils = {
    clone: cloneUniforms,
    merge: mergeUniforms
};
var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
/**
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>
 * }
 */ class ShaderMaterial extends Material {
    constructor(parameters){
        super();
        this.type = 'ShaderMaterial';
        this.defines = {};
        this.uniforms = {};
        this.vertexShader = default_vertex;
        this.fragmentShader = default_fragment;
        this.linewidth = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false; // set to use scene fog
        this.lights = false; // set to use scene lights
        this.clipping = false; // set to use user-defined clipping planes
        this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false // set to use shader texture LOD
        };
        // When rendered geometry doesn't include these attributes but the material does,
        // use these default values in WebGL. This avoids errors when buffer data is missing.
        this.defaultAttributeValues = {
            'color': [
                1,
                1,
                1
            ],
            'uv': [
                0,
                0
            ],
            'uv2': [
                0,
                0
            ]
        };
        this.index0AttributeName = undefined;
        this.uniformsNeedUpdate = false;
        this.glslVersion = null;
        if (parameters !== undefined) {
            if (parameters.attributes !== undefined) console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
            this.setValues(parameters);
        }
    }
    copy(source) {
        super.copy(source);
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = cloneUniforms(source.uniforms);
        this.defines = Object.assign({}, source.defines);
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.lights = source.lights;
        this.clipping = source.clipping;
        this.extensions = Object.assign({}, source.extensions);
        this.glslVersion = source.glslVersion;
        return this;
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        data.glslVersion = this.glslVersion;
        data.uniforms = {};
        for(const name in this.uniforms){
            const uniform = this.uniforms[name];
            const value = uniform.value;
            if (value && value.isTexture) data.uniforms[name] = {
                type: 't',
                value: value.toJSON(meta).uuid
            };
            else if (value && value.isColor) data.uniforms[name] = {
                type: 'c',
                value: value.getHex()
            };
            else if (value && value.isVector2) data.uniforms[name] = {
                type: 'v2',
                value: value.toArray()
            };
            else if (value && value.isVector3) data.uniforms[name] = {
                type: 'v3',
                value: value.toArray()
            };
            else if (value && value.isVector4) data.uniforms[name] = {
                type: 'v4',
                value: value.toArray()
            };
            else if (value && value.isMatrix3) data.uniforms[name] = {
                type: 'm3',
                value: value.toArray()
            };
            else if (value && value.isMatrix4) data.uniforms[name] = {
                type: 'm4',
                value: value.toArray()
            };
            else data.uniforms[name] = {
                value: value
            };
        }
        if (Object.keys(this.defines).length > 0) data.defines = this.defines;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
        const extensions = {};
        for(const key in this.extensions)if (this.extensions[key] === true) extensions[key] = true;
        if (Object.keys(extensions).length > 0) data.extensions = extensions;
        return data;
    }
}
ShaderMaterial.prototype.isShaderMaterial = true;
class Camera extends Object3D {
    constructor(){
        super();
        this.type = 'Camera';
        this.matrixWorldInverse = new Matrix4();
        this.projectionMatrix = new Matrix4();
        this.projectionMatrixInverse = new Matrix4();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        return this;
    }
    getWorldDirection(target) {
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return target.set(-e[8], -e[9], -e[10]).normalize();
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(updateParents, updateChildren) {
        super.updateWorldMatrix(updateParents, updateChildren);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
Camera.prototype.isCamera = true;
class PerspectiveCamera extends Camera {
    constructor(fov1 = 50, aspect1 = 1, near = 0.1, far = 2000){
        super();
        this.type = 'PerspectiveCamera';
        this.fov = fov1;
        this.zoom = 1;
        this.near = near;
        this.far = far;
        this.focus = 10;
        this.aspect = aspect1;
        this.view = null;
        this.filmGauge = 35; // width of the film (default in millimeters)
        this.filmOffset = 0; // horizontal film offset (same unit as gauge)
        this.updateProjectionMatrix();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
    }
    /**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */ setFocalLength(focalLength) {
        /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */ const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
    }
    /**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */ getFocalLength() {
        const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
    }
    getEffectiveFOV() {
        return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
        // film not completely covered in portrait format (aspect < 1)
        return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
        // film not completely covered in landscape format (aspect > 1)
        return this.filmGauge / Math.max(this.aspect, 1);
    }
    /**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */ setViewOffset(fullWidth, fullHeight, x, y, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        const near = this.near;
        let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
        let height = 2 * top;
        let width = this.aspect * height;
        let left = -0.5 * width;
        const view = this.view;
        if (this.view !== null && this.view.enabled) {
            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width / fullWidth;
            top -= view.offsetY * height / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
        }
        const skew = this.filmOffset;
        if (skew !== 0) left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null) data.object.view = Object.assign({}, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
    }
}
PerspectiveCamera.prototype.isPerspectiveCamera = true;
const fov = 90, aspect = 1;
class CubeCamera extends Object3D {
    constructor(near, far, renderTarget){
        super();
        this.type = 'CubeCamera';
        if (renderTarget.isWebGLCubeRenderTarget !== true) {
            console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
            return;
        }
        this.renderTarget = renderTarget;
        const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
        cameraPX.layers = this.layers;
        cameraPX.up.set(0, -1, 0);
        cameraPX.lookAt(new Vector3(1, 0, 0));
        this.add(cameraPX);
        const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
        cameraNX.layers = this.layers;
        cameraNX.up.set(0, -1, 0);
        cameraNX.lookAt(new Vector3(-1, 0, 0));
        this.add(cameraNX);
        const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
        cameraPY.layers = this.layers;
        cameraPY.up.set(0, 0, 1);
        cameraPY.lookAt(new Vector3(0, 1, 0));
        this.add(cameraPY);
        const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
        cameraNY.layers = this.layers;
        cameraNY.up.set(0, 0, -1);
        cameraNY.lookAt(new Vector3(0, -1, 0));
        this.add(cameraNY);
        const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraPZ.layers = this.layers;
        cameraPZ.up.set(0, -1, 0);
        cameraPZ.lookAt(new Vector3(0, 0, 1));
        this.add(cameraPZ);
        const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraNZ.layers = this.layers;
        cameraNZ.up.set(0, -1, 0);
        cameraNZ.lookAt(new Vector3(0, 0, -1));
        this.add(cameraNZ);
    }
    update(renderer, scene) {
        if (this.parent === null) this.updateMatrixWorld();
        const renderTarget = this.renderTarget;
        const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
        const currentXrEnabled = renderer.xr.enabled;
        const currentRenderTarget = renderer.getRenderTarget();
        renderer.xr.enabled = false;
        const generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderer.setRenderTarget(renderTarget, 0);
        renderer.render(scene, cameraPX);
        renderer.setRenderTarget(renderTarget, 1);
        renderer.render(scene, cameraNX);
        renderer.setRenderTarget(renderTarget, 2);
        renderer.render(scene, cameraPY);
        renderer.setRenderTarget(renderTarget, 3);
        renderer.render(scene, cameraNY);
        renderer.setRenderTarget(renderTarget, 4);
        renderer.render(scene, cameraPZ);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderer.setRenderTarget(renderTarget, 5);
        renderer.render(scene, cameraNZ);
        renderer.setRenderTarget(currentRenderTarget);
        renderer.xr.enabled = currentXrEnabled;
    }
}
class CubeTexture extends Texture {
    constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding){
        images = images !== undefined ? images : [];
        mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
        format = format !== undefined ? format : RGBFormat;
        super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.flipY = false;
    }
    get images() {
        return this.image;
    }
    set images(value) {
        this.image = value;
    }
}
CubeTexture.prototype.isCubeTexture = true;
class WebGLCubeRenderTarget extends WebGLRenderTarget {
    constructor(size, options, dummy){
        if (Number.isInteger(options)) {
            console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
            options = dummy;
        }
        super(size, size, options);
        options = options || {};
        // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
        // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
        // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
        // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
        // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
        // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).
        this.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        this.texture.isRenderTargetTexture = true;
        this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
        this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
        this.texture._needsFlipEnvMap = false;
    }
    fromEquirectangularTexture(renderer, texture) {
        this.texture.type = texture.type;
        this.texture.format = RGBAFormat; // see #18859
        this.texture.encoding = texture.encoding;
        this.texture.generateMipmaps = texture.generateMipmaps;
        this.texture.minFilter = texture.minFilter;
        this.texture.magFilter = texture.magFilter;
        const shader = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: /* glsl */ `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: /* glsl */ `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        };
        const geometry = new BoxGeometry(5, 5, 5);
        const material = new ShaderMaterial({
            name: 'CubemapFromEquirect',
            uniforms: cloneUniforms(shader.uniforms),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader,
            side: BackSide,
            blending: NoBlending
        });
        material.uniforms.tEquirect.value = texture;
        const mesh = new Mesh(geometry, material);
        const currentMinFilter = texture.minFilter;
        // Avoid blurred poles
        if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
        const camera = new CubeCamera(1, 10, this);
        camera.update(renderer, mesh);
        texture.minFilter = currentMinFilter;
        mesh.geometry.dispose();
        mesh.material.dispose();
        return this;
    }
    clear(renderer, color, depth, stencil) {
        const currentRenderTarget = renderer.getRenderTarget();
        for(let i66 = 0; i66 < 6; i66++){
            renderer.setRenderTarget(this, i66);
            renderer.clear(color, depth, stencil);
        }
        renderer.setRenderTarget(currentRenderTarget);
    }
}
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
const _vector1 = /*@__PURE__*/ new Vector3();
const _vector2 = /*@__PURE__*/ new Vector3();
const _normalMatrix = /*@__PURE__*/ new Matrix3();
class Plane {
    constructor(normal = new Vector3(1, 0, 0), constant = 0){
        // normal is assumed to be normalized
        this.normal = normal;
        this.constant = constant;
    }
    set(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
    }
    setComponents(x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
    }
    setFromNormalAndCoplanarPoint(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
    }
    setFromCoplanarPoints(a, b, c) {
        const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
        // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
        this.setFromNormalAndCoplanarPoint(normal, a);
        return this;
    }
    copy(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
    }
    normalize() {
        // Note: will lead to a divide by zero if the plane is invalid.
        const inverseNormalLength = 1 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
    }
    negate() {
        this.constant *= -1;
        this.normal.negate();
        return this;
    }
    distanceToPoint(point) {
        return this.normal.dot(point) + this.constant;
    }
    distanceToSphere(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
    }
    projectPoint(point, target) {
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    }
    intersectLine(line, target) {
        const direction = line.delta(_vector1);
        const denominator = this.normal.dot(direction);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (this.distanceToPoint(line.start) === 0) return target.copy(line.start);
            // Unsure if this is the correct method to handle this case.
            return null;
        }
        const t = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t < 0 || t > 1) return null;
        return target.copy(direction).multiplyScalar(t).add(line.start);
    }
    intersectsLine(line) {
        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
        const startSign = this.distanceToPoint(line.start);
        const endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
    intersectsBox(box) {
        return box.intersectsPlane(this);
    }
    intersectsSphere(sphere) {
        return sphere.intersectsPlane(this);
    }
    coplanarPoint(target) {
        return target.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(matrix, optionalNormalMatrix) {
        const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
        const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
        const normal = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal);
        return this;
    }
    translate(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
    }
    equals(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
Plane.prototype.isPlane = true;
const _sphere$2 = /*@__PURE__*/ new Sphere();
const _vector$7 = /*@__PURE__*/ new Vector3();
class Frustum {
    constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()){
        this.planes = [
            p0,
            p1,
            p2,
            p3,
            p4,
            p5
        ];
    }
    set(p0, p1, p2, p3, p4, p5) {
        const planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
    }
    copy(frustum) {
        const planes = this.planes;
        for(let i67 = 0; i67 < 6; i67++)planes[i67].copy(frustum.planes[i67]);
        return this;
    }
    setFromProjectionMatrix(m) {
        const planes = this.planes;
        const me = m.elements;
        const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
    }
    intersectsObject(object) {
        const geometry = object.geometry;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        return this.intersectsSphere(_sphere$2);
    }
    intersectsSprite(sprite) {
        _sphere$2.center.set(0, 0, 0);
        _sphere$2.radius = 0.7071067811865476;
        _sphere$2.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(_sphere$2);
    }
    intersectsSphere(sphere) {
        const planes = this.planes;
        const center = sphere.center;
        const negRadius = -sphere.radius;
        for(let i68 = 0; i68 < 6; i68++){
            const distance = planes[i68].distanceToPoint(center);
            if (distance < negRadius) return false;
        }
        return true;
    }
    intersectsBox(box) {
        const planes = this.planes;
        for(let i69 = 0; i69 < 6; i69++){
            const plane = planes[i69];
            // corner at max distance
            _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            if (plane.distanceToPoint(_vector$7) < 0) return false;
        }
        return true;
    }
    containsPoint(point) {
        const planes = this.planes;
        for(let i70 = 0; i70 < 6; i70++){
            if (planes[i70].distanceToPoint(point) < 0) return false;
        }
        return true;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
function WebGLAnimation() {
    let context = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time, frame) {
        animationLoop(time, frame);
        requestId = context.requestAnimationFrame(onAnimationFrame);
    }
    return {
        start: function() {
            if (isAnimating === true) return;
            if (animationLoop === null) return;
            requestId = context.requestAnimationFrame(onAnimationFrame);
            isAnimating = true;
        },
        stop: function() {
            context.cancelAnimationFrame(requestId);
            isAnimating = false;
        },
        setAnimationLoop: function(callback) {
            animationLoop = callback;
        },
        setContext: function(value) {
            context = value;
        }
    };
}
function WebGLAttributes(gl, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = new WeakMap();
    function createBuffer(attribute, bufferType) {
        const array = attribute.array;
        const usage = attribute.usage;
        const buffer = gl.createBuffer();
        gl.bindBuffer(bufferType, buffer);
        gl.bufferData(bufferType, array, usage);
        attribute.onUploadCallback();
        let type = 5126;
        if (array instanceof Float32Array) type = 5126;
        else if (array instanceof Float64Array) console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
        else if (array instanceof Uint16Array) {
            if (attribute.isFloat16BufferAttribute) {
                if (isWebGL2) type = 5131;
                else console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
            } else type = 5123;
        } else if (array instanceof Int16Array) type = 5122;
        else if (array instanceof Uint32Array) type = 5125;
        else if (array instanceof Int32Array) type = 5124;
        else if (array instanceof Int8Array) type = 5120;
        else if (array instanceof Uint8Array) type = 5121;
        else if (array instanceof Uint8ClampedArray) type = 5121;
        return {
            buffer: buffer,
            type: type,
            bytesPerElement: array.BYTES_PER_ELEMENT,
            version: attribute.version
        };
    }
    function updateBuffer(buffer, attribute, bufferType) {
        const array = attribute.array;
        const updateRange = attribute.updateRange;
        gl.bindBuffer(bufferType, buffer);
        if (updateRange.count === -1) // Not using update ranges
        gl.bufferSubData(bufferType, 0, array);
        else {
            if (isWebGL2) gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
            else gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
            updateRange.count = -1; // reset range
        }
    }
    //
    function get(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        return buffers.get(attribute);
    }
    function remove(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data) {
            gl.deleteBuffer(data.buffer);
            buffers.delete(attribute);
        }
    }
    function update(attribute, bufferType) {
        if (attribute.isGLBufferAttribute) {
            const cached = buffers.get(attribute);
            if (!cached || cached.version < attribute.version) buffers.set(attribute, {
                buffer: attribute.buffer,
                type: attribute.type,
                bytesPerElement: attribute.elementSize,
                version: attribute.version
            });
            return;
        }
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data === undefined) buffers.set(attribute, createBuffer(attribute, bufferType));
        else if (data.version < attribute.version) {
            updateBuffer(data.buffer, attribute, bufferType);
            data.version = attribute.version;
        }
    }
    return {
        get: get,
        remove: remove,
        update: update
    };
}
class PlaneGeometry extends BufferGeometry {
    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1){
        super();
        this.type = 'PlaneGeometry';
        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
        const width_half = width / 2;
        const height_half = height / 2;
        const gridX = Math.floor(widthSegments);
        const gridY = Math.floor(heightSegments);
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        const segment_width = width / gridX;
        const segment_height = height / gridY;
        //
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        for(let iy = 0; iy < gridY1; iy++){
            const y = iy * segment_height - height_half;
            for(let ix = 0; ix < gridX1; ix++){
                const x = ix * segment_width - width_half;
                vertices.push(x, -y, 0);
                normals.push(0, 0, 1);
                uvs.push(ix / gridX);
                uvs.push(1 - iy / gridY);
            }
        }
        for(let iy2 = 0; iy2 < gridY; iy2++)for(let ix = 0; ix < gridX; ix++){
            const a = ix + gridX1 * iy2;
            const b = ix + gridX1 * (iy2 + 1);
            const c = ix + 1 + gridX1 * (iy2 + 1);
            const d = ix + 1 + gridX1 * iy2;
            indices.push(a, b, d);
            indices.push(b, c, d);
        }
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    static fromJSON(data) {
        return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
    }
}
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotVH = saturate( dot( geometry.viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float NoH ) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float NoV, float NoL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( NoL + NoV - NoL * NoV ) ) );\n}\nvec3 BRDF_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in GeometricContext geometry ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenTint = sheenTint;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenTint;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( material.roughness, directLight.direction, geometry, material.sheenTint );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = transmission.a;\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
var meshnormal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var meshnormal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenTint;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";
var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
const ShaderChunk = {
    alphamap_fragment: alphamap_fragment,
    alphamap_pars_fragment: alphamap_pars_fragment,
    alphatest_fragment: alphatest_fragment,
    alphatest_pars_fragment: alphatest_pars_fragment,
    aomap_fragment: aomap_fragment,
    aomap_pars_fragment: aomap_pars_fragment,
    begin_vertex: begin_vertex,
    beginnormal_vertex: beginnormal_vertex,
    bsdfs: bsdfs,
    bumpmap_pars_fragment: bumpmap_pars_fragment,
    clipping_planes_fragment: clipping_planes_fragment,
    clipping_planes_pars_fragment: clipping_planes_pars_fragment,
    clipping_planes_pars_vertex: clipping_planes_pars_vertex,
    clipping_planes_vertex: clipping_planes_vertex,
    color_fragment: color_fragment,
    color_pars_fragment: color_pars_fragment,
    color_pars_vertex: color_pars_vertex,
    color_vertex: color_vertex,
    common: common,
    cube_uv_reflection_fragment: cube_uv_reflection_fragment,
    defaultnormal_vertex: defaultnormal_vertex,
    displacementmap_pars_vertex: displacementmap_pars_vertex,
    displacementmap_vertex: displacementmap_vertex,
    emissivemap_fragment: emissivemap_fragment,
    emissivemap_pars_fragment: emissivemap_pars_fragment,
    encodings_fragment: encodings_fragment,
    encodings_pars_fragment: encodings_pars_fragment,
    envmap_fragment: envmap_fragment,
    envmap_common_pars_fragment: envmap_common_pars_fragment,
    envmap_pars_fragment: envmap_pars_fragment,
    envmap_pars_vertex: envmap_pars_vertex,
    envmap_physical_pars_fragment: envmap_physical_pars_fragment,
    envmap_vertex: envmap_vertex,
    fog_vertex: fog_vertex,
    fog_pars_vertex: fog_pars_vertex,
    fog_fragment: fog_fragment,
    fog_pars_fragment: fog_pars_fragment,
    gradientmap_pars_fragment: gradientmap_pars_fragment,
    lightmap_fragment: lightmap_fragment,
    lightmap_pars_fragment: lightmap_pars_fragment,
    lights_lambert_vertex: lights_lambert_vertex,
    lights_pars_begin: lights_pars_begin,
    lights_toon_fragment: lights_toon_fragment,
    lights_toon_pars_fragment: lights_toon_pars_fragment,
    lights_phong_fragment: lights_phong_fragment,
    lights_phong_pars_fragment: lights_phong_pars_fragment,
    lights_physical_fragment: lights_physical_fragment,
    lights_physical_pars_fragment: lights_physical_pars_fragment,
    lights_fragment_begin: lights_fragment_begin,
    lights_fragment_maps: lights_fragment_maps,
    lights_fragment_end: lights_fragment_end,
    logdepthbuf_fragment: logdepthbuf_fragment,
    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
    logdepthbuf_vertex: logdepthbuf_vertex,
    map_fragment: map_fragment,
    map_pars_fragment: map_pars_fragment,
    map_particle_fragment: map_particle_fragment,
    map_particle_pars_fragment: map_particle_pars_fragment,
    metalnessmap_fragment: metalnessmap_fragment,
    metalnessmap_pars_fragment: metalnessmap_pars_fragment,
    morphnormal_vertex: morphnormal_vertex,
    morphtarget_pars_vertex: morphtarget_pars_vertex,
    morphtarget_vertex: morphtarget_vertex,
    normal_fragment_begin: normal_fragment_begin,
    normal_fragment_maps: normal_fragment_maps,
    normal_pars_fragment: normal_pars_fragment,
    normal_pars_vertex: normal_pars_vertex,
    normal_vertex: normal_vertex,
    normalmap_pars_fragment: normalmap_pars_fragment,
    clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment: clearcoat_pars_fragment,
    output_fragment: output_fragment,
    packing: packing,
    premultiplied_alpha_fragment: premultiplied_alpha_fragment,
    project_vertex: project_vertex,
    dithering_fragment: dithering_fragment,
    dithering_pars_fragment: dithering_pars_fragment,
    roughnessmap_fragment: roughnessmap_fragment,
    roughnessmap_pars_fragment: roughnessmap_pars_fragment,
    shadowmap_pars_fragment: shadowmap_pars_fragment,
    shadowmap_pars_vertex: shadowmap_pars_vertex,
    shadowmap_vertex: shadowmap_vertex,
    shadowmask_pars_fragment: shadowmask_pars_fragment,
    skinbase_vertex: skinbase_vertex,
    skinning_pars_vertex: skinning_pars_vertex,
    skinning_vertex: skinning_vertex,
    skinnormal_vertex: skinnormal_vertex,
    specularmap_fragment: specularmap_fragment,
    specularmap_pars_fragment: specularmap_pars_fragment,
    tonemapping_fragment: tonemapping_fragment,
    tonemapping_pars_fragment: tonemapping_pars_fragment,
    transmission_fragment: transmission_fragment,
    transmission_pars_fragment: transmission_pars_fragment,
    uv_pars_fragment: uv_pars_fragment,
    uv_pars_vertex: uv_pars_vertex,
    uv_vertex: uv_vertex,
    uv2_pars_fragment: uv2_pars_fragment,
    uv2_pars_vertex: uv2_pars_vertex,
    uv2_vertex: uv2_vertex,
    worldpos_vertex: worldpos_vertex,
    background_frag: background_frag,
    background_vert: background_vert,
    cube_frag: cube_frag,
    cube_vert: cube_vert,
    depth_frag: depth_frag,
    depth_vert: depth_vert,
    distanceRGBA_frag: distanceRGBA_frag,
    distanceRGBA_vert: distanceRGBA_vert,
    equirect_frag: equirect_frag,
    equirect_vert: equirect_vert,
    linedashed_frag: linedashed_frag,
    linedashed_vert: linedashed_vert,
    meshbasic_frag: meshbasic_frag,
    meshbasic_vert: meshbasic_vert,
    meshlambert_frag: meshlambert_frag,
    meshlambert_vert: meshlambert_vert,
    meshmatcap_frag: meshmatcap_frag,
    meshmatcap_vert: meshmatcap_vert,
    meshnormal_frag: meshnormal_frag,
    meshnormal_vert: meshnormal_vert,
    meshphong_frag: meshphong_frag,
    meshphong_vert: meshphong_vert,
    meshphysical_frag: meshphysical_frag,
    meshphysical_vert: meshphysical_vert,
    meshtoon_frag: meshtoon_frag,
    meshtoon_vert: meshtoon_vert,
    points_frag: points_frag,
    points_vert: points_vert,
    shadow_frag: shadow_frag,
    shadow_vert: shadow_vert,
    sprite_frag: sprite_frag,
    sprite_vert: sprite_vert
};
/**
 * Uniforms library for shared webgl shaders
 */ const UniformsLib = {
    common: {
        diffuse: {
            value: new Color(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Matrix3()
        },
        uv2Transform: {
            value: new Matrix3()
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: 0.98
        },
        maxMipLevel: {
            value: 0
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new Vector2(1, 1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 0.00025
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2000
        },
        fogColor: {
            value: new Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Color(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Matrix3()
        }
    },
    sprite: {
        diffuse: {
            value: new Color(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new Vector2(0.5, 0.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Matrix3()
        }
    }
};
const ShaderLib = {
    basic: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0)
                }
            }
        ]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0)
                },
                specular: {
                    value: new Color(1118481)
                },
                shininess: {
                    value: 30
                }
            }
        ]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.roughnessmap,
            UniformsLib.metalnessmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                } // temporary
            }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.gradientmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0)
                }
            }
        ]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            {
                matcap: {
                    value: null
                }
            }
        ]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
        uniforms: mergeUniforms([
            UniformsLib.points,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.fog,
            {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }
        ]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap
        ]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: ShaderChunk.meshnormal_vert,
        fragmentShader: ShaderChunk.meshnormal_frag
    },
    sprite: {
        uniforms: mergeUniforms([
            UniformsLib.sprite,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Matrix3()
            },
            t2D: {
                value: null
            }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
    },
    /* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */ cube: {
        uniforms: mergeUniforms([
            UniformsLib.envmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap,
            {
                referencePosition: {
                    value: new Vector3()
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1000
                }
            }
        ]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
        uniforms: mergeUniforms([
            UniformsLib.lights,
            UniformsLib.fog,
            {
                color: {
                    value: new Color(0)
                },
                opacity: {
                    value: 1
                }
            }, 
        ]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
    }
};
ShaderLib.physical = {
    uniforms: mergeUniforms([
        ShaderLib.standard.uniforms,
        {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new Vector2(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheenTint: {
                value: new Color(0)
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            },
            transmissionSamplerSize: {
                value: new Vector2()
            },
            transmissionSamplerMap: {
                value: null
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            attenuationDistance: {
                value: 0
            },
            attenuationTint: {
                value: new Color(0)
            },
            specularIntensity: {
                value: 0
            },
            specularIntensityMap: {
                value: null
            },
            specularTint: {
                value: new Color(1, 1, 1)
            },
            specularTintMap: {
                value: null
            }
        }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
    const clearColor = new Color(0);
    let clearAlpha = 0;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render(renderList, scene) {
        let forceClear = false;
        let background = scene.isScene === true ? scene.background : null;
        if (background && background.isTexture) background = cubemaps.get(background);
        // Ignore background in AR
        // TODO: Reconsider this.
        const xr = renderer.xr;
        const session = xr.getSession && xr.getSession();
        if (session && session.environmentBlendMode === 'additive') background = null;
        if (background === null) setClear(clearColor, clearAlpha);
        else if (background && background.isColor) {
            setClear(background, 1);
            forceClear = true;
        }
        if (renderer.autoClear || forceClear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
            if (boxMesh === undefined) {
                boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
                    name: 'BackgroundCubeMaterial',
                    uniforms: cloneUniforms(ShaderLib.cube.uniforms),
                    vertexShader: ShaderLib.cube.vertexShader,
                    fragmentShader: ShaderLib.cube.fragmentShader,
                    side: BackSide,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                boxMesh.geometry.deleteAttribute('normal');
                boxMesh.geometry.deleteAttribute('uv');
                boxMesh.onBeforeRender = function(renderer, scene, camera) {
                    this.matrixWorld.copyPosition(camera.matrixWorld);
                };
                // enable code injection for non-built-in material
                Object.defineProperty(boxMesh.material, 'envMap', {
                    get: function() {
                        return this.uniforms.envMap.value;
                    }
                });
                objects.update(boxMesh);
            }
            boxMesh.material.uniforms.envMap.value = background;
            boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                boxMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
            }
            // push to the pre-sorted opaque render list
            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
        } else if (background && background.isTexture) {
            if (planeMesh === undefined) {
                planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
                    name: 'BackgroundMaterial',
                    uniforms: cloneUniforms(ShaderLib.background.uniforms),
                    vertexShader: ShaderLib.background.vertexShader,
                    fragmentShader: ShaderLib.background.fragmentShader,
                    side: FrontSide,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                planeMesh.geometry.deleteAttribute('normal');
                // enable code injection for non-built-in material
                Object.defineProperty(planeMesh.material, 'map', {
                    get: function() {
                        return this.uniforms.t2D.value;
                    }
                });
                objects.update(planeMesh);
            }
            planeMesh.material.uniforms.t2D.value = background;
            if (background.matrixAutoUpdate === true) background.updateMatrix();
            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                planeMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
            }
            // push to the pre-sorted opaque render list
            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
        }
    }
    function setClear(color, alpha) {
        state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
    }
    return {
        getClearColor: function() {
            return clearColor;
        },
        setClearColor: function(color, alpha = 1) {
            clearColor.set(color);
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
        },
        getClearAlpha: function() {
            return clearAlpha;
        },
        setClearAlpha: function(alpha) {
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
        },
        render: render
    };
}
function WebGLBindingStates(gl, extensions, attributes1, capabilities) {
    const maxVertexAttributes = gl.getParameter(34921);
    const extension1 = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
    const vaoAvailable = capabilities.isWebGL2 || extension1 !== null;
    const bindingStates = {};
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    function setup(object, material, program, geometry, index) {
        let updateBuffers = false;
        if (vaoAvailable) {
            const state = getBindingState(geometry, program, material);
            if (currentState !== state) {
                currentState = state;
                bindVertexArrayObject(currentState.object);
            }
            updateBuffers = needsUpdate(geometry, index);
            if (updateBuffers) saveCache(geometry, index);
        } else {
            const wireframe = material.wireframe === true;
            if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
                currentState.geometry = geometry.id;
                currentState.program = program.id;
                currentState.wireframe = wireframe;
                updateBuffers = true;
            }
        }
        if (object.isInstancedMesh === true) updateBuffers = true;
        if (index !== null) attributes1.update(index, 34963);
        if (updateBuffers) {
            setupVertexAttributes(object, material, program, geometry);
            if (index !== null) gl.bindBuffer(34963, attributes1.get(index).buffer);
        }
    }
    function createVertexArrayObject() {
        if (capabilities.isWebGL2) return gl.createVertexArray();
        return extension1.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
        return extension1.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
        return extension1.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry, program, material) {
        const wireframe = material.wireframe === true;
        let programMap = bindingStates[geometry.id];
        if (programMap === undefined) {
            programMap = {};
            bindingStates[geometry.id] = programMap;
        }
        let stateMap = programMap[program.id];
        if (stateMap === undefined) {
            stateMap = {};
            programMap[program.id] = stateMap;
        }
        let state = stateMap[wireframe];
        if (state === undefined) {
            state = createBindingState(createVertexArrayObject());
            stateMap[wireframe] = state;
        }
        return state;
    }
    function createBindingState(vao) {
        const newAttributes = [];
        const enabledAttributes = [];
        const attributeDivisors = [];
        for(let i71 = 0; i71 < maxVertexAttributes; i71++){
            newAttributes[i71] = 0;
            enabledAttributes[i71] = 0;
            attributeDivisors[i71] = 0;
        }
        return {
            // for backward compatibility on non-VAO support browser
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes: newAttributes,
            enabledAttributes: enabledAttributes,
            attributeDivisors: attributeDivisors,
            object: vao,
            attributes: {},
            index: null
        };
    }
    function needsUpdate(geometry, index) {
        const cachedAttributes = currentState.attributes;
        const geometryAttributes = geometry.attributes;
        let attributesNum = 0;
        for(const key in geometryAttributes){
            const cachedAttribute = cachedAttributes[key];
            const geometryAttribute = geometryAttributes[key];
            if (cachedAttribute === undefined) return true;
            if (cachedAttribute.attribute !== geometryAttribute) return true;
            if (cachedAttribute.data !== geometryAttribute.data) return true;
            attributesNum++;
        }
        if (currentState.attributesNum !== attributesNum) return true;
        if (currentState.index !== index) return true;
        return false;
    }
    function saveCache(geometry, index) {
        const cache = {};
        const attributes = geometry.attributes;
        let attributesNum = 0;
        for(const key in attributes){
            const attribute = attributes[key];
            const data = {};
            data.attribute = attribute;
            if (attribute.data) data.data = attribute.data;
            cache[key] = data;
            attributesNum++;
        }
        currentState.attributes = cache;
        currentState.attributesNum = attributesNum;
        currentState.index = index;
    }
    function initAttributes() {
        const newAttributes = currentState.newAttributes;
        for(let i72 = 0, il = newAttributes.length; i72 < il; i72++)newAttributes[i72] = 0;
    }
    function enableAttribute(attribute) {
        enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        const attributeDivisors = currentState.attributeDivisors;
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== meshPerAttribute) {
            const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
            extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
            attributeDivisors[attribute] = meshPerAttribute;
        }
    }
    function disableUnusedAttributes() {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        for(let i73 = 0, il = enabledAttributes.length; i73 < il; i73++)if (enabledAttributes[i73] !== newAttributes[i73]) {
            gl.disableVertexAttribArray(i73);
            enabledAttributes[i73] = 0;
        }
    }
    function vertexAttribPointer(index, size, type, normalized, stride, offset) {
        if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) gl.vertexAttribIPointer(index, size, type, stride, offset);
        else gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
    function setupVertexAttributes(object, material, program, geometry) {
        if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
            if (extensions.get('ANGLE_instanced_arrays') === null) return;
        }
        initAttributes();
        const geometryAttributes = geometry.attributes;
        const programAttributes = program.getAttributes();
        const materialDefaultAttributeValues = material.defaultAttributeValues;
        for(const name in programAttributes){
            const programAttribute = programAttributes[name];
            if (programAttribute.location >= 0) {
                let geometryAttribute = geometryAttributes[name];
                if (geometryAttribute === undefined) {
                    if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
                    if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;
                }
                if (geometryAttribute !== undefined) {
                    const normalized = geometryAttribute.normalized;
                    const size = geometryAttribute.itemSize;
                    const attribute = attributes1.get(geometryAttribute);
                    // TODO Attribute may not be available on context restore
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type = attribute.type;
                    const bytesPerElement = attribute.bytesPerElement;
                    if (geometryAttribute.isInterleavedBufferAttribute) {
                        const data = geometryAttribute.data;
                        const stride = data.stride;
                        const offset = geometryAttribute.offset;
                        if (data && data.isInstancedInterleavedBuffer) {
                            for(let i75 = 0; i75 < programAttribute.locationSize; i75++)enableAttributeAndDivisor(programAttribute.location + i75, data.meshPerAttribute);
                            if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                        } else for(let i76 = 0; i76 < programAttribute.locationSize; i76++)enableAttribute(programAttribute.location + i76);
                        gl.bindBuffer(34962, buffer);
                        for(let i74 = 0; i74 < programAttribute.locationSize; i74++)vertexAttribPointer(programAttribute.location + i74, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i74) * bytesPerElement);
                    } else {
                        if (geometryAttribute.isInstancedBufferAttribute) {
                            for(let i78 = 0; i78 < programAttribute.locationSize; i78++)enableAttributeAndDivisor(programAttribute.location + i78, geometryAttribute.meshPerAttribute);
                            if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                        } else for(let i79 = 0; i79 < programAttribute.locationSize; i79++)enableAttribute(programAttribute.location + i79);
                        gl.bindBuffer(34962, buffer);
                        for(let i77 = 0; i77 < programAttribute.locationSize; i77++)vertexAttribPointer(programAttribute.location + i77, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i77 * bytesPerElement);
                    }
                } else if (materialDefaultAttributeValues !== undefined) {
                    const value = materialDefaultAttributeValues[name];
                    if (value !== undefined) switch(value.length){
                        case 2:
                            gl.vertexAttrib2fv(programAttribute.location, value);
                            break;
                        case 3:
                            gl.vertexAttrib3fv(programAttribute.location, value);
                            break;
                        case 4:
                            gl.vertexAttrib4fv(programAttribute.location, value);
                            break;
                        default:
                            gl.vertexAttrib1fv(programAttribute.location, value);
                    }
                }
            }
        }
        disableUnusedAttributes();
    }
    function dispose() {
        reset();
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            for(const programId in programMap){
                const stateMap = programMap[programId];
                for(const wireframe in stateMap){
                    deleteVertexArrayObject(stateMap[wireframe].object);
                    delete stateMap[wireframe];
                }
                delete programMap[programId];
            }
            delete bindingStates[geometryId];
        }
    }
    function releaseStatesOfGeometry(geometry) {
        if (bindingStates[geometry.id] === undefined) return;
        const programMap = bindingStates[geometry.id];
        for(const programId in programMap){
            const stateMap = programMap[programId];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[programId];
        }
        delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            if (programMap[program.id] === undefined) continue;
            const stateMap = programMap[program.id];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[program.id];
        }
    }
    function reset() {
        resetDefaultState();
        if (currentState === defaultState) return;
        currentState = defaultState;
        bindVertexArrayObject(currentState.object);
    }
    // for backward-compatilibity
    function resetDefaultState() {
        defaultState.geometry = null;
        defaultState.program = null;
        defaultState.wireframe = false;
    }
    return {
        setup: setup,
        reset: reset,
        resetDefaultState: resetDefaultState,
        dispose: dispose,
        releaseStatesOfGeometry: releaseStatesOfGeometry,
        releaseStatesOfProgram: releaseStatesOfProgram,
        initAttributes: initAttributes,
        enableAttribute: enableAttribute,
        disableUnusedAttributes: disableUnusedAttributes
    };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
        mode = value;
    }
    function render(start, count) {
        gl.drawArrays(mode, start, count);
        info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
            extension = gl;
            methodName = 'drawArraysInstanced';
        } else {
            extension = extensions.get('ANGLE_instanced_arrays');
            methodName = 'drawArraysInstancedANGLE';
            if (extension === null) {
                console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
        }
        extension[methodName](mode, start, count, primcount);
        info.update(count, mode, primcount);
    }
    //
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
        if (maxAnisotropy !== undefined) return maxAnisotropy;
        if (extensions.has('EXT_texture_filter_anisotropic') === true) {
            const extension = extensions.get('EXT_texture_filter_anisotropic');
            maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else maxAnisotropy = 0;
        return maxAnisotropy;
    }
    function getMaxPrecision(precision) {
        if (precision === 'highp') {
            if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) return 'highp';
            precision = 'mediump';
        }
        if (precision === 'mediump') {
            if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) return 'mediump';
        }
        return 'lowp';
    }
    /* eslint-disable no-undef */ const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
    /* eslint-enable no-undef */ let precision1 = parameters.precision !== undefined ? parameters.precision : 'highp';
    const maxPrecision = getMaxPrecision(precision1);
    if (maxPrecision !== precision1) {
        console.warn('THREE.WebGLRenderer:', precision1, 'not supported, using', maxPrecision, 'instead.');
        precision1 = maxPrecision;
    }
    const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl.getParameter(34930);
    const maxVertexTextures = gl.getParameter(35660);
    const maxTextureSize = gl.getParameter(3379);
    const maxCubemapSize = gl.getParameter(34076);
    const maxAttributes = gl.getParameter(34921);
    const maxVertexUniforms = gl.getParameter(36347);
    const maxVaryings = gl.getParameter(36348);
    const maxFragmentUniforms = gl.getParameter(36349);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
    return {
        isWebGL2: isWebGL2,
        drawBuffers: drawBuffers,
        getMaxAnisotropy: getMaxAnisotropy,
        getMaxPrecision: getMaxPrecision,
        precision: precision1,
        logarithmicDepthBuffer: logarithmicDepthBuffer,
        maxTextures: maxTextures,
        maxVertexTextures: maxVertexTextures,
        maxTextureSize: maxTextureSize,
        maxCubemapSize: maxCubemapSize,
        maxAttributes: maxAttributes,
        maxVertexUniforms: maxVertexUniforms,
        maxVaryings: maxVaryings,
        maxFragmentUniforms: maxFragmentUniforms,
        vertexTextures: vertexTextures,
        floatFragmentTextures: floatFragmentTextures,
        floatVertexTextures: floatVertexTextures,
        maxSamples: maxSamples
    };
}
function WebGLClipping(properties) {
    const scope = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {
        value: null,
        needsUpdate: false
    };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera) {
        const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
        // run another frame in order to reset the state:
        numGlobalPlanes !== 0 || localClippingEnabled;
        localClippingEnabled = enableLocalClipping;
        globalState = projectPlanes(planes, camera, 0);
        numGlobalPlanes = planes.length;
        return enabled;
    };
    this.beginShadows = function() {
        renderingShadows = true;
        projectPlanes(null);
    };
    this.endShadows = function() {
        renderingShadows = false;
        resetGlobalState();
    };
    this.setState = function(material, camera, useCache) {
        const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
        const materialProperties = properties.get(material);
        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
            // there's no local clipping
            if (renderingShadows) // there's no global clipping
            projectPlanes(null);
            else resetGlobalState();
        } else {
            const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
            let dstArray = materialProperties.clippingState || null;
            uniform.value = dstArray; // ensure unique state
            dstArray = projectPlanes(planes, camera, lGlobal, useCache);
            for(let i80 = 0; i80 !== lGlobal; ++i80)dstArray[i80] = globalState[i80];
            materialProperties.clippingState = dstArray;
            this.numIntersection = clipIntersection ? this.numPlanes : 0;
            this.numPlanes += nGlobal;
        }
    };
    function resetGlobalState() {
        if (uniform.value !== globalState) {
            uniform.value = globalState;
            uniform.needsUpdate = numGlobalPlanes > 0;
        }
        scope.numPlanes = numGlobalPlanes;
        scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
        const nPlanes = planes !== null ? planes.length : 0;
        let dstArray = null;
        if (nPlanes !== 0) {
            dstArray = uniform.value;
            if (skipTransform !== true || dstArray === null) {
                const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                viewNormalMatrix.getNormalMatrix(viewMatrix);
                if (dstArray === null || dstArray.length < flatSize) dstArray = new Float32Array(flatSize);
                for(let i81 = 0, i4 = dstOffset; i81 !== nPlanes; ++i81, i4 += 4){
                    plane.copy(planes[i81]).applyMatrix4(viewMatrix, viewNormalMatrix);
                    plane.normal.toArray(dstArray, i4);
                    dstArray[i4 + 3] = plane.constant;
                }
            }
            uniform.value = dstArray;
            uniform.needsUpdate = true;
        }
        scope.numPlanes = nPlanes;
        scope.numIntersection = 0;
        return dstArray;
    }
}
function WebGLCubeMaps(renderer) {
    let cubemaps = new WeakMap();
    function mapTextureMapping(texture, mapping) {
        if (mapping === EquirectangularReflectionMapping) texture.mapping = CubeReflectionMapping;
        else if (mapping === EquirectangularRefractionMapping) texture.mapping = CubeRefractionMapping;
        return texture;
    }
    function get(texture) {
        if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
            const mapping = texture.mapping;
            if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
                if (cubemaps.has(texture)) {
                    const cubemap = cubemaps.get(texture).texture;
                    return mapTextureMapping(cubemap, texture.mapping);
                } else {
                    const image = texture.image;
                    if (image && image.height > 0) {
                        const currentRenderTarget = renderer.getRenderTarget();
                        const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
                        renderTarget.fromEquirectangularTexture(renderer, texture);
                        cubemaps.set(texture, renderTarget);
                        renderer.setRenderTarget(currentRenderTarget);
                        texture.addEventListener('dispose', onTextureDispose);
                        return mapTextureMapping(renderTarget.texture, texture.mapping);
                    } else // image not yet ready. try the conversion next frame
                    return null;
                }
            }
        }
        return texture;
    }
    function onTextureDispose(event) {
        const texture = event.target;
        texture.removeEventListener('dispose', onTextureDispose);
        const cubemap = cubemaps.get(texture);
        if (cubemap !== undefined) {
            cubemaps.delete(texture);
            cubemap.dispose();
        }
    }
    function dispose() {
        cubemaps = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
class OrthographicCamera extends Camera {
    constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000){
        super();
        this.type = 'OrthographicCamera';
        this.zoom = 1;
        this.view = null;
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
        this.near = near;
        this.far = far;
        this.updateProjectionMatrix();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        return this;
    }
    setViewOffset(fullWidth, fullHeight, x, y, width, height) {
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        const dx = (this.right - this.left) / (2 * this.zoom);
        const dy = (this.top - this.bottom) / (2 * this.zoom);
        const cx = (this.right + this.left) / 2;
        const cy = (this.top + this.bottom) / 2;
        let left = cx - dx;
        let right = cx + dx;
        let top = cy + dy;
        let bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left += scaleW * this.view.offsetX;
            right = left + scaleW * this.view.width;
            top -= scaleH * this.view.offsetY;
            bottom = top - scaleH * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null) data.object.view = Object.assign({}, this.view);
        return data;
    }
}
OrthographicCamera.prototype.isOrthographicCamera = true;
class RawShaderMaterial extends ShaderMaterial {
    constructor(parameters){
        super(parameters);
        this.type = 'RawShaderMaterial';
    }
}
RawShaderMaterial.prototype.isRawShaderMaterial = true;
const LOD_MIN = 4;
const LOD_MAX = 8;
const SIZE_MAX = Math.pow(2, LOD_MAX);
// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [
    0.125,
    0.215,
    0.35,
    0.446,
    0.526,
    0.582
];
const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;
const ENCODINGS = {
    [LinearEncoding]: 0,
    [sRGBEncoding]: 1,
    [RGBEEncoding]: 2,
    [RGBM7Encoding]: 3,
    [RGBM16Encoding]: 4,
    [RGBDEncoding]: 5,
    [GammaEncoding]: 6
};
const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
const { _lodPlanes , _sizeLods , _sigmas  } = /*@__PURE__*/ _createPlanes();
const _clearColor = /*@__PURE__*/ new Color();
let _oldTarget = null;
// Golden Ratio
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
    /*@__PURE__*/ new Vector3(1, 1, 1),
    /*@__PURE__*/ new Vector3(-1, 1, 1),
    /*@__PURE__*/ new Vector3(1, 1, -1),
    /*@__PURE__*/ new Vector3(-1, 1, -1),
    /*@__PURE__*/ new Vector3(0, PHI, INV_PHI),
    /*@__PURE__*/ new Vector3(0, PHI, -INV_PHI),
    /*@__PURE__*/ new Vector3(INV_PHI, 0, PHI),
    /*@__PURE__*/ new Vector3(-INV_PHI, 0, PHI),
    /*@__PURE__*/ new Vector3(PHI, INV_PHI, 0),
    /*@__PURE__*/ new Vector3(-PHI, INV_PHI, 0)
];
/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/ class PMREMGenerator {
    constructor(renderer){
        this._renderer = renderer;
        this._pingPongRenderTarget = null;
        this._blurMaterial = _getBlurShader(MAX_SAMPLES);
        this._equirectShader = null;
        this._cubemapShader = null;
        this._compileMaterial(this._blurMaterial);
    }
    /**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */ fromScene(scene, sigma = 0, near = 0.1, far = 100) {
        _oldTarget = this._renderer.getRenderTarget();
        const cubeUVRenderTarget = this._allocateTargets();
        this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
        if (sigma > 0) this._blur(cubeUVRenderTarget, 0, 0, sigma);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    }
    /**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */ fromEquirectangular(equirectangular) {
        return this._fromTexture(equirectangular);
    }
    /**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */ fromCubemap(cubemap) {
        return this._fromTexture(cubemap);
    }
    /**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */ compileCubemapShader() {
        if (this._cubemapShader === null) {
            this._cubemapShader = _getCubemapShader();
            this._compileMaterial(this._cubemapShader);
        }
    }
    /**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */ compileEquirectangularShader() {
        if (this._equirectShader === null) {
            this._equirectShader = _getEquirectShader();
            this._compileMaterial(this._equirectShader);
        }
    }
    /**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */ dispose() {
        this._blurMaterial.dispose();
        if (this._cubemapShader !== null) this._cubemapShader.dispose();
        if (this._equirectShader !== null) this._equirectShader.dispose();
        for(let i82 = 0; i82 < _lodPlanes.length; i82++)_lodPlanes[i82].dispose();
    }
    // private interface
    _cleanup(outputTarget) {
        this._pingPongRenderTarget.dispose();
        this._renderer.setRenderTarget(_oldTarget);
        outputTarget.scissorTest = false;
        _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
    }
    _fromTexture(texture) {
        _oldTarget = this._renderer.getRenderTarget();
        const cubeUVRenderTarget = this._allocateTargets(texture);
        this._textureToCubeUV(texture, cubeUVRenderTarget);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    }
    _allocateTargets(texture) {
        const params = {
            magFilter: NearestFilter,
            minFilter: NearestFilter,
            generateMipmaps: false,
            type: UnsignedByteType,
            format: RGBEFormat,
            encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
            depthBuffer: false
        };
        const cubeUVRenderTarget = _createRenderTarget(params);
        cubeUVRenderTarget.depthBuffer = texture ? false : true;
        this._pingPongRenderTarget = _createRenderTarget(params);
        return cubeUVRenderTarget;
    }
    _compileMaterial(material) {
        const tmpMesh = new Mesh(_lodPlanes[0], material);
        this._renderer.compile(tmpMesh, _flatCamera);
    }
    _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
        const fov2 = 90;
        const aspect2 = 1;
        const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
        const upSign = [
            1,
            -1,
            1,
            1,
            1,
            1
        ];
        const forwardSign = [
            1,
            1,
            1,
            -1,
            -1,
            -1
        ];
        const renderer = this._renderer;
        const originalAutoClear = renderer.autoClear;
        const outputEncoding = renderer.outputEncoding;
        const toneMapping = renderer.toneMapping;
        renderer.getClearColor(_clearColor);
        renderer.toneMapping = NoToneMapping;
        renderer.outputEncoding = LinearEncoding;
        renderer.autoClear = false;
        const backgroundMaterial = new MeshBasicMaterial({
            name: 'PMREM.Background',
            side: BackSide,
            depthWrite: false,
            depthTest: false
        });
        const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
        let useSolidColor = false;
        const background = scene.background;
        if (background) {
            if (background.isColor) {
                backgroundMaterial.color.copy(background);
                scene.background = null;
                useSolidColor = true;
            }
        } else {
            backgroundMaterial.color.copy(_clearColor);
            useSolidColor = true;
        }
        for(let i83 = 0; i83 < 6; i83++){
            const col = i83 % 3;
            if (col == 0) {
                cubeCamera.up.set(0, upSign[i83], 0);
                cubeCamera.lookAt(forwardSign[i83], 0, 0);
            } else if (col == 1) {
                cubeCamera.up.set(0, 0, upSign[i83]);
                cubeCamera.lookAt(0, forwardSign[i83], 0);
            } else {
                cubeCamera.up.set(0, upSign[i83], 0);
                cubeCamera.lookAt(0, 0, forwardSign[i83]);
            }
            _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i83 > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
            renderer.setRenderTarget(cubeUVRenderTarget);
            if (useSolidColor) renderer.render(backgroundBox, cubeCamera);
            renderer.render(scene, cubeCamera);
        }
        backgroundBox.geometry.dispose();
        backgroundBox.material.dispose();
        renderer.toneMapping = toneMapping;
        renderer.outputEncoding = outputEncoding;
        renderer.autoClear = originalAutoClear;
        scene.background = background;
    }
    _textureToCubeUV(texture, cubeUVRenderTarget) {
        const renderer = this._renderer;
        if (texture.isCubeTexture) {
            if (this._cubemapShader == null) this._cubemapShader = _getCubemapShader();
        } else if (this._equirectShader == null) this._equirectShader = _getEquirectShader();
        const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
        const mesh = new Mesh(_lodPlanes[0], material);
        const uniforms = material.uniforms;
        uniforms['envMap'].value = texture;
        if (!texture.isCubeTexture) uniforms['texelSize'].value.set(1 / texture.image.width, 1 / texture.image.height);
        uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];
        uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];
        _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
        renderer.setRenderTarget(cubeUVRenderTarget);
        renderer.render(mesh, _flatCamera);
    }
    _applyPMREM(cubeUVRenderTarget) {
        const renderer = this._renderer;
        const autoClear = renderer.autoClear;
        renderer.autoClear = false;
        for(let i84 = 1; i84 < TOTAL_LODS; i84++){
            const sigma = Math.sqrt(_sigmas[i84] * _sigmas[i84] - _sigmas[i84 - 1] * _sigmas[i84 - 1]);
            const poleAxis = _axisDirections[(i84 - 1) % _axisDirections.length];
            this._blur(cubeUVRenderTarget, i84 - 1, i84, sigma, poleAxis);
        }
        renderer.autoClear = autoClear;
    }
    /**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */ _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
        const pingPongRenderTarget = this._pingPongRenderTarget;
        this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
        this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
    }
    _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
        const renderer = this._renderer;
        const blurMaterial = this._blurMaterial;
        if (direction !== 'latitudinal' && direction !== 'longitudinal') console.error('blur direction must be either latitudinal or longitudinal!');
        // Number of standard deviations at which to cut off the discrete approximation.
        const STANDARD_DEVIATIONS = 3;
        const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
        const blurUniforms = blurMaterial.uniforms;
        const pixels = _sizeLods[lodIn] - 1;
        const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
        const sigmaPixels = sigmaRadians / radiansPerPixel;
        const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
        if (samples > MAX_SAMPLES) console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
        const weights = [];
        let sum = 0;
        for(let i86 = 0; i86 < MAX_SAMPLES; ++i86){
            const x = i86 / sigmaPixels;
            const weight = Math.exp(-x * x / 2);
            weights.push(weight);
            if (i86 == 0) sum += weight;
            else if (i86 < samples) sum += 2 * weight;
        }
        for(let i85 = 0; i85 < weights.length; i85++)weights[i85] = weights[i85] / sum;
        blurUniforms['envMap'].value = targetIn.texture;
        blurUniforms['samples'].value = samples;
        blurUniforms['weights'].value = weights;
        blurUniforms['latitudinal'].value = direction === 'latitudinal';
        if (poleAxis) blurUniforms['poleAxis'].value = poleAxis;
        blurUniforms['dTheta'].value = radiansPerPixel;
        blurUniforms['mipInt'].value = LOD_MAX - lodIn;
        blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
        blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
        const outputSize = _sizeLods[lodOut];
        const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
        const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
        _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
        renderer.setRenderTarget(targetOut);
        renderer.render(blurMesh, _flatCamera);
    }
}
function _isLDR(texture) {
    if (texture === undefined || texture.type !== UnsignedByteType) return false;
    return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
}
function _createPlanes() {
    const _lodPlanes1 = [];
    const _sizeLods1 = [];
    const _sigmas1 = [];
    let lod = LOD_MAX;
    for(let i87 = 0; i87 < TOTAL_LODS; i87++){
        const sizeLod = Math.pow(2, lod);
        _sizeLods1.push(sizeLod);
        let sigma = 1 / sizeLod;
        if (i87 > LOD_MAX - LOD_MIN) sigma = EXTRA_LOD_SIGMA[i87 - LOD_MAX + LOD_MIN - 1];
        else if (i87 == 0) sigma = 0;
        _sigmas1.push(sigma);
        const texelSize = 1 / (sizeLod - 1);
        const min = -texelSize / 2;
        const max = 1 + texelSize / 2;
        const uv1 = [
            min,
            min,
            max,
            min,
            max,
            max,
            min,
            min,
            max,
            max,
            min,
            max
        ];
        const cubeFaces = 6;
        const vertices = 6;
        const positionSize = 3;
        const uvSize = 2;
        const faceIndexSize = 1;
        const position = new Float32Array(positionSize * vertices * cubeFaces);
        const uv = new Float32Array(uvSize * vertices * cubeFaces);
        const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
        for(let face = 0; face < cubeFaces; face++){
            const x = face % 3 * 2 / 3 - 1;
            const y = face > 2 ? 0 : -1;
            const coordinates = [
                x,
                y,
                0,
                x + 2 / 3,
                y,
                0,
                x + 2 / 3,
                y + 1,
                0,
                x,
                y,
                0,
                x + 2 / 3,
                y + 1,
                0,
                x,
                y + 1,
                0
            ];
            position.set(coordinates, positionSize * vertices * face);
            uv.set(uv1, uvSize * vertices * face);
            const fill = [
                face,
                face,
                face,
                face,
                face,
                face
            ];
            faceIndex.set(fill, faceIndexSize * vertices * face);
        }
        const planes = new BufferGeometry();
        planes.setAttribute('position', new BufferAttribute(position, positionSize));
        planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
        planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
        _lodPlanes1.push(planes);
        if (lod > LOD_MIN) lod--;
    }
    return {
        _lodPlanes: _lodPlanes1,
        _sizeLods: _sizeLods1,
        _sigmas: _sigmas1
    };
}
function _createRenderTarget(params) {
    const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
    cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
    cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
    cubeUVRenderTarget.scissorTest = true;
    return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
    target.viewport.set(x, y, width, height);
    target.scissor.set(x, y, width, height);
}
function _getBlurShader(maxSamples) {
    const weights = new Float32Array(maxSamples);
    const poleAxis = new Vector3(0, 1, 0);
    const shaderMaterial = new RawShaderMaterial({
        name: 'SphericalGaussianBlur',
        defines: {
            'n': maxSamples
        },
        uniforms: {
            'envMap': {
                value: null
            },
            'samples': {
                value: 1
            },
            'weights': {
                value: weights
            },
            'latitudinal': {
                value: false
            },
            'dTheta': {
                value: 0
            },
            'mipInt': {
                value: 0
            },
            'poleAxis': {
                value: poleAxis
            },
            'inputEncoding': {
                value: ENCODINGS[LinearEncoding]
            },
            'outputEncoding': {
                value: ENCODINGS[LinearEncoding]
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: /* glsl */ `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function _getEquirectShader() {
    const texelSize = new Vector2(1, 1);
    const shaderMaterial = new RawShaderMaterial({
        name: 'EquirectangularToCubeUV',
        uniforms: {
            'envMap': {
                value: null
            },
            'texelSize': {
                value: texelSize
            },
            'inputEncoding': {
                value: ENCODINGS[LinearEncoding]
            },
            'outputEncoding': {
                value: ENCODINGS[LinearEncoding]
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: /* glsl */ `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function _getCubemapShader() {
    const shaderMaterial = new RawShaderMaterial({
        name: 'CubemapToCubeUV',
        uniforms: {
            'envMap': {
                value: null
            },
            'inputEncoding': {
                value: ENCODINGS[LinearEncoding]
            },
            'outputEncoding': {
                value: ENCODINGS[LinearEncoding]
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: /* glsl */ `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function _getCommonVertexShader() {
    return /* glsl */ `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function _getEncodings() {
    return /* glsl */ `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;
}
function WebGLCubeUVMaps(renderer) {
    let cubeUVmaps = new WeakMap();
    let pmremGenerator = null;
    function get(texture) {
        if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
            const mapping = texture.mapping;
            const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
            const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
            if (isEquirectMap || isCubeMap) {
                // equirect/cube map to cubeUV conversion
                if (cubeUVmaps.has(texture)) return cubeUVmaps.get(texture).texture;
                else {
                    const image = texture.image;
                    if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
                        const currentRenderTarget = renderer.getRenderTarget();
                        if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
                        const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                        cubeUVmaps.set(texture, renderTarget);
                        renderer.setRenderTarget(currentRenderTarget);
                        texture.addEventListener('dispose', onTextureDispose);
                        return renderTarget.texture;
                    } else // image not yet ready. try the conversion next frame
                    return null;
                }
            }
        }
        return texture;
    }
    function isCubeTextureComplete(image) {
        let count = 0;
        const length = 6;
        for(let i88 = 0; i88 < length; i88++)if (image[i88] !== undefined) count++;
        return count === length;
    }
    function onTextureDispose(event) {
        const texture = event.target;
        texture.removeEventListener('dispose', onTextureDispose);
        const cubemapUV = cubeUVmaps.get(texture);
        if (cubemapUV !== undefined) {
            cubeUVmaps.delete(texture);
            cubemapUV.dispose();
        }
    }
    function dispose() {
        cubeUVmaps = new WeakMap();
        if (pmremGenerator !== null) {
            pmremGenerator.dispose();
            pmremGenerator = null;
        }
    }
    return {
        get: get,
        dispose: dispose
    };
}
function WebGLExtensions(gl) {
    const extensions = {};
    function getExtension(name) {
        if (extensions[name] !== undefined) return extensions[name];
        let extension;
        switch(name){
            case 'WEBGL_depth_texture':
                extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                break;
            case 'EXT_texture_filter_anisotropic':
                extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                break;
            case 'WEBGL_compressed_texture_s3tc':
                extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                break;
            case 'WEBGL_compressed_texture_pvrtc':
                extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                break;
            default:
                extension = gl.getExtension(name);
        }
        extensions[name] = extension;
        return extension;
    }
    return {
        has: function(name) {
            return getExtension(name) !== null;
        },
        init: function(capabilities) {
            if (capabilities.isWebGL2) getExtension('EXT_color_buffer_float');
            else {
                getExtension('WEBGL_depth_texture');
                getExtension('OES_texture_float');
                getExtension('OES_texture_half_float');
                getExtension('OES_texture_half_float_linear');
                getExtension('OES_standard_derivatives');
                getExtension('OES_element_index_uint');
                getExtension('OES_vertex_array_object');
                getExtension('ANGLE_instanced_arrays');
            }
            getExtension('OES_texture_float_linear');
            getExtension('EXT_color_buffer_half_float');
        },
        get: function(name) {
            const extension = getExtension(name);
            if (extension === null) console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
            return extension;
        }
    };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
    const geometries = {};
    const wireframeAttributes = new WeakMap();
    function onGeometryDispose(event) {
        const geometry = event.target;
        if (geometry.index !== null) attributes.remove(geometry.index);
        for(const name in geometry.attributes)attributes.remove(geometry.attributes[name]);
        geometry.removeEventListener('dispose', onGeometryDispose);
        delete geometries[geometry.id];
        const attribute = wireframeAttributes.get(geometry);
        if (attribute) {
            attributes.remove(attribute);
            wireframeAttributes.delete(geometry);
        }
        bindingStates.releaseStatesOfGeometry(geometry);
        if (geometry.isInstancedBufferGeometry === true) delete geometry._maxInstanceCount;
        //
        info.memory.geometries--;
    }
    function get(object, geometry) {
        if (geometries[geometry.id] === true) return geometry;
        geometry.addEventListener('dispose', onGeometryDispose);
        geometries[geometry.id] = true;
        info.memory.geometries++;
        return geometry;
    }
    function update(geometry) {
        const geometryAttributes = geometry.attributes;
        // Updating index buffer in VAO now. See WebGLBindingStates.
        for(const name in geometryAttributes)attributes.update(geometryAttributes[name], 34962);
        // morph targets
        const morphAttributes = geometry.morphAttributes;
        for(const name3 in morphAttributes){
            const array = morphAttributes[name3];
            for(let i89 = 0, l = array.length; i89 < l; i89++)attributes.update(array[i89], 34962);
        }
    }
    function updateWireframeAttribute(geometry) {
        const indices = [];
        const geometryIndex = geometry.index;
        const geometryPosition = geometry.attributes.position;
        let version = 0;
        if (geometryIndex !== null) {
            const array = geometryIndex.array;
            version = geometryIndex.version;
            for(let i90 = 0, l = array.length; i90 < l; i90 += 3){
                const a = array[i90 + 0];
                const b = array[i90 + 1];
                const c = array[i90 + 2];
                indices.push(a, b, b, c, c, a);
            }
        } else {
            const array = geometryPosition.array;
            version = geometryPosition.version;
            for(let i91 = 0, l = array.length / 3 - 1; i91 < l; i91 += 3){
                const a = i91 + 0;
                const b = i91 + 1;
                const c = i91 + 2;
                indices.push(a, b, b, c, c, a);
            }
        }
        const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
        attribute.version = version;
        // Updating index buffer in VAO now. See WebGLBindingStates
        //
        const previousAttribute = wireframeAttributes.get(geometry);
        if (previousAttribute) attributes.remove(previousAttribute);
        //
        wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
        const currentAttribute = wireframeAttributes.get(geometry);
        if (currentAttribute) {
            const geometryIndex = geometry.index;
            if (geometryIndex !== null) // if the attribute is obsolete, create a new one
            {
                if (currentAttribute.version < geometryIndex.version) updateWireframeAttribute(geometry);
            }
        } else updateWireframeAttribute(geometry);
        return wireframeAttributes.get(geometry);
    }
    return {
        get: get,
        update: update,
        getWireframeAttribute: getWireframeAttribute
    };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
        mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
        type = value.type;
        bytesPerElement = value.bytesPerElement;
    }
    function render(start, count) {
        gl.drawElements(mode, count, type, start * bytesPerElement);
        info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
            extension = gl;
            methodName = 'drawElementsInstanced';
        } else {
            extension = extensions.get('ANGLE_instanced_arrays');
            methodName = 'drawElementsInstancedANGLE';
            if (extension === null) {
                console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
        }
        extension[methodName](mode, count, type, start * bytesPerElement, primcount);
        info.update(count, mode, primcount);
    }
    //
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
    const memory = {
        geometries: 0,
        textures: 0
    };
    const render = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function update(count, mode, instanceCount) {
        render.calls++;
        switch(mode){
            case 4:
                render.triangles += instanceCount * (count / 3);
                break;
            case 1:
                render.lines += instanceCount * (count / 2);
                break;
            case 3:
                render.lines += instanceCount * (count - 1);
                break;
            case 2:
                render.lines += instanceCount * count;
                break;
            case 0:
                render.points += instanceCount * count;
                break;
            default:
                console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
                break;
        }
    }
    function reset() {
        render.frame++;
        render.calls = 0;
        render.triangles = 0;
        render.points = 0;
        render.lines = 0;
    }
    return {
        memory: memory,
        render: render,
        programs: null,
        autoReset: true,
        reset: reset,
        update: update
    };
}
function numericalSort(a, b) {
    return a[0] - b[0];
}
function absNumericalSort(a, b) {
    return Math.abs(b[1]) - Math.abs(a[1]);
}
function WebGLMorphtargets(gl) {
    const influencesList = {};
    const morphInfluences = new Float32Array(8);
    const workInfluences = [];
    for(let i92 = 0; i92 < 8; i92++)workInfluences[i92] = [
        i92,
        0
    ];
    function update(object, geometry, material, program) {
        const objectInfluences = object.morphTargetInfluences;
        // When object doesn't have morph target influences defined, we treat it as a 0-length array
        // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
        const length = objectInfluences === undefined ? 0 : objectInfluences.length;
        let influences = influencesList[geometry.id];
        if (influences === undefined || influences.length !== length) {
            // initialise list
            influences = [];
            for(let i95 = 0; i95 < length; i95++)influences[i95] = [
                i95,
                0
            ];
            influencesList[geometry.id] = influences;
        }
        // Collect influences
        for(let i96 = 0; i96 < length; i96++){
            const influence = influences[i96];
            influence[0] = i96;
            influence[1] = objectInfluences[i96];
        }
        influences.sort(absNumericalSort);
        for(let i93 = 0; i93 < 8; i93++)if (i93 < length && influences[i93][1]) {
            workInfluences[i93][0] = influences[i93][0];
            workInfluences[i93][1] = influences[i93][1];
        } else {
            workInfluences[i93][0] = Number.MAX_SAFE_INTEGER;
            workInfluences[i93][1] = 0;
        }
        workInfluences.sort(numericalSort);
        const morphTargets = geometry.morphAttributes.position;
        const morphNormals = geometry.morphAttributes.normal;
        let morphInfluencesSum = 0;
        for(let i94 = 0; i94 < 8; i94++){
            const influence = workInfluences[i94];
            const index = influence[0];
            const value = influence[1];
            if (index !== Number.MAX_SAFE_INTEGER && value) {
                if (morphTargets && geometry.getAttribute('morphTarget' + i94) !== morphTargets[index]) geometry.setAttribute('morphTarget' + i94, morphTargets[index]);
                if (morphNormals && geometry.getAttribute('morphNormal' + i94) !== morphNormals[index]) geometry.setAttribute('morphNormal' + i94, morphNormals[index]);
                morphInfluences[i94] = value;
                morphInfluencesSum += value;
            } else {
                if (morphTargets && geometry.hasAttribute('morphTarget' + i94) === true) geometry.deleteAttribute('morphTarget' + i94);
                if (morphNormals && geometry.hasAttribute('morphNormal' + i94) === true) geometry.deleteAttribute('morphNormal' + i94);
                morphInfluences[i94] = 0;
            }
        }
        // GLSL shader uses formula baseinfluence * base + sum(target * influence)
        // This allows us to switch between absolute morphs and relative morphs without changing shader code
        // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
        program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
    }
    return {
        update: update
    };
}
function WebGLObjects(gl, geometries, attributes, info) {
    let updateMap = new WeakMap();
    function update(object) {
        const frame = info.render.frame;
        const geometry = object.geometry;
        const buffergeometry = geometries.get(object, geometry);
        // Update once per frame
        if (updateMap.get(buffergeometry) !== frame) {
            geometries.update(buffergeometry);
            updateMap.set(buffergeometry, frame);
        }
        if (object.isInstancedMesh) {
            if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) object.addEventListener('dispose', onInstancedMeshDispose);
            attributes.update(object.instanceMatrix, 34962);
            if (object.instanceColor !== null) attributes.update(object.instanceColor, 34962);
        }
        return buffergeometry;
    }
    function dispose() {
        updateMap = new WeakMap();
    }
    function onInstancedMeshDispose(event) {
        const instancedMesh = event.target;
        instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
        attributes.remove(instancedMesh.instanceMatrix);
        if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
    }
    return {
        update: update,
        dispose: dispose
    };
}
class DataTexture2DArray extends Texture {
    constructor(data = null, width = 1, height = 1, depth = 1){
        super(null);
        this.image = {
            data,
            width,
            height,
            depth
        };
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
        this.wrapR = ClampToEdgeWrapping;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
        this.needsUpdate = true;
    }
}
DataTexture2DArray.prototype.isDataTexture2DArray = true;
class DataTexture3D extends Texture {
    constructor(data = null, width = 1, height = 1, depth = 1){
        // We're going to add .setXXX() methods for setting properties later.
        // Users can still set in DataTexture3D directly.
        //
        //	const texture = new THREE.DataTexture3D( data, width, height, depth );
        // 	texture.anisotropy = 16;
        //
        // See #14839
        super(null);
        this.image = {
            data,
            width,
            height,
            depth
        };
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
        this.wrapR = ClampToEdgeWrapping;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
        this.needsUpdate = true;
    }
}
DataTexture3D.prototype.isDataTexture3D = true;
/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */ const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture();
// --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)
const arrayCacheF32 = [];
const arrayCacheI32 = [];
// Float32Array caches used for uploading Matrix uniforms
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
// Flattening for arrays of vectors and matrices
function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0) return array;
    // unoptimized: ! isNaN( firstElem )
    // see http://jacksondunstan.com/articles/983
    const n = nBlocks * blockSize;
    let r = arrayCacheF32[n];
    if (r === undefined) {
        r = new Float32Array(n);
        arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
        firstElem.toArray(r, 0);
        for(let i97 = 1, offset = 0; i97 !== nBlocks; ++i97){
            offset += blockSize;
            array[i97].toArray(r, offset);
        }
    }
    return r;
}
function arraysEqual(a, b) {
    if (a.length !== b.length) return false;
    for(let i98 = 0, l = a.length; i98 < l; i98++){
        if (a[i98] !== b[i98]) return false;
    }
    return true;
}
function copyArray(a, b) {
    for(let i99 = 0, l = b.length; i99 < l; i99++)a[i99] = b[i99];
}
// Texture unit allocation
function allocTexUnits(textures, n) {
    let r = arrayCacheI32[n];
    if (r === undefined) {
        r = new Int32Array(n);
        arrayCacheI32[n] = r;
    }
    for(let i100 = 0; i100 !== n; ++i100)r[i100] = textures.allocateTextureUnit();
    return r;
}
// --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar
function setValueV1f(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
}
// Single float vector (from flat array or THREE.VectorN)
function setValueV2f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y) {
            gl.uniform2f(this.addr, v.x, v.y);
            cache[0] = v.x;
            cache[1] = v.y;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform2fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValueV3f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
            gl.uniform3f(this.addr, v.x, v.y, v.z);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
        }
    } else if (v.r !== undefined) {
        if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
            gl.uniform3f(this.addr, v.r, v.g, v.b);
            cache[0] = v.r;
            cache[1] = v.g;
            cache[2] = v.b;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform3fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValueV4f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
            cache[3] = v.w;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform4fv(this.addr, v);
        copyArray(cache, v);
    }
}
// Single matrix (from flat array or THREE.MatrixN)
function setValueM2(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix2fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat2array.set(elements);
        gl.uniformMatrix2fv(this.addr, false, mat2array);
        copyArray(cache, elements);
    }
}
function setValueM3(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix3fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat3array.set(elements);
        gl.uniformMatrix3fv(this.addr, false, mat3array);
        copyArray(cache, elements);
    }
}
function setValueM4(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix4fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat4array.set(elements);
        gl.uniformMatrix4fv(this.addr, false, mat4array);
        copyArray(cache, elements);
    }
}
// Single integer / boolean
function setValueV1i(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
}
// Single integer / boolean vector (from flat array)
function setValueV2i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
}
function setValueV3i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
}
function setValueV4i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
}
// Single unsigned integer
function setValueV1ui(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
}
// Single unsigned integer vector (from flat array)
function setValueV2ui(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform2uiv(this.addr, v);
    copyArray(cache, v);
}
function setValueV3ui(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform3uiv(this.addr, v);
    copyArray(cache, v);
}
function setValueV4ui(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform4uiv(this.addr, v);
    copyArray(cache, v);
}
// Single texture (2D / Cube)
function setValueT1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.safeSetTexture2D(v || emptyTexture, unit);
}
function setValueT3D1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture3D(v || emptyTexture3d, unit);
}
function setValueT6(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.safeSetTextureCube(v || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}
// Helper to pick the right setter for the singular case
function getSingularSetter(type) {
    switch(type){
        case 5126:
            return setValueV1f; // FLOAT
        case 35664:
            return setValueV2f; // _VEC2
        case 35665:
            return setValueV3f; // _VEC3
        case 35666:
            return setValueV4f; // _VEC4
        case 35674:
            return setValueM2; // _MAT2
        case 35675:
            return setValueM3; // _MAT3
        case 35676:
            return setValueM4; // _MAT4
        case 5124:
        case 35670:
            return setValueV1i; // INT, BOOL
        case 35667:
        case 35671:
            return setValueV2i; // _VEC2
        case 35668:
        case 35672:
            return setValueV3i; // _VEC3
        case 35669:
        case 35673:
            return setValueV4i; // _VEC4
        case 5125:
            return setValueV1ui; // UINT
        case 36294:
            return setValueV2ui; // _VEC2
        case 36295:
            return setValueV3ui; // _VEC3
        case 36296:
            return setValueV4ui; // _VEC4
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return setValueT1;
        case 35679:
        case 36299:
        case 36307:
            return setValueT3D1;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return setValueT6;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return setValueT2DArray1;
    }
}
// Array of scalars
function setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
}
// Array of vectors (from flat array or array of THREE.VectorN)
function setValueV2fArray(gl, v) {
    const data = flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
    const data = flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data);
}
// Array of matrices (from flat array or array of THREE.MatrixN)
function setValueM2Array(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
    const data = flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
    const data = flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
}
// Array of integer / boolean
function setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
}
// Array of integer / boolean vectors (from flat array)
function setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
}
// Array of unsigned integer
function setValueV1uiArray(gl, v) {
    gl.uniform1uiv(this.addr, v);
}
// Array of unsigned integer vectors (from flat array)
function setValueV2uiArray(gl, v) {
    gl.uniform2uiv(this.addr, v);
}
function setValueV3uiArray(gl, v) {
    gl.uniform3uiv(this.addr, v);
}
function setValueV4uiArray(gl, v) {
    gl.uniform4uiv(this.addr, v);
}
// Array of textures (2D / Cube)
function setValueT1Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i101 = 0; i101 !== n; ++i101)textures.safeSetTexture2D(v[i101] || emptyTexture, units[i101]);
}
function setValueT6Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i102 = 0; i102 !== n; ++i102)textures.safeSetTextureCube(v[i102] || emptyCubeTexture, units[i102]);
}
// Helper to pick the right setter for a pure (bottom-level) array
function getPureArraySetter(type) {
    switch(type){
        case 5126:
            return setValueV1fArray; // FLOAT
        case 35664:
            return setValueV2fArray; // _VEC2
        case 35665:
            return setValueV3fArray; // _VEC3
        case 35666:
            return setValueV4fArray; // _VEC4
        case 35674:
            return setValueM2Array; // _MAT2
        case 35675:
            return setValueM3Array; // _MAT3
        case 35676:
            return setValueM4Array; // _MAT4
        case 5124:
        case 35670:
            return setValueV1iArray; // INT, BOOL
        case 35667:
        case 35671:
            return setValueV2iArray; // _VEC2
        case 35668:
        case 35672:
            return setValueV3iArray; // _VEC3
        case 35669:
        case 35673:
            return setValueV4iArray; // _VEC4
        case 5125:
            return setValueV1uiArray; // UINT
        case 36294:
            return setValueV2uiArray; // _VEC2
        case 36295:
            return setValueV3uiArray; // _VEC3
        case 36296:
            return setValueV4uiArray; // _VEC4
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return setValueT1Array;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return setValueT6Array;
    }
}
// --- Uniform Classes ---
function SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
// this.path = activeInfo.name; // DEBUG
}
function PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
// this.path = activeInfo.name; // DEBUG
}
PureArrayUniform.prototype.updateCache = function(data) {
    const cache = this.cache;
    if (data instanceof Float32Array && cache.length !== data.length) this.cache = new Float32Array(data.length);
    copyArray(cache, data);
};
function StructuredUniform(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
    const seq = this.seq;
    for(let i103 = 0, n = seq.length; i103 !== n; ++i103){
        const u = seq[i103];
        u.setValue(gl, value[u.id], textures);
    }
};
// --- Top-level ---
// Parser - builds up the property tree from the path strings
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    // reset RegExp object, because of the early exit of a previous run
    RePathPart.lastIndex = 0;
    while(true){
        const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
        let id = match[1];
        const idIsIndex = match[2] === ']', subscript = match[3];
        if (idIsIndex) id = id | 0; // convert to integer
        if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
            // bare name or "pure" bottom-level array "[0]" suffix
            addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
            break;
        } else {
            // step into inner node / create it in case it doesn't exist
            const map = container.map;
            let next = map[id];
            if (next === undefined) {
                next = new StructuredUniform(id);
                addUniform(container, next);
            }
            container = next;
        }
    }
}
// Root Container
function WebGLUniforms(gl, program) {
    this.seq = [];
    this.map = {};
    const n = gl.getProgramParameter(program, 35718);
    for(let i104 = 0; i104 < n; ++i104){
        const info = gl.getActiveUniform(program, i104), addr = gl.getUniformLocation(program, info.name);
        parseUniform(info, addr, this);
    }
}
WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== undefined) u.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name) {
    const v = object[name];
    if (v !== undefined) this.setValue(gl, name, v);
};
// Static interface
WebGLUniforms.upload = function(gl, seq, values, textures) {
    for(let i105 = 0, n = seq.length; i105 !== n; ++i105){
        const u = seq[i105], v = values[u.id];
        if (v.needsUpdate !== false) // note: always updating when .needsUpdate is undefined
        u.setValue(gl, v.value, textures);
    }
};
WebGLUniforms.seqWithValue = function(seq, values) {
    const r = [];
    for(let i106 = 0, n = seq.length; i106 !== n; ++i106){
        const u = seq[i106];
        if (u.id in values) r.push(u);
    }
    return r;
};
function WebGLShader(gl, type, string) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
}
let programIdCount = 0;
function addLineNumbers(string) {
    const lines = string.split('\n');
    for(let i107 = 0; i107 < lines.length; i107++)lines[i107] = i107 + 1 + ': ' + lines[i107];
    return lines.join('\n');
}
function getEncodingComponents(encoding) {
    switch(encoding){
        case LinearEncoding:
            return [
                'Linear',
                '( value )'
            ];
        case sRGBEncoding:
            return [
                'sRGB',
                '( value )'
            ];
        case RGBEEncoding:
            return [
                'RGBE',
                '( value )'
            ];
        case RGBM7Encoding:
            return [
                'RGBM',
                '( value, 7.0 )'
            ];
        case RGBM16Encoding:
            return [
                'RGBM',
                '( value, 16.0 )'
            ];
        case RGBDEncoding:
            return [
                'RGBD',
                '( value, 256.0 )'
            ];
        case GammaEncoding:
            return [
                'Gamma',
                '( value, float( GAMMA_FACTOR ) )'
            ];
        case LogLuvEncoding:
            return [
                'LogLuv',
                '( value )'
            ];
        default:
            console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
            return [
                'Linear',
                '( value )'
            ];
    }
}
function getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, 35713);
    const errors = gl.getShaderInfoLog(shader).trim();
    if (status && errors === '') return '';
    // --enable-privileged-webgl-extension
    // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
    return type.toUpperCase() + '\n\n' + errors + '\n\n' + addLineNumbers(gl.getShaderSource(shader));
}
function getTexelDecodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
}
function getTexelEncodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}
function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch(toneMapping){
        case LinearToneMapping:
            toneMappingName = 'Linear';
            break;
        case ReinhardToneMapping:
            toneMappingName = 'Reinhard';
            break;
        case CineonToneMapping:
            toneMappingName = 'OptimizedCineon';
            break;
        case ACESFilmicToneMapping:
            toneMappingName = 'ACESFilmic';
            break;
        case CustomToneMapping:
            toneMappingName = 'Custom';
            break;
        default:
            console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
            toneMappingName = 'Linear';
    }
    return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}
function generateExtensions(parameters) {
    const chunks = [
        parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '',
        (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
        parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '',
        (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
    ];
    return chunks.filter(filterEmptyLine).join('\n');
}
function generateDefines(defines) {
    const chunks = [];
    for(const name in defines){
        const value = defines[name];
        if (value === false) continue;
        chunks.push('#define ' + name + ' ' + value);
    }
    return chunks.join('\n');
}
function fetchAttributeLocations(gl, program) {
    const attributes = {};
    const n = gl.getProgramParameter(program, 35721);
    for(let i108 = 0; i108 < n; i108++){
        const info = gl.getActiveAttrib(program, i108);
        const name = info.name;
        let locationSize = 1;
        if (info.type === 35674) locationSize = 2;
        if (info.type === 35675) locationSize = 3;
        if (info.type === 35676) locationSize = 4;
        // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
        attributes[name] = {
            type: info.type,
            location: gl.getAttribLocation(program, name),
            locationSize: locationSize
        };
    }
    return attributes;
}
function filterEmptyLine(string) {
    return string !== '';
}
function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
// Resolve Includes
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
    const string = ShaderChunk[include];
    if (string === undefined) throw new Error('Can not resolve #include <' + include + '>');
    return resolveIncludes(string);
}
// Unroll Loops
const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start, end, snippet) {
    console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
    return loopReplacer(match, start, end, snippet);
}
function loopReplacer(match, start, end, snippet) {
    let string = '';
    for(let i109 = parseInt(start); i109 < parseInt(end); i109++)string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i109 + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i109);
    return string;
}
//
function generatePrecision(parameters) {
    let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';
    if (parameters.precision === 'highp') precisionstring += '\n#define HIGH_PRECISION';
    else if (parameters.precision === 'mediump') precisionstring += '\n#define MEDIUM_PRECISION';
    else if (parameters.precision === 'lowp') precisionstring += '\n#define LOW_PRECISION';
    return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
    if (parameters.shadowMapType === PCFShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
    else if (parameters.shadowMapType === PCFSoftShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
    else if (parameters.shadowMapType === VSMShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
    return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    if (parameters.envMap) switch(parameters.envMapMode){
        case CubeReflectionMapping:
        case CubeRefractionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
            break;
        case CubeUVReflectionMapping:
        case CubeUVRefractionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
            break;
    }
    return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    if (parameters.envMap) switch(parameters.envMapMode){
        case CubeRefractionMapping:
        case CubeUVRefractionMapping:
            envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
            break;
    }
    return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
    if (parameters.envMap) switch(parameters.combine){
        case MultiplyOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
            break;
        case MixOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
            break;
        case AddOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
            break;
    }
    return envMapBlendingDefine;
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
    // TODO Send this event to Three.js DevTools
    // console.log( 'WebGLProgram', cacheKey );
    const gl = renderer.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
    const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';
    if (parameters.isRawShaderMaterial) {
        prefixVertex = [
            customDefines
        ].filter(filterEmptyLine).join('\n');
        if (prefixVertex.length > 0) prefixVertex += '\n';
        prefixFragment = [
            customExtensions,
            customDefines
        ].filter(filterEmptyLine).join('\n');
        if (prefixFragment.length > 0) prefixFragment += '\n';
    } else {
        prefixVertex = [
            generatePrecision(parameters),
            '#define SHADER_NAME ' + parameters.shaderName,
            customDefines,
            parameters.instancing ? '#define USE_INSTANCING' : '',
            parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
            parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
            '#define GAMMA_FACTOR ' + gammaFactorDefine,
            '#define MAX_BONES ' + parameters.maxBones,
            parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
            parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',
            parameters.map ? '#define USE_MAP' : '',
            parameters.envMap ? '#define USE_ENVMAP' : '',
            parameters.envMap ? '#define ' + envMapModeDefine : '',
            parameters.lightMap ? '#define USE_LIGHTMAP' : '',
            parameters.aoMap ? '#define USE_AOMAP' : '',
            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            parameters.bumpMap ? '#define USE_BUMPMAP' : '',
            parameters.normalMap ? '#define USE_NORMALMAP' : '',
            parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
            parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
            parameters.specularMap ? '#define USE_SPECULARMAP' : '',
            parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
            parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '',
            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
            parameters.transmission ? '#define USE_TRANSMISSION' : '',
            parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
            parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',
            parameters.vertexTangents ? '#define USE_TANGENT' : '',
            parameters.vertexColors ? '#define USE_COLOR' : '',
            parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
            parameters.vertexUvs ? '#define USE_UV' : '',
            parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            parameters.flatShading ? '#define FLAT_SHADED' : '',
            parameters.skinning ? '#define USE_SKINNING' : '',
            parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
            parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
            parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
            parameters.flipSided ? '#define FLIP_SIDED' : '',
            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
            parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
            'uniform mat4 modelMatrix;',
            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform mat4 viewMatrix;',
            'uniform mat3 normalMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            '#ifdef USE_INSTANCING',
            '	attribute mat4 instanceMatrix;',
            '#endif',
            '#ifdef USE_INSTANCING_COLOR',
            '	attribute vec3 instanceColor;',
            '#endif',
            'attribute vec3 position;',
            'attribute vec3 normal;',
            'attribute vec2 uv;',
            '#ifdef USE_TANGENT',
            '	attribute vec4 tangent;',
            '#endif',
            '#if defined( USE_COLOR_ALPHA )',
            '	attribute vec4 color;',
            '#elif defined( USE_COLOR )',
            '	attribute vec3 color;',
            '#endif',
            '#ifdef USE_MORPHTARGETS',
            '	attribute vec3 morphTarget0;',
            '	attribute vec3 morphTarget1;',
            '	attribute vec3 morphTarget2;',
            '	attribute vec3 morphTarget3;',
            '	#ifdef USE_MORPHNORMALS',
            '		attribute vec3 morphNormal0;',
            '		attribute vec3 morphNormal1;',
            '		attribute vec3 morphNormal2;',
            '		attribute vec3 morphNormal3;',
            '	#else',
            '		attribute vec3 morphTarget4;',
            '		attribute vec3 morphTarget5;',
            '		attribute vec3 morphTarget6;',
            '		attribute vec3 morphTarget7;',
            '	#endif',
            '#endif',
            '#ifdef USE_SKINNING',
            '	attribute vec4 skinIndex;',
            '	attribute vec4 skinWeight;',
            '#endif',
            '\n'
        ].filter(filterEmptyLine).join('\n');
        prefixFragment = [
            customExtensions,
            generatePrecision(parameters),
            '#define SHADER_NAME ' + parameters.shaderName,
            customDefines,
            '#define GAMMA_FACTOR ' + gammaFactorDefine,
            parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
            parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',
            parameters.map ? '#define USE_MAP' : '',
            parameters.matcap ? '#define USE_MATCAP' : '',
            parameters.envMap ? '#define USE_ENVMAP' : '',
            parameters.envMap ? '#define ' + envMapTypeDefine : '',
            parameters.envMap ? '#define ' + envMapModeDefine : '',
            parameters.envMap ? '#define ' + envMapBlendingDefine : '',
            parameters.lightMap ? '#define USE_LIGHTMAP' : '',
            parameters.aoMap ? '#define USE_AOMAP' : '',
            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            parameters.bumpMap ? '#define USE_BUMPMAP' : '',
            parameters.normalMap ? '#define USE_NORMALMAP' : '',
            parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
            parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
            parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            parameters.specularMap ? '#define USE_SPECULARMAP' : '',
            parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
            parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '',
            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
            parameters.alphaTest ? '#define USE_ALPHATEST' : '',
            parameters.sheenTint ? '#define USE_SHEEN' : '',
            parameters.transmission ? '#define USE_TRANSMISSION' : '',
            parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
            parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',
            parameters.vertexTangents ? '#define USE_TANGENT' : '',
            parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
            parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
            parameters.vertexUvs ? '#define USE_UV' : '',
            parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
            parameters.flatShading ? '#define FLAT_SHADED' : '',
            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
            parameters.flipSided ? '#define FLIP_SIDED' : '',
            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
            parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
            parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
            (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '',
            'uniform mat4 viewMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '',
            parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '',
            parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',
            parameters.dithering ? '#define DITHERING' : '',
            parameters.format === RGBFormat ? '#define OPAQUE' : '',
            ShaderChunk['encodings_pars_fragment'],
            parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
            parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '',
            parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
            parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
            parameters.specularTintMap ? getTexelDecodingFunction('specularTintMapTexelToLinear', parameters.specularTintMapEncoding) : '',
            parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '',
            getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding),
            parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',
            '\n'
        ].filter(filterEmptyLine).join('\n');
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
        // GLSL 3.0 conversion for built-in materials and ShaderMaterial
        versionString = '#version 300 es\n';
        prefixVertex = [
            '#define attribute in',
            '#define varying out',
            '#define texture2D texture'
        ].join('\n') + '\n' + prefixVertex;
        prefixFragment = [
            '#define varying in',
            parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;',
            parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor',
            '#define gl_FragDepthEXT gl_FragDepth',
            '#define texture2D texture',
            '#define textureCube texture',
            '#define texture2DProj textureProj',
            '#define texture2DLodEXT textureLod',
            '#define texture2DProjLodEXT textureProjLod',
            '#define textureCubeLodEXT textureLod',
            '#define texture2DGradEXT textureGrad',
            '#define texture2DProjGradEXT textureProjGrad',
            '#define textureCubeGradEXT textureGrad'
        ].join('\n') + '\n' + prefixFragment;
    }
    const vertexGlsl = versionString + prefixVertex + vertexShader;
    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
    // console.log( '*VERTEX*', vertexGlsl );
    // console.log( '*FRAGMENT*', fragmentGlsl );
    const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
    const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    // Force a particular attribute to index 0.
    if (parameters.index0AttributeName !== undefined) gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    else if (parameters.morphTargets === true) // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, 'position');
    gl.linkProgram(program);
    // check for link errors
    if (renderer.debug.checkShaderErrors) {
        const programLog = gl.getProgramInfoLog(program).trim();
        const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
        const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
        let runnable = true;
        let haveDiagnostics = true;
        if (gl.getProgramParameter(program, 35714) === false) {
            runnable = false;
            const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
            const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
            console.error('THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' + 'VALIDATE_STATUS ' + gl.getProgramParameter(program, 35715) + '\n\n' + 'Program Info Log: ' + programLog + '\n' + vertexErrors + '\n' + fragmentErrors);
        } else if (programLog !== '') console.warn('THREE.WebGLProgram: Program Info Log:', programLog);
        else if (vertexLog === '' || fragmentLog === '') haveDiagnostics = false;
        if (haveDiagnostics) this.diagnostics = {
            runnable: runnable,
            programLog: programLog,
            vertexShader: {
                log: vertexLog,
                prefix: prefixVertex
            },
            fragmentShader: {
                log: fragmentLog,
                prefix: prefixFragment
            }
        };
    }
    // Clean up
    // Crashes in iOS9 and iOS10. #18402
    // gl.detachShader( program, glVertexShader );
    // gl.detachShader( program, glFragmentShader );
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    // set up caching for uniform locations
    let cachedUniforms;
    this.getUniforms = function() {
        if (cachedUniforms === undefined) cachedUniforms = new WebGLUniforms(gl, program);
        return cachedUniforms;
    };
    // set up caching for attribute locations
    let cachedAttributes;
    this.getAttributes = function() {
        if (cachedAttributes === undefined) cachedAttributes = fetchAttributeLocations(gl, program);
        return cachedAttributes;
    };
    // free resource
    this.destroy = function() {
        bindingStates.releaseStatesOfProgram(this);
        gl.deleteProgram(program);
        this.program = undefined;
    };
    //
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
}
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
    const programs = [];
    const isWebGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const floatVertexTextures = capabilities.floatVertexTextures;
    const maxVertexUniforms = capabilities.maxVertexUniforms;
    const vertexTextures = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshDistanceMaterial: 'distanceRGBA',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        MeshToonMaterial: 'toon',
        MeshStandardMaterial: 'physical',
        MeshPhysicalMaterial: 'physical',
        MeshMatcapMaterial: 'matcap',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points',
        ShadowMaterial: 'shadow',
        SpriteMaterial: 'sprite'
    };
    const parameterNames = [
        'precision',
        'isWebGL2',
        'supportsVertexTextures',
        'outputEncoding',
        'instancing',
        'instancingColor',
        'map',
        'mapEncoding',
        'matcap',
        'matcapEncoding',
        'envMap',
        'envMapMode',
        'envMapEncoding',
        'envMapCubeUV',
        'lightMap',
        'lightMapEncoding',
        'aoMap',
        'emissiveMap',
        'emissiveMapEncoding',
        'bumpMap',
        'normalMap',
        'objectSpaceNormalMap',
        'tangentSpaceNormalMap',
        'clearcoat',
        'clearcoatMap',
        'clearcoatRoughnessMap',
        'clearcoatNormalMap',
        'displacementMap',
        'specularMap',
        'specularIntensityMap',
        'specularTintMap',
        'specularTintMapEncoding',
        'roughnessMap',
        'metalnessMap',
        'gradientMap',
        'alphaMap',
        'alphaTest',
        'combine',
        'vertexColors',
        'vertexAlphas',
        'vertexTangents',
        'vertexUvs',
        'uvsVertexOnly',
        'fog',
        'useFog',
        'fogExp2',
        'flatShading',
        'sizeAttenuation',
        'logarithmicDepthBuffer',
        'skinning',
        'maxBones',
        'useVertexTexture',
        'morphTargets',
        'morphNormals',
        'premultipliedAlpha',
        'numDirLights',
        'numPointLights',
        'numSpotLights',
        'numHemiLights',
        'numRectAreaLights',
        'numDirLightShadows',
        'numPointLightShadows',
        'numSpotLightShadows',
        'shadowMapEnabled',
        'shadowMapType',
        'toneMapping',
        'physicallyCorrectLights',
        'doubleSided',
        'flipSided',
        'numClippingPlanes',
        'numClipIntersection',
        'depthPacking',
        'dithering',
        'format',
        'sheenTint',
        'transmission',
        'transmissionMap',
        'thicknessMap'
    ];
    function getMaxBones(object) {
        const skeleton = object.skeleton;
        const bones = skeleton.bones;
        if (floatVertexTextures) return 1024;
        else {
            // default for when object is not specified
            // ( for example when prebuilding shader to be used with multiple objects )
            //
            //  - leave some extra space for other uniforms
            //  - limit here is ANGLE's 254 max uniform vectors
            //    (up to 54 should be safe)
            const nVertexUniforms = maxVertexUniforms;
            const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
            const maxBones = Math.min(nVertexMatrices, bones.length);
            if (maxBones < bones.length) {
                console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                return 0;
            }
            return maxBones;
        }
    }
    function getTextureEncodingFromMap(map) {
        let encoding;
        if (map && map.isTexture) encoding = map.encoding;
        else if (map && map.isWebGLRenderTarget) {
            console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');
            encoding = map.texture.encoding;
        } else encoding = LinearEncoding;
        return encoding;
    }
    function getParameters(material, lights, shadows, scene, object) {
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
        const shaderID = shaderIDs[material.type];
        // heuristics to create shader parameters according to lights in the scene
        // (not to blow over maxLights budget)
        const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
        if (material.precision !== null) {
            precision = capabilities.getMaxPrecision(material.precision);
            if (precision !== material.precision) console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
        }
        let vertexShader, fragmentShader;
        if (shaderID) {
            const shader = ShaderLib[shaderID];
            vertexShader = shader.vertexShader;
            fragmentShader = shader.fragmentShader;
        } else {
            vertexShader = material.vertexShader;
            fragmentShader = material.fragmentShader;
        }
        const currentRenderTarget = renderer.getRenderTarget();
        const useAlphaTest = material.alphaTest > 0;
        const useClearcoat = material.clearcoat > 0;
        const parameters = {
            isWebGL2: isWebGL2,
            shaderID: shaderID,
            shaderName: material.type,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            defines: material.defines,
            isRawShaderMaterial: material.isRawShaderMaterial === true,
            glslVersion: material.glslVersion,
            precision: precision,
            instancing: object.isInstancedMesh === true,
            instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
            supportsVertexTextures: vertexTextures,
            outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
            map: !!material.map,
            mapEncoding: getTextureEncodingFromMap(material.map),
            matcap: !!material.matcap,
            matcapEncoding: getTextureEncodingFromMap(material.matcap),
            envMap: !!envMap,
            envMapMode: envMap && envMap.mapping,
            envMapEncoding: getTextureEncodingFromMap(envMap),
            envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
            lightMap: !!material.lightMap,
            lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
            tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
            clearcoat: useClearcoat,
            clearcoatMap: useClearcoat && !!material.clearcoatMap,
            clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
            clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
            displacementMap: !!material.displacementMap,
            roughnessMap: !!material.roughnessMap,
            metalnessMap: !!material.metalnessMap,
            specularMap: !!material.specularMap,
            specularIntensityMap: !!material.specularIntensityMap,
            specularTintMap: !!material.specularTintMap,
            specularTintMapEncoding: getTextureEncodingFromMap(material.specularTintMap),
            alphaMap: !!material.alphaMap,
            alphaTest: useAlphaTest,
            gradientMap: !!material.gradientMap,
            sheenTint: !!material.sheenTint && (material.sheenTint.r > 0 || material.sheenTint.g > 0 || material.sheenTint.b > 0),
            transmission: material.transmission > 0,
            transmissionMap: !!material.transmissionMap,
            thicknessMap: !!material.thicknessMap,
            combine: material.combine,
            vertexTangents: !!material.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,
            vertexColors: material.vertexColors,
            vertexAlphas: material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
            vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap,
            uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap) && !!material.displacementMap,
            fog: !!fog,
            useFog: material.fog,
            fogExp2: fog && fog.isFogExp2,
            flatShading: !!material.flatShading,
            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            skinning: object.isSkinnedMesh === true && maxBones > 0,
            maxBones: maxBones,
            useVertexTexture: floatVertexTextures,
            morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
            morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,
            numDirLights: lights.directional.length,
            numPointLights: lights.point.length,
            numSpotLights: lights.spot.length,
            numRectAreaLights: lights.rectArea.length,
            numHemiLights: lights.hemi.length,
            numDirLightShadows: lights.directionalShadowMap.length,
            numPointLightShadows: lights.pointShadowMap.length,
            numSpotLightShadows: lights.spotShadowMap.length,
            numClippingPlanes: clipping.numPlanes,
            numClipIntersection: clipping.numIntersection,
            format: material.format,
            dithering: material.dithering,
            shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
            shadowMapType: renderer.shadowMap.type,
            toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
            physicallyCorrectLights: renderer.physicallyCorrectLights,
            premultipliedAlpha: material.premultipliedAlpha,
            doubleSided: material.side === DoubleSide,
            flipSided: material.side === BackSide,
            depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
            index0AttributeName: material.index0AttributeName,
            extensionDerivatives: material.extensions && material.extensions.derivatives,
            extensionFragDepth: material.extensions && material.extensions.fragDepth,
            extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
            extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
            rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
            rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
            customProgramCacheKey: material.customProgramCacheKey()
        };
        return parameters;
    }
    function getProgramCacheKey(parameters) {
        const array = [];
        if (parameters.shaderID) array.push(parameters.shaderID);
        else {
            array.push(parameters.fragmentShader);
            array.push(parameters.vertexShader);
        }
        if (parameters.defines !== undefined) for(const name in parameters.defines){
            array.push(name);
            array.push(parameters.defines[name]);
        }
        if (parameters.isRawShaderMaterial === false) {
            for(let i110 = 0; i110 < parameterNames.length; i110++)array.push(parameters[parameterNames[i110]]);
            array.push(renderer.outputEncoding);
            array.push(renderer.gammaFactor);
        }
        array.push(parameters.customProgramCacheKey);
        return array.join();
    }
    function getUniforms(material) {
        const shaderID = shaderIDs[material.type];
        let uniforms;
        if (shaderID) {
            const shader = ShaderLib[shaderID];
            uniforms = UniformsUtils.clone(shader.uniforms);
        } else uniforms = material.uniforms;
        return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
        let program;
        // Check if code has been already compiled
        for(let p = 0, pl = programs.length; p < pl; p++){
            const preexistingProgram = programs[p];
            if (preexistingProgram.cacheKey === cacheKey) {
                program = preexistingProgram;
                ++program.usedTimes;
                break;
            }
        }
        if (program === undefined) {
            program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
            programs.push(program);
        }
        return program;
    }
    function releaseProgram(program) {
        if (--program.usedTimes === 0) {
            // Remove from unordered set
            const i111 = programs.indexOf(program);
            programs[i111] = programs[programs.length - 1];
            programs.pop();
            // Free WebGL resources
            program.destroy();
        }
    }
    return {
        getParameters: getParameters,
        getProgramCacheKey: getProgramCacheKey,
        getUniforms: getUniforms,
        acquireProgram: acquireProgram,
        releaseProgram: releaseProgram,
        // Exposed for resource monitoring & error feedback via renderer.info:
        programs: programs
    };
}
function WebGLProperties() {
    let properties = new WeakMap();
    function get(object) {
        let map = properties.get(object);
        if (map === undefined) {
            map = {};
            properties.set(object, map);
        }
        return map;
    }
    function remove(object) {
        properties.delete(object);
    }
    function update(object, key, value) {
        properties.get(object)[key] = value;
    }
    function dispose() {
        properties = new WeakMap();
    }
    return {
        get: get,
        remove: remove,
        update: update,
        dispose: dispose
    };
}
function painterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) return a.groupOrder - b.groupOrder;
    else if (a.renderOrder !== b.renderOrder) return a.renderOrder - b.renderOrder;
    else if (a.program !== b.program) return a.program.id - b.program.id;
    else if (a.material.id !== b.material.id) return a.material.id - b.material.id;
    else if (a.z !== b.z) return a.z - b.z;
    else return a.id - b.id;
}
function reversePainterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) return a.groupOrder - b.groupOrder;
    else if (a.renderOrder !== b.renderOrder) return a.renderOrder - b.renderOrder;
    else if (a.z !== b.z) return b.z - a.z;
    else return a.id - b.id;
}
function WebGLRenderList(properties) {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transmissive = [];
    const transparent = [];
    const defaultProgram = {
        id: -1
    };
    function init() {
        renderItemsIndex = 0;
        opaque.length = 0;
        transmissive.length = 0;
        transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
        let renderItem = renderItems[renderItemsIndex];
        const materialProperties = properties.get(material);
        if (renderItem === undefined) {
            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                program: materialProperties.program || defaultProgram,
                groupOrder: groupOrder,
                renderOrder: object.renderOrder,
                z: z,
                group: group
            };
            renderItems[renderItemsIndex] = renderItem;
        } else {
            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.program = materialProperties.program || defaultProgram;
            renderItem.groupOrder = groupOrder;
            renderItem.renderOrder = object.renderOrder;
            renderItem.z = z;
            renderItem.group = group;
        }
        renderItemsIndex++;
        return renderItem;
    }
    function push(object, geometry, material, groupOrder, z, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
        if (material.transmission > 0) transmissive.push(renderItem);
        else if (material.transparent === true) transparent.push(renderItem);
        else opaque.push(renderItem);
    }
    function unshift(object, geometry, material, groupOrder, z, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
        if (material.transmission > 0) transmissive.unshift(renderItem);
        else if (material.transparent === true) transparent.unshift(renderItem);
        else opaque.unshift(renderItem);
    }
    function sort(customOpaqueSort, customTransparentSort) {
        if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
        if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
        if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
    }
    function finish() {
        // Clear references from inactive renderItems in the list
        for(let i112 = renderItemsIndex, il = renderItems.length; i112 < il; i112++){
            const renderItem = renderItems[i112];
            if (renderItem.id === null) break;
            renderItem.id = null;
            renderItem.object = null;
            renderItem.geometry = null;
            renderItem.material = null;
            renderItem.program = null;
            renderItem.group = null;
        }
    }
    return {
        opaque: opaque,
        transmissive: transmissive,
        transparent: transparent,
        init: init,
        push: push,
        unshift: unshift,
        finish: finish,
        sort: sort
    };
}
function WebGLRenderLists(properties) {
    let lists = new WeakMap();
    function get(scene, renderCallDepth) {
        let list;
        if (lists.has(scene) === false) {
            list = new WebGLRenderList(properties);
            lists.set(scene, [
                list
            ]);
        } else if (renderCallDepth >= lists.get(scene).length) {
            list = new WebGLRenderList(properties);
            lists.get(scene).push(list);
        } else list = lists.get(scene)[renderCallDepth];
        return list;
    }
    function dispose() {
        lists = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
function UniformsCache() {
    const lights = {};
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) return lights[light.id];
            let uniforms;
            switch(light.type){
                case 'DirectionalLight':
                    uniforms = {
                        direction: new Vector3(),
                        color: new Color()
                    };
                    break;
                case 'SpotLight':
                    uniforms = {
                        position: new Vector3(),
                        direction: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case 'PointLight':
                    uniforms = {
                        position: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        decay: 0
                    };
                    break;
                case 'HemisphereLight':
                    uniforms = {
                        direction: new Vector3(),
                        skyColor: new Color(),
                        groundColor: new Color()
                    };
                    break;
                case 'RectAreaLight':
                    uniforms = {
                        color: new Color(),
                        position: new Vector3(),
                        halfWidth: new Vector3(),
                        halfHeight: new Vector3()
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
function ShadowUniformsCache() {
    const lights = {};
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) return lights[light.id];
            let uniforms;
            switch(light.type){
                case 'DirectionalLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;
                case 'SpotLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;
                case 'PointLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1000
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
let nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        },
        ambient: [
            0,
            0,
            0
        ],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
    };
    for(let i113 = 0; i113 < 9; i113++)state.probe.push(new Vector3());
    const vector3 = new Vector3();
    const matrix4 = new Matrix4();
    const matrix42 = new Matrix4();
    function setup(lights, physicallyCorrectLights) {
        let r = 0, g = 0, b = 0;
        for(let i115 = 0; i115 < 9; i115++)state.probe[i115].set(0, 0, 0);
        let directionalLength = 0;
        let pointLength = 0;
        let spotLength = 0;
        let rectAreaLength = 0;
        let hemiLength = 0;
        let numDirectionalShadows = 0;
        let numPointShadows = 0;
        let numSpotShadows = 0;
        lights.sort(shadowCastingLightsFirst);
        // artist-friendly light intensity scaling factor
        const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
        for(let i114 = 0, l = lights.length; i114 < l; i114++){
            const light = lights[i114];
            const color = light.color;
            const intensity = light.intensity;
            const distance = light.distance;
            const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
            if (light.isAmbientLight) {
                r += color.r * intensity * scaleFactor;
                g += color.g * intensity * scaleFactor;
                b += color.b * intensity * scaleFactor;
            } else if (light.isLightProbe) for(let j = 0; j < 9; j++)state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
            else if (light.isDirectionalLight) {
                const uniforms = cache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    state.directionalShadow[directionalLength] = shadowUniforms;
                    state.directionalShadowMap[directionalLength] = shadowMap;
                    state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                    numDirectionalShadows++;
                }
                state.directional[directionalLength] = uniforms;
                directionalLength++;
            } else if (light.isSpotLight) {
                const uniforms = cache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
                uniforms.distance = distance;
                uniforms.coneCos = Math.cos(light.angle);
                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                uniforms.decay = light.decay;
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    state.spotShadow[spotLength] = shadowUniforms;
                    state.spotShadowMap[spotLength] = shadowMap;
                    state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                    numSpotShadows++;
                }
                state.spot[spotLength] = uniforms;
                spotLength++;
            } else if (light.isRectAreaLight) {
                const uniforms = cache.get(light);
                // (a) intensity is the total visible light emitted
                //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
                // (b) intensity is the brightness of the light
                uniforms.color.copy(color).multiplyScalar(intensity);
                uniforms.halfWidth.set(light.width * 0.5, 0, 0);
                uniforms.halfHeight.set(0, light.height * 0.5, 0);
                state.rectArea[rectAreaLength] = uniforms;
                rectAreaLength++;
            } else if (light.isPointLight) {
                const uniforms = cache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
                uniforms.distance = light.distance;
                uniforms.decay = light.decay;
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    shadowUniforms.shadowCameraNear = shadow.camera.near;
                    shadowUniforms.shadowCameraFar = shadow.camera.far;
                    state.pointShadow[pointLength] = shadowUniforms;
                    state.pointShadowMap[pointLength] = shadowMap;
                    state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                    numPointShadows++;
                }
                state.point[pointLength] = uniforms;
                pointLength++;
            } else if (light.isHemisphereLight) {
                const uniforms = cache.get(light);
                uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
                state.hemi[hemiLength] = uniforms;
                hemiLength++;
            }
        }
        if (rectAreaLength > 0) {
            if (capabilities.isWebGL2) {
                // WebGL 2
                state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
            } else {
                // WebGL 1
                if (extensions.has('OES_texture_float_linear') === true) {
                    state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                    state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
                } else if (extensions.has('OES_texture_half_float_linear') === true) {
                    state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
                    state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
                } else console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
            }
        }
        state.ambient[0] = r;
        state.ambient[1] = g;
        state.ambient[2] = b;
        const hash = state.hash;
        if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
            state.directional.length = directionalLength;
            state.spot.length = spotLength;
            state.rectArea.length = rectAreaLength;
            state.point.length = pointLength;
            state.hemi.length = hemiLength;
            state.directionalShadow.length = numDirectionalShadows;
            state.directionalShadowMap.length = numDirectionalShadows;
            state.pointShadow.length = numPointShadows;
            state.pointShadowMap.length = numPointShadows;
            state.spotShadow.length = numSpotShadows;
            state.spotShadowMap.length = numSpotShadows;
            state.directionalShadowMatrix.length = numDirectionalShadows;
            state.pointShadowMatrix.length = numPointShadows;
            state.spotShadowMatrix.length = numSpotShadows;
            hash.directionalLength = directionalLength;
            hash.pointLength = pointLength;
            hash.spotLength = spotLength;
            hash.rectAreaLength = rectAreaLength;
            hash.hemiLength = hemiLength;
            hash.numDirectionalShadows = numDirectionalShadows;
            hash.numPointShadows = numPointShadows;
            hash.numSpotShadows = numSpotShadows;
            state.version = nextVersion++;
        }
    }
    function setupView(lights, camera) {
        let directionalLength = 0;
        let pointLength = 0;
        let spotLength = 0;
        let rectAreaLength = 0;
        let hemiLength = 0;
        const viewMatrix = camera.matrixWorldInverse;
        for(let i116 = 0, l = lights.length; i116 < l; i116++){
            const light = lights[i116];
            if (light.isDirectionalLight) {
                const uniforms = state.directional[directionalLength];
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                directionalLength++;
            } else if (light.isSpotLight) {
                const uniforms = state.spot[spotLength];
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                spotLength++;
            } else if (light.isRectAreaLight) {
                const uniforms = state.rectArea[rectAreaLength];
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                // extract local rotation of light to derive width/height half vectors
                matrix42.identity();
                matrix4.copy(light.matrixWorld);
                matrix4.premultiply(viewMatrix);
                matrix42.extractRotation(matrix4);
                uniforms.halfWidth.set(light.width * 0.5, 0, 0);
                uniforms.halfHeight.set(0, light.height * 0.5, 0);
                uniforms.halfWidth.applyMatrix4(matrix42);
                uniforms.halfHeight.applyMatrix4(matrix42);
                rectAreaLength++;
            } else if (light.isPointLight) {
                const uniforms = state.point[pointLength];
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                pointLength++;
            } else if (light.isHemisphereLight) {
                const uniforms = state.hemi[hemiLength];
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.direction.normalize();
                hemiLength++;
            }
        }
    }
    return {
        setup: setup,
        setupView: setupView,
        state: state
    };
}
function WebGLRenderState(extensions, capabilities) {
    const lights = new WebGLLights(extensions, capabilities);
    const lightsArray = [];
    const shadowsArray = [];
    function init() {
        lightsArray.length = 0;
        shadowsArray.length = 0;
    }
    function pushLight(light) {
        lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
        shadowsArray.push(shadowLight);
    }
    function setupLights(physicallyCorrectLights) {
        lights.setup(lightsArray, physicallyCorrectLights);
    }
    function setupLightsView(camera) {
        lights.setupView(lightsArray, camera);
    }
    const state = {
        lightsArray: lightsArray,
        shadowsArray: shadowsArray,
        lights: lights
    };
    return {
        init: init,
        state: state,
        setupLights: setupLights,
        setupLightsView: setupLightsView,
        pushLight: pushLight,
        pushShadow: pushShadow
    };
}
function WebGLRenderStates(extensions, capabilities) {
    let renderStates = new WeakMap();
    function get(scene, renderCallDepth = 0) {
        let renderState;
        if (renderStates.has(scene) === false) {
            renderState = new WebGLRenderState(extensions, capabilities);
            renderStates.set(scene, [
                renderState
            ]);
        } else if (renderCallDepth >= renderStates.get(scene).length) {
            renderState = new WebGLRenderState(extensions, capabilities);
            renderStates.get(scene).push(renderState);
        } else renderState = renderStates.get(scene)[renderCallDepth];
        return renderState;
    }
    function dispose() {
        renderStates = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
/**
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */ class MeshDepthMaterial extends Material {
    constructor(parameters){
        super();
        this.type = 'MeshDepthMaterial';
        this.depthPacking = BasicDepthPacking;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.depthPacking = source.depthPacking;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
    }
}
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
/**
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */ class MeshDistanceMaterial extends Material {
    constructor(parameters){
        super();
        this.type = 'MeshDistanceMaterial';
        this.referencePosition = new Vector3();
        this.nearDistance = 1;
        this.farDistance = 1000;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.fog = false;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.referencePosition.copy(source.referencePosition);
        this.nearDistance = source.nearDistance;
        this.farDistance = source.farDistance;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        return this;
    }
}
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
function WebGLShadowMap(_renderer, _objects, _capabilities) {
    let _frustum = new Frustum();
    const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking
    }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
    const shadowSide = {
        0: BackSide,
        1: FrontSide,
        2: DoubleSide
    };
    const shadowMaterialVertical = new ShaderMaterial({
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new Vector2()
            },
            radius: {
                value: 4
            },
            samples: {
                value: 8
            }
        },
        vertexShader: vsm_vert,
        fragmentShader: vsm_frag
    });
    const shadowMaterialHorizontal = shadowMaterialVertical.clone();
    shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
    const fullScreenTri = new BufferGeometry();
    fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([
        -1,
        -1,
        0.5,
        3,
        -1,
        0.5,
        -1,
        3,
        0.5
    ]), 3));
    const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
    const scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.render = function(lights, scene, camera) {
        if (scope.enabled === false) return;
        if (scope.autoUpdate === false && scope.needsUpdate === false) return;
        if (lights.length === 0) return;
        const currentRenderTarget = _renderer.getRenderTarget();
        const activeCubeFace = _renderer.getActiveCubeFace();
        const activeMipmapLevel = _renderer.getActiveMipmapLevel();
        const _state = _renderer.state;
        // Set GL state for depth map.
        _state.setBlending(NoBlending);
        _state.buffers.color.setClear(1, 1, 1, 1);
        _state.buffers.depth.setTest(true);
        _state.setScissorTest(false);
        // render depth map
        for(let i117 = 0, il = lights.length; i117 < il; i117++){
            const light = lights[i117];
            const shadow = light.shadow;
            if (shadow === undefined) {
                console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                continue;
            }
            if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
            _shadowMapSize.copy(shadow.mapSize);
            const shadowFrameExtents = shadow.getFrameExtents();
            _shadowMapSize.multiply(shadowFrameExtents);
            _viewportSize.copy(shadow.mapSize);
            if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
                if (_shadowMapSize.x > _maxTextureSize) {
                    _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
                    _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                    shadow.mapSize.x = _viewportSize.x;
                }
                if (_shadowMapSize.y > _maxTextureSize) {
                    _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
                    _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                    shadow.mapSize.y = _viewportSize.y;
                }
            }
            if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
                const pars = {
                    minFilter: LinearFilter,
                    magFilter: LinearFilter,
                    format: RGBAFormat
                };
                shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + '.shadowMap';
                shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.camera.updateProjectionMatrix();
            }
            if (shadow.map === null) {
                const pars = {
                    minFilter: NearestFilter,
                    magFilter: NearestFilter,
                    format: RGBAFormat
                };
                shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + '.shadowMap';
                shadow.camera.updateProjectionMatrix();
            }
            _renderer.setRenderTarget(shadow.map);
            _renderer.clear();
            const viewportCount = shadow.getViewportCount();
            for(let vp = 0; vp < viewportCount; vp++){
                const viewport = shadow.getViewport(vp);
                _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
                _state.viewport(_viewport);
                shadow.updateMatrices(light, vp);
                _frustum = shadow.getFrustum();
                renderObject(scene, camera, shadow.camera, light, this.type);
            }
            // do blur pass for VSM
            if (!shadow.isPointLightShadow && this.type === VSMShadowMap) VSMPass(shadow, camera);
            shadow.needsUpdate = false;
        }
        scope.needsUpdate = false;
        _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera) {
        const geometry = _objects.update(fullScreenMesh);
        // vertical pass
        shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
        shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialVertical.uniforms.radius.value = shadow.radius;
        shadowMaterialVertical.uniforms.samples.value = shadow.blurSamples;
        _renderer.setRenderTarget(shadow.mapPass);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
        // horizontal pass
        shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
        shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
        shadowMaterialHorizontal.uniforms.samples.value = shadow.blurSamples;
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
    }
    function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
        let result = null;
        const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
        if (customMaterial !== undefined) result = customMaterial;
        else result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
        if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
            // in this case we need a unique material instance reflecting the
            // appropriate state
            const keyA = result.uuid, keyB = material.uuid;
            let materialsForVariant = _materialCache[keyA];
            if (materialsForVariant === undefined) {
                materialsForVariant = {};
                _materialCache[keyA] = materialsForVariant;
            }
            let cachedMaterial = materialsForVariant[keyB];
            if (cachedMaterial === undefined) {
                cachedMaterial = result.clone();
                materialsForVariant[keyB] = cachedMaterial;
            }
            result = cachedMaterial;
        }
        result.visible = material.visible;
        result.wireframe = material.wireframe;
        if (type === VSMShadowMap) result.side = material.shadowSide !== null ? material.shadowSide : material.side;
        else result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
        result.alphaMap = material.alphaMap;
        result.alphaTest = material.alphaTest;
        result.clipShadows = material.clipShadows;
        result.clippingPlanes = material.clippingPlanes;
        result.clipIntersection = material.clipIntersection;
        result.displacementMap = material.displacementMap;
        result.displacementScale = material.displacementScale;
        result.displacementBias = material.displacementBias;
        result.wireframeLinewidth = material.wireframeLinewidth;
        result.linewidth = material.linewidth;
        if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
            result.referencePosition.setFromMatrixPosition(light.matrixWorld);
            result.nearDistance = shadowCameraNear;
            result.farDistance = shadowCameraFar;
        }
        return result;
    }
    function renderObject(object, camera, shadowCamera, light, type) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible && (object.isMesh || object.isLine || object.isPoints)) {
            if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                const geometry = _objects.update(object);
                const material = object.material;
                if (Array.isArray(material)) {
                    const groups = geometry.groups;
                    for(let k = 0, kl = groups.length; k < kl; k++){
                        const group = groups[k];
                        const groupMaterial = material[group.materialIndex];
                        if (groupMaterial && groupMaterial.visible) {
                            const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                        }
                    }
                } else if (material.visible) {
                    const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                }
            }
        }
        const children = object.children;
        for(let i118 = 0, l = children.length; i118 < l; i118++)renderObject(children[i118], camera, shadowCamera, light, type);
    }
}
function WebGLState(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
        let locked = false;
        const color = new Vector4();
        let currentColorMask = null;
        const currentColorClear = new Vector4(0, 0, 0, 0);
        return {
            setMask: function(colorMask) {
                if (currentColorMask !== colorMask && !locked) {
                    gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                    currentColorMask = colorMask;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(r, g, b, a, premultipliedAlpha) {
                if (premultipliedAlpha === true) {
                    r *= a;
                    g *= a;
                    b *= a;
                }
                color.set(r, g, b, a);
                if (currentColorClear.equals(color) === false) {
                    gl.clearColor(r, g, b, a);
                    currentColorClear.copy(color);
                }
            },
            reset: function() {
                locked = false;
                currentColorMask = null;
                currentColorClear.set(-1, 0, 0, 0); // set to invalid state
            }
        };
    }
    function DepthBuffer() {
        let locked = false;
        let currentDepthMask = null;
        let currentDepthFunc = null;
        let currentDepthClear = null;
        return {
            setTest: function(depthTest) {
                if (depthTest) enable(2929);
                else disable(2929);
            },
            setMask: function(depthMask) {
                if (currentDepthMask !== depthMask && !locked) {
                    gl.depthMask(depthMask);
                    currentDepthMask = depthMask;
                }
            },
            setFunc: function(depthFunc) {
                if (currentDepthFunc !== depthFunc) {
                    if (depthFunc) switch(depthFunc){
                        case NeverDepth:
                            gl.depthFunc(512);
                            break;
                        case AlwaysDepth:
                            gl.depthFunc(519);
                            break;
                        case LessDepth:
                            gl.depthFunc(513);
                            break;
                        case LessEqualDepth:
                            gl.depthFunc(515);
                            break;
                        case EqualDepth:
                            gl.depthFunc(514);
                            break;
                        case GreaterEqualDepth:
                            gl.depthFunc(518);
                            break;
                        case GreaterDepth:
                            gl.depthFunc(516);
                            break;
                        case NotEqualDepth:
                            gl.depthFunc(517);
                            break;
                        default:
                            gl.depthFunc(515);
                    }
                    else gl.depthFunc(515);
                    currentDepthFunc = depthFunc;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(depth) {
                if (currentDepthClear !== depth) {
                    gl.clearDepth(depth);
                    currentDepthClear = depth;
                }
            },
            reset: function() {
                locked = false;
                currentDepthMask = null;
                currentDepthFunc = null;
                currentDepthClear = null;
            }
        };
    }
    function StencilBuffer() {
        let locked = false;
        let currentStencilMask = null;
        let currentStencilFunc = null;
        let currentStencilRef = null;
        let currentStencilFuncMask = null;
        let currentStencilFail = null;
        let currentStencilZFail = null;
        let currentStencilZPass = null;
        let currentStencilClear = null;
        return {
            setTest: function(stencilTest) {
                if (!locked) {
                    if (stencilTest) enable(2960);
                    else disable(2960);
                }
            },
            setMask: function(stencilMask) {
                if (currentStencilMask !== stencilMask && !locked) {
                    gl.stencilMask(stencilMask);
                    currentStencilMask = stencilMask;
                }
            },
            setFunc: function(stencilFunc, stencilRef, stencilMask) {
                if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                    gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                    currentStencilFunc = stencilFunc;
                    currentStencilRef = stencilRef;
                    currentStencilFuncMask = stencilMask;
                }
            },
            setOp: function(stencilFail, stencilZFail, stencilZPass) {
                if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                    gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                    currentStencilFail = stencilFail;
                    currentStencilZFail = stencilZFail;
                    currentStencilZPass = stencilZPass;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(stencil) {
                if (currentStencilClear !== stencil) {
                    gl.clearStencil(stencil);
                    currentStencilClear = stencil;
                }
            },
            reset: function() {
                locked = false;
                currentStencilMask = null;
                currentStencilFunc = null;
                currentStencilRef = null;
                currentStencilFuncMask = null;
                currentStencilFail = null;
                currentStencilZFail = null;
                currentStencilZPass = null;
                currentStencilClear = null;
            }
        };
    }
    //
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    let enabledCapabilities = {};
    let xrFramebuffer = null;
    let currentBoundFramebuffers = {};
    let currentProgram = null;
    let currentBlendingEnabled = false;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(35661);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(7938);
    if (glVersion.indexOf('WebGL') !== -1) {
        version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf('OpenGL ES') !== -1) {
        version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {};
    const scissorParam = gl.getParameter(3088);
    const viewportParam = gl.getParameter(2978);
    const currentScissor = new Vector4().fromArray(scissorParam);
    const currentViewport = new Vector4().fromArray(viewportParam);
    function createTexture(type, target, count) {
        const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
        const texture = gl.createTexture();
        gl.bindTexture(type, texture);
        gl.texParameteri(type, 10241, 9728);
        gl.texParameteri(type, 10240, 9728);
        for(let i119 = 0; i119 < count; i119++)gl.texImage2D(target + i119, 0, 6408, 1, 1, 0, 6408, 5121, data);
        return texture;
    }
    const emptyTextures = {};
    emptyTextures[3553] = createTexture(3553, 3553, 1);
    emptyTextures[34067] = createTexture(34067, 34069, 6);
    // init
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(2929);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(2884);
    setBlending(NoBlending);
    //
    function enable(id) {
        if (enabledCapabilities[id] !== true) {
            gl.enable(id);
            enabledCapabilities[id] = true;
        }
    }
    function disable(id) {
        if (enabledCapabilities[id] !== false) {
            gl.disable(id);
            enabledCapabilities[id] = false;
        }
    }
    function bindXRFramebuffer(framebuffer) {
        if (framebuffer !== xrFramebuffer) {
            gl.bindFramebuffer(36160, framebuffer);
            xrFramebuffer = framebuffer;
        }
    }
    function bindFramebuffer(target, framebuffer) {
        if (framebuffer === null && xrFramebuffer !== null) framebuffer = xrFramebuffer; // use active XR framebuffer if available
        if (currentBoundFramebuffers[target] !== framebuffer) {
            gl.bindFramebuffer(target, framebuffer);
            currentBoundFramebuffers[target] = framebuffer;
            if (isWebGL2) {
                // 36009 is equivalent to 36160
                if (target === 36009) currentBoundFramebuffers[36160] = framebuffer;
                if (target === 36160) currentBoundFramebuffers[36009] = framebuffer;
            }
            return true;
        }
        return false;
    }
    function useProgram(program) {
        if (currentProgram !== program) {
            gl.useProgram(program);
            currentProgram = program;
            return true;
        }
        return false;
    }
    const equationToGL = {
        [AddEquation]: 32774,
        [SubtractEquation]: 32778,
        [ReverseSubtractEquation]: 32779
    };
    if (isWebGL2) {
        equationToGL[MinEquation] = 32775;
        equationToGL[MaxEquation] = 32776;
    } else {
        const extension = extensions.get('EXT_blend_minmax');
        if (extension !== null) {
            equationToGL[MinEquation] = extension.MIN_EXT;
            equationToGL[MaxEquation] = extension.MAX_EXT;
        }
    }
    const factorToGL = {
        [ZeroFactor]: 0,
        [OneFactor]: 1,
        [SrcColorFactor]: 768,
        [SrcAlphaFactor]: 770,
        [SrcAlphaSaturateFactor]: 776,
        [DstColorFactor]: 774,
        [DstAlphaFactor]: 772,
        [OneMinusSrcColorFactor]: 769,
        [OneMinusSrcAlphaFactor]: 771,
        [OneMinusDstColorFactor]: 775,
        [OneMinusDstAlphaFactor]: 773
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
        if (blending === NoBlending) {
            if (currentBlendingEnabled === true) {
                disable(3042);
                currentBlendingEnabled = false;
            }
            return;
        }
        if (currentBlendingEnabled === false) {
            enable(3042);
            currentBlendingEnabled = true;
        }
        if (blending !== CustomBlending) {
            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
                    gl.blendEquation(32774);
                    currentBlendEquation = AddEquation;
                    currentBlendEquationAlpha = AddEquation;
                }
                if (premultipliedAlpha) switch(blending){
                    case NormalBlending:
                        gl.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case AdditiveBlending:
                        gl.blendFunc(1, 1);
                        break;
                    case SubtractiveBlending:
                        gl.blendFuncSeparate(0, 0, 769, 771);
                        break;
                    case MultiplyBlending:
                        gl.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error('THREE.WebGLState: Invalid blending: ', blending);
                        break;
                }
                else switch(blending){
                    case NormalBlending:
                        gl.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case AdditiveBlending:
                        gl.blendFunc(770, 1);
                        break;
                    case SubtractiveBlending:
                        gl.blendFunc(0, 769);
                        break;
                    case MultiplyBlending:
                        gl.blendFunc(0, 768);
                        break;
                    default:
                        console.error('THREE.WebGLState: Invalid blending: ', blending);
                        break;
                }
                currentBlendSrc = null;
                currentBlendDst = null;
                currentBlendSrcAlpha = null;
                currentBlendDstAlpha = null;
                currentBlending = blending;
                currentPremultipledAlpha = premultipliedAlpha;
            }
            return;
        }
        // custom blending
        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;
        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
        }
        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
        }
        currentBlending = blending;
        currentPremultipledAlpha = null;
    }
    function setMaterial(material, frontFaceCW) {
        material.side === DoubleSide ? disable(2884) : enable(2884);
        let flipSided = material.side === BackSide;
        if (frontFaceCW) flipSided = !flipSided;
        setFlipSided(flipSided);
        material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
        depthBuffer.setFunc(material.depthFunc);
        depthBuffer.setTest(material.depthTest);
        depthBuffer.setMask(material.depthWrite);
        colorBuffer.setMask(material.colorWrite);
        const stencilWrite = material.stencilWrite;
        stencilBuffer.setTest(stencilWrite);
        if (stencilWrite) {
            stencilBuffer.setMask(material.stencilWriteMask);
            stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
            stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
        }
        setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        material.alphaToCoverage === true ? enable(32926) : disable(32926);
    }
    //
    function setFlipSided(flipSided) {
        if (currentFlipSided !== flipSided) {
            if (flipSided) gl.frontFace(2304);
            else gl.frontFace(2305);
            currentFlipSided = flipSided;
        }
    }
    function setCullFace(cullFace) {
        if (cullFace !== CullFaceNone) {
            enable(2884);
            if (cullFace !== currentCullFace) {
                if (cullFace === CullFaceBack) gl.cullFace(1029);
                else if (cullFace === CullFaceFront) gl.cullFace(1028);
                else gl.cullFace(1032);
            }
        } else disable(2884);
        currentCullFace = cullFace;
    }
    function setLineWidth(width) {
        if (width !== currentLineWidth) {
            if (lineWidthAvailable) gl.lineWidth(width);
            currentLineWidth = width;
        }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
        if (polygonOffset) {
            enable(32823);
            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                gl.polygonOffset(factor, units);
                currentPolygonOffsetFactor = factor;
                currentPolygonOffsetUnits = units;
            }
        } else disable(32823);
    }
    function setScissorTest(scissorTest) {
        if (scissorTest) enable(3089);
        else disable(3089);
    }
    // texture
    function activeTexture(webglSlot) {
        if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
            gl.activeTexture(webglSlot);
            currentTextureSlot = webglSlot;
        }
    }
    function bindTexture(webglType, webglTexture) {
        if (currentTextureSlot === null) activeTexture();
        let boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture === undefined) {
            boundTexture = {
                type: undefined,
                texture: undefined
            };
            currentBoundTextures[currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;
        }
    }
    function unbindTexture() {
        const boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture !== undefined && boundTexture.type !== undefined) {
            gl.bindTexture(boundTexture.type, null);
            boundTexture.type = undefined;
            boundTexture.texture = undefined;
        }
    }
    function compressedTexImage2D() {
        try {
            gl.compressedTexImage2D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    function texImage2D() {
        try {
            gl.texImage2D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    function texImage3D() {
        try {
            gl.texImage3D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    //
    function scissor1(scissor) {
        if (currentScissor.equals(scissor) === false) {
            gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
            currentScissor.copy(scissor);
        }
    }
    function viewport1(viewport) {
        if (currentViewport.equals(viewport) === false) {
            gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
            currentViewport.copy(viewport);
        }
    }
    //
    function reset() {
        // reset state
        gl.disable(3042);
        gl.disable(2884);
        gl.disable(2929);
        gl.disable(32823);
        gl.disable(3089);
        gl.disable(2960);
        gl.disable(32926);
        gl.blendEquation(32774);
        gl.blendFunc(1, 0);
        gl.blendFuncSeparate(1, 0, 1, 0);
        gl.colorMask(true, true, true, true);
        gl.clearColor(0, 0, 0, 0);
        gl.depthMask(true);
        gl.depthFunc(513);
        gl.clearDepth(1);
        gl.stencilMask(4294967295);
        gl.stencilFunc(519, 0, 4294967295);
        gl.stencilOp(7680, 7680, 7680);
        gl.clearStencil(0);
        gl.cullFace(1029);
        gl.frontFace(2305);
        gl.polygonOffset(0, 0);
        gl.activeTexture(33984);
        gl.bindFramebuffer(36160, null);
        if (isWebGL2 === true) {
            gl.bindFramebuffer(36009, null);
            gl.bindFramebuffer(36008, null);
        }
        gl.useProgram(null);
        gl.lineWidth(1);
        gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        // reset internals
        enabledCapabilities = {};
        currentTextureSlot = null;
        currentBoundTextures = {};
        xrFramebuffer = null;
        currentBoundFramebuffers = {};
        currentProgram = null;
        currentBlendingEnabled = false;
        currentBlending = null;
        currentBlendEquation = null;
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendEquationAlpha = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentPremultipledAlpha = false;
        currentFlipSided = null;
        currentCullFace = null;
        currentLineWidth = null;
        currentPolygonOffsetFactor = null;
        currentPolygonOffsetUnits = null;
        currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
        currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
        colorBuffer.reset();
        depthBuffer.reset();
        stencilBuffer.reset();
    }
    return {
        buffers: {
            color: colorBuffer,
            depth: depthBuffer,
            stencil: stencilBuffer
        },
        enable: enable,
        disable: disable,
        bindFramebuffer: bindFramebuffer,
        bindXRFramebuffer: bindXRFramebuffer,
        useProgram: useProgram,
        setBlending: setBlending,
        setMaterial: setMaterial,
        setFlipSided: setFlipSided,
        setCullFace: setCullFace,
        setLineWidth: setLineWidth,
        setPolygonOffset: setPolygonOffset,
        setScissorTest: setScissorTest,
        activeTexture: activeTexture,
        bindTexture: bindTexture,
        unbindTexture: unbindTexture,
        compressedTexImage2D: compressedTexImage2D,
        texImage2D: texImage2D,
        texImage3D: texImage3D,
        scissor: scissor1,
        viewport: viewport1,
        reset: reset
    };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const _videoTextures = new WeakMap();
    let _canvas1;
    // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
    // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
    // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
    let useOffscreenCanvas = false;
    try {
        useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
    } catch (err) {
    // Ignore any errors
    }
    function createCanvas(width, height) {
        // Use OffscreenCanvas when available. Specially needed in web workers
        return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
        let scale = 1;
        // handle case if texture exceeds max size
        if (image.width > maxSize || image.height > maxSize) scale = maxSize / Math.max(image.width, image.height);
        // only perform resize if necessary
        if (scale < 1 || needsPowerOfTwo === true) {
            // only perform resize for certain image types
            if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
                const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
                const width = floor(scale * image.width);
                const height = floor(scale * image.height);
                if (_canvas1 === undefined) _canvas1 = createCanvas(width, height);
                // cube textures can't reuse the same canvas
                const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas1;
                canvas.width = width;
                canvas.height = height;
                const context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, width, height);
                console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
                return canvas;
            } else {
                if ('data' in image) console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
                return image;
            }
        }
        return image;
    }
    function isPowerOfTwo$1(image) {
        return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
        if (isWebGL2) return false;
        return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
        return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target, texture, width, height, depth = 1) {
        _gl.generateMipmap(target);
        const textureProperties = properties.get(texture);
        textureProperties.__maxMipLevel = Math.log2(Math.max(width, height, depth));
    }
    function getInternalFormat(internalFormatName, glFormat, glType) {
        if (isWebGL2 === false) return glFormat;
        if (internalFormatName !== null) {
            if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
            console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
        }
        let internalFormat = glFormat;
        if (glFormat === 6403) {
            if (glType === 5126) internalFormat = 33326;
            if (glType === 5131) internalFormat = 33325;
            if (glType === 5121) internalFormat = 33321;
        }
        if (glFormat === 6407) {
            if (glType === 5126) internalFormat = 34837;
            if (glType === 5131) internalFormat = 34843;
            if (glType === 5121) internalFormat = 32849;
        }
        if (glFormat === 6408) {
            if (glType === 5126) internalFormat = 34836;
            if (glType === 5131) internalFormat = 34842;
            if (glType === 5121) internalFormat = 32856;
        }
        if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) extensions.get('EXT_color_buffer_float');
        return internalFormat;
    }
    // Fallback filters for non-power-of-2 textures
    function filterFallback(f) {
        if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) return 9728;
        return 9729;
    }
    //
    function onTextureDispose(event) {
        const texture = event.target;
        texture.removeEventListener('dispose', onTextureDispose);
        deallocateTexture(texture);
        if (texture.isVideoTexture) _videoTextures.delete(texture);
        info.memory.textures--;
    }
    function onRenderTargetDispose(event) {
        const renderTarget = event.target;
        renderTarget.removeEventListener('dispose', onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
    }
    //
    function deallocateTexture(texture) {
        const textureProperties = properties.get(texture);
        if (textureProperties.__webglInit === undefined) return;
        _gl.deleteTexture(textureProperties.__webglTexture);
        properties.remove(texture);
    }
    function deallocateRenderTarget(renderTarget) {
        const texture = renderTarget.texture;
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(texture);
        if (!renderTarget) return;
        if (textureProperties.__webglTexture !== undefined) {
            _gl.deleteTexture(textureProperties.__webglTexture);
            info.memory.textures--;
        }
        if (renderTarget.depthTexture) renderTarget.depthTexture.dispose();
        if (renderTarget.isWebGLCubeRenderTarget) for(let i121 = 0; i121 < 6; i121++){
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i121]);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i121]);
        }
        else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
            if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
            if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
        }
        if (renderTarget.isWebGLMultipleRenderTargets) for(let i120 = 0, il = texture.length; i120 < il; i120++){
            const attachmentProperties = properties.get(texture[i120]);
            if (attachmentProperties.__webglTexture) {
                _gl.deleteTexture(attachmentProperties.__webglTexture);
                info.memory.textures--;
            }
            properties.remove(texture[i120]);
        }
        properties.remove(texture);
        properties.remove(renderTarget);
    }
    //
    let textureUnits = 0;
    function resetTextureUnits() {
        textureUnits = 0;
    }
    function allocateTextureUnit() {
        const textureUnit = textureUnits;
        if (textureUnit >= maxTextures) console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
        textureUnits += 1;
        return textureUnit;
    }
    //
    function setTexture2D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.isVideoTexture) updateVideoTexture(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            const image = texture.image;
            if (image === undefined) console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
            else if (image.complete === false) console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
            else {
                uploadTexture(textureProperties, texture, slot);
                return;
            }
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(3553, textureProperties.__webglTexture);
    }
    function setTexture2DArray(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(35866, textureProperties.__webglTexture);
    }
    function setTexture3D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(32879, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadCubeTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
    }
    const wrappingToGL = {
        [RepeatWrapping]: 10497,
        [ClampToEdgeWrapping]: 33071,
        [MirroredRepeatWrapping]: 33648
    };
    const filterToGL = {
        [NearestFilter]: 9728,
        [NearestMipmapNearestFilter]: 9984,
        [NearestMipmapLinearFilter]: 9986,
        [LinearFilter]: 9729,
        [LinearMipmapNearestFilter]: 9985,
        [LinearMipmapLinearFilter]: 9987
    };
    function setTextureParameters(textureType, texture, supportsMips) {
        if (supportsMips) {
            _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
            _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
            if (textureType === 32879 || textureType === 35866) _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
            _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
            _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
        } else {
            _gl.texParameteri(textureType, 10242, 33071);
            _gl.texParameteri(textureType, 10243, 33071);
            if (textureType === 32879 || textureType === 35866) _gl.texParameteri(textureType, 32882, 33071);
            if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
            _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
            _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
            if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
        }
        if (extensions.has('EXT_texture_filter_anisotropic') === true) {
            const extension = extensions.get('EXT_texture_filter_anisotropic');
            if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2
            if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only
            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                properties.get(texture).__currentAnisotropy = texture.anisotropy;
            }
        }
    }
    function initTexture(textureProperties, texture) {
        if (textureProperties.__webglInit === undefined) {
            textureProperties.__webglInit = true;
            texture.addEventListener('dispose', onTextureDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
        }
    }
    function uploadTexture(textureProperties, texture, slot) {
        let textureType = 3553;
        if (texture.isDataTexture2DArray) textureType = 35866;
        if (texture.isDataTexture3D) textureType = 32879;
        initTexture(textureProperties, texture);
        state.activeTexture(33984 + slot);
        state.bindTexture(textureType, textureProperties.__webglTexture);
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        _gl.pixelStorei(37443, 0);
        const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
        const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
        const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format);
        let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        setTextureParameters(textureType, texture, supportsMips);
        let mipmap;
        const mipmaps = texture.mipmaps;
        if (texture.isDepthTexture) {
            // populate depth texture with dummy data
            glInternalFormat = 6402;
            if (isWebGL2) {
                if (texture.type === FloatType) glInternalFormat = 36012;
                else if (texture.type === UnsignedIntType) glInternalFormat = 33190;
                else if (texture.type === UnsignedInt248Type) glInternalFormat = 35056;
                else glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D
            } else if (texture.type === FloatType) console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
            // validation checks for WebGL 1
            if (texture.format === DepthFormat && glInternalFormat === 6402) // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
            // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
            // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
            {
                if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                    console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
                    texture.type = UnsignedShortType;
                    glType = utils.convert(texture.type);
                }
            }
            if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
                // Depth stencil textures need the DEPTH_STENCIL internal format
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                glInternalFormat = 34041;
                // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                if (texture.type !== UnsignedInt248Type) {
                    console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
                    texture.type = UnsignedInt248Type;
                    glType = utils.convert(texture.type);
                }
            }
            //
            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        } else if (texture.isDataTexture) {
            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels
            if (mipmaps.length > 0 && supportsMips) {
                for(let i122 = 0, il = mipmaps.length; i122 < il; i122++){
                    mipmap = mipmaps[i122];
                    state.texImage2D(3553, i122, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
                texture.generateMipmaps = false;
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
                state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
                textureProperties.__maxMipLevel = 0;
            }
        } else if (texture.isCompressedTexture) {
            for(let i123 = 0, il = mipmaps.length; i123 < il; i123++){
                mipmap = mipmaps[i123];
                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                    if (glFormat !== null) state.compressedTexImage2D(3553, i123, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    else console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                } else state.texImage2D(3553, i123, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else if (texture.isDataTexture2DArray) {
            state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
        } else if (texture.isDataTexture3D) {
            state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
        } else // regular Texture (image, video, canvas)
        // use manually created mipmaps if available
        // if there are no manual mipmaps
        // set 0 level mipmap and then use GL to generate other mipmap levels
        if (mipmaps.length > 0 && supportsMips) {
            for(let i124 = 0, il = mipmaps.length; i124 < il; i124++){
                mipmap = mipmaps[i124];
                state.texImage2D(3553, i124, glInternalFormat, glFormat, glType, mipmap);
            }
            texture.generateMipmaps = false;
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
            textureProperties.__maxMipLevel = 0;
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) generateMipmap(textureType, texture, image.width, image.height);
        textureProperties.__version = texture.version;
        if (texture.onUpdate) texture.onUpdate(texture);
    }
    function uploadCubeTexture(textureProperties, texture, slot) {
        if (texture.image.length !== 6) return;
        initTexture(textureProperties, texture);
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        _gl.pixelStorei(37443, 0);
        const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
        const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        const cubeImage = [];
        for(let i125 = 0; i125 < 6; i125++)if (!isCompressed && !isDataTexture) cubeImage[i125] = resizeImage(texture.image[i125], false, true, maxCubemapSize);
        else cubeImage[i125] = isDataTexture ? texture.image[i125].image : texture.image[i125];
        const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        setTextureParameters(34067, texture, supportsMips);
        let mipmaps;
        if (isCompressed) {
            for(let i126 = 0; i126 < 6; i126++){
                mipmaps = cubeImage[i126].mipmaps;
                for(let j = 0; j < mipmaps.length; j++){
                    const mipmap = mipmaps[j];
                    if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                        if (glFormat !== null) state.compressedTexImage2D(34069 + i126, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                        else console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                    } else state.texImage2D(34069 + i126, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
            }
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
            mipmaps = texture.mipmaps;
            for(let i127 = 0; i127 < 6; i127++)if (isDataTexture) {
                state.texImage2D(34069 + i127, 0, glInternalFormat, cubeImage[i127].width, cubeImage[i127].height, 0, glFormat, glType, cubeImage[i127].data);
                for(let j = 0; j < mipmaps.length; j++){
                    const mipmap = mipmaps[j];
                    const mipmapImage = mipmap.image[i127].image;
                    state.texImage2D(34069 + i127, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                }
            } else {
                state.texImage2D(34069 + i127, 0, glInternalFormat, glFormat, glType, cubeImage[i127]);
                for(let j = 0; j < mipmaps.length; j++){
                    const mipmap = mipmaps[j];
                    state.texImage2D(34069 + i127, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i127]);
                }
            }
            textureProperties.__maxMipLevel = mipmaps.length;
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) // We assume images for cube map have the same size.
        generateMipmap(34067, texture, image.width, image.height);
        textureProperties.__version = texture.version;
        if (texture.onUpdate) texture.onUpdate(texture);
    }
    // Render targets
    // Setup storage for target texture and bind it to correct framebuffer
    function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
        const glFormat = utils.convert(texture.format);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        if (textureTarget === 32879 || textureTarget === 35866) state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
        else state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        state.bindFramebuffer(36160, framebuffer);
        _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
        state.bindFramebuffer(36160, null);
    }
    // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
        _gl.bindRenderbuffer(36161, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            let glInternalFormat = 33189;
            if (isMultisample) {
                const depthTexture = renderTarget.depthTexture;
                if (depthTexture && depthTexture.isDepthTexture) {
                    if (depthTexture.type === FloatType) glInternalFormat = 36012;
                    else if (depthTexture.type === UnsignedIntType) glInternalFormat = 33190;
                }
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            if (isMultisample) {
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
        } else {
            // Use the first texture for MRT so far
            const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
            const glFormat = utils.convert(texture.format);
            const glType = utils.convert(texture.type);
            const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
            if (isMultisample) {
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
        _gl.bindRenderbuffer(36161, null);
    }
    // Setup resources for a Depth Texture for a FBO (needs an extension)
    function setupDepthTexture(framebuffer, renderTarget) {
        const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
        if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
        state.bindFramebuffer(36160, framebuffer);
        if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
        // upload an empty depth texture with framebuffer size
        if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
            renderTarget.depthTexture.image.width = renderTarget.width;
            renderTarget.depthTexture.image.height = renderTarget.height;
            renderTarget.depthTexture.needsUpdate = true;
        }
        setTexture2D(renderTarget.depthTexture, 0);
        const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
        if (renderTarget.depthTexture.format === DepthFormat) _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
        else if (renderTarget.depthTexture.format === DepthStencilFormat) _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
        else throw new Error('Unknown depthTexture format');
    }
    // Setup GL resources for a non-texture depth buffer
    function setupDepthRenderbuffer(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        if (renderTarget.depthTexture) {
            if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
        } else if (isCube) {
            renderTargetProperties.__webglDepthbuffer = [];
            for(let i128 = 0; i128 < 6; i128++){
                state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i128]);
                renderTargetProperties.__webglDepthbuffer[i128] = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i128], renderTarget, false);
            }
        } else {
            state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        }
        state.bindFramebuffer(36160, null);
    }
    // Set up GL resources for the render target
    function setupRenderTarget(renderTarget) {
        const texture = renderTarget.texture;
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(texture);
        renderTarget.addEventListener('dispose', onRenderTargetDispose);
        if (renderTarget.isWebGLMultipleRenderTargets !== true) {
            textureProperties.__webglTexture = _gl.createTexture();
            textureProperties.__version = texture.version;
            info.memory.textures++;
        }
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
        const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
        const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
        const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
        // Handles WebGL2 RGBFormat fallback - #18858
        if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
            texture.format = RGBAFormat;
            console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
        }
        // Setup framebuffer
        if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            for(let i129 = 0; i129 < 6; i129++)renderTargetProperties.__webglFramebuffer[i129] = _gl.createFramebuffer();
        } else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (isMultipleRenderTargets) {
                if (capabilities.drawBuffers) {
                    const textures = renderTarget.texture;
                    for(let i130 = 0, il = textures.length; i130 < il; i130++){
                        const attachmentProperties = properties.get(textures[i130]);
                        if (attachmentProperties.__webglTexture === undefined) {
                            attachmentProperties.__webglTexture = _gl.createTexture();
                            info.memory.textures++;
                        }
                    }
                } else console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');
            } else if (isMultisample) {
                if (isWebGL2) {
                    renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                    renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
                    _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
                    const glFormat = utils.convert(texture.format);
                    const glType = utils.convert(texture.type);
                    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
                    const samples = getRenderTargetSamples(renderTarget);
                    _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                    state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
                    _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
                    _gl.bindRenderbuffer(36161, null);
                    if (renderTarget.depthBuffer) {
                        renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                        setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
                    }
                    state.bindFramebuffer(36160, null);
                } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
            }
        }
        // Setup color buffer
        if (isCube) {
            state.bindTexture(34067, textureProperties.__webglTexture);
            setTextureParameters(34067, texture, supportsMips);
            for(let i131 = 0; i131 < 6; i131++)setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i131], renderTarget, texture, 36064, 34069 + i131);
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) generateMipmap(34067, texture, renderTarget.width, renderTarget.height);
            state.unbindTexture();
        } else if (isMultipleRenderTargets) {
            const textures = renderTarget.texture;
            for(let i132 = 0, il = textures.length; i132 < il; i132++){
                const attachment = textures[i132];
                const attachmentProperties = properties.get(attachment);
                state.bindTexture(3553, attachmentProperties.__webglTexture);
                setTextureParameters(3553, attachment, supportsMips);
                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i132, 3553);
                if (textureNeedsGenerateMipmaps(attachment, supportsMips)) generateMipmap(3553, attachment, renderTarget.width, renderTarget.height);
            }
            state.unbindTexture();
        } else {
            let glTextureType = 3553;
            if (isRenderTarget3D) {
                // Render targets containing layers, i.e: Texture 3D and 2d arrays
                if (isWebGL2) {
                    const isTexture3D = texture.isDataTexture3D;
                    glTextureType = isTexture3D ? 32879 : 35866;
                } else console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');
            }
            state.bindTexture(glTextureType, textureProperties.__webglTexture);
            setTextureParameters(glTextureType, texture, supportsMips);
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) generateMipmap(glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth);
            state.unbindTexture();
        }
        // Setup depth and stencil buffers
        if (renderTarget.depthBuffer) setupDepthRenderbuffer(renderTarget);
    }
    function updateRenderTargetMipmap(renderTarget) {
        const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
        const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [
            renderTarget.texture
        ];
        for(let i133 = 0, il = textures.length; i133 < il; i133++){
            const texture = textures[i133];
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
                const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
                const webglTexture = properties.get(texture).__webglTexture;
                state.bindTexture(target, webglTexture);
                generateMipmap(target, texture, renderTarget.width, renderTarget.height);
                state.unbindTexture();
            }
        }
    }
    function updateMultisampleRenderTarget(renderTarget) {
        if (renderTarget.isWebGLMultisampleRenderTarget) {
            if (isWebGL2) {
                const width = renderTarget.width;
                const height = renderTarget.height;
                let mask = 16384;
                if (renderTarget.depthBuffer) mask |= 256;
                if (renderTarget.stencilBuffer) mask |= 1024;
                const renderTargetProperties = properties.get(renderTarget);
                state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
                state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
                _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
                state.bindFramebuffer(36008, null);
                state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
            } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
        }
    }
    function getRenderTargetSamples(renderTarget) {
        return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
    }
    function updateVideoTexture(texture) {
        const frame = info.render.frame;
        // Check the last frame we updated the VideoTexture
        if (_videoTextures.get(texture) !== frame) {
            _videoTextures.set(texture, frame);
            texture.update();
        }
    }
    // backwards compatibility
    let warnedTexture2D = false;
    let warnedTextureCube = false;
    function safeSetTexture2D(texture, slot) {
        if (texture && texture.isWebGLRenderTarget) {
            if (warnedTexture2D === false) {
                console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.');
                warnedTexture2D = true;
            }
            texture = texture.texture;
        }
        setTexture2D(texture, slot);
    }
    function safeSetTextureCube(texture, slot) {
        if (texture && texture.isWebGLCubeRenderTarget) {
            if (warnedTextureCube === false) {
                console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');
                warnedTextureCube = true;
            }
            texture = texture.texture;
        }
        setTextureCube(texture, slot);
    }
    //
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.safeSetTexture2D = safeSetTexture2D;
    this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p) {
        let extension;
        if (p === UnsignedByteType) return 5121;
        if (p === UnsignedShort4444Type) return 32819;
        if (p === UnsignedShort5551Type) return 32820;
        if (p === UnsignedShort565Type) return 33635;
        if (p === ByteType) return 5120;
        if (p === ShortType) return 5122;
        if (p === UnsignedShortType) return 5123;
        if (p === IntType) return 5124;
        if (p === UnsignedIntType) return 5125;
        if (p === FloatType) return 5126;
        if (p === HalfFloatType) {
            if (isWebGL2) return 5131;
            extension = extensions.get('OES_texture_half_float');
            if (extension !== null) return extension.HALF_FLOAT_OES;
            else return null;
        }
        if (p === AlphaFormat) return 6406;
        if (p === RGBFormat) return 6407;
        if (p === RGBAFormat) return 6408;
        if (p === LuminanceFormat) return 6409;
        if (p === LuminanceAlphaFormat) return 6410;
        if (p === DepthFormat) return 6402;
        if (p === DepthStencilFormat) return 34041;
        if (p === RedFormat) return 6403;
        // WebGL2 formats.
        if (p === RedIntegerFormat) return 36244;
        if (p === RGFormat) return 33319;
        if (p === RGIntegerFormat) return 33320;
        if (p === RGBIntegerFormat) return 36248;
        if (p === RGBAIntegerFormat) return 36249;
        if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
            extension = extensions.get('WEBGL_compressed_texture_s3tc');
            if (extension !== null) {
                if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
        }
        if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
            extension = extensions.get('WEBGL_compressed_texture_pvrtc');
            if (extension !== null) {
                if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
        }
        if (p === RGB_ETC1_Format) {
            extension = extensions.get('WEBGL_compressed_texture_etc1');
            if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
            else return null;
        }
        if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
            extension = extensions.get('WEBGL_compressed_texture_etc');
            if (extension !== null) {
                if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
                if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
            }
        }
        if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
            extension = extensions.get('WEBGL_compressed_texture_astc');
            if (extension !== null) // TODO Complete?
            return p;
            else return null;
        }
        if (p === RGBA_BPTC_Format) {
            extension = extensions.get('EXT_texture_compression_bptc');
            if (extension !== null) // TODO Complete?
            return p;
            else return null;
        }
        if (p === UnsignedInt248Type) {
            if (isWebGL2) return 34042;
            extension = extensions.get('WEBGL_depth_texture');
            if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
            else return null;
        }
    }
    return {
        convert: convert
    };
}
class ArrayCamera extends PerspectiveCamera {
    constructor(array = []){
        super();
        this.cameras = array;
    }
}
ArrayCamera.prototype.isArrayCamera = true;
class Group extends Object3D {
    constructor(){
        super();
        this.type = 'Group';
    }
}
Group.prototype.isGroup = true;
const _moveEvent = {
    type: 'move'
};
class WebXRController {
    constructor(){
        this._targetRay = null;
        this._grip = null;
        this._hand = null;
    }
    getHandSpace() {
        if (this._hand === null) {
            this._hand = new Group();
            this._hand.matrixAutoUpdate = false;
            this._hand.visible = false;
            this._hand.joints = {};
            this._hand.inputState = {
                pinching: false
            };
        }
        return this._hand;
    }
    getTargetRaySpace() {
        if (this._targetRay === null) {
            this._targetRay = new Group();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
            this._targetRay.hasLinearVelocity = false;
            this._targetRay.linearVelocity = new Vector3();
            this._targetRay.hasAngularVelocity = false;
            this._targetRay.angularVelocity = new Vector3();
        }
        return this._targetRay;
    }
    getGripSpace() {
        if (this._grip === null) {
            this._grip = new Group();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
            this._grip.hasLinearVelocity = false;
            this._grip.linearVelocity = new Vector3();
            this._grip.hasAngularVelocity = false;
            this._grip.angularVelocity = new Vector3();
        }
        return this._grip;
    }
    dispatchEvent(event) {
        if (this._targetRay !== null) this._targetRay.dispatchEvent(event);
        if (this._grip !== null) this._grip.dispatchEvent(event);
        if (this._hand !== null) this._hand.dispatchEvent(event);
        return this;
    }
    disconnect(inputSource) {
        this.dispatchEvent({
            type: 'disconnected',
            data: inputSource
        });
        if (this._targetRay !== null) this._targetRay.visible = false;
        if (this._grip !== null) this._grip.visible = false;
        if (this._hand !== null) this._hand.visible = false;
        return this;
    }
    update(inputSource, frame, referenceSpace) {
        let inputPose = null;
        let gripPose = null;
        let handPose = null;
        const targetRay = this._targetRay;
        const grip = this._grip;
        const hand = this._hand;
        if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
            if (targetRay !== null) {
                inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                if (inputPose !== null) {
                    targetRay.matrix.fromArray(inputPose.transform.matrix);
                    targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                    if (inputPose.linearVelocity) {
                        targetRay.hasLinearVelocity = true;
                        targetRay.linearVelocity.copy(inputPose.linearVelocity);
                    } else targetRay.hasLinearVelocity = false;
                    if (inputPose.angularVelocity) {
                        targetRay.hasAngularVelocity = true;
                        targetRay.angularVelocity.copy(inputPose.angularVelocity);
                    } else targetRay.hasAngularVelocity = false;
                    this.dispatchEvent(_moveEvent);
                }
            }
            if (hand && inputSource.hand) {
                handPose = true;
                for (const inputjoint of inputSource.hand.values()){
                    // Update the joints groups with the XRJoint poses
                    const jointPose = frame.getJointPose(inputjoint, referenceSpace);
                    if (hand.joints[inputjoint.jointName] === undefined) {
                        // The transform of this joint will be updated with the joint pose on each frame
                        const joint = new Group();
                        joint.matrixAutoUpdate = false;
                        joint.visible = false;
                        hand.joints[inputjoint.jointName] = joint;
                        // ??
                        hand.add(joint);
                    }
                    const joint = hand.joints[inputjoint.jointName];
                    if (jointPose !== null) {
                        joint.matrix.fromArray(jointPose.transform.matrix);
                        joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                        joint.jointRadius = jointPose.radius;
                    }
                    joint.visible = jointPose !== null;
                }
                // Custom events
                // Check pinchz
                const indexTip = hand.joints['index-finger-tip'];
                const thumbTip = hand.joints['thumb-tip'];
                const distance = indexTip.position.distanceTo(thumbTip.position);
                const distanceToPinch = 0.02;
                const threshold = 0.005;
                if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                    hand.inputState.pinching = false;
                    this.dispatchEvent({
                        type: 'pinchend',
                        handedness: inputSource.handedness,
                        target: this
                    });
                } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                    hand.inputState.pinching = true;
                    this.dispatchEvent({
                        type: 'pinchstart',
                        handedness: inputSource.handedness,
                        target: this
                    });
                }
            } else if (grip !== null && inputSource.gripSpace) {
                gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                if (gripPose !== null) {
                    grip.matrix.fromArray(gripPose.transform.matrix);
                    grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                    if (gripPose.linearVelocity) {
                        grip.hasLinearVelocity = true;
                        grip.linearVelocity.copy(gripPose.linearVelocity);
                    } else grip.hasLinearVelocity = false;
                    if (gripPose.angularVelocity) {
                        grip.hasAngularVelocity = true;
                        grip.angularVelocity.copy(gripPose.angularVelocity);
                    } else grip.hasAngularVelocity = false;
                }
            }
        }
        if (targetRay !== null) targetRay.visible = inputPose !== null;
        if (grip !== null) grip.visible = gripPose !== null;
        if (hand !== null) hand.visible = handPose !== null;
        return this;
    }
}
class WebXRManager extends EventDispatcher {
    constructor(renderer, gl){
        super();
        const scope = this;
        const state = renderer.state;
        let session = null;
        let framebufferScaleFactor = 1;
        let referenceSpace = null;
        let referenceSpaceType = 'local-floor';
        let pose = null;
        let glBinding = null;
        let glFramebuffer = null;
        let glProjLayer = null;
        let glBaseLayer = null;
        let isMultisample = false;
        let glMultisampledFramebuffer = null;
        let glColorRenderbuffer = null;
        let glDepthRenderbuffer = null;
        let xrFrame = null;
        let depthStyle = null;
        let clearStyle = null;
        const controllers = [];
        const inputSourcesMap = new Map();
        //
        const cameraL1 = new PerspectiveCamera();
        cameraL1.layers.enable(1);
        cameraL1.viewport = new Vector4();
        const cameraR1 = new PerspectiveCamera();
        cameraR1.layers.enable(2);
        cameraR1.viewport = new Vector4();
        const cameras1 = [
            cameraL1,
            cameraR1
        ];
        const cameraVR = new ArrayCamera();
        cameraVR.layers.enable(1);
        cameraVR.layers.enable(2);
        let _currentDepthNear = null;
        let _currentDepthFar = null;
        //
        this.cameraAutoUpdate = true;
        this.enabled = false;
        this.isPresenting = false;
        this.getController = function(index) {
            let controller = controllers[index];
            if (controller === undefined) {
                controller = new WebXRController();
                controllers[index] = controller;
            }
            return controller.getTargetRaySpace();
        };
        this.getControllerGrip = function(index) {
            let controller = controllers[index];
            if (controller === undefined) {
                controller = new WebXRController();
                controllers[index] = controller;
            }
            return controller.getGripSpace();
        };
        this.getHand = function(index) {
            let controller = controllers[index];
            if (controller === undefined) {
                controller = new WebXRController();
                controllers[index] = controller;
            }
            return controller.getHandSpace();
        };
        //
        function onSessionEvent(event) {
            const controller = inputSourcesMap.get(event.inputSource);
            if (controller) controller.dispatchEvent({
                type: event.type,
                data: event.inputSource
            });
        }
        function onSessionEnd() {
            inputSourcesMap.forEach(function(controller, inputSource) {
                controller.disconnect(inputSource);
            });
            inputSourcesMap.clear();
            _currentDepthNear = null;
            _currentDepthFar = null;
            // restore framebuffer/rendering state
            state.bindXRFramebuffer(null);
            renderer.setRenderTarget(renderer.getRenderTarget());
            if (glFramebuffer) gl.deleteFramebuffer(glFramebuffer);
            if (glMultisampledFramebuffer) gl.deleteFramebuffer(glMultisampledFramebuffer);
            if (glColorRenderbuffer) gl.deleteRenderbuffer(glColorRenderbuffer);
            if (glDepthRenderbuffer) gl.deleteRenderbuffer(glDepthRenderbuffer);
            glFramebuffer = null;
            glMultisampledFramebuffer = null;
            glColorRenderbuffer = null;
            glDepthRenderbuffer = null;
            glBaseLayer = null;
            glProjLayer = null;
            glBinding = null;
            session = null;
            //
            animation.stop();
            scope.isPresenting = false;
            scope.dispatchEvent({
                type: 'sessionend'
            });
        }
        this.setFramebufferScaleFactor = function(value) {
            framebufferScaleFactor = value;
            if (scope.isPresenting === true) console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
        };
        this.setReferenceSpaceType = function(value) {
            referenceSpaceType = value;
            if (scope.isPresenting === true) console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
        };
        this.getReferenceSpace = function() {
            return referenceSpace;
        };
        this.getBaseLayer = function() {
            return glProjLayer !== null ? glProjLayer : glBaseLayer;
        };
        this.getBinding = function() {
            return glBinding;
        };
        this.getFrame = function() {
            return xrFrame;
        };
        this.getSession = function() {
            return session;
        };
        this.setSession = async function(value) {
            session = value;
            if (session !== null) {
                session.addEventListener('select', onSessionEvent);
                session.addEventListener('selectstart', onSessionEvent);
                session.addEventListener('selectend', onSessionEvent);
                session.addEventListener('squeeze', onSessionEvent);
                session.addEventListener('squeezestart', onSessionEvent);
                session.addEventListener('squeezeend', onSessionEvent);
                session.addEventListener('end', onSessionEnd);
                session.addEventListener('inputsourceschange', onInputSourcesChange);
                const attributes = gl.getContextAttributes();
                if (attributes.xrCompatible !== true) await gl.makeXRCompatible();
                if (session.renderState.layers === undefined) {
                    const layerInit = {
                        antialias: attributes.antialias,
                        alpha: attributes.alpha,
                        depth: attributes.depth,
                        stencil: attributes.stencil,
                        framebufferScaleFactor: framebufferScaleFactor
                    };
                    glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                    session.updateRenderState({
                        baseLayer: glBaseLayer
                    });
                } else if (gl instanceof WebGLRenderingContext) {
                    // Use old style webgl layer because we can't use MSAA
                    // WebGL2 support.
                    const layerInit = {
                        antialias: true,
                        alpha: attributes.alpha,
                        depth: attributes.depth,
                        stencil: attributes.stencil,
                        framebufferScaleFactor: framebufferScaleFactor
                    };
                    glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                    session.updateRenderState({
                        layers: [
                            glBaseLayer
                        ]
                    });
                } else {
                    isMultisample = attributes.antialias;
                    let depthFormat = null;
                    if (attributes.depth) {
                        clearStyle = 256;
                        if (attributes.stencil) clearStyle |= 1024;
                        depthStyle = attributes.stencil ? 33306 : 36096;
                        depthFormat = attributes.stencil ? 35056 : 33190;
                    }
                    const projectionlayerInit = {
                        colorFormat: attributes.alpha ? 32856 : 32849,
                        depthFormat: depthFormat,
                        scaleFactor: framebufferScaleFactor
                    };
                    glBinding = new XRWebGLBinding(session, gl);
                    glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                    glFramebuffer = gl.createFramebuffer();
                    session.updateRenderState({
                        layers: [
                            glProjLayer
                        ]
                    });
                    if (isMultisample) {
                        glMultisampledFramebuffer = gl.createFramebuffer();
                        glColorRenderbuffer = gl.createRenderbuffer();
                        gl.bindRenderbuffer(36161, glColorRenderbuffer);
                        gl.renderbufferStorageMultisample(36161, 4, 32856, glProjLayer.textureWidth, glProjLayer.textureHeight);
                        state.bindFramebuffer(36160, glMultisampledFramebuffer);
                        gl.framebufferRenderbuffer(36160, 36064, 36161, glColorRenderbuffer);
                        gl.bindRenderbuffer(36161, null);
                        if (depthFormat !== null) {
                            glDepthRenderbuffer = gl.createRenderbuffer();
                            gl.bindRenderbuffer(36161, glDepthRenderbuffer);
                            gl.renderbufferStorageMultisample(36161, 4, depthFormat, glProjLayer.textureWidth, glProjLayer.textureHeight);
                            gl.framebufferRenderbuffer(36160, depthStyle, 36161, glDepthRenderbuffer);
                            gl.bindRenderbuffer(36161, null);
                        }
                        state.bindFramebuffer(36160, null);
                    }
                }
                referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
                animation.setContext(session);
                animation.start();
                scope.isPresenting = true;
                scope.dispatchEvent({
                    type: 'sessionstart'
                });
            }
        };
        function onInputSourcesChange(event) {
            const inputSources = session.inputSources;
            // Assign inputSources to available controllers
            for(let i136 = 0; i136 < controllers.length; i136++)inputSourcesMap.set(inputSources[i136], controllers[i136]);
            // Notify disconnected
            for(let i134 = 0; i134 < event.removed.length; i134++){
                const inputSource = event.removed[i134];
                const controller = inputSourcesMap.get(inputSource);
                if (controller) {
                    controller.dispatchEvent({
                        type: 'disconnected',
                        data: inputSource
                    });
                    inputSourcesMap.delete(inputSource);
                }
            }
            // Notify connected
            for(let i135 = 0; i135 < event.added.length; i135++){
                const inputSource = event.added[i135];
                const controller = inputSourcesMap.get(inputSource);
                if (controller) controller.dispatchEvent({
                    type: 'connected',
                    data: inputSource
                });
            }
        }
        //
        const cameraLPos = new Vector3();
        const cameraRPos = new Vector3();
        /**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */ function setProjectionFromUnion(camera, cameraL, cameraR) {
            cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
            cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
            const ipd = cameraLPos.distanceTo(cameraRPos);
            const projL = cameraL.projectionMatrix.elements;
            const projR = cameraR.projectionMatrix.elements;
            // VR systems will have identical far and near planes, and
            // most likely identical top and bottom frustum extents.
            // Use the left camera for these values.
            const near = projL[14] / (projL[10] - 1);
            const far = projL[14] / (projL[10] + 1);
            const topFov = (projL[9] + 1) / projL[5];
            const bottomFov = (projL[9] - 1) / projL[5];
            const leftFov = (projL[8] - 1) / projL[0];
            const rightFov = (projR[8] + 1) / projR[0];
            const left = near * leftFov;
            const right = near * rightFov;
            // Calculate the new camera's position offset from the
            // left camera. xOffset should be roughly half `ipd`.
            const zOffset = ipd / (-leftFov + rightFov);
            const xOffset = zOffset * -leftFov;
            // TODO: Better way to apply this offset?
            cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
            camera.translateX(xOffset);
            camera.translateZ(zOffset);
            camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            // Find the union of the frustum values of the cameras and scale
            // the values so that the near plane's position does not change in world space,
            // although must now be relative to the new union camera.
            const near2 = near + zOffset;
            const far2 = far + zOffset;
            const left2 = left - xOffset;
            const right2 = right + (ipd - xOffset);
            const top2 = topFov * far / far2 * near2;
            const bottom2 = bottomFov * far / far2 * near2;
            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
        }
        function updateCamera(camera, parent) {
            if (parent === null) camera.matrixWorld.copy(camera.matrix);
            else camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
        }
        this.updateCamera = function(camera) {
            if (session === null) return;
            cameraVR.near = cameraR1.near = cameraL1.near = camera.near;
            cameraVR.far = cameraR1.far = cameraL1.far = camera.far;
            if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
                // Note that the new renderState won't apply until the next frame. See #18320
                session.updateRenderState({
                    depthNear: cameraVR.near,
                    depthFar: cameraVR.far
                });
                _currentDepthNear = cameraVR.near;
                _currentDepthFar = cameraVR.far;
            }
            const parent = camera.parent;
            const cameras = cameraVR.cameras;
            updateCamera(cameraVR, parent);
            for(let i138 = 0; i138 < cameras.length; i138++)updateCamera(cameras[i138], parent);
            cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
            // update user camera and its children
            camera.position.copy(cameraVR.position);
            camera.quaternion.copy(cameraVR.quaternion);
            camera.scale.copy(cameraVR.scale);
            camera.matrix.copy(cameraVR.matrix);
            camera.matrixWorld.copy(cameraVR.matrixWorld);
            const children = camera.children;
            for(let i137 = 0, l = children.length; i137 < l; i137++)children[i137].updateMatrixWorld(true);
            // update projection matrix for proper view frustum culling
            if (cameras.length === 2) setProjectionFromUnion(cameraVR, cameraL1, cameraR1);
            else // assume single camera setup (AR)
            cameraVR.projectionMatrix.copy(cameraL1.projectionMatrix);
        };
        this.getCamera = function() {
            return cameraVR;
        };
        this.getFoveation = function() {
            if (glProjLayer !== null) return glProjLayer.fixedFoveation;
            if (glBaseLayer !== null) return glBaseLayer.fixedFoveation;
            return undefined;
        };
        this.setFoveation = function(foveation) {
            // 0 = no foveation = full resolution
            // 1 = maximum foveation = the edges render at lower resolution
            if (glProjLayer !== null) glProjLayer.fixedFoveation = foveation;
            if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) glBaseLayer.fixedFoveation = foveation;
        };
        // Animation Loop
        let onAnimationFrameCallback = null;
        function onAnimationFrame(time, frame) {
            pose = frame.getViewerPose(referenceSpace);
            xrFrame = frame;
            if (pose !== null) {
                const views = pose.views;
                if (glBaseLayer !== null) state.bindXRFramebuffer(glBaseLayer.framebuffer);
                let cameraVRNeedsUpdate = false;
                // check if it's necessary to rebuild cameraVR's camera list
                if (views.length !== cameraVR.cameras.length) {
                    cameraVR.cameras.length = 0;
                    cameraVRNeedsUpdate = true;
                }
                for(let i139 = 0; i139 < views.length; i139++){
                    const view = views[i139];
                    let viewport = null;
                    if (glBaseLayer !== null) viewport = glBaseLayer.getViewport(view);
                    else {
                        const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                        state.bindXRFramebuffer(glFramebuffer);
                        if (glSubImage.depthStencilTexture !== undefined) gl.framebufferTexture2D(36160, depthStyle, 3553, glSubImage.depthStencilTexture, 0);
                        gl.framebufferTexture2D(36160, 36064, 3553, glSubImage.colorTexture, 0);
                        viewport = glSubImage.viewport;
                    }
                    const camera = cameras1[i139];
                    camera.matrix.fromArray(view.transform.matrix);
                    camera.projectionMatrix.fromArray(view.projectionMatrix);
                    camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                    if (i139 === 0) cameraVR.matrix.copy(camera.matrix);
                    if (cameraVRNeedsUpdate === true) cameraVR.cameras.push(camera);
                }
                if (isMultisample) {
                    state.bindXRFramebuffer(glMultisampledFramebuffer);
                    if (clearStyle !== null) gl.clear(clearStyle);
                }
            }
            //
            const inputSources = session.inputSources;
            for(let i140 = 0; i140 < controllers.length; i140++){
                const controller = controllers[i140];
                const inputSource = inputSources[i140];
                controller.update(inputSource, frame, referenceSpace);
            }
            if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
            if (isMultisample) {
                const width = glProjLayer.textureWidth;
                const height = glProjLayer.textureHeight;
                state.bindFramebuffer(36008, glMultisampledFramebuffer);
                state.bindFramebuffer(36009, glFramebuffer);
                // Invalidate the depth here to avoid flush of the depth data to main memory.
                gl.invalidateFramebuffer(36008, [
                    depthStyle
                ]);
                gl.invalidateFramebuffer(36009, [
                    depthStyle
                ]);
                gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, 16384, 9728);
                // Invalidate the MSAA buffer because it's not needed anymore.
                gl.invalidateFramebuffer(36008, [
                    36064
                ]);
                state.bindFramebuffer(36008, null);
                state.bindFramebuffer(36009, null);
                state.bindFramebuffer(36160, glMultisampledFramebuffer);
            }
            xrFrame = null;
        }
        const animation = new WebGLAnimation();
        animation.setAnimationLoop(onAnimationFrame);
        this.setAnimationLoop = function(callback) {
            onAnimationFrameCallback = callback;
        };
        this.dispose = function() {};
    }
}
function WebGLMaterials(properties) {
    function refreshFogUniforms(uniforms, fog) {
        uniforms.fogColor.value.copy(fog.color);
        if (fog.isFog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
        } else if (fog.isFogExp2) uniforms.fogDensity.value = fog.density;
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
        if (material.isMeshBasicMaterial) refreshUniformsCommon(uniforms, material);
        else if (material.isMeshLambertMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsLambert(uniforms, material);
        } else if (material.isMeshToonMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsToon(uniforms, material);
        } else if (material.isMeshPhongMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsPhong(uniforms, material);
        } else if (material.isMeshStandardMaterial) {
            refreshUniformsCommon(uniforms, material);
            if (material.isMeshPhysicalMaterial) refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
            else refreshUniformsStandard(uniforms, material);
        } else if (material.isMeshMatcapMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsMatcap(uniforms, material);
        } else if (material.isMeshDepthMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDepth(uniforms, material);
        } else if (material.isMeshDistanceMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDistance(uniforms, material);
        } else if (material.isMeshNormalMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsNormal(uniforms, material);
        } else if (material.isLineBasicMaterial) {
            refreshUniformsLine(uniforms, material);
            if (material.isLineDashedMaterial) refreshUniformsDash(uniforms, material);
        } else if (material.isPointsMaterial) refreshUniformsPoints(uniforms, material, pixelRatio, height);
        else if (material.isSpriteMaterial) refreshUniformsSprites(uniforms, material);
        else if (material.isShadowMaterial) {
            uniforms.color.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
        } else if (material.isShaderMaterial) material.uniformsNeedUpdate = false; // #15581
    }
    function refreshUniformsCommon(uniforms, material) {
        uniforms.opacity.value = material.opacity;
        if (material.color) uniforms.diffuse.value.copy(material.color);
        if (material.emissive) uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        if (material.specularMap) uniforms.specularMap.value = material.specularMap;
        if (material.alphaTest > 0) uniforms.alphaTest.value = material.alphaTest;
        const envMap = properties.get(material).envMap;
        if (envMap) {
            uniforms.envMap.value = envMap;
            uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
            uniforms.reflectivity.value = material.reflectivity;
            uniforms.ior.value = material.ior;
            uniforms.refractionRatio.value = material.refractionRatio;
            const maxMipLevel = properties.get(envMap).__maxMipLevel;
            if (maxMipLevel !== undefined) uniforms.maxMipLevel.value = maxMipLevel;
        }
        if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.aoMap) {
            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;
        }
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. displacementMap map
        // 4. normal map
        // 5. bump map
        // 6. roughnessMap map
        // 7. metalnessMap map
        // 8. alphaMap map
        // 9. emissiveMap map
        // 10. clearcoat map
        // 11. clearcoat normal map
        // 12. clearcoat roughnessMap map
        // 13. specular intensity map
        // 14. specular tint map
        // 15. transmission map
        // 16. thickness map
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.specularMap) uvScaleMap = material.specularMap;
        else if (material.displacementMap) uvScaleMap = material.displacementMap;
        else if (material.normalMap) uvScaleMap = material.normalMap;
        else if (material.bumpMap) uvScaleMap = material.bumpMap;
        else if (material.roughnessMap) uvScaleMap = material.roughnessMap;
        else if (material.metalnessMap) uvScaleMap = material.metalnessMap;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        else if (material.emissiveMap) uvScaleMap = material.emissiveMap;
        else if (material.clearcoatMap) uvScaleMap = material.clearcoatMap;
        else if (material.clearcoatNormalMap) uvScaleMap = material.clearcoatNormalMap;
        else if (material.clearcoatRoughnessMap) uvScaleMap = material.clearcoatRoughnessMap;
        else if (material.specularIntensityMap) uvScaleMap = material.specularIntensityMap;
        else if (material.specularTintMap) uvScaleMap = material.specularTintMap;
        else if (material.transmissionMap) uvScaleMap = material.transmissionMap;
        else if (material.thicknessMap) uvScaleMap = material.thicknessMap;
        if (uvScaleMap !== undefined) {
            // backwards compatibility
            if (uvScaleMap.isWebGLRenderTarget) uvScaleMap = uvScaleMap.texture;
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
        // uv repeat and offset setting priorities for uv2
        // 1. ao map
        // 2. light map
        let uv2ScaleMap;
        if (material.aoMap) uv2ScaleMap = material.aoMap;
        else if (material.lightMap) uv2ScaleMap = material.lightMap;
        if (uv2ScaleMap !== undefined) {
            // backwards compatibility
            if (uv2ScaleMap.isWebGLRenderTarget) uv2ScaleMap = uv2ScaleMap.texture;
            if (uv2ScaleMap.matrixAutoUpdate === true) uv2ScaleMap.updateMatrix();
            uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
        }
    }
    function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size * pixelRatio;
        uniforms.scale.value = height * 0.5;
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        if (material.alphaTest > 0) uniforms.alphaTest.value = material.alphaTest;
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. alpha map
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsSprites(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.rotation.value = material.rotation;
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        if (material.alphaTest > 0) uniforms.alphaTest.value = material.alphaTest;
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. alpha map
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsLambert(uniforms, material) {
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
    }
    function refreshUniformsPhong(uniforms, material) {
        uniforms.specular.value.copy(material.specular);
        uniforms.shininess.value = Math.max(material.shininess, 0.0001); // to prevent pow( 0.0, 0.0 )
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsToon(uniforms, material) {
        if (material.gradientMap) uniforms.gradientMap.value = material.gradientMap;
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsStandard(uniforms, material) {
        uniforms.roughness.value = material.roughness;
        uniforms.metalness.value = material.metalness;
        if (material.roughnessMap) uniforms.roughnessMap.value = material.roughnessMap;
        if (material.metalnessMap) uniforms.metalnessMap.value = material.metalnessMap;
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        const envMap = properties.get(material).envMap;
        if (envMap) //uniforms.envMap.value = material.envMap; // part of uniforms common
        uniforms.envMapIntensity.value = material.envMapIntensity;
    }
    function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
        refreshUniformsStandard(uniforms, material);
        uniforms.ior.value = material.ior; // also part of uniforms common
        if (material.sheenTint) uniforms.sheenTint.value.copy(material.sheenTint);
        if (material.clearcoat > 0) {
            uniforms.clearcoat.value = material.clearcoat;
            uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
            if (material.clearcoatMap) uniforms.clearcoatMap.value = material.clearcoatMap;
            if (material.clearcoatRoughnessMap) uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
            if (material.clearcoatNormalMap) {
                uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
                uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
                if (material.side === BackSide) uniforms.clearcoatNormalScale.value.negate();
            }
        }
        if (material.transmission > 0) {
            uniforms.transmission.value = material.transmission;
            uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
            uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
            if (material.transmissionMap) uniforms.transmissionMap.value = material.transmissionMap;
            uniforms.thickness.value = material.thickness;
            if (material.thicknessMap) uniforms.thicknessMap.value = material.thicknessMap;
            uniforms.attenuationDistance.value = material.attenuationDistance;
            uniforms.attenuationTint.value.copy(material.attenuationTint);
        }
        uniforms.specularIntensity.value = material.specularIntensity;
        uniforms.specularTint.value.copy(material.specularTint);
        if (material.specularIntensityMap) uniforms.specularIntensityMap.value = material.specularIntensityMap;
        if (material.specularTintMap) uniforms.specularTintMap.value = material.specularTintMap;
    }
    function refreshUniformsMatcap(uniforms, material) {
        if (material.matcap) uniforms.matcap.value = material.matcap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsDepth(uniforms, material) {
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsDistance(uniforms, material) {
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        uniforms.referencePosition.value.copy(material.referencePosition);
        uniforms.nearDistance.value = material.nearDistance;
        uniforms.farDistance.value = material.farDistance;
    }
    function refreshUniformsNormal(uniforms, material) {
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    return {
        refreshFogUniforms: refreshFogUniforms,
        refreshMaterialUniforms: refreshMaterialUniforms
    };
}
function createCanvasElement() {
    const canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
    canvas.style.display = 'block';
    return canvas;
}
function WebGLRenderer(parameters1 = {}) {
    const _canvas2 = parameters1.canvas !== undefined ? parameters1.canvas : createCanvasElement(), _context1 = parameters1.context !== undefined ? parameters1.context : null, _alpha = parameters1.alpha !== undefined ? parameters1.alpha : false, _depth = parameters1.depth !== undefined ? parameters1.depth : true, _stencil = parameters1.stencil !== undefined ? parameters1.stencil : true, _antialias = parameters1.antialias !== undefined ? parameters1.antialias : false, _premultipliedAlpha = parameters1.premultipliedAlpha !== undefined ? parameters1.premultipliedAlpha : true, _preserveDrawingBuffer = parameters1.preserveDrawingBuffer !== undefined ? parameters1.preserveDrawingBuffer : false, _powerPreference = parameters1.powerPreference !== undefined ? parameters1.powerPreference : 'default', _failIfMajorPerformanceCaveat = parameters1.failIfMajorPerformanceCaveat !== undefined ? parameters1.failIfMajorPerformanceCaveat : false;
    let currentRenderList1 = null;
    let currentRenderState = null;
    // render() can be called from within a callback triggered by another render.
    // We track this so that the nested render call gets its list and state isolated from the parent render call.
    const renderListStack = [];
    const renderStateStack = [];
    // public properties
    this.domElement = _canvas2;
    // Debug configuration container
    this.debug = {
        /**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */ checkShaderErrors: true
    };
    // clearing
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    // scene graph
    this.sortObjects = true;
    // user-defined clipping
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    // physically based shading
    this.gammaFactor = 2; // for backwards compatibility
    this.outputEncoding = LinearEncoding;
    // physical lights
    this.physicallyCorrectLights = false;
    // tone mapping
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    // internal properties
    const _this = this;
    let _isContextLost = false;
    // internal state cache
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    //
    let _width = _canvas2.width;
    let _height = _canvas2.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    //
    const _currentDrawBuffers = [];
    // frustum
    const _frustum = new Frustum();
    // clipping
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    // transmission
    let _transmissionRenderTarget = null;
    // camera matrices cache
    const _projScreenMatrix1 = new Matrix4();
    const _vector3 = new Vector3();
    const _emptyScene = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: true
    };
    function getTargetPixelRatio() {
        return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    // initialize
    let _gl = _context1;
    function getContext(contextNames, contextAttributes) {
        for(let i141 = 0; i141 < contextNames.length; i141++){
            const contextName = contextNames[i141];
            const context = _canvas2.getContext(contextName, contextAttributes);
            if (context !== null) return context;
        }
        return null;
    }
    try {
        const contextAttributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer,
            powerPreference: _powerPreference,
            failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
        };
        // event listeners must be registered before WebGL context is created, see #12753
        _canvas2.addEventListener('webglcontextlost', onContextLost, false);
        _canvas2.addEventListener('webglcontextrestored', onContextRestore, false);
        if (_gl === null) {
            const contextNames = [
                'webgl2',
                'webgl',
                'experimental-webgl'
            ];
            if (_this.isWebGL1Renderer === true) contextNames.shift();
            _gl = getContext(contextNames, contextAttributes);
            if (_gl === null) {
                if (getContext(contextNames)) throw new Error('Error creating WebGL context with your selected attributes.');
                else throw new Error('Error creating WebGL context.');
            }
        }
        // Some experimental-webgl implementations do not have getShaderPrecisionFormat
        if (_gl.getShaderPrecisionFormat === undefined) _gl.getShaderPrecisionFormat = function() {
            return {
                'rangeMin': 1,
                'rangeMax': 1,
                'precision': 1
            };
        };
    } catch (error) {
        console.error('THREE.WebGLRenderer: ' + error.message);
        throw error;
    }
    let extensions, capabilities, state, info;
    let properties, textures1, cubemaps, cubeuvmaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates;
    function initGLContext() {
        extensions = new WebGLExtensions(_gl);
        capabilities = new WebGLCapabilities(_gl, extensions, parameters1);
        extensions.init(capabilities);
        utils = new WebGLUtils(_gl, extensions, capabilities);
        state = new WebGLState(_gl, extensions, capabilities);
        _currentDrawBuffers[0] = 1029;
        info = new WebGLInfo(_gl);
        properties = new WebGLProperties();
        textures1 = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
        cubemaps = new WebGLCubeMaps(_this);
        cubeuvmaps = new WebGLCubeUVMaps(_this);
        attributes = new WebGLAttributes(_gl, capabilities);
        bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
        geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
        objects = new WebGLObjects(_gl, geometries, attributes, info);
        morphtargets = new WebGLMorphtargets(_gl);
        clipping = new WebGLClipping(properties);
        programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
        materials = new WebGLMaterials(properties);
        renderLists = new WebGLRenderLists(properties);
        renderStates = new WebGLRenderStates(extensions, capabilities);
        background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
        shadowMap = new WebGLShadowMap(_this, objects, capabilities);
        bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
        indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
        info.programs = programCache.programs;
        _this.capabilities = capabilities;
        _this.extensions = extensions;
        _this.properties = properties;
        _this.renderLists = renderLists;
        _this.shadowMap = shadowMap;
        _this.state = state;
        _this.info = info;
    }
    initGLContext();
    // xr
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    // API
    this.getContext = function() {
        return _gl;
    };
    this.getContextAttributes = function() {
        return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
        const extension = extensions.get('WEBGL_lose_context');
        if (extension) extension.loseContext();
    };
    this.forceContextRestore = function() {
        const extension = extensions.get('WEBGL_lose_context');
        if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function() {
        return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
        if (value === undefined) return;
        _pixelRatio = value;
        this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
        return target.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle) {
        if (xr.isPresenting) {
            console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
            return;
        }
        _width = width;
        _height = height;
        _canvas2.width = Math.floor(width * _pixelRatio);
        _canvas2.height = Math.floor(height * _pixelRatio);
        if (updateStyle !== false) {
            _canvas2.style.width = width + 'px';
            _canvas2.style.height = height + 'px';
        }
        this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
        return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
        _width = width;
        _height = height;
        _pixelRatio = pixelRatio;
        _canvas2.width = Math.floor(width * pixelRatio);
        _canvas2.height = Math.floor(height * pixelRatio);
        this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target) {
        return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
        return target.copy(_viewport);
    };
    this.setViewport = function(x, y, width, height) {
        if (x.isVector4) _viewport.set(x.x, x.y, x.z, x.w);
        else _viewport.set(x, y, width, height);
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
        return target.copy(_scissor);
    };
    this.setScissor = function(x, y, width, height) {
        if (x.isVector4) _scissor.set(x.x, x.y, x.z, x.w);
        else _scissor.set(x, y, width, height);
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
        return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
        state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
        _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
        _transparentSort = method;
    };
    // Clearing
    this.getClearColor = function(target) {
        return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
        background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
        return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
        background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color, depth, stencil) {
        let bits = 0;
        if (color === undefined || color) bits |= 16384;
        if (depth === undefined || depth) bits |= 256;
        if (stencil === undefined || stencil) bits |= 1024;
        _gl.clear(bits);
    };
    this.clearColor = function() {
        this.clear(true, false, false);
    };
    this.clearDepth = function() {
        this.clear(false, true, false);
    };
    this.clearStencil = function() {
        this.clear(false, false, true);
    };
    //
    this.dispose = function() {
        _canvas2.removeEventListener('webglcontextlost', onContextLost, false);
        _canvas2.removeEventListener('webglcontextrestored', onContextRestore, false);
        renderLists.dispose();
        renderStates.dispose();
        properties.dispose();
        cubemaps.dispose();
        cubeuvmaps.dispose();
        objects.dispose();
        bindingStates.dispose();
        xr.dispose();
        xr.removeEventListener('sessionstart', onXRSessionStart);
        xr.removeEventListener('sessionend', onXRSessionEnd);
        if (_transmissionRenderTarget) {
            _transmissionRenderTarget.dispose();
            _transmissionRenderTarget = null;
        }
        animation.stop();
    };
    // Events
    function onContextLost(event) {
        event.preventDefault();
        console.log('THREE.WebGLRenderer: Context Lost.');
        _isContextLost = true;
    }
    function onContextRestore() {
        console.log('THREE.WebGLRenderer: Context Restored.');
        _isContextLost = false;
        const infoAutoReset = info.autoReset;
        const shadowMapEnabled = shadowMap.enabled;
        const shadowMapAutoUpdate = shadowMap.autoUpdate;
        const shadowMapNeedsUpdate = shadowMap.needsUpdate;
        const shadowMapType = shadowMap.type;
        initGLContext();
        info.autoReset = infoAutoReset;
        shadowMap.enabled = shadowMapEnabled;
        shadowMap.autoUpdate = shadowMapAutoUpdate;
        shadowMap.needsUpdate = shadowMapNeedsUpdate;
        shadowMap.type = shadowMapType;
    }
    function onMaterialDispose(event) {
        const material = event.target;
        material.removeEventListener('dispose', onMaterialDispose);
        deallocateMaterial(material);
    }
    // Buffer deallocation
    function deallocateMaterial(material) {
        releaseMaterialProgramReferences(material);
        properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
        const programs = properties.get(material).programs;
        if (programs !== undefined) programs.forEach(function(program) {
            programCache.releaseProgram(program);
        });
    }
    // Buffer rendering
    function renderObjectImmediate(object1, program) {
        object1.render(function(object) {
            _this.renderBufferImmediate(object, program);
        });
    }
    this.renderBufferImmediate = function(object, program) {
        bindingStates.initAttributes();
        const buffers = properties.get(object);
        if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
        if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
        if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
        if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
        const programAttributes = program.getAttributes();
        if (object.hasPositions) {
            _gl.bindBuffer(34962, buffers.position);
            _gl.bufferData(34962, object.positionArray, 35048);
            bindingStates.enableAttribute(programAttributes.position.location);
            _gl.vertexAttribPointer(programAttributes.position.location, 3, 5126, false, 0, 0);
        }
        if (object.hasNormals) {
            _gl.bindBuffer(34962, buffers.normal);
            _gl.bufferData(34962, object.normalArray, 35048);
            bindingStates.enableAttribute(programAttributes.normal.location);
            _gl.vertexAttribPointer(programAttributes.normal.location, 3, 5126, false, 0, 0);
        }
        if (object.hasUvs) {
            _gl.bindBuffer(34962, buffers.uv);
            _gl.bufferData(34962, object.uvArray, 35048);
            bindingStates.enableAttribute(programAttributes.uv.location);
            _gl.vertexAttribPointer(programAttributes.uv.location, 2, 5126, false, 0, 0);
        }
        if (object.hasColors) {
            _gl.bindBuffer(34962, buffers.color);
            _gl.bufferData(34962, object.colorArray, 35048);
            bindingStates.enableAttribute(programAttributes.color.location);
            _gl.vertexAttribPointer(programAttributes.color.location, 3, 5126, false, 0, 0);
        }
        bindingStates.disableUnusedAttributes();
        _gl.drawArrays(4, 0, object.count);
        object.count = 0;
    };
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
        if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)
        const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
        const program = setProgram(camera, scene, material, object);
        state.setMaterial(material, frontFaceCW);
        //
        let index = geometry.index;
        const position = geometry.attributes.position;
        //
        if (index === null) {
            if (position === undefined || position.count === 0) return;
        } else if (index.count === 0) return;
        //
        let rangeFactor = 1;
        if (material.wireframe === true) {
            index = geometries.getWireframeAttribute(geometry);
            rangeFactor = 2;
        }
        if (geometry.morphAttributes.position !== undefined || geometry.morphAttributes.normal !== undefined) morphtargets.update(object, geometry, material, program);
        bindingStates.setup(object, material, program, geometry, index);
        let attribute;
        let renderer = bufferRenderer;
        if (index !== null) {
            attribute = attributes.get(index);
            renderer = indexedBufferRenderer;
            renderer.setIndex(attribute);
        }
        //
        const dataCount = index !== null ? index.count : position.count;
        const rangeStart = geometry.drawRange.start * rangeFactor;
        const rangeCount = geometry.drawRange.count * rangeFactor;
        const groupStart = group !== null ? group.start * rangeFactor : 0;
        const groupCount = group !== null ? group.count * rangeFactor : Infinity;
        const drawStart = Math.max(rangeStart, groupStart);
        const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
        const drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (drawCount === 0) return;
        //
        if (object.isMesh) {
            if (material.wireframe === true) {
                state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                renderer.setMode(1);
            } else renderer.setMode(4);
        } else if (object.isLine) {
            let lineWidth = material.linewidth;
            if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material
            state.setLineWidth(lineWidth * getTargetPixelRatio());
            if (object.isLineSegments) renderer.setMode(1);
            else if (object.isLineLoop) renderer.setMode(2);
            else renderer.setMode(3);
        } else if (object.isPoints) renderer.setMode(0);
        else if (object.isSprite) renderer.setMode(4);
        if (object.isInstancedMesh) renderer.renderInstances(drawStart, drawCount, object.count);
        else if (geometry.isInstancedBufferGeometry) {
            const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
            renderer.renderInstances(drawStart, drawCount, instanceCount);
        } else renderer.render(drawStart, drawCount);
    };
    // Compile
    this.compile = function(scene, camera) {
        currentRenderState = renderStates.get(scene);
        currentRenderState.init();
        renderStateStack.push(currentRenderState);
        scene.traverseVisible(function(object) {
            if (object.isLight && object.layers.test(camera.layers)) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            }
        });
        currentRenderState.setupLights(_this.physicallyCorrectLights);
        scene.traverse(function(object) {
            const material = object.material;
            if (material) {
                if (Array.isArray(material)) for(let i142 = 0; i142 < material.length; i142++){
                    const material2 = material[i142];
                    getProgram(material2, scene, object);
                }
                else getProgram(material, scene, object);
            }
        });
        renderStateStack.pop();
        currentRenderState = null;
    };
    // Animation Loop
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
        if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
        animation.stop();
    }
    function onXRSessionEnd() {
        animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof window !== 'undefined') animation.setContext(window);
    this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
        xr.setAnimationLoop(callback);
        callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener('sessionstart', onXRSessionStart);
    xr.addEventListener('sessionend', onXRSessionEnd);
    // Rendering
    this.render = function(scene, camera) {
        if (camera !== undefined && camera.isCamera !== true) {
            console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
            return;
        }
        if (_isContextLost === true) return;
        // update scene graph
        if (scene.autoUpdate === true) scene.updateMatrixWorld();
        // update camera matrices and frustum
        if (camera.parent === null) camera.updateMatrixWorld();
        if (xr.enabled === true && xr.isPresenting === true) {
            if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
            camera = xr.getCamera(); // use XR camera for rendering
        }
        //
        if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
        currentRenderState = renderStates.get(scene, renderStateStack.length);
        currentRenderState.init();
        renderStateStack.push(currentRenderState);
        _projScreenMatrix1.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromProjectionMatrix(_projScreenMatrix1);
        _localClippingEnabled = this.localClippingEnabled;
        _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
        currentRenderList1 = renderLists.get(scene, renderListStack.length);
        currentRenderList1.init();
        renderListStack.push(currentRenderList1);
        projectObject(scene, camera, 0, _this.sortObjects);
        currentRenderList1.finish();
        if (_this.sortObjects === true) currentRenderList1.sort(_opaqueSort, _transparentSort);
        //
        if (_clippingEnabled === true) clipping.beginShadows();
        const shadowsArray = currentRenderState.state.shadowsArray;
        shadowMap.render(shadowsArray, scene, camera);
        if (_clippingEnabled === true) clipping.endShadows();
        //
        if (this.info.autoReset === true) this.info.reset();
        //
        background.render(currentRenderList1, scene);
        // render scene
        currentRenderState.setupLights(_this.physicallyCorrectLights);
        if (camera.isArrayCamera) {
            const cameras = camera.cameras;
            for(let i143 = 0, l = cameras.length; i143 < l; i143++){
                const camera2 = cameras[i143];
                renderScene(currentRenderList1, scene, camera2, camera2.viewport);
            }
        } else renderScene(currentRenderList1, scene, camera);
        //
        if (_currentRenderTarget !== null) {
            // resolve multisample renderbuffers to a single-sample texture if necessary
            textures1.updateMultisampleRenderTarget(_currentRenderTarget);
            // Generate mipmap if we're using any kind of mipmap filtering
            textures1.updateRenderTargetMipmap(_currentRenderTarget);
        }
        //
        if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
        // Ensure depth buffer writing is enabled so it can be cleared on next render
        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);
        state.setPolygonOffset(false);
        // _gl.finish();
        bindingStates.resetDefaultState();
        _currentMaterialId = -1;
        _currentCamera = null;
        renderStateStack.pop();
        if (renderStateStack.length > 0) currentRenderState = renderStateStack[renderStateStack.length - 1];
        else currentRenderState = null;
        renderListStack.pop();
        if (renderListStack.length > 0) currentRenderList1 = renderListStack[renderListStack.length - 1];
        else currentRenderList1 = null;
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible) {
            if (object.isGroup) groupOrder = object.renderOrder;
            else if (object.isLOD) {
                if (object.autoUpdate === true) object.update(camera);
            } else if (object.isLight) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            } else if (object.isSprite) {
                if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                    if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix1);
                    const geometry = objects.update(object);
                    const material = object.material;
                    if (material.visible) currentRenderList1.push(object, geometry, material, groupOrder, _vector3.z, null);
                }
            } else if (object.isImmediateRenderObject) {
                if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix1);
                currentRenderList1.push(object, null, object.material, groupOrder, _vector3.z, null);
            } else if (object.isMesh || object.isLine || object.isPoints) {
                if (object.isSkinnedMesh) // update skeleton only once in a frame
                {
                    if (object.skeleton.frame !== info.render.frame) {
                        object.skeleton.update();
                        object.skeleton.frame = info.render.frame;
                    }
                }
                if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                    if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix1);
                    const geometry = objects.update(object);
                    const material = object.material;
                    if (Array.isArray(material)) {
                        const groups = geometry.groups;
                        for(let i144 = 0, l = groups.length; i144 < l; i144++){
                            const group = groups[i144];
                            const groupMaterial = material[group.materialIndex];
                            if (groupMaterial && groupMaterial.visible) currentRenderList1.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                        }
                    } else if (material.visible) currentRenderList1.push(object, geometry, material, groupOrder, _vector3.z, null);
                }
            }
        }
        const children = object.children;
        for(let i145 = 0, l = children.length; i145 < l; i145++)projectObject(children[i145], camera, groupOrder, sortObjects);
    }
    function renderScene(currentRenderList, scene, camera, viewport) {
        const opaqueObjects = currentRenderList.opaque;
        const transmissiveObjects = currentRenderList.transmissive;
        const transparentObjects = currentRenderList.transparent;
        currentRenderState.setupLightsView(camera);
        if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, scene, camera);
        if (viewport) state.viewport(_currentViewport.copy(viewport));
        if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
        if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
        if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
    }
    function renderTransmissionPass(opaqueObjects, scene, camera) {
        if (_transmissionRenderTarget === null) {
            const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
            const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
            _transmissionRenderTarget = new renderTargetType(1024, 1024, {
                generateMipmaps: true,
                type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
                minFilter: LinearMipmapLinearFilter,
                magFilter: NearestFilter,
                wrapS: ClampToEdgeWrapping,
                wrapT: ClampToEdgeWrapping
            });
        }
        const currentRenderTarget = _this.getRenderTarget();
        _this.setRenderTarget(_transmissionRenderTarget);
        _this.clear();
        // Turn off the features which can affect the frag color for opaque objects pass.
        // Otherwise they are applied twice in opaque objects pass and transmission objects pass.
        const currentToneMapping = _this.toneMapping;
        _this.toneMapping = NoToneMapping;
        renderObjects(opaqueObjects, scene, camera);
        _this.toneMapping = currentToneMapping;
        textures1.updateMultisampleRenderTarget(_transmissionRenderTarget);
        textures1.updateRenderTargetMipmap(_transmissionRenderTarget);
        _this.setRenderTarget(currentRenderTarget);
    }
    function renderObjects(renderList, scene, camera) {
        const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
        for(let i146 = 0, l = renderList.length; i146 < l; i146++){
            const renderItem = renderList[i146];
            const object = renderItem.object;
            const geometry = renderItem.geometry;
            const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
            const group = renderItem.group;
            if (object.layers.test(camera.layers)) renderObject(object, scene, camera, geometry, material, group);
        }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
        object.onBeforeRender(_this, scene, camera, geometry, material, group);
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        if (object.isImmediateRenderObject) {
            const program = setProgram(camera, scene, material, object);
            state.setMaterial(material);
            bindingStates.reset();
            renderObjectImmediate(object, program);
        } else if (material.transparent === true && material.side === DoubleSide) {
            material.side = BackSide;
            material.needsUpdate = true;
            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
            material.side = FrontSide;
            material.needsUpdate = true;
            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
            material.side = DoubleSide;
        } else _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
        if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        const shadowsArray = currentRenderState.state.shadowsArray;
        const lightsStateVersion = lights.state.version;
        const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
        const programCacheKey = programCache.getProgramCacheKey(parameters);
        let programs = materialProperties.programs;
        // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change
        materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
        materialProperties.fog = scene.fog;
        materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
        if (programs === undefined) {
            // new material
            material.addEventListener('dispose', onMaterialDispose);
            programs = new Map();
            materialProperties.programs = programs;
        }
        let program = programs.get(programCacheKey);
        if (program !== undefined) // early out if program and light state is identical
        {
            if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
                updateCommonMaterialProperties(material, parameters);
                return program;
            }
        } else {
            parameters.uniforms = programCache.getUniforms(material);
            material.onBuild(parameters, _this);
            material.onBeforeCompile(parameters, _this);
            program = programCache.acquireProgram(parameters, programCacheKey);
            programs.set(programCacheKey, program);
            materialProperties.uniforms = parameters.uniforms;
        }
        const uniforms = materialProperties.uniforms;
        if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) uniforms.clippingPlanes = clipping.uniform;
        updateCommonMaterialProperties(material, parameters);
        // store the light setup it was created for
        materialProperties.needsLights = materialNeedsLights(material);
        materialProperties.lightsStateVersion = lightsStateVersion;
        if (materialProperties.needsLights) {
            // wire up the material to this renderer's lighting state
            uniforms.ambientLightColor.value = lights.state.ambient;
            uniforms.lightProbe.value = lights.state.probe;
            uniforms.directionalLights.value = lights.state.directional;
            uniforms.directionalLightShadows.value = lights.state.directionalShadow;
            uniforms.spotLights.value = lights.state.spot;
            uniforms.spotLightShadows.value = lights.state.spotShadow;
            uniforms.rectAreaLights.value = lights.state.rectArea;
            uniforms.ltc_1.value = lights.state.rectAreaLTC1;
            uniforms.ltc_2.value = lights.state.rectAreaLTC2;
            uniforms.pointLights.value = lights.state.point;
            uniforms.pointLightShadows.value = lights.state.pointShadow;
            uniforms.hemisphereLights.value = lights.state.hemi;
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
            uniforms.spotShadowMap.value = lights.state.spotShadowMap;
            uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
            uniforms.pointShadowMap.value = lights.state.pointShadowMap;
            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        // TODO (abelnation): add area lights shadow info to uniforms
        }
        const progUniforms = program.getUniforms();
        const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
        materialProperties.currentProgram = program;
        materialProperties.uniformsList = uniformsList;
        return program;
    }
    function updateCommonMaterialProperties(material, parameters) {
        const materialProperties = properties.get(material);
        materialProperties.outputEncoding = parameters.outputEncoding;
        materialProperties.instancing = parameters.instancing;
        materialProperties.skinning = parameters.skinning;
        materialProperties.morphTargets = parameters.morphTargets;
        materialProperties.morphNormals = parameters.morphNormals;
        materialProperties.numClippingPlanes = parameters.numClippingPlanes;
        materialProperties.numIntersection = parameters.numClipIntersection;
        materialProperties.vertexAlphas = parameters.vertexAlphas;
        materialProperties.vertexTangents = parameters.vertexTangents;
    }
    function setProgram(camera, scene, material, object) {
        if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
        textures1.resetTextureUnits();
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
        const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
        const vertexAlphas = material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;
        const vertexTangents = !!object.geometry && !!object.geometry.attributes.tangent;
        const morphTargets = !!object.geometry && !!object.geometry.morphAttributes.position;
        const morphNormals = !!object.geometry && !!object.geometry.morphAttributes.normal;
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        if (_clippingEnabled === true) {
            if (_localClippingEnabled === true || camera !== _currentCamera) {
                const useCache = camera === _currentCamera && material.id === _currentMaterialId;
                // we might want to call this function with some ClippingGroup
                // object instead of the material, once it becomes feasible
                // (#8465, #8379)
                clipping.setState(material, camera, useCache);
            }
        }
        //
        let needsProgramChange = false;
        if (material.version === materialProperties.__version) {
            if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) needsProgramChange = true;
            else if (materialProperties.outputEncoding !== encoding) needsProgramChange = true;
            else if (object.isInstancedMesh && materialProperties.instancing === false) needsProgramChange = true;
            else if (!object.isInstancedMesh && materialProperties.instancing === true) needsProgramChange = true;
            else if (object.isSkinnedMesh && materialProperties.skinning === false) needsProgramChange = true;
            else if (!object.isSkinnedMesh && materialProperties.skinning === true) needsProgramChange = true;
            else if (materialProperties.envMap !== envMap) needsProgramChange = true;
            else if (material.fog && materialProperties.fog !== fog) needsProgramChange = true;
            else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) needsProgramChange = true;
            else if (materialProperties.vertexAlphas !== vertexAlphas) needsProgramChange = true;
            else if (materialProperties.vertexTangents !== vertexTangents) needsProgramChange = true;
            else if (materialProperties.morphTargets !== morphTargets) needsProgramChange = true;
            else if (materialProperties.morphNormals !== morphNormals) needsProgramChange = true;
        } else {
            needsProgramChange = true;
            materialProperties.__version = material.version;
        }
        //
        let program = materialProperties.currentProgram;
        if (needsProgramChange === true) program = getProgram(material, scene, object);
        let refreshProgram = false;
        let refreshMaterial = false;
        let refreshLights = false;
        const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
        if (state.useProgram(program.program)) {
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
            _currentMaterialId = material.id;
            refreshMaterial = true;
        }
        if (refreshProgram || _currentCamera !== camera) {
            p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
            if (capabilities.logarithmicDepthBuffer) p_uniforms.setValue(_gl, 'logDepthBufFC', 2 / (Math.log(camera.far + 1) / Math.LN2));
            if (_currentCamera !== camera) {
                _currentCamera = camera;
                // lighting uniforms depend on the camera so enforce an update
                // now, in case this material supports lights - or later, when
                // the next material that does gets activated:
                refreshMaterial = true; // set to true on material change
                refreshLights = true; // remains set until update done
            }
            // load material specific uniforms
            // (shader material also gets them for the sake of genericity)
            if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
                const uCamPos = p_uniforms.map.cameraPosition;
                if (uCamPos !== undefined) uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
            }
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
        }
        // skinning uniforms must be set even if material didn't change
        // auto-setting of texture unit for bone texture must go before other textures
        // otherwise textures used for skinning can take over texture units reserved for other material textures
        if (object.isSkinnedMesh) {
            p_uniforms.setOptional(_gl, object, 'bindMatrix');
            p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
            const skeleton = object.skeleton;
            if (skeleton) {
                if (capabilities.floatVertexTextures) {
                    if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
                    p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures1);
                    p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
                } else p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
            }
        }
        if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
            materialProperties.receiveShadow = object.receiveShadow;
            p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
        }
        if (refreshMaterial) {
            p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
            if (materialProperties.needsLights) // the current material requires lighting info
            // note: all lighting uniforms are always set correctly
            // they simply reference the renderer's state for their
            // values
            //
            // use the current material's .needsUpdate flags to set
            // the GL state when required
            markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            // refresh uniforms common to several materials
            if (fog && material.fog) materials.refreshFogUniforms(m_uniforms, fog);
            materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures1);
        }
        if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures1);
            material.uniformsNeedUpdate = false;
        }
        if (material.isSpriteMaterial) p_uniforms.setValue(_gl, 'center', object.center);
        // common matrices
        p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
        p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
        p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
        return program;
    }
    // If uniforms are marked as clean, they don't need to be loaded to the GPU.
    function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.lightProbe.needsUpdate = value;
        uniforms.directionalLights.needsUpdate = value;
        uniforms.directionalLightShadows.needsUpdate = value;
        uniforms.pointLights.needsUpdate = value;
        uniforms.pointLightShadows.needsUpdate = value;
        uniforms.spotLights.needsUpdate = value;
        uniforms.spotLightShadows.needsUpdate = value;
        uniforms.rectAreaLights.needsUpdate = value;
        uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
        return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
        return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
        return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
        return _currentRenderTarget;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
        _currentRenderTarget = renderTarget;
        _currentActiveCubeFace = activeCubeFace;
        _currentActiveMipmapLevel = activeMipmapLevel;
        if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) textures1.setupRenderTarget(renderTarget);
        let framebuffer = null;
        let isCube = false;
        let isRenderTarget3D = false;
        if (renderTarget) {
            const texture = renderTarget.texture;
            if (texture.isDataTexture3D || texture.isDataTexture2DArray) isRenderTarget3D = true;
            const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget) {
                framebuffer = __webglFramebuffer[activeCubeFace];
                isCube = true;
            } else if (renderTarget.isWebGLMultisampleRenderTarget) framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
            else framebuffer = __webglFramebuffer;
            _currentViewport.copy(renderTarget.viewport);
            _currentScissor.copy(renderTarget.scissor);
            _currentScissorTest = renderTarget.scissorTest;
        } else {
            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
            _currentScissorTest = _scissorTest;
        }
        const framebufferBound = state.bindFramebuffer(36160, framebuffer);
        if (framebufferBound && capabilities.drawBuffers) {
            let needsUpdate = false;
            if (renderTarget) {
                if (renderTarget.isWebGLMultipleRenderTargets) {
                    const textures = renderTarget.texture;
                    if (_currentDrawBuffers.length !== textures.length || _currentDrawBuffers[0] !== 36064) {
                        for(let i147 = 0, il = textures.length; i147 < il; i147++)_currentDrawBuffers[i147] = 36064 + i147;
                        _currentDrawBuffers.length = textures.length;
                        needsUpdate = true;
                    }
                } else if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 36064) {
                    _currentDrawBuffers[0] = 36064;
                    _currentDrawBuffers.length = 1;
                    needsUpdate = true;
                }
            } else if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 1029) {
                _currentDrawBuffers[0] = 1029;
                _currentDrawBuffers.length = 1;
                needsUpdate = true;
            }
            if (needsUpdate) {
                if (capabilities.isWebGL2) _gl.drawBuffers(_currentDrawBuffers);
                else extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers);
            }
        }
        state.viewport(_currentViewport);
        state.scissor(_currentScissor);
        state.setScissorTest(_currentScissorTest);
        if (isCube) {
            const textureProperties = properties.get(renderTarget.texture);
            _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
        } else if (isRenderTarget3D) {
            const textureProperties = properties.get(renderTarget.texture);
            const layer = activeCubeFace || 0;
            _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
        }
        _currentMaterialId = -1; // reset current material to ensure correct uniform bindings
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
            return;
        }
        let framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) framebuffer = framebuffer[activeCubeFaceIndex];
        if (framebuffer) {
            state.bindFramebuffer(36160, framebuffer);
            try {
                const texture = renderTarget.texture;
                const textureFormat = texture.format;
                const textureType = texture.type;
                if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                    return;
                }
                const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));
                if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && !halfFloatSupportedByExt) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                    return;
                }
                if (_gl.checkFramebufferStatus(36160) === 36053) // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
                {
                    if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                } else console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
            } finally{
                // restore framebuffer of current render target if necessary
                const framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
                state.bindFramebuffer(36160, framebuffer);
            }
        }
    };
    this.copyFramebufferToTexture = function(position, texture, level = 0) {
        const levelScale = Math.pow(2, -level);
        const width = Math.floor(texture.image.width * levelScale);
        const height = Math.floor(texture.image.height * levelScale);
        let glFormat = utils.convert(texture.format);
        if (capabilities.isWebGL2) {
            // Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
            // Not needed in Chrome 93+
            if (glFormat === 6407) glFormat = 32849;
            if (glFormat === 6408) glFormat = 32856;
        }
        textures1.setTexture2D(texture, 0);
        _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
        state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
        const width = srcTexture.image.width;
        const height = srcTexture.image.height;
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        textures1.setTexture2D(dstTexture, 0);
        // As another texture upload may have changed pixelStorei
        // parameters, make sure they are correct for the dstTexture
        _gl.pixelStorei(37440, dstTexture.flipY);
        _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(3317, dstTexture.unpackAlignment);
        if (srcTexture.isDataTexture) _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
        else if (srcTexture.isCompressedTexture) _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        else _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
        // Generate mipmaps only when copying level 0
        if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);
        state.unbindTexture();
    };
    this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
        if (_this.isWebGL1Renderer) {
            console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');
            return;
        }
        const width = sourceBox.max.x - sourceBox.min.x + 1;
        const height = sourceBox.max.y - sourceBox.min.y + 1;
        const depth = sourceBox.max.z - sourceBox.min.z + 1;
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        let glTarget;
        if (dstTexture.isDataTexture3D) {
            textures1.setTexture3D(dstTexture, 0);
            glTarget = 32879;
        } else if (dstTexture.isDataTexture2DArray) {
            textures1.setTexture2DArray(dstTexture, 0);
            glTarget = 35866;
        } else {
            console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
            return;
        }
        _gl.pixelStorei(37440, dstTexture.flipY);
        _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(3317, dstTexture.unpackAlignment);
        const unpackRowLen = _gl.getParameter(3314);
        const unpackImageHeight = _gl.getParameter(32878);
        const unpackSkipPixels = _gl.getParameter(3316);
        const unpackSkipRows = _gl.getParameter(3315);
        const unpackSkipImages = _gl.getParameter(32877);
        const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
        _gl.pixelStorei(3314, image.width);
        _gl.pixelStorei(32878, image.height);
        _gl.pixelStorei(3316, sourceBox.min.x);
        _gl.pixelStorei(3315, sourceBox.min.y);
        _gl.pixelStorei(32877, sourceBox.min.z);
        if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
        else if (srcTexture.isCompressedTexture) {
            console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');
            _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
        } else _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
        _gl.pixelStorei(3314, unpackRowLen);
        _gl.pixelStorei(32878, unpackImageHeight);
        _gl.pixelStorei(3316, unpackSkipPixels);
        _gl.pixelStorei(3315, unpackSkipRows);
        _gl.pixelStorei(32877, unpackSkipImages);
        // Generate mipmaps only when copying level 0
        if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
        state.unbindTexture();
    };
    this.initTexture = function(texture) {
        textures1.setTexture2D(texture, 0);
        state.unbindTexture();
    };
    this.resetState = function() {
        _currentActiveCubeFace = 0;
        _currentActiveMipmapLevel = 0;
        _currentRenderTarget = null;
        state.reset();
        bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== 'undefined') __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: this
    })); // eslint-disable-line no-undef
}
class WebGL1Renderer extends WebGLRenderer {
}
WebGL1Renderer.prototype.isWebGL1Renderer = true;
class FogExp2 {
    constructor(color, density = 0.00025){
        this.name = '';
        this.color = new Color(color);
        this.density = density;
    }
    clone() {
        return new FogExp2(this.color, this.density);
    }
    toJSON() {
        return {
            type: 'FogExp2',
            color: this.color.getHex(),
            density: this.density
        };
    }
}
FogExp2.prototype.isFogExp2 = true;
class Fog {
    constructor(color, near = 1, far = 1000){
        this.name = '';
        this.color = new Color(color);
        this.near = near;
        this.far = far;
    }
    clone() {
        return new Fog(this.color, this.near, this.far);
    }
    toJSON() {
        return {
            type: 'Fog',
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    }
}
Fog.prototype.isFog = true;
class Scene extends Object3D {
    constructor(){
        super();
        this.type = 'Scene';
        this.background = null;
        this.environment = null;
        this.fog = null;
        this.overrideMaterial = null;
        this.autoUpdate = true; // checked by the renderer
        if (typeof __THREE_DEVTOOLS__ !== 'undefined') __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
            detail: this
        })); // eslint-disable-line no-undef
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        if (source.background !== null) this.background = source.background.clone();
        if (source.environment !== null) this.environment = source.environment.clone();
        if (source.fog !== null) this.fog = source.fog.clone();
        if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        if (this.fog !== null) data.object.fog = this.fog.toJSON();
        return data;
    }
}
Scene.prototype.isScene = true;
class InterleavedBuffer {
    constructor(array, stride){
        this.array = array;
        this.stride = stride;
        this.count = array !== undefined ? array.length / stride : 0;
        this.usage = StaticDrawUsage;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.version = 0;
        this.uuid = generateUUID();
    }
    onUploadCallback() {}
    set needsUpdate(value) {
        if (value === true) this.version++;
    }
    setUsage(value) {
        this.usage = value;
        return this;
    }
    copy(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
    }
    copyAt(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for(let i148 = 0, l = this.stride; i148 < l; i148++)this.array[index1 + i148] = attribute.array[index2 + i148];
        return this;
    }
    set(value, offset = 0) {
        this.array.set(value, offset);
        return this;
    }
    clone(data) {
        if (data.arrayBuffers === undefined) data.arrayBuffers = {};
        if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = generateUUID();
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
        const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
        const ib = new this.constructor(array, this.stride);
        ib.setUsage(this.usage);
        return ib;
    }
    onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
    }
    toJSON(data) {
        if (data.arrayBuffers === undefined) data.arrayBuffers = {};
        // generate UUID for array buffer if necessary
        if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = generateUUID();
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
        //
        return {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        };
    }
}
InterleavedBuffer.prototype.isInterleavedBuffer = true;
const _vector$6 = /*@__PURE__*/ new Vector3();
class InterleavedBufferAttribute {
    constructor(interleavedBuffer, itemSize, offset, normalized = false){
        this.name = '';
        this.data = interleavedBuffer;
        this.itemSize = itemSize;
        this.offset = offset;
        this.normalized = normalized === true;
    }
    get count() {
        return this.data.count;
    }
    get array() {
        return this.data.array;
    }
    set needsUpdate(value) {
        this.data.needsUpdate = value;
    }
    applyMatrix4(m) {
        for(let i149 = 0, l = this.data.count; i149 < l; i149++){
            _vector$6.x = this.getX(i149);
            _vector$6.y = this.getY(i149);
            _vector$6.z = this.getZ(i149);
            _vector$6.applyMatrix4(m);
            this.setXYZ(i149, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
    }
    applyNormalMatrix(m) {
        for(let i150 = 0, l = this.count; i150 < l; i150++){
            _vector$6.x = this.getX(i150);
            _vector$6.y = this.getY(i150);
            _vector$6.z = this.getZ(i150);
            _vector$6.applyNormalMatrix(m);
            this.setXYZ(i150, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
    }
    transformDirection(m) {
        for(let i151 = 0, l = this.count; i151 < l; i151++){
            _vector$6.x = this.getX(i151);
            _vector$6.y = this.getY(i151);
            _vector$6.z = this.getZ(i151);
            _vector$6.transformDirection(m);
            this.setXYZ(i151, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
    }
    setX(index, x) {
        this.data.array[index * this.data.stride + this.offset] = x;
        return this;
    }
    setY(index, y) {
        this.data.array[index * this.data.stride + this.offset + 1] = y;
        return this;
    }
    setZ(index, z) {
        this.data.array[index * this.data.stride + this.offset + 2] = z;
        return this;
    }
    setW(index, w) {
        this.data.array[index * this.data.stride + this.offset + 3] = w;
        return this;
    }
    getX(index) {
        return this.data.array[index * this.data.stride + this.offset];
    }
    getY(index) {
        return this.data.array[index * this.data.stride + this.offset + 1];
    }
    getZ(index) {
        return this.data.array[index * this.data.stride + this.offset + 2];
    }
    getW(index) {
        return this.data.array[index * this.data.stride + this.offset + 3];
    }
    setXY(index, x, y) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        return this;
    }
    setXYZ(index, x, y, z) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        return this;
    }
    setXYZW(index, x, y, z, w) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        this.data.array[index + 3] = w;
        return this;
    }
    clone(data) {
        if (data === undefined) {
            console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
            const array = [];
            for(let i152 = 0; i152 < this.count; i152++){
                const index = i152 * this.data.stride + this.offset;
                for(let j = 0; j < this.itemSize; j++)array.push(this.data.array[index + j]);
            }
            return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
        } else {
            if (data.interleavedBuffers === undefined) data.interleavedBuffers = {};
            if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
            return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
    }
    toJSON(data) {
        if (data === undefined) {
            console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
            const array = [];
            for(let i153 = 0; i153 < this.count; i153++){
                const index = i153 * this.data.stride + this.offset;
                for(let j = 0; j < this.itemSize; j++)array.push(this.data.array[index + j]);
            }
            // deinterleave data and save it as an ordinary buffer attribute for now
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: array,
                normalized: this.normalized
            };
        } else {
            // save as true interlaved attribtue
            if (data.interleavedBuffers === undefined) data.interleavedBuffers = {};
            if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
            return {
                isInterleavedBufferAttribute: true,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            };
        }
    }
}
InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
/**
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */ class SpriteMaterial extends Material {
    constructor(parameters){
        super();
        this.type = 'SpriteMaterial';
        this.color = new Color(16777215);
        this.map = null;
        this.alphaMap = null;
        this.rotation = 0;
        this.sizeAttenuation = true;
        this.transparent = true;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.rotation = source.rotation;
        this.sizeAttenuation = source.sizeAttenuation;
        return this;
    }
}
SpriteMaterial.prototype.isSpriteMaterial = true;
let _geometry;
const _intersectPoint = /*@__PURE__*/ new Vector3();
const _worldScale = /*@__PURE__*/ new Vector3();
const _mvPosition = /*@__PURE__*/ new Vector3();
const _alignedPosition = /*@__PURE__*/ new Vector2();
const _rotatedPosition = /*@__PURE__*/ new Vector2();
const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();
const _vA = /*@__PURE__*/ new Vector3();
const _vB = /*@__PURE__*/ new Vector3();
const _vC = /*@__PURE__*/ new Vector3();
const _uvA = /*@__PURE__*/ new Vector2();
const _uvB = /*@__PURE__*/ new Vector2();
const _uvC = /*@__PURE__*/ new Vector2();
class Sprite extends Object3D {
    constructor(material){
        super();
        this.type = 'Sprite';
        if (_geometry === undefined) {
            _geometry = new BufferGeometry();
            const float32Array = new Float32Array([
                -0.5,
                -0.5,
                0,
                0,
                0,
                0.5,
                -0.5,
                0,
                1,
                0,
                0.5,
                0.5,
                0,
                1,
                1,
                -0.5,
                0.5,
                0,
                0,
                1
            ]);
            const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
            _geometry.setIndex([
                0,
                1,
                2,
                0,
                2,
                3
            ]);
            _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
            _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
        }
        this.geometry = _geometry;
        this.material = material !== undefined ? material : new SpriteMaterial();
        this.center = new Vector2(0.5, 0.5);
    }
    raycast(raycaster, intersects2) {
        if (raycaster.camera === null) console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
        _worldScale.setFromMatrixScale(this.matrixWorld);
        _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
        _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) _worldScale.multiplyScalar(-_mvPosition.z);
        const rotation = this.material.rotation;
        let sin, cos;
        if (rotation !== 0) {
            cos = Math.cos(rotation);
            sin = Math.sin(rotation);
        }
        const center = this.center;
        transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        _uvA.set(0, 0);
        _uvB.set(1, 0);
        _uvC.set(1, 1);
        // check first triangle
        let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
        if (intersect === null) {
            // check second triangle
            transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
            _uvB.set(0, 1);
            intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
            if (intersect === null) return;
        }
        const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects2.push({
            distance: distance,
            point: _intersectPoint.clone(),
            uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
            face: null,
            object: this
        });
    }
    copy(source) {
        super.copy(source);
        if (source.center !== undefined) this.center.copy(source.center);
        this.material = source.material;
        return this;
    }
}
Sprite.prototype.isSprite = true;
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
    // compute position in camera space
    _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
    // to check if rotation is not zero
    if (sin !== undefined) {
        _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
        _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
    } else _rotatedPosition.copy(_alignedPosition);
    vertexPosition.copy(mvPosition);
    vertexPosition.x += _rotatedPosition.x;
    vertexPosition.y += _rotatedPosition.y;
    // transform to world space
    vertexPosition.applyMatrix4(_viewWorldMatrix);
}
const _v1$2 = /*@__PURE__*/ new Vector3();
const _v2$1 = /*@__PURE__*/ new Vector3();
class LOD extends Object3D {
    constructor(){
        super();
        this._currentLevel = 0;
        this.type = 'LOD';
        Object.defineProperties(this, {
            levels: {
                enumerable: true,
                value: []
            },
            isLOD: {
                value: true
            }
        });
        this.autoUpdate = true;
    }
    copy(source) {
        super.copy(source, false);
        const levels = source.levels;
        for(let i154 = 0, l = levels.length; i154 < l; i154++){
            const level = levels[i154];
            this.addLevel(level.object.clone(), level.distance);
        }
        this.autoUpdate = source.autoUpdate;
        return this;
    }
    addLevel(object, distance = 0) {
        distance = Math.abs(distance);
        const levels = this.levels;
        let l;
        for(l = 0; l < levels.length; l++){
            if (distance < levels[l].distance) break;
        }
        levels.splice(l, 0, {
            distance: distance,
            object: object
        });
        this.add(object);
        return this;
    }
    getCurrentLevel() {
        return this._currentLevel;
    }
    getObjectForDistance(distance) {
        const levels = this.levels;
        if (levels.length > 0) {
            let i155, l;
            for(i155 = 1, l = levels.length; i155 < l; i155++){
                if (distance < levels[i155].distance) break;
            }
            return levels[i155 - 1].object;
        }
        return null;
    }
    raycast(raycaster, intersects3) {
        const levels = this.levels;
        if (levels.length > 0) {
            _v1$2.setFromMatrixPosition(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(_v1$2);
            this.getObjectForDistance(distance).raycast(raycaster, intersects3);
        }
    }
    update(camera) {
        const levels = this.levels;
        if (levels.length > 1) {
            _v1$2.setFromMatrixPosition(camera.matrixWorld);
            _v2$1.setFromMatrixPosition(this.matrixWorld);
            const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
            levels[0].object.visible = true;
            let i156, l;
            for(i156 = 1, l = levels.length; i156 < l; i156++){
                if (distance >= levels[i156].distance) {
                    levels[i156 - 1].object.visible = false;
                    levels[i156].object.visible = true;
                } else break;
            }
            this._currentLevel = i156 - 1;
            for(; i156 < l; i156++)levels[i156].object.visible = false;
        }
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        if (this.autoUpdate === false) data.object.autoUpdate = false;
        data.object.levels = [];
        const levels = this.levels;
        for(let i157 = 0, l = levels.length; i157 < l; i157++){
            const level = levels[i157];
            data.object.levels.push({
                object: level.object.uuid,
                distance: level.distance
            });
        }
        return data;
    }
}
const _basePosition = /*@__PURE__*/ new Vector3();
const _skinIndex = /*@__PURE__*/ new Vector4();
const _skinWeight = /*@__PURE__*/ new Vector4();
const _vector$5 = /*@__PURE__*/ new Vector3();
const _matrix = /*@__PURE__*/ new Matrix4();
class SkinnedMesh extends Mesh {
    constructor(geometry, material){
        super(geometry, material);
        this.type = 'SkinnedMesh';
        this.bindMode = 'attached';
        this.bindMatrix = new Matrix4();
        this.bindMatrixInverse = new Matrix4();
    }
    copy(source) {
        super.copy(source);
        this.bindMode = source.bindMode;
        this.bindMatrix.copy(source.bindMatrix);
        this.bindMatrixInverse.copy(source.bindMatrixInverse);
        this.skeleton = source.skeleton;
        return this;
    }
    bind(skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === undefined) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.copy(bindMatrix).invert();
    }
    pose() {
        this.skeleton.pose();
    }
    normalizeSkinWeights() {
        const vector = new Vector4();
        const skinWeight = this.geometry.attributes.skinWeight;
        for(let i158 = 0, l = skinWeight.count; i158 < l; i158++){
            vector.x = skinWeight.getX(i158);
            vector.y = skinWeight.getY(i158);
            vector.z = skinWeight.getZ(i158);
            vector.w = skinWeight.getW(i158);
            const scale = 1 / vector.manhattanLength();
            if (scale !== Infinity) vector.multiplyScalar(scale);
            else vector.set(1, 0, 0, 0); // do something reasonable
            skinWeight.setXYZW(i158, vector.x, vector.y, vector.z, vector.w);
        }
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        if (this.bindMode === 'attached') this.bindMatrixInverse.copy(this.matrixWorld).invert();
        else if (this.bindMode === 'detached') this.bindMatrixInverse.copy(this.bindMatrix).invert();
        else console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
    }
    boneTransform(index, target) {
        const skeleton = this.skeleton;
        const geometry = this.geometry;
        _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
        _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
        _basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
        target.set(0, 0, 0);
        for(let i159 = 0; i159 < 4; i159++){
            const weight = _skinWeight.getComponent(i159);
            if (weight !== 0) {
                const boneIndex = _skinIndex.getComponent(i159);
                _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
                target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
            }
        }
        return target.applyMatrix4(this.bindMatrixInverse);
    }
}
SkinnedMesh.prototype.isSkinnedMesh = true;
class Bone extends Object3D {
    constructor(){
        super();
        this.type = 'Bone';
    }
}
Bone.prototype.isBone = true;
class DataTexture extends Texture {
    constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding){
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = {
            data: data,
            width: width,
            height: height
        };
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
        this.needsUpdate = true;
    }
}
DataTexture.prototype.isDataTexture = true;
const _offsetMatrix = /*@__PURE__*/ new Matrix4();
const _identityMatrix = /*@__PURE__*/ new Matrix4();
class Skeleton {
    constructor(bones = [], boneInverses = []){
        this.uuid = generateUUID();
        this.bones = bones.slice(0);
        this.boneInverses = boneInverses;
        this.boneMatrices = null;
        this.boneTexture = null;
        this.boneTextureSize = 0;
        this.frame = -1;
        this.init();
    }
    init() {
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        this.boneMatrices = new Float32Array(bones.length * 16);
        // calculate inverse bone matrices if necessary
        if (boneInverses.length === 0) this.calculateInverses();
        else // handle special case
        if (bones.length !== boneInverses.length) {
            console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
            this.boneInverses = [];
            for(let i160 = 0, il = this.bones.length; i160 < il; i160++)this.boneInverses.push(new Matrix4());
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for(let i161 = 0, il = this.bones.length; i161 < il; i161++){
            const inverse = new Matrix4();
            if (this.bones[i161]) inverse.copy(this.bones[i161].matrixWorld).invert();
            this.boneInverses.push(inverse);
        }
    }
    pose() {
        // recover the bind-time world matrices
        for(let i163 = 0, il = this.bones.length; i163 < il; i163++){
            const bone = this.bones[i163];
            if (bone) bone.matrixWorld.copy(this.boneInverses[i163]).invert();
        }
        // compute the local matrices, positions, rotations and scales
        for(let i162 = 0, il6 = this.bones.length; i162 < il6; i162++){
            const bone = this.bones[i162];
            if (bone) {
                if (bone.parent && bone.parent.isBone) {
                    bone.matrix.copy(bone.parent.matrixWorld).invert();
                    bone.matrix.multiply(bone.matrixWorld);
                } else bone.matrix.copy(bone.matrixWorld);
                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
        }
    }
    update() {
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        const boneMatrices = this.boneMatrices;
        const boneTexture = this.boneTexture;
        // flatten bone matrices to array
        for(let i164 = 0, il = bones.length; i164 < il; i164++){
            // compute the offset between the current and the original transform
            const matrix = bones[i164] ? bones[i164].matrixWorld : _identityMatrix;
            _offsetMatrix.multiplyMatrices(matrix, boneInverses[i164]);
            _offsetMatrix.toArray(boneMatrices, i164 * 16);
        }
        if (boneTexture !== null) boneTexture.needsUpdate = true;
    }
    clone() {
        return new Skeleton(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
        // layout (1 matrix = 4 pixels)
        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
        //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
        //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
        //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
        //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
        let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix
        size = ceilPowerOfTwo(size);
        size = Math.max(size, 4);
        const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
        boneMatrices.set(this.boneMatrices); // copy current values
        const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
        this.boneMatrices = boneMatrices;
        this.boneTexture = boneTexture;
        this.boneTextureSize = size;
        return this;
    }
    getBoneByName(name) {
        for(let i165 = 0, il = this.bones.length; i165 < il; i165++){
            const bone = this.bones[i165];
            if (bone.name === name) return bone;
        }
        return undefined;
    }
    dispose() {
        if (this.boneTexture !== null) {
            this.boneTexture.dispose();
            this.boneTexture = null;
        }
    }
    fromJSON(json, bones) {
        this.uuid = json.uuid;
        for(let i166 = 0, l = json.bones.length; i166 < l; i166++){
            const uuid = json.bones[i166];
            let bone = bones[uuid];
            if (bone === undefined) {
                console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
                bone = new Bone();
            }
            this.bones.push(bone);
            this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i166]));
        }
        this.init();
        return this;
    }
    toJSON() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'Skeleton',
                generator: 'Skeleton.toJSON'
            },
            bones: [],
            boneInverses: []
        };
        data.uuid = this.uuid;
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        for(let i167 = 0, l = bones.length; i167 < l; i167++){
            const bone = bones[i167];
            data.bones.push(bone.uuid);
            const boneInverse = boneInverses[i167];
            data.boneInverses.push(boneInverse.toArray());
        }
        return data;
    }
}
class InstancedBufferAttribute extends BufferAttribute {
    constructor(array, itemSize, normalized, meshPerAttribute = 1){
        if (typeof normalized === 'number') {
            meshPerAttribute = normalized;
            normalized = false;
            console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
        }
        super(array, itemSize, normalized);
        this.meshPerAttribute = meshPerAttribute;
    }
    copy(source) {
        super.copy(source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.meshPerAttribute = this.meshPerAttribute;
        data.isInstancedBufferAttribute = true;
        return data;
    }
}
InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();
const _instanceIntersects = [];
const _mesh = /*@__PURE__*/ new Mesh();
class InstancedMesh extends Mesh {
    constructor(geometry, material, count){
        super(geometry, material);
        this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
        this.instanceColor = null;
        this.count = count;
        this.frustumCulled = false;
    }
    copy(source) {
        super.copy(source);
        this.instanceMatrix.copy(source.instanceMatrix);
        if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
        this.count = source.count;
        return this;
    }
    getColorAt(index, color) {
        color.fromArray(this.instanceColor.array, index * 3);
    }
    getMatrixAt(index, matrix) {
        matrix.fromArray(this.instanceMatrix.array, index * 16);
    }
    raycast(raycaster, intersects4) {
        const matrixWorld = this.matrixWorld;
        const raycastTimes = this.count;
        _mesh.geometry = this.geometry;
        _mesh.material = this.material;
        if (_mesh.material === undefined) return;
        for(let instanceId = 0; instanceId < raycastTimes; instanceId++){
            // calculate the world matrix for each instance
            this.getMatrixAt(instanceId, _instanceLocalMatrix);
            _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
            // the mesh represents this single instance
            _mesh.matrixWorld = _instanceWorldMatrix;
            _mesh.raycast(raycaster, _instanceIntersects);
            // process the result of raycast
            for(let i168 = 0, l = _instanceIntersects.length; i168 < l; i168++){
                const intersect = _instanceIntersects[i168];
                intersect.instanceId = instanceId;
                intersect.object = this;
                intersects4.push(intersect);
            }
            _instanceIntersects.length = 0;
        }
    }
    setColorAt(index, color) {
        if (this.instanceColor === null) this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
        color.toArray(this.instanceColor.array, index * 3);
    }
    setMatrixAt(index, matrix) {
        matrix.toArray(this.instanceMatrix.array, index * 16);
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
}
InstancedMesh.prototype.isInstancedMesh = true;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */ class LineBasicMaterial extends Material {
    constructor(parameters){
        super();
        this.type = 'LineBasicMaterial';
        this.color = new Color(16777215);
        this.linewidth = 1;
        this.linecap = 'round';
        this.linejoin = 'round';
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
        return this;
    }
}
LineBasicMaterial.prototype.isLineBasicMaterial = true;
const _start$1 = /*@__PURE__*/ new Vector3();
const _end$1 = /*@__PURE__*/ new Vector3();
const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
const _ray$1 = /*@__PURE__*/ new Ray();
const _sphere$1 = /*@__PURE__*/ new Sphere();
class Line extends Object3D {
    constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()){
        super();
        this.type = 'Line';
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
    }
    copy(source) {
        super.copy(source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    }
    computeLineDistances() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            // we assume non-indexed geometry
            if (geometry.index === null) {
                const positionAttribute = geometry.attributes.position;
                const lineDistances = [
                    0
                ];
                for(let i169 = 1, l = positionAttribute.count; i169 < l; i169++){
                    _start$1.fromBufferAttribute(positionAttribute, i169 - 1);
                    _end$1.fromBufferAttribute(positionAttribute, i169);
                    lineDistances[i169] = lineDistances[i169 - 1];
                    lineDistances[i169] += _start$1.distanceTo(_end$1);
                }
                geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
            } else console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        } else if (geometry.isGeometry) console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        return this;
    }
    raycast(raycaster, intersects5) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Line.threshold;
        const drawRange = geometry.drawRange;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$1.copy(geometry.boundingSphere);
        _sphere$1.applyMatrix4(matrixWorld);
        _sphere$1.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;
        //
        _inverseMatrix$1.copy(matrixWorld).invert();
        _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        const vStart = new Vector3();
        const vEnd = new Vector3();
        const interSegment = new Vector3();
        const interRay = new Vector3();
        const step = this.isLineSegments ? 2 : 1;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(index.count, drawRange.start + drawRange.count);
                for(let i170 = start, l = end - 1; i170 < l; i170 += step){
                    const a = index.getX(i170);
                    const b = index.getX(i170 + 1);
                    vStart.fromBufferAttribute(positionAttribute, a);
                    vEnd.fromBufferAttribute(positionAttribute, b);
                    const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                    if (distSq > localThresholdSq) continue;
                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                    const distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far) continue;
                    intersects5.push({
                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i170,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
                for(let i171 = start, l = end - 1; i171 < l; i171 += step){
                    vStart.fromBufferAttribute(positionAttribute, i171);
                    vEnd.fromBufferAttribute(positionAttribute, i171 + 1);
                    const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                    if (distSq > localThresholdSq) continue;
                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                    const distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far) continue;
                    intersects5.push({
                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i171,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            }
        } else if (geometry.isGeometry) console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
    updateMorphTargets() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    }
}
Line.prototype.isLine = true;
const _start = /*@__PURE__*/ new Vector3();
const _end = /*@__PURE__*/ new Vector3();
class LineSegments extends Line {
    constructor(geometry, material){
        super(geometry, material);
        this.type = 'LineSegments';
    }
    computeLineDistances() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            // we assume non-indexed geometry
            if (geometry.index === null) {
                const positionAttribute = geometry.attributes.position;
                const lineDistances = [];
                for(let i172 = 0, l = positionAttribute.count; i172 < l; i172 += 2){
                    _start.fromBufferAttribute(positionAttribute, i172);
                    _end.fromBufferAttribute(positionAttribute, i172 + 1);
                    lineDistances[i172] = i172 === 0 ? 0 : lineDistances[i172 - 1];
                    lineDistances[i172 + 1] = lineDistances[i172] + _start.distanceTo(_end);
                }
                geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
            } else console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        } else if (geometry.isGeometry) console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        return this;
    }
}
LineSegments.prototype.isLineSegments = true;
class LineLoop extends Line {
    constructor(geometry, material){
        super(geometry, material);
        this.type = 'LineLoop';
    }
}
LineLoop.prototype.isLineLoop = true;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 * }
 */ class PointsMaterial extends Material {
    constructor(parameters){
        super();
        this.type = 'PointsMaterial';
        this.color = new Color(16777215);
        this.map = null;
        this.alphaMap = null;
        this.size = 1;
        this.sizeAttenuation = true;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
        return this;
    }
}
PointsMaterial.prototype.isPointsMaterial = true;
const _inverseMatrix = /*@__PURE__*/ new Matrix4();
const _ray = /*@__PURE__*/ new Ray();
const _sphere = /*@__PURE__*/ new Sphere();
const _position$2 = /*@__PURE__*/ new Vector3();
class Points extends Object3D {
    constructor(geometry = new BufferGeometry(), material = new PointsMaterial()){
        super();
        this.type = 'Points';
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
    }
    copy(source) {
        super.copy(source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    }
    raycast(raycaster, intersects6) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Points.threshold;
        const drawRange = geometry.drawRange;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere.copy(geometry.boundingSphere);
        _sphere.applyMatrix4(matrixWorld);
        _sphere.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere) === false) return;
        //
        _inverseMatrix.copy(matrixWorld).invert();
        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(index.count, drawRange.start + drawRange.count);
                for(let i173 = start, il = end; i173 < il; i173++){
                    const a = index.getX(i173);
                    _position$2.fromBufferAttribute(positionAttribute, a);
                    testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects6, this);
                }
            } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
                for(let i174 = start, l = end; i174 < l; i174++){
                    _position$2.fromBufferAttribute(positionAttribute, i174);
                    testPoint(_position$2, i174, localThresholdSq, matrixWorld, raycaster, intersects6, this);
                }
            }
        } else console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
    updateMorphTargets() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    }
}
Points.prototype.isPoints = true;
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects7, object) {
    const rayPointDistanceSq = _ray.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
        const intersectPoint = new Vector3();
        _ray.closestPointToPoint(point, intersectPoint);
        intersectPoint.applyMatrix4(matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects7.push({
            distance: distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint,
            index: index,
            face: null,
            object: object
        });
    }
}
class VideoTexture extends Texture {
    constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy){
        super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.format = format !== undefined ? format : RGBFormat;
        this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
        this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
        this.generateMipmaps = false;
        const scope = this;
        function updateVideo() {
            scope.needsUpdate = true;
            video.requestVideoFrameCallback(updateVideo);
        }
        if ('requestVideoFrameCallback' in video) video.requestVideoFrameCallback(updateVideo);
    }
    clone() {
        return new this.constructor(this.image).copy(this);
    }
    update() {
        const video = this.image;
        const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;
        if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) this.needsUpdate = true;
    }
}
VideoTexture.prototype.isVideoTexture = true;
class CompressedTexture extends Texture {
    constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding){
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = {
            width: width,
            height: height
        };
        this.mipmaps = mipmaps;
        // no flipping for cube textures
        // (also flipping doesn't work for compressed textures )
        this.flipY = false;
        // can't generate mipmaps for compressed textures
        // mips must be embedded in DDS files
        this.generateMipmaps = false;
    }
}
CompressedTexture.prototype.isCompressedTexture = true;
class CanvasTexture extends Texture {
    constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy){
        super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.needsUpdate = true;
    }
}
CanvasTexture.prototype.isCanvasTexture = true;
class DepthTexture extends Texture {
    constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format){
        format = format !== undefined ? format : DepthFormat;
        if (format !== DepthFormat && format !== DepthStencilFormat) throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
        if (type === undefined && format === DepthFormat) type = UnsignedShortType;
        if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.image = {
            width: width,
            height: height
        };
        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
        this.flipY = false;
        this.generateMipmaps = false;
    }
}
DepthTexture.prototype.isDepthTexture = true;
class CircleGeometry extends BufferGeometry {
    constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2){
        super();
        this.type = 'CircleGeometry';
        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        segments = Math.max(3, segments);
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        const vertex = new Vector3();
        const uv = new Vector2();
        // center point
        vertices.push(0, 0, 0);
        normals.push(0, 0, 1);
        uvs.push(0.5, 0.5);
        for(let s = 0, i176 = 3; s <= segments; s++, i176 += 3){
            const segment = thetaStart + s / segments * thetaLength;
            // vertex
            vertex.x = radius * Math.cos(segment);
            vertex.y = radius * Math.sin(segment);
            vertices.push(vertex.x, vertex.y, vertex.z);
            // normal
            normals.push(0, 0, 1);
            // uvs
            uv.x = (vertices[i176] / radius + 1) / 2;
            uv.y = (vertices[i176 + 1] / radius + 1) / 2;
            uvs.push(uv.x, uv.y);
        }
        // indices
        for(let i175 = 1; i175 <= segments; i175++)indices.push(i175, i175 + 1, 0);
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    static fromJSON(data) {
        return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
    }
}
class CylinderGeometry extends BufferGeometry {
    constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2){
        super();
        this.type = 'CylinderGeometry';
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        const scope = this;
        radialSegments = Math.floor(radialSegments);
        heightSegments = Math.floor(heightSegments);
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        let index = 0;
        const indexArray = [];
        const halfHeight = height / 2;
        let groupStart = 0;
        // generate geometry
        generateTorso();
        if (openEnded === false) {
            if (radiusTop > 0) generateCap(true);
            if (radiusBottom > 0) generateCap(false);
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        function generateTorso() {
            const normal = new Vector3();
            const vertex = new Vector3();
            let groupCount = 0;
            // this will be used to calculate the normal
            const slope = (radiusBottom - radiusTop) / height;
            // generate vertices, normals and uvs
            for(let y = 0; y <= heightSegments; y++){
                const indexRow = [];
                const v = y / heightSegments;
                // calculate the radius of the current row
                const radius = v * (radiusBottom - radiusTop) + radiusTop;
                for(let x = 0; x <= radialSegments; x++){
                    const u = x / radialSegments;
                    const theta = u * thetaLength + thetaStart;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    // vertex
                    vertex.x = radius * sinTheta;
                    vertex.y = -v * height + halfHeight;
                    vertex.z = radius * cosTheta;
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // normal
                    normal.set(sinTheta, slope, cosTheta).normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    // uv
                    uvs.push(u, 1 - v);
                    // save index of vertex in respective row
                    indexRow.push(index++);
                }
                // now save vertices of the row in our index array
                indexArray.push(indexRow);
            }
            // generate indices
            for(let x = 0; x < radialSegments; x++)for(let y3 = 0; y3 < heightSegments; y3++){
                // we use the index array to access the correct indices
                const a = indexArray[y3][x];
                const b = indexArray[y3 + 1][x];
                const c = indexArray[y3 + 1][x + 1];
                const d = indexArray[y3][x + 1];
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
                // update group counter
                groupCount += 6;
            }
            // add a group to the geometry. this will ensure multi material support
            scope.addGroup(groupStart, groupCount, 0);
            // calculate new start value for groups
            groupStart += groupCount;
        }
        function generateCap(top) {
            // save the index of the first center vertex
            const centerIndexStart = index;
            const uv = new Vector2();
            const vertex = new Vector3();
            let groupCount = 0;
            const radius = top === true ? radiusTop : radiusBottom;
            const sign2 = top === true ? 1 : -1;
            // first we generate the center vertex data of the cap.
            // because the geometry needs one set of uvs per face,
            // we must generate a center vertex per face/segment
            for(let x = 1; x <= radialSegments; x++){
                // vertex
                vertices.push(0, halfHeight * sign2, 0);
                // normal
                normals.push(0, sign2, 0);
                // uv
                uvs.push(0.5, 0.5);
                // increase index
                index++;
            }
            // save the index of the last center vertex
            const centerIndexEnd = index;
            // now we generate the surrounding vertices, normals and uvs
            for(let x3 = 0; x3 <= radialSegments; x3++){
                const u = x3 / radialSegments;
                const theta = u * thetaLength + thetaStart;
                const cosTheta = Math.cos(theta);
                const sinTheta = Math.sin(theta);
                // vertex
                vertex.x = radius * sinTheta;
                vertex.y = halfHeight * sign2;
                vertex.z = radius * cosTheta;
                vertices.push(vertex.x, vertex.y, vertex.z);
                // normal
                normals.push(0, sign2, 0);
                // uv
                uv.x = cosTheta * 0.5 + 0.5;
                uv.y = sinTheta * 0.5 * sign2 + 0.5;
                uvs.push(uv.x, uv.y);
                // increase index
                index++;
            }
            // generate indices
            for(let x4 = 0; x4 < radialSegments; x4++){
                const c = centerIndexStart + x4;
                const i177 = centerIndexEnd + x4;
                if (top === true) // face top
                indices.push(i177, i177 + 1, c);
                else // face bottom
                indices.push(i177 + 1, i177, c);
                groupCount += 3;
            }
            // add a group to the geometry. this will ensure multi material support
            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
            // calculate new start value for groups
            groupStart += groupCount;
        }
    }
    static fromJSON(data) {
        return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
    }
}
class ConeGeometry extends CylinderGeometry {
    constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2){
        super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        this.type = 'ConeGeometry';
        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    static fromJSON(data) {
        return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
    }
}
class PolyhedronGeometry extends BufferGeometry {
    constructor(vertices, indices, radius1 = 1, detail1 = 0){
        super();
        this.type = 'PolyhedronGeometry';
        this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius1,
            detail: detail1
        };
        // default buffer data
        const vertexBuffer = [];
        const uvBuffer = [];
        // the subdivision creates the vertex buffer data
        subdivide(detail1);
        // all vertices should lie on a conceptual sphere with a given radius
        applyRadius(radius1);
        // finally, create the uv data
        generateUVs();
        // build non-indexed geometry
        this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
        this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
        if (detail1 === 0) this.computeVertexNormals(); // flat normals
        else this.normalizeNormals(); // smooth normals
        // helper functions
        function subdivide(detail) {
            const a = new Vector3();
            const b = new Vector3();
            const c = new Vector3();
            // iterate over all faces and apply a subdivison with the given detail value
            for(let i178 = 0; i178 < indices.length; i178 += 3){
                // get the vertices of the face
                getVertexByIndex(indices[i178 + 0], a);
                getVertexByIndex(indices[i178 + 1], b);
                getVertexByIndex(indices[i178 + 2], c);
                // perform subdivision
                subdivideFace(a, b, c, detail);
            }
        }
        function subdivideFace(a, b, c, detail) {
            const cols = detail + 1;
            // we use this multidimensional array as a data structure for creating the subdivision
            const v = [];
            // construct all of the vertices for this subdivision
            for(let i180 = 0; i180 <= cols; i180++){
                v[i180] = [];
                const aj = a.clone().lerp(c, i180 / cols);
                const bj = b.clone().lerp(c, i180 / cols);
                const rows = cols - i180;
                for(let j = 0; j <= rows; j++)if (j === 0 && i180 === cols) v[i180][j] = aj;
                else v[i180][j] = aj.clone().lerp(bj, j / rows);
            }
            // construct all of the faces
            for(let i179 = 0; i179 < cols; i179++)for(let j = 0; j < 2 * (cols - i179) - 1; j++){
                const k = Math.floor(j / 2);
                if (j % 2 === 0) {
                    pushVertex(v[i179][k + 1]);
                    pushVertex(v[i179 + 1][k]);
                    pushVertex(v[i179][k]);
                } else {
                    pushVertex(v[i179][k + 1]);
                    pushVertex(v[i179 + 1][k + 1]);
                    pushVertex(v[i179 + 1][k]);
                }
            }
        }
        function applyRadius(radius) {
            const vertex = new Vector3();
            // iterate over the entire buffer and apply the radius to each vertex
            for(let i181 = 0; i181 < vertexBuffer.length; i181 += 3){
                vertex.x = vertexBuffer[i181 + 0];
                vertex.y = vertexBuffer[i181 + 1];
                vertex.z = vertexBuffer[i181 + 2];
                vertex.normalize().multiplyScalar(radius);
                vertexBuffer[i181 + 0] = vertex.x;
                vertexBuffer[i181 + 1] = vertex.y;
                vertexBuffer[i181 + 2] = vertex.z;
            }
        }
        function generateUVs() {
            const vertex = new Vector3();
            for(let i182 = 0; i182 < vertexBuffer.length; i182 += 3){
                vertex.x = vertexBuffer[i182 + 0];
                vertex.y = vertexBuffer[i182 + 1];
                vertex.z = vertexBuffer[i182 + 2];
                const u = azimuth1(vertex) / 2 / Math.PI + 0.5;
                const v = inclination(vertex) / Math.PI + 0.5;
                uvBuffer.push(u, 1 - v);
            }
            correctUVs();
            correctSeam();
        }
        function correctSeam() {
            // handle case when face straddles the seam, see #3269
            for(let i183 = 0; i183 < uvBuffer.length; i183 += 6){
                // uv data of a single face
                const x0 = uvBuffer[i183 + 0];
                const x1 = uvBuffer[i183 + 2];
                const x2 = uvBuffer[i183 + 4];
                const max = Math.max(x0, x1, x2);
                const min = Math.min(x0, x1, x2);
                // 0.9 is somewhat arbitrary
                if (max > 0.9 && min < 0.1) {
                    if (x0 < 0.2) uvBuffer[i183 + 0] += 1;
                    if (x1 < 0.2) uvBuffer[i183 + 2] += 1;
                    if (x2 < 0.2) uvBuffer[i183 + 4] += 1;
                }
            }
        }
        function pushVertex(vertex) {
            vertexBuffer.push(vertex.x, vertex.y, vertex.z);
        }
        function getVertexByIndex(index, vertex) {
            const stride = index * 3;
            vertex.x = vertices[stride + 0];
            vertex.y = vertices[stride + 1];
            vertex.z = vertices[stride + 2];
        }
        function correctUVs() {
            const a = new Vector3();
            const b = new Vector3();
            const c = new Vector3();
            const centroid = new Vector3();
            const uvA = new Vector2();
            const uvB = new Vector2();
            const uvC = new Vector2();
            for(let i184 = 0, j = 0; i184 < vertexBuffer.length; i184 += 9, j += 6){
                a.set(vertexBuffer[i184 + 0], vertexBuffer[i184 + 1], vertexBuffer[i184 + 2]);
                b.set(vertexBuffer[i184 + 3], vertexBuffer[i184 + 4], vertexBuffer[i184 + 5]);
                c.set(vertexBuffer[i184 + 6], vertexBuffer[i184 + 7], vertexBuffer[i184 + 8]);
                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                centroid.copy(a).add(b).add(c).divideScalar(3);
                const azi = azimuth1(centroid);
                correctUV(uvA, j + 0, a, azi);
                correctUV(uvB, j + 2, b, azi);
                correctUV(uvC, j + 4, c, azi);
            }
        }
        function correctUV(uv, stride, vector, azimuth) {
            if (azimuth < 0 && uv.x === 1) uvBuffer[stride] = uv.x - 1;
            if (vector.x === 0 && vector.z === 0) uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
        }
        // Angle around the Y axis, counter-clockwise when looking from above.
        function azimuth1(vector) {
            return Math.atan2(vector.z, -vector.x);
        }
        // Angle above the XZ plane.
        function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
        }
    }
    static fromJSON(data) {
        return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
    }
}
class DodecahedronGeometry extends PolyhedronGeometry {
    constructor(radius = 1, detail = 0){
        const t = (1 + Math.sqrt(5)) / 2;
        const r = 1 / t;
        const vertices = [
            // (Â±1, Â±1, Â±1)
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            // (0, Â±1/Ï†, Â±Ï†)
            0,
            -r,
            -t,
            0,
            -r,
            t,
            0,
            r,
            -t,
            0,
            r,
            t,
            // (Â±1/Ï†, Â±Ï†, 0)
            -r,
            -t,
            0,
            -r,
            t,
            0,
            r,
            -t,
            0,
            r,
            t,
            0,
            // (Â±Ï†, 0, Â±1/Ï†)
            -t,
            0,
            -r,
            t,
            0,
            -r,
            -t,
            0,
            r,
            t,
            0,
            r
        ];
        const indices = [
            3,
            11,
            7,
            3,
            7,
            15,
            3,
            15,
            13,
            7,
            19,
            17,
            7,
            17,
            6,
            7,
            6,
            15,
            17,
            4,
            8,
            17,
            8,
            10,
            17,
            10,
            6,
            8,
            0,
            16,
            8,
            16,
            2,
            8,
            2,
            10,
            0,
            12,
            1,
            0,
            1,
            18,
            0,
            18,
            16,
            6,
            10,
            2,
            6,
            2,
            13,
            6,
            13,
            15,
            2,
            16,
            18,
            2,
            18,
            3,
            2,
            3,
            13,
            18,
            1,
            9,
            18,
            9,
            11,
            18,
            11,
            3,
            4,
            14,
            12,
            4,
            12,
            0,
            4,
            0,
            8,
            11,
            9,
            5,
            11,
            5,
            19,
            11,
            19,
            7,
            19,
            5,
            14,
            19,
            14,
            4,
            19,
            4,
            17,
            1,
            12,
            14,
            1,
            14,
            5,
            1,
            5,
            9
        ];
        super(vertices, indices, radius, detail);
        this.type = 'DodecahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    static fromJSON(data) {
        return new DodecahedronGeometry(data.radius, data.detail);
    }
}
const _v0 = new Vector3();
const _v1$1 = new Vector3();
const _normal = new Vector3();
const _triangle = new Triangle();
class EdgesGeometry extends BufferGeometry {
    constructor(geometry, thresholdAngle){
        super();
        this.type = 'EdgesGeometry';
        this.parameters = {
            thresholdAngle: thresholdAngle
        };
        thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;
        if (geometry.isGeometry === true) {
            console.error('THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
            return;
        }
        const precisionPoints = 4;
        const precision = Math.pow(10, precisionPoints);
        const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
        const indexAttr = geometry.getIndex();
        const positionAttr = geometry.getAttribute('position');
        const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
        const indexArr = [
            0,
            0,
            0
        ];
        const vertKeys = [
            'a',
            'b',
            'c'
        ];
        const hashes = new Array(3);
        const edgeData = {};
        const vertices = [];
        for(let i185 = 0; i185 < indexCount; i185 += 3){
            if (indexAttr) {
                indexArr[0] = indexAttr.getX(i185);
                indexArr[1] = indexAttr.getX(i185 + 1);
                indexArr[2] = indexAttr.getX(i185 + 2);
            } else {
                indexArr[0] = i185;
                indexArr[1] = i185 + 1;
                indexArr[2] = i185 + 2;
            }
            const { a , b , c  } = _triangle;
            a.fromBufferAttribute(positionAttr, indexArr[0]);
            b.fromBufferAttribute(positionAttr, indexArr[1]);
            c.fromBufferAttribute(positionAttr, indexArr[2]);
            _triangle.getNormal(_normal);
            // create hashes for the edge from the vertices
            hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
            hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
            hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
            // skip degenerate triangles
            if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) continue;
            // iterate over every edge
            for(let j = 0; j < 3; j++){
                // get the first and next vertex making up the edge
                const jNext = (j + 1) % 3;
                const vecHash0 = hashes[j];
                const vecHash1 = hashes[jNext];
                const v0 = _triangle[vertKeys[j]];
                const v1 = _triangle[vertKeys[jNext]];
                const hash = `${vecHash0}_${vecHash1}`;
                const reverseHash = `${vecHash1}_${vecHash0}`;
                if (reverseHash in edgeData && edgeData[reverseHash]) {
                    // if we found a sibling edge add it into the vertex array if
                    // it meets the angle threshold and delete the edge from the map.
                    if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                        vertices.push(v0.x, v0.y, v0.z);
                        vertices.push(v1.x, v1.y, v1.z);
                    }
                    edgeData[reverseHash] = null;
                } else if (!(hash in edgeData)) // if we've already got an edge here then skip adding a new one
                edgeData[hash] = {
                    index0: indexArr[j],
                    index1: indexArr[jNext],
                    normal: _normal.clone()
                };
            }
        }
        // iterate over all remaining, unmatched edges and add them to the vertex array
        for(const key in edgeData)if (edgeData[key]) {
            const { index0 , index1  } = edgeData[key];
            _v0.fromBufferAttribute(positionAttr, index0);
            _v1$1.fromBufferAttribute(positionAttr, index1);
            vertices.push(_v0.x, _v0.y, _v0.z);
            vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    }
}
/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/ class Curve {
    constructor(){
        this.type = 'Curve';
        this.arcLengthDivisions = 200;
    }
    // Virtual base class method to overwrite and implement in subclasses
    //	- t [0 .. 1]
    getPoint() {
        console.warn('THREE.Curve: .getPoint() not implemented.');
        return null;
    }
    // Get point at relative position in curve according to arc length
    // - u [0 .. 1]
    getPointAt(u, optionalTarget) {
        const t = this.getUtoTmapping(u);
        return this.getPoint(t, optionalTarget);
    }
    // Get sequence of points using getPoint( t )
    getPoints(divisions = 5) {
        const points = [];
        for(let d = 0; d <= divisions; d++)points.push(this.getPoint(d / divisions));
        return points;
    }
    // Get sequence of points using getPointAt( u )
    getSpacedPoints(divisions = 5) {
        const points = [];
        for(let d = 0; d <= divisions; d++)points.push(this.getPointAt(d / divisions));
        return points;
    }
    // Get total curve arc length
    getLength() {
        const lengths = this.getLengths();
        return lengths[lengths.length - 1];
    }
    // Get list of cumulative segment lengths
    getLengths(divisions = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = false;
        const cache = [];
        let current, last = this.getPoint(0);
        let sum = 0;
        cache.push(0);
        for(let p = 1; p <= divisions; p++){
            current = this.getPoint(p / divisions);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
        }
        this.cacheArcLengths = cache;
        return cache; // { sums: cache, sum: sum }; Sum is in the last element.
    }
    updateArcLengths() {
        this.needsUpdate = true;
        this.getLengths();
    }
    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
    getUtoTmapping(u, distance) {
        const arcLengths = this.getLengths();
        let i186 = 0;
        const il = arcLengths.length;
        let targetArcLength; // The targeted u distance value to get
        if (distance) targetArcLength = distance;
        else targetArcLength = u * arcLengths[il - 1];
        // binary search for the index with largest value smaller than target u distance
        let low = 0, high = il - 1, comparison;
        while(low <= high){
            i186 = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
            comparison = arcLengths[i186] - targetArcLength;
            if (comparison < 0) low = i186 + 1;
            else if (comparison > 0) high = i186 - 1;
            else {
                high = i186;
                break;
            // DONE
            }
        }
        i186 = high;
        if (arcLengths[i186] === targetArcLength) return i186 / (il - 1);
        // we could get finer grain at lengths, or use simple interpolation between two points
        const lengthBefore = arcLengths[i186];
        const lengthAfter = arcLengths[i186 + 1];
        const segmentLength = lengthAfter - lengthBefore;
        // determine where we are between the 'before' and 'after' points
        const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        // add that fractional amount to t
        const t = (i186 + segmentFraction) / (il - 1);
        return t;
    }
    // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation
    getTangent(t, optionalTarget) {
        const delta = 0.0001;
        let t1 = t - delta;
        let t2 = t + delta;
        // Capping in case of danger
        if (t1 < 0) t1 = 0;
        if (t2 > 1) t2 = 1;
        const pt1 = this.getPoint(t1);
        const pt2 = this.getPoint(t2);
        const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
        tangent.copy(pt2).sub(pt1).normalize();
        return tangent;
    }
    getTangentAt(u, optionalTarget) {
        const t = this.getUtoTmapping(u);
        return this.getTangent(t, optionalTarget);
    }
    computeFrenetFrames(segments, closed) {
        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
        const normal = new Vector3();
        const tangents = [];
        const normals = [];
        const binormals = [];
        const vec = new Vector3();
        const mat = new Matrix4();
        // compute the tangent vectors for each segment on the curve
        for(let i188 = 0; i188 <= segments; i188++){
            const u = i188 / segments;
            tangents[i188] = this.getTangentAt(u, new Vector3());
            tangents[i188].normalize();
        }
        // select an initial normal vector perpendicular to the first tangent vector,
        // and in the direction of the minimum tangent xyz component
        normals[0] = new Vector3();
        binormals[0] = new Vector3();
        let min = Number.MAX_VALUE;
        const tx = Math.abs(tangents[0].x);
        const ty = Math.abs(tangents[0].y);
        const tz = Math.abs(tangents[0].z);
        if (tx <= min) {
            min = tx;
            normal.set(1, 0, 0);
        }
        if (ty <= min) {
            min = ty;
            normal.set(0, 1, 0);
        }
        if (tz <= min) normal.set(0, 0, 1);
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
        // compute the slowly-varying normal and binormal vectors for each segment on the curve
        for(let i187 = 1; i187 <= segments; i187++){
            normals[i187] = normals[i187 - 1].clone();
            binormals[i187] = binormals[i187 - 1].clone();
            vec.crossVectors(tangents[i187 - 1], tangents[i187]);
            if (vec.length() > Number.EPSILON) {
                vec.normalize();
                const theta = Math.acos(clamp(tangents[i187 - 1].dot(tangents[i187]), -1, 1)); // clamp for floating pt errors
                normals[i187].applyMatrix4(mat.makeRotationAxis(vec, theta));
            }
            binormals[i187].crossVectors(tangents[i187], normals[i187]);
        }
        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
        if (closed === true) {
            let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
            theta /= segments;
            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) theta = -theta;
            for(let i189 = 1; i189 <= segments; i189++){
                // twist a little...
                normals[i189].applyMatrix4(mat.makeRotationAxis(tangents[i189], theta * i189));
                binormals[i189].crossVectors(tangents[i189], normals[i189]);
            }
        }
        return {
            tangents: tangents,
            normals: normals,
            binormals: binormals
        };
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
    }
    toJSON() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'Curve',
                generator: 'Curve.toJSON'
            }
        };
        data.arcLengthDivisions = this.arcLengthDivisions;
        data.type = this.type;
        return data;
    }
    fromJSON(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
    }
}
class EllipseCurve extends Curve {
    constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0){
        super();
        this.type = 'EllipseCurve';
        this.aX = aX;
        this.aY = aY;
        this.xRadius = xRadius;
        this.yRadius = yRadius;
        this.aStartAngle = aStartAngle;
        this.aEndAngle = aEndAngle;
        this.aClockwise = aClockwise;
        this.aRotation = aRotation;
    }
    getPoint(t, optionalTarget) {
        const point = optionalTarget || new Vector2();
        const twoPi = Math.PI * 2;
        let deltaAngle = this.aEndAngle - this.aStartAngle;
        const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
        // ensures that deltaAngle is 0 .. 2 PI
        while(deltaAngle < 0)deltaAngle += twoPi;
        while(deltaAngle > twoPi)deltaAngle -= twoPi;
        if (deltaAngle < Number.EPSILON) {
            if (samePoints) deltaAngle = 0;
            else deltaAngle = twoPi;
        }
        if (this.aClockwise === true && !samePoints) {
            if (deltaAngle === twoPi) deltaAngle = -twoPi;
            else deltaAngle = deltaAngle - twoPi;
        }
        const angle = this.aStartAngle + t * deltaAngle;
        let x = this.aX + this.xRadius * Math.cos(angle);
        let y = this.aY + this.yRadius * Math.sin(angle);
        if (this.aRotation !== 0) {
            const cos = Math.cos(this.aRotation);
            const sin = Math.sin(this.aRotation);
            const tx = x - this.aX;
            const ty = y - this.aY;
            // Rotate the point about the center of the ellipse.
            x = tx * cos - ty * sin + this.aX;
            y = tx * sin + ty * cos + this.aY;
        }
        return point.set(x, y);
    }
    copy(source) {
        super.copy(source);
        this.aX = source.aX;
        this.aY = source.aY;
        this.xRadius = source.xRadius;
        this.yRadius = source.yRadius;
        this.aStartAngle = source.aStartAngle;
        this.aEndAngle = source.aEndAngle;
        this.aClockwise = source.aClockwise;
        this.aRotation = source.aRotation;
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.aX = this.aX;
        data.aY = this.aY;
        data.xRadius = this.xRadius;
        data.yRadius = this.yRadius;
        data.aStartAngle = this.aStartAngle;
        data.aEndAngle = this.aEndAngle;
        data.aClockwise = this.aClockwise;
        data.aRotation = this.aRotation;
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.aX = json.aX;
        this.aY = json.aY;
        this.xRadius = json.xRadius;
        this.yRadius = json.yRadius;
        this.aStartAngle = json.aStartAngle;
        this.aEndAngle = json.aEndAngle;
        this.aClockwise = json.aClockwise;
        this.aRotation = json.aRotation;
        return this;
    }
}
EllipseCurve.prototype.isEllipseCurve = true;
class ArcCurve extends EllipseCurve {
    constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise){
        super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        this.type = 'ArcCurve';
    }
}
ArcCurve.prototype.isArcCurve = true;
/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */ /*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/ function CubicPoly() {
    let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
    /*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */ function init(x0, x1, t0, t1) {
        c0 = x0;
        c1 = t0;
        c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
        c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }
    return {
        initCatmullRom: function(x0, x1, x2, x3, tension) {
            init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
        },
        initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
            // compute tangents when parameterized in [t1,t2]
            let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
            let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
            // rescale tangents for parametrization in [0,1]
            t1 *= dt1;
            t2 *= dt1;
            init(x1, x2, t1, t2);
        },
        calc: function(t) {
            const t2 = t * t;
            const t3 = t2 * t;
            return c0 + c1 * t + c2 * t2 + c3 * t3;
        }
    };
}
//
const tmp = new Vector3();
const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
class CatmullRomCurve3 extends Curve {
    constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5){
        super();
        this.type = 'CatmullRomCurve3';
        this.points = points;
        this.closed = closed;
        this.curveType = curveType;
        this.tension = tension;
    }
    getPoint(t, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        const points = this.points;
        const l = points.length;
        const p = (l - (this.closed ? 0 : 1)) * t;
        let intPoint = Math.floor(p);
        let weight = p - intPoint;
        if (this.closed) intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
        else if (weight === 0 && intPoint === l - 1) {
            intPoint = l - 2;
            weight = 1;
        }
        let p0, p3; // 4 points (p1 & p2 defined below)
        if (this.closed || intPoint > 0) p0 = points[(intPoint - 1) % l];
        else {
            // extrapolate first point
            tmp.subVectors(points[0], points[1]).add(points[0]);
            p0 = tmp;
        }
        const p1 = points[intPoint % l];
        const p2 = points[(intPoint + 1) % l];
        if (this.closed || intPoint + 2 < l) p3 = points[(intPoint + 2) % l];
        else {
            // extrapolate last point
            tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
            p3 = tmp;
        }
        if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
            // init Centripetal / Chordal Catmull-Rom
            const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
            let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
            let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
            let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
            // safety check for repeated points
            if (dt1 < 0.0001) dt1 = 1;
            if (dt0 < 0.0001) dt0 = dt1;
            if (dt2 < 0.0001) dt2 = dt1;
            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else if (this.curveType === 'catmullrom') {
            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
        }
        point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.points = [];
        for(let i190 = 0, l = source.points.length; i190 < l; i190++){
            const point = source.points[i190];
            this.points.push(point.clone());
        }
        this.closed = source.closed;
        this.curveType = source.curveType;
        this.tension = source.tension;
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.points = [];
        for(let i191 = 0, l = this.points.length; i191 < l; i191++){
            const point = this.points[i191];
            data.points.push(point.toArray());
        }
        data.closed = this.closed;
        data.curveType = this.curveType;
        data.tension = this.tension;
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.points = [];
        for(let i192 = 0, l = json.points.length; i192 < l; i192++){
            const point = json.points[i192];
            this.points.push(new Vector3().fromArray(point));
        }
        this.closed = json.closed;
        this.curveType = json.curveType;
        this.tension = json.tension;
        return this;
    }
}
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
/**
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/BÃ©zier_curve
 */ function CatmullRom(t, p0, p1, p2, p3) {
    const v0 = (p2 - p0) * 0.5;
    const v1 = (p3 - p1) * 0.5;
    const t2 = t * t;
    const t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
//
function QuadraticBezierP0(t, p) {
    const k = 1 - t;
    return k * k * p;
}
function QuadraticBezierP1(t, p) {
    return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
    return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
    return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}
//
function CubicBezierP0(t, p) {
    const k = 1 - t;
    return k * k * k * p;
}
function CubicBezierP1(t, p) {
    const k = 1 - t;
    return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
    return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
    return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
    return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}
class CubicBezierCurve extends Curve {
    constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()){
        super();
        this.type = 'CubicBezierCurve';
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    }
    getPoint(t, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
    }
}
CubicBezierCurve.prototype.isCubicBezierCurve = true;
class CubicBezierCurve3 extends Curve {
    constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()){
        super();
        this.type = 'CubicBezierCurve3';
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    }
    getPoint(t, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
    }
}
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
class LineCurve extends Curve {
    constructor(v1 = new Vector2(), v2 = new Vector2()){
        super();
        this.type = 'LineCurve';
        this.v1 = v1;
        this.v2 = v2;
    }
    getPoint(t, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        if (t === 1) point.copy(this.v2);
        else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
        }
        return point;
    }
    // Line curve is linear, so we can overwrite default getPointAt
    getPointAt(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
    }
    getTangent(t, optionalTarget) {
        const tangent = optionalTarget || new Vector2();
        tangent.copy(this.v2).sub(this.v1).normalize();
        return tangent;
    }
    copy(source) {
        super.copy(source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
}
LineCurve.prototype.isLineCurve = true;
class LineCurve3 extends Curve {
    constructor(v1 = new Vector3(), v2 = new Vector3()){
        super();
        this.type = 'LineCurve3';
        this.isLineCurve3 = true;
        this.v1 = v1;
        this.v2 = v2;
    }
    getPoint(t, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        if (t === 1) point.copy(this.v2);
        else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
        }
        return point;
    }
    // Line curve is linear, so we can overwrite default getPointAt
    getPointAt(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
    }
    copy(source) {
        super.copy(source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
}
class QuadraticBezierCurve extends Curve {
    constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()){
        super();
        this.type = 'QuadraticBezierCurve';
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
    }
    getPoint(t, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2;
        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
}
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
class QuadraticBezierCurve3 extends Curve {
    constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()){
        super();
        this.type = 'QuadraticBezierCurve3';
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
    }
    getPoint(t, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2;
        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
}
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
class SplineCurve extends Curve {
    constructor(points = []){
        super();
        this.type = 'SplineCurve';
        this.points = points;
    }
    getPoint(t, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        const points = this.points;
        const p = (points.length - 1) * t;
        const intPoint = Math.floor(p);
        const weight = p - intPoint;
        const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
        const p1 = points[intPoint];
        const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
        const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
        point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.points = [];
        for(let i193 = 0, l = source.points.length; i193 < l; i193++){
            const point = source.points[i193];
            this.points.push(point.clone());
        }
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.points = [];
        for(let i194 = 0, l = this.points.length; i194 < l; i194++){
            const point = this.points[i194];
            data.points.push(point.toArray());
        }
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.points = [];
        for(let i195 = 0, l = json.points.length; i195 < l; i195++){
            const point = json.points[i195];
            this.points.push(new Vector2().fromArray(point));
        }
        return this;
    }
}
SplineCurve.prototype.isSplineCurve = true;
var Curves = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ArcCurve: ArcCurve,
    CatmullRomCurve3: CatmullRomCurve3,
    CubicBezierCurve: CubicBezierCurve,
    CubicBezierCurve3: CubicBezierCurve3,
    EllipseCurve: EllipseCurve,
    LineCurve: LineCurve,
    LineCurve3: LineCurve3,
    QuadraticBezierCurve: QuadraticBezierCurve,
    QuadraticBezierCurve3: QuadraticBezierCurve3,
    SplineCurve: SplineCurve
});
/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */ const Earcut = {
    triangulate: function(data, holeIndices, dim = 2) {
        const hasHoles = holeIndices && holeIndices.length;
        const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        let outerNode = linkedList(data, 0, outerLen, dim, true);
        const triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) return triangles;
        let minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for(let i196 = dim; i196 < outerLen; i196 += dim){
                x = data[i196];
                y = data[i196 + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
};
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    let i197, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) for(i197 = start; i197 < end; i197 += dim)last = insertNode(i197, data[i197], data[i197 + 1], last);
    else for(i197 = end - dim; i197 >= start; i197 -= dim)last = insertNode(i197, data[i197], data[i197 + 1], last);
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    let p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
        } else p = p.next;
    }while (again || p !== end)
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) splitEarcut(ear, triangles, dim, minX, minY, invSize);
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    let p = ear.next.next;
    while(p !== ear.prev){
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // triangle bbox; min & max are calculated like this for speed
    const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
    // z-order range for the current triangle bbox;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p = ear.prevZ, n = ear.nextZ;
    // look for points inside the triangle in both directions
    while(p && p.z >= minZ && n && n.z <= maxZ){
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while(p && p.z >= minZ){
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    // look for remaining points in increasing z-order
    while(n && n.z <= maxZ){
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
        const a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    }while (p !== start)
    return filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    let a = start;
    do {
        let b = a.next.next;
        while(b !== a.prev){
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                let c = splitPolygon(a, b);
                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    }while (a !== start)
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    let i198, len, start, end, list;
    for(i198 = 0, len = holeIndices.length; i198 < len; i198++){
        start = holeIndices[i198] * dim;
        end = i198 < len - 1 ? holeIndices[i198 + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for(i198 = 0; i198 < queue.length; i198++){
        eliminateHole(queue[i198], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        const b = splitPolygon(outerNode, hole);
        // filter collinear points around the cuts
        filterPoints(outerNode, outerNode.next);
        filterPoints(b, b.next);
    }
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    }while (p !== outerNode)
    if (!m) return null;
    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    const stop = m, mx = m.x, my = m.y;
    let tanMin = Infinity, tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }while (p !== stop)
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start)
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    let i199, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i199 = 0; i199 < inSize; i199++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1)
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    let p = start, leftmost = start;
    do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
    }while (p !== start)
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px1, py1) {
    return (cx - px1) * (ay - py1) - (ax - px1) * (cy - py1) >= 0 && (ax - px1) * (by - py1) - (bx - px1) * (ay - py1) >= 0 && (bx - px1) * (cy - py1) - (cx - px1) * (by - py1) >= 0;
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}
// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case
    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    let p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
    }while (p !== a)
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    let p = a, inside = false;
    const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
    do {
        if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a)
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i200, x, y, last) {
    const p = new Node(i200, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i201, x, y) {
    // vertex index in coordinates array
    this.i = i201;
    // vertex coordinates
    this.x = x;
    this.y = y;
    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = null;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
function signedArea(data, start, end, dim) {
    let sum = 0;
    for(let i202 = start, j = end - dim; i202 < end; i202 += dim){
        sum += (data[j] - data[i202]) * (data[i202 + 1] + data[j + 1]);
        j = i202;
    }
    return sum;
}
class ShapeUtils {
    // calculate area of the contour polygon
    static area(contour) {
        const n = contour.length;
        let a = 0;
        for(let p = n - 1, q = 0; q < n; p = q++)a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        return a * 0.5;
    }
    static isClockWise(pts) {
        return ShapeUtils.area(pts) < 0;
    }
    static triangulateShape(contour, holes) {
        const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
        const holeIndices = []; // array of hole indices
        const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
        removeDupEndPts(contour);
        addContour(vertices, contour);
        //
        let holeIndex = contour.length;
        holes.forEach(removeDupEndPts);
        for(let i204 = 0; i204 < holes.length; i204++){
            holeIndices.push(holeIndex);
            holeIndex += holes[i204].length;
            addContour(vertices, holes[i204]);
        }
        //
        const triangles = Earcut.triangulate(vertices, holeIndices);
        //
        for(let i203 = 0; i203 < triangles.length; i203 += 3)faces.push(triangles.slice(i203, i203 + 3));
        return faces;
    }
}
function removeDupEndPts(points) {
    const l = points.length;
    if (l > 2 && points[l - 1].equals(points[0])) points.pop();
}
function addContour(vertices, contour) {
    for(let i205 = 0; i205 < contour.length; i205++){
        vertices.push(contour[i205].x);
        vertices.push(contour[i205].y);
    }
}
/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */ class ExtrudeGeometry extends BufferGeometry {
    constructor(shapes, options){
        super();
        this.type = 'ExtrudeGeometry';
        this.parameters = {
            shapes: shapes,
            options: options
        };
        shapes = Array.isArray(shapes) ? shapes : [
            shapes
        ];
        const scope = this;
        const verticesArray = [];
        const uvArray = [];
        for(let i206 = 0, l = shapes.length; i206 < l; i206++){
            const shape = shapes[i206];
            addShape(shape);
        }
        // build geometry
        this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
        this.computeVertexNormals();
        // functions
        function addShape(shape) {
            const placeholder = [];
            // options
            const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
            const steps = options.steps !== undefined ? options.steps : 1;
            let depth = options.depth !== undefined ? options.depth : 100;
            let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
            let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
            let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
            let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
            let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
            const extrudePath = options.extrudePath;
            const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;
            // deprecated options
            if (options.amount !== undefined) {
                console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
                depth = options.amount;
            }
            //
            let extrudePts, extrudeByPath = false;
            let splineTube, binormal, normal, position2;
            if (extrudePath) {
                extrudePts = extrudePath.getSpacedPoints(steps);
                extrudeByPath = true;
                bevelEnabled = false; // bevels not supported for path extrusion
                // SETUP TNB variables
                // TODO1 - have a .isClosed in spline?
                splineTube = extrudePath.computeFrenetFrames(steps, false);
                // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
                binormal = new Vector3();
                normal = new Vector3();
                position2 = new Vector3();
            }
            // Safeguards if bevels are not enabled
            if (!bevelEnabled) {
                bevelSegments = 0;
                bevelThickness = 0;
                bevelSize = 0;
                bevelOffset = 0;
            }
            // Variables initialization
            const shapePoints = shape.extractPoints(curveSegments);
            let vertices = shapePoints.shape;
            const holes = shapePoints.holes;
            const reverse = !ShapeUtils.isClockWise(vertices);
            if (reverse) {
                vertices = vertices.reverse();
                // Maybe we should also check if holes are in the opposite direction, just to be safe ...
                for(let h = 0, hl = holes.length; h < hl; h++){
                    const ahole = holes[h];
                    if (ShapeUtils.isClockWise(ahole)) holes[h] = ahole.reverse();
                }
            }
            const faces = ShapeUtils.triangulateShape(vertices, holes);
            /* Vertices */ const contour1 = vertices; // vertices has all points but contour has only points of circumference
            for(let h2 = 0, hl2 = holes.length; h2 < hl2; h2++){
                const ahole = holes[h2];
                vertices = vertices.concat(ahole);
            }
            function scalePt2(pt, vec, size) {
                if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
                return vec.clone().multiplyScalar(size).add(pt);
            }
            const vlen = vertices.length, flen = faces.length;
            // Find directions for point movement
            function getBevelVec(inPt, inPrev, inNext) {
                // computes for inPt the corresponding point inPt' on a new contour
                //   shifted by 1 unit (length of normalized vector) to the left
                // if we walk along contour clockwise, this new contour is outside the old one
                //
                // inPt' is the intersection of the two lines parallel to the two
                //  adjacent edges of inPt at a distance of 1 unit on the left side.
                let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
                // good reading for geometry algorithms (here: line-line intersection)
                // http://geomalgorithms.com/a05-_intersect-1.html
                const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
                const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
                const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
                // check for collinear edges
                const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
                if (Math.abs(collinear0) > Number.EPSILON) {
                    // not collinear
                    // length of vectors for normalizing
                    const v_prev_len = Math.sqrt(v_prev_lensq);
                    const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                    // shift adjacent points by unit vectors to the left
                    const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                    const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                    const ptNextShift_x = inNext.x - v_next_y / v_next_len;
                    const ptNextShift_y = inNext.y + v_next_x / v_next_len;
                    // scaling factor for v_prev to intersection point
                    const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                    // vector from inPt to intersection point
                    v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                    v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                    // Don't normalize!, otherwise sharp corners become ugly
                    //  but prevent crazy spikes
                    const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                    if (v_trans_lensq <= 2) return new Vector2(v_trans_x, v_trans_y);
                    else shrink_by = Math.sqrt(v_trans_lensq / 2);
                } else {
                    // handle special case of collinear edges
                    let direction_eq = false; // assumes: opposite
                    if (v_prev_x > Number.EPSILON) {
                        if (v_next_x > Number.EPSILON) direction_eq = true;
                    } else {
                        if (v_prev_x < -Number.EPSILON) {
                            if (v_next_x < -Number.EPSILON) direction_eq = true;
                        } else if (Math.sign(v_prev_y) === Math.sign(v_next_y)) direction_eq = true;
                    }
                    if (direction_eq) {
                        // console.log("Warning: lines are a straight sequence");
                        v_trans_x = -v_prev_y;
                        v_trans_y = v_prev_x;
                        shrink_by = Math.sqrt(v_prev_lensq);
                    } else {
                        // console.log("Warning: lines are a straight spike");
                        v_trans_x = v_prev_x;
                        v_trans_y = v_prev_y;
                        shrink_by = Math.sqrt(v_prev_lensq / 2);
                    }
                }
                return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            const contourMovements = [];
            for(let i209 = 0, il = contour1.length, j1 = il - 1, k1 = i209 + 1; i209 < il; i209++, j1++, k1++){
                if (j1 === il) j1 = 0;
                if (k1 === il) k1 = 0;
                //  (j)---(i)---(k)
                // console.log('i,j,k', i, j , k)
                contourMovements[i209] = getBevelVec(contour1[i209], contour1[j1], contour1[k1]);
            }
            const holesMovements = [];
            let oneHoleMovements, verticesMovements = contourMovements.concat();
            for(let h1 = 0, hl1 = holes.length; h1 < hl1; h1++){
                const ahole = holes[h1];
                oneHoleMovements = [];
                for(let i210 = 0, il = ahole.length, j = il - 1, k = i210 + 1; i210 < il; i210++, j++, k++){
                    if (j === il) j = 0;
                    if (k === il) k = 0;
                    //  (j)---(i)---(k)
                    oneHoleMovements[i210] = getBevelVec(ahole[i210], ahole[j], ahole[k]);
                }
                holesMovements.push(oneHoleMovements);
                verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            // Loop bevelSegments, 1 for the front, 1 for the back
            for(let b4 = 0; b4 < bevelSegments; b4++){
                //for ( b = bevelSegments; b > 0; b -- ) {
                const t = b4 / bevelSegments;
                const z = bevelThickness * Math.cos(t * Math.PI / 2);
                const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                // contract shape
                for(let i211 = 0, il = contour1.length; i211 < il; i211++){
                    const vert = scalePt2(contour1[i211], contourMovements[i211], bs);
                    v(vert.x, vert.y, -z);
                }
                // expand holes
                for(let h = 0, hl = holes.length; h < hl; h++){
                    const ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for(let i212 = 0, il = ahole.length; i212 < il; i212++){
                        const vert = scalePt2(ahole[i212], oneHoleMovements[i212], bs);
                        v(vert.x, vert.y, -z);
                    }
                }
            }
            const bs = bevelSize + bevelOffset;
            // Back facing vertices
            for(let i207 = 0; i207 < vlen; i207++){
                const vert = bevelEnabled ? scalePt2(vertices[i207], verticesMovements[i207], bs) : vertices[i207];
                if (!extrudeByPath) v(vert.x, vert.y, 0);
                else {
                    // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
                    normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                    position2.copy(extrudePts[0]).add(normal).add(binormal);
                    v(position2.x, position2.y, position2.z);
                }
            }
            // Add stepped vertices...
            // Including front facing vertices
            for(let s4 = 1; s4 <= steps; s4++)for(let i208 = 0; i208 < vlen; i208++){
                const vert = bevelEnabled ? scalePt2(vertices[i208], verticesMovements[i208], bs) : vertices[i208];
                if (!extrudeByPath) v(vert.x, vert.y, depth / steps * s4);
                else {
                    // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
                    normal.copy(splineTube.normals[s4]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[s4]).multiplyScalar(vert.y);
                    position2.copy(extrudePts[s4]).add(normal).add(binormal);
                    v(position2.x, position2.y, position2.z);
                }
            }
            // Add bevel segments planes
            //for ( b = 1; b <= bevelSegments; b ++ ) {
            for(let b3 = bevelSegments - 1; b3 >= 0; b3--){
                const t = b3 / bevelSegments;
                const z = bevelThickness * Math.cos(t * Math.PI / 2);
                const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                // contract shape
                for(let i213 = 0, il = contour1.length; i213 < il; i213++){
                    const vert = scalePt2(contour1[i213], contourMovements[i213], bs);
                    v(vert.x, vert.y, depth + z);
                }
                // expand holes
                for(let h = 0, hl = holes.length; h < hl; h++){
                    const ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for(let i214 = 0, il = ahole.length; i214 < il; i214++){
                        const vert = scalePt2(ahole[i214], oneHoleMovements[i214], bs);
                        if (!extrudeByPath) v(vert.x, vert.y, depth + z);
                        else v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                    }
                }
            }
            /* Faces */ // Top and bottom faces
            buildLidFaces();
            // Sides faces
            buildSideFaces();
            /////  Internal functions
            function buildLidFaces() {
                const start = verticesArray.length / 3;
                if (bevelEnabled) {
                    let layer = 0; // steps + 1
                    let offset = vlen * layer;
                    // Bottom faces
                    for(let i216 = 0; i216 < flen; i216++){
                        const face = faces[i216];
                        f3(face[2] + offset, face[1] + offset, face[0] + offset);
                    }
                    layer = steps + bevelSegments * 2;
                    offset = vlen * layer;
                    // Top faces
                    for(let i215 = 0; i215 < flen; i215++){
                        const face = faces[i215];
                        f3(face[0] + offset, face[1] + offset, face[2] + offset);
                    }
                } else {
                    // Bottom faces
                    for(let i218 = 0; i218 < flen; i218++){
                        const face = faces[i218];
                        f3(face[2], face[1], face[0]);
                    }
                    // Top faces
                    for(let i217 = 0; i217 < flen; i217++){
                        const face = faces[i217];
                        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                    }
                }
                scope.addGroup(start, verticesArray.length / 3 - start, 0);
            }
            // Create faces for the z-sides of the shape
            function buildSideFaces() {
                const start = verticesArray.length / 3;
                let layeroffset = 0;
                sidewalls(contour1, layeroffset);
                layeroffset += contour1.length;
                for(let h = 0, hl = holes.length; h < hl; h++){
                    const ahole = holes[h];
                    sidewalls(ahole, layeroffset);
                    //, true
                    layeroffset += ahole.length;
                }
                scope.addGroup(start, verticesArray.length / 3 - start, 1);
            }
            function sidewalls(contour, layeroffset) {
                let i219 = contour.length;
                while(--i219 >= 0){
                    const j = i219;
                    let k = i219 - 1;
                    if (k < 0) k = contour.length - 1;
                    //console.log('b', i,j, i-1, k,vertices.length);
                    for(let s = 0, sl = steps + bevelSegments * 2; s < sl; s++){
                        const slen1 = vlen * s;
                        const slen2 = vlen * (s + 1);
                        const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                        f4(a, b, c, d);
                    }
                }
            }
            function v(x, y, z) {
                placeholder.push(x);
                placeholder.push(y);
                placeholder.push(z);
            }
            function f3(a, b, c) {
                addVertex(a);
                addVertex(b);
                addVertex(c);
                const nextIndex = verticesArray.length / 3;
                const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[2]);
            }
            function f4(a, b, c, d) {
                addVertex(a);
                addVertex(b);
                addVertex(d);
                addVertex(b);
                addVertex(c);
                addVertex(d);
                const nextIndex = verticesArray.length / 3;
                const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[3]);
                addUV(uvs[1]);
                addUV(uvs[2]);
                addUV(uvs[3]);
            }
            function addVertex(index) {
                verticesArray.push(placeholder[index * 3 + 0]);
                verticesArray.push(placeholder[index * 3 + 1]);
                verticesArray.push(placeholder[index * 3 + 2]);
            }
            function addUV(vector2) {
                uvArray.push(vector2.x);
                uvArray.push(vector2.y);
            }
        }
    }
    toJSON() {
        const data = super.toJSON();
        const shapes = this.parameters.shapes;
        const options = this.parameters.options;
        return toJSON$1(shapes, options, data);
    }
    static fromJSON(data, shapes) {
        const geometryShapes = [];
        for(let j = 0, jl = data.shapes.length; j < jl; j++){
            const shape = shapes[data.shapes[j]];
            geometryShapes.push(shape);
        }
        const extrudePath = data.options.extrudePath;
        if (extrudePath !== undefined) data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
        return new ExtrudeGeometry(geometryShapes, data.options);
    }
}
const WorldUVGenerator = {
    generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        return [
            new Vector2(a_x, a_y),
            new Vector2(b_x, b_y),
            new Vector2(c_x, c_y)
        ];
    },
    generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const a_z = vertices[indexA * 3 + 2];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const b_z = vertices[indexB * 3 + 2];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        const c_z = vertices[indexC * 3 + 2];
        const d_x = vertices[indexD * 3];
        const d_y = vertices[indexD * 3 + 1];
        const d_z = vertices[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) return [
            new Vector2(a_x, 1 - a_z),
            new Vector2(b_x, 1 - b_z),
            new Vector2(c_x, 1 - c_z),
            new Vector2(d_x, 1 - d_z)
        ];
        else return [
            new Vector2(a_y, 1 - a_z),
            new Vector2(b_y, 1 - b_z),
            new Vector2(c_y, 1 - c_z),
            new Vector2(d_y, 1 - d_z)
        ];
    }
};
function toJSON$1(shapes, options, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) for(let i220 = 0, l = shapes.length; i220 < l; i220++){
        const shape = shapes[i220];
        data.shapes.push(shape.uuid);
    }
    else data.shapes.push(shapes.uuid);
    if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
    return data;
}
class IcosahedronGeometry extends PolyhedronGeometry {
    constructor(radius = 1, detail = 0){
        const t = (1 + Math.sqrt(5)) / 2;
        const vertices = [
            -1,
            t,
            0,
            1,
            t,
            0,
            -1,
            -t,
            0,
            1,
            -t,
            0,
            0,
            -1,
            t,
            0,
            1,
            t,
            0,
            -1,
            -t,
            0,
            1,
            -t,
            t,
            0,
            -1,
            t,
            0,
            1,
            -t,
            0,
            -1,
            -t,
            0,
            1
        ];
        const indices = [
            0,
            11,
            5,
            0,
            5,
            1,
            0,
            1,
            7,
            0,
            7,
            10,
            0,
            10,
            11,
            1,
            5,
            9,
            5,
            11,
            4,
            11,
            10,
            2,
            10,
            7,
            6,
            7,
            1,
            8,
            3,
            9,
            4,
            3,
            4,
            2,
            3,
            2,
            6,
            3,
            6,
            8,
            3,
            8,
            9,
            4,
            9,
            5,
            2,
            4,
            11,
            6,
            2,
            10,
            8,
            6,
            7,
            9,
            8,
            1
        ];
        super(vertices, indices, radius, detail);
        this.type = 'IcosahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    static fromJSON(data) {
        return new IcosahedronGeometry(data.radius, data.detail);
    }
}
class LatheGeometry extends BufferGeometry {
    constructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2){
        super();
        this.type = 'LatheGeometry';
        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };
        segments = Math.floor(segments);
        // clamp phiLength so it's in range of [ 0, 2PI ]
        phiLength = clamp(phiLength, 0, Math.PI * 2);
        // buffers
        const indices = [];
        const vertices = [];
        const uvs = [];
        // helper variables
        const inverseSegments = 1 / segments;
        const vertex = new Vector3();
        const uv = new Vector2();
        // generate vertices and uvs
        for(let i222 = 0; i222 <= segments; i222++){
            const phi = phiStart + i222 * inverseSegments * phiLength;
            const sin = Math.sin(phi);
            const cos = Math.cos(phi);
            for(let j = 0; j <= points.length - 1; j++){
                // vertex
                vertex.x = points[j].x * sin;
                vertex.y = points[j].y;
                vertex.z = points[j].x * cos;
                vertices.push(vertex.x, vertex.y, vertex.z);
                // uv
                uv.x = i222 / segments;
                uv.y = j / (points.length - 1);
                uvs.push(uv.x, uv.y);
            }
        }
        // indices
        for(let i221 = 0; i221 < segments; i221++)for(let j = 0; j < points.length - 1; j++){
            const base = j + i221 * points.length;
            const a = base;
            const b = base + points.length;
            const c = base + points.length + 1;
            const d = base + 1;
            // faces
            indices.push(a, b, d);
            indices.push(b, c, d);
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        // generate normals
        this.computeVertexNormals();
        // if the geometry is closed, we need to average the normals along the seam.
        // because the corresponding vertices are identical (but still have different UVs).
        if (phiLength === Math.PI * 2) {
            const normals = this.attributes.normal.array;
            const n1 = new Vector3();
            const n2 = new Vector3();
            const n = new Vector3();
            // this is the buffer offset for the last line of vertices
            const base = segments * points.length * 3;
            for(let i223 = 0, j = 0; i223 < points.length; i223++, j += 3){
                // select the normal of the vertex in the first line
                n1.x = normals[j + 0];
                n1.y = normals[j + 1];
                n1.z = normals[j + 2];
                // select the normal of the vertex in the last line
                n2.x = normals[base + j + 0];
                n2.y = normals[base + j + 1];
                n2.z = normals[base + j + 2];
                // average normals
                n.addVectors(n1, n2).normalize();
                // assign the new values to both normals
                normals[j + 0] = normals[base + j + 0] = n.x;
                normals[j + 1] = normals[base + j + 1] = n.y;
                normals[j + 2] = normals[base + j + 2] = n.z;
            }
        }
    }
    static fromJSON(data) {
        return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
    }
}
class OctahedronGeometry extends PolyhedronGeometry {
    constructor(radius = 1, detail = 0){
        const vertices = [
            1,
            0,
            0,
            -1,
            0,
            0,
            0,
            1,
            0,
            0,
            -1,
            0,
            0,
            0,
            1,
            0,
            0,
            -1
        ];
        const indices = [
            0,
            2,
            4,
            0,
            4,
            3,
            0,
            3,
            5,
            0,
            5,
            2,
            1,
            2,
            5,
            1,
            5,
            3,
            1,
            3,
            4,
            1,
            4,
            2
        ];
        super(vertices, indices, radius, detail);
        this.type = 'OctahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    static fromJSON(data) {
        return new OctahedronGeometry(data.radius, data.detail);
    }
}
/**
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */ class ParametricGeometry extends BufferGeometry {
    constructor(func, slices, stacks){
        super();
        this.type = 'ParametricGeometry';
        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        const EPS = 0.00001;
        const normal = new Vector3();
        const p0 = new Vector3(), p1 = new Vector3();
        const pu = new Vector3(), pv = new Vector3();
        if (func.length < 3) console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
        // generate vertices, normals and uvs
        const sliceCount = slices + 1;
        for(let i225 = 0; i225 <= stacks; i225++){
            const v = i225 / stacks;
            for(let j = 0; j <= slices; j++){
                const u = j / slices;
                // vertex
                func(u, v, p0);
                vertices.push(p0.x, p0.y, p0.z);
                // normal
                // approximate tangent vectors via finite differences
                if (u - EPS >= 0) {
                    func(u - EPS, v, p1);
                    pu.subVectors(p0, p1);
                } else {
                    func(u + EPS, v, p1);
                    pu.subVectors(p1, p0);
                }
                if (v - EPS >= 0) {
                    func(u, v - EPS, p1);
                    pv.subVectors(p0, p1);
                } else {
                    func(u, v + EPS, p1);
                    pv.subVectors(p1, p0);
                }
                // cross product of tangent vectors returns surface normal
                normal.crossVectors(pu, pv).normalize();
                normals.push(normal.x, normal.y, normal.z);
                // uv
                uvs.push(u, v);
            }
        }
        // generate indices
        for(let i224 = 0; i224 < stacks; i224++)for(let j = 0; j < slices; j++){
            const a = i224 * sliceCount + j;
            const b = i224 * sliceCount + j + 1;
            const c = (i224 + 1) * sliceCount + j + 1;
            const d = (i224 + 1) * sliceCount + j;
            // faces one and two
            indices.push(a, b, d);
            indices.push(b, c, d);
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
}
class RingGeometry extends BufferGeometry {
    constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2){
        super();
        this.type = 'RingGeometry';
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        thetaSegments = Math.max(3, thetaSegments);
        phiSegments = Math.max(1, phiSegments);
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // some helper variables
        let radius = innerRadius;
        const radiusStep = (outerRadius - innerRadius) / phiSegments;
        const vertex = new Vector3();
        const uv = new Vector2();
        // generate vertices, normals and uvs
        for(let j = 0; j <= phiSegments; j++){
            for(let i226 = 0; i226 <= thetaSegments; i226++){
                // values are generate from the inside of the ring to the outside
                const segment = thetaStart + i226 / thetaSegments * thetaLength;
                // vertex
                vertex.x = radius * Math.cos(segment);
                vertex.y = radius * Math.sin(segment);
                vertices.push(vertex.x, vertex.y, vertex.z);
                // normal
                normals.push(0, 0, 1);
                // uv
                uv.x = (vertex.x / outerRadius + 1) / 2;
                uv.y = (vertex.y / outerRadius + 1) / 2;
                uvs.push(uv.x, uv.y);
            }
            // increase the radius for next row of vertices
            radius += radiusStep;
        }
        // indices
        for(let j2 = 0; j2 < phiSegments; j2++){
            const thetaSegmentLevel = j2 * (thetaSegments + 1);
            for(let i227 = 0; i227 < thetaSegments; i227++){
                const segment = i227 + thetaSegmentLevel;
                const a = segment;
                const b = segment + thetaSegments + 1;
                const c = segment + thetaSegments + 2;
                const d = segment + 1;
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    static fromJSON(data) {
        return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
    }
}
class ShapeGeometry extends BufferGeometry {
    constructor(shapes, curveSegments = 12){
        super();
        this.type = 'ShapeGeometry';
        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        let groupStart = 0;
        let groupCount = 0;
        // allow single and array values for "shapes" parameter
        if (Array.isArray(shapes) === false) addShape(shapes);
        else for(let i228 = 0; i228 < shapes.length; i228++){
            addShape(shapes[i228]);
            this.addGroup(groupStart, groupCount, i228); // enables MultiMaterial support
            groupStart += groupCount;
            groupCount = 0;
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        // helper functions
        function addShape(shape) {
            const indexOffset = vertices.length / 3;
            const points = shape.extractPoints(curveSegments);
            let shapeVertices = points.shape;
            const shapeHoles = points.holes;
            // check direction of vertices
            if (ShapeUtils.isClockWise(shapeVertices) === false) shapeVertices = shapeVertices.reverse();
            for(let i232 = 0, l = shapeHoles.length; i232 < l; i232++){
                const shapeHole = shapeHoles[i232];
                if (ShapeUtils.isClockWise(shapeHole) === true) shapeHoles[i232] = shapeHole.reverse();
            }
            const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
            // join vertices of inner and outer paths to a single array
            for(let i229 = 0, l3 = shapeHoles.length; i229 < l3; i229++){
                const shapeHole = shapeHoles[i229];
                shapeVertices = shapeVertices.concat(shapeHole);
            }
            // vertices, normals, uvs
            for(let i230 = 0, l4 = shapeVertices.length; i230 < l4; i230++){
                const vertex = shapeVertices[i230];
                vertices.push(vertex.x, vertex.y, 0);
                normals.push(0, 0, 1);
                uvs.push(vertex.x, vertex.y); // world uvs
            }
            // incides
            for(let i231 = 0, l5 = faces.length; i231 < l5; i231++){
                const face = faces[i231];
                const a = face[0] + indexOffset;
                const b = face[1] + indexOffset;
                const c = face[2] + indexOffset;
                indices.push(a, b, c);
                groupCount += 3;
            }
        }
    }
    toJSON() {
        const data = super.toJSON();
        const shapes = this.parameters.shapes;
        return toJSON(shapes, data);
    }
    static fromJSON(data, shapes) {
        const geometryShapes = [];
        for(let j = 0, jl = data.shapes.length; j < jl; j++){
            const shape = shapes[data.shapes[j]];
            geometryShapes.push(shape);
        }
        return new ShapeGeometry(geometryShapes, data.curveSegments);
    }
}
function toJSON(shapes, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) for(let i233 = 0, l = shapes.length; i233 < l; i233++){
        const shape = shapes[i233];
        data.shapes.push(shape.uuid);
    }
    else data.shapes.push(shapes.uuid);
    return data;
}
class SphereGeometry extends BufferGeometry {
    constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI){
        super();
        this.type = 'SphereGeometry';
        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        widthSegments = Math.max(3, Math.floor(widthSegments));
        heightSegments = Math.max(2, Math.floor(heightSegments));
        const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
        let index = 0;
        const grid = [];
        const vertex = new Vector3();
        const normal = new Vector3();
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // generate vertices, normals and uvs
        for(let iy = 0; iy <= heightSegments; iy++){
            const verticesRow = [];
            const v = iy / heightSegments;
            // special case for the poles
            let uOffset = 0;
            if (iy == 0 && thetaStart == 0) uOffset = 0.5 / widthSegments;
            else if (iy == heightSegments && thetaEnd == Math.PI) uOffset = -0.5 / widthSegments;
            for(let ix = 0; ix <= widthSegments; ix++){
                const u = ix / widthSegments;
                // vertex
                vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertices.push(vertex.x, vertex.y, vertex.z);
                // normal
                normal.copy(vertex).normalize();
                normals.push(normal.x, normal.y, normal.z);
                // uv
                uvs.push(u + uOffset, 1 - v);
                verticesRow.push(index++);
            }
            grid.push(verticesRow);
        }
        // indices
        for(let iy3 = 0; iy3 < heightSegments; iy3++)for(let ix = 0; ix < widthSegments; ix++){
            const a = grid[iy3][ix + 1];
            const b = grid[iy3][ix];
            const c = grid[iy3 + 1][ix];
            const d = grid[iy3 + 1][ix + 1];
            if (iy3 !== 0 || thetaStart > 0) indices.push(a, b, d);
            if (iy3 !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    static fromJSON(data) {
        return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
    }
}
class TetrahedronGeometry extends PolyhedronGeometry {
    constructor(radius = 1, detail = 0){
        const vertices = [
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            1,
            -1,
            -1
        ];
        const indices = [
            2,
            1,
            0,
            0,
            3,
            2,
            1,
            3,
            0,
            2,
            3,
            1
        ];
        super(vertices, indices, radius, detail);
        this.type = 'TetrahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    static fromJSON(data) {
        return new TetrahedronGeometry(data.radius, data.detail);
    }
}
/**
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */ class TextGeometry extends ExtrudeGeometry {
    constructor(text, parameters = {}){
        const font = parameters.font;
        if (!(font && font.isFont)) {
            console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
            return new BufferGeometry();
        }
        const shapes = font.generateShapes(text, parameters.size);
        // translate parameters to ExtrudeGeometry API
        parameters.depth = parameters.height !== undefined ? parameters.height : 50;
        // defaults
        if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
        if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
        if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
        super(shapes, parameters);
        this.type = 'TextGeometry';
    }
}
class TorusGeometry extends BufferGeometry {
    constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2){
        super();
        this.type = 'TorusGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };
        radialSegments = Math.floor(radialSegments);
        tubularSegments = Math.floor(tubularSegments);
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        const center = new Vector3();
        const vertex = new Vector3();
        const normal = new Vector3();
        // generate vertices, normals and uvs
        for(let j = 0; j <= radialSegments; j++)for(let i235 = 0; i235 <= tubularSegments; i235++){
            const u = i235 / tubularSegments * arc;
            const v = j / radialSegments * Math.PI * 2;
            // vertex
            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
            vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
            vertex.z = tube * Math.sin(v);
            vertices.push(vertex.x, vertex.y, vertex.z);
            // normal
            center.x = radius * Math.cos(u);
            center.y = radius * Math.sin(u);
            normal.subVectors(vertex, center).normalize();
            normals.push(normal.x, normal.y, normal.z);
            // uv
            uvs.push(i235 / tubularSegments);
            uvs.push(j / radialSegments);
        }
        // generate indices
        for(let j3 = 1; j3 <= radialSegments; j3++)for(let i234 = 1; i234 <= tubularSegments; i234++){
            // indices
            const a = (tubularSegments + 1) * j3 + i234 - 1;
            const b = (tubularSegments + 1) * (j3 - 1) + i234 - 1;
            const c = (tubularSegments + 1) * (j3 - 1) + i234;
            const d = (tubularSegments + 1) * j3 + i234;
            // faces
            indices.push(a, b, d);
            indices.push(b, c, d);
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    static fromJSON(data) {
        return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
    }
}
class TorusKnotGeometry extends BufferGeometry {
    constructor(radius3 = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p6 = 2, q3 = 3){
        super();
        this.type = 'TorusKnotGeometry';
        this.parameters = {
            radius: radius3,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p6,
            q: q3
        };
        tubularSegments = Math.floor(tubularSegments);
        radialSegments = Math.floor(radialSegments);
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        const vertex = new Vector3();
        const normal = new Vector3();
        const P1 = new Vector3();
        const P2 = new Vector3();
        const B = new Vector3();
        const T = new Vector3();
        const N = new Vector3();
        // generate vertices, normals and uvs
        for(let i237 = 0; i237 <= tubularSegments; ++i237){
            // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
            const u = i237 / tubularSegments * p6 * Math.PI * 2;
            // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
            // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
            calculatePositionOnCurve(u, p6, q3, radius3, P1);
            calculatePositionOnCurve(u + 0.01, p6, q3, radius3, P2);
            // calculate orthonormal basis
            T.subVectors(P2, P1);
            N.addVectors(P2, P1);
            B.crossVectors(T, N);
            N.crossVectors(B, T);
            // normalize B, N. T can be ignored, we don't use it
            B.normalize();
            N.normalize();
            for(let j = 0; j <= radialSegments; ++j){
                // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
                // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
                const v = j / radialSegments * Math.PI * 2;
                const cx = -tube * Math.cos(v);
                const cy = tube * Math.sin(v);
                // now calculate the final vertex position.
                // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
                vertex.x = P1.x + (cx * N.x + cy * B.x);
                vertex.y = P1.y + (cx * N.y + cy * B.y);
                vertex.z = P1.z + (cx * N.z + cy * B.z);
                vertices.push(vertex.x, vertex.y, vertex.z);
                // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
                normal.subVectors(vertex, P1).normalize();
                normals.push(normal.x, normal.y, normal.z);
                // uv
                uvs.push(i237 / tubularSegments);
                uvs.push(j / radialSegments);
            }
        }
        // generate indices
        for(let j = 1; j <= tubularSegments; j++)for(let i236 = 1; i236 <= radialSegments; i236++){
            // indices
            const a = (radialSegments + 1) * (j - 1) + (i236 - 1);
            const b = (radialSegments + 1) * j + (i236 - 1);
            const c = (radialSegments + 1) * j + i236;
            const d = (radialSegments + 1) * (j - 1) + i236;
            // faces
            indices.push(a, b, d);
            indices.push(b, c, d);
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        // this function calculates the current position on the torus curve
        function calculatePositionOnCurve(u, p, q, radius, position) {
            const cu = Math.cos(u);
            const su = Math.sin(u);
            const quOverP = q / p * u;
            const cs = Math.cos(quOverP);
            position.x = radius * (2 + cs) * 0.5 * cu;
            position.y = radius * (2 + cs) * su * 0.5;
            position.z = radius * Math.sin(quOverP) * 0.5;
        }
    }
    static fromJSON(data) {
        return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
    }
}
class TubeGeometry extends BufferGeometry {
    constructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false){
        super();
        this.type = 'TubeGeometry';
        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };
        const frames = path.computeFrenetFrames(tubularSegments, closed);
        // expose internals
        this.tangents = frames.tangents;
        this.normals = frames.normals;
        this.binormals = frames.binormals;
        // helper variables
        const vertex = new Vector3();
        const normal = new Vector3();
        const uv = new Vector2();
        let P = new Vector3();
        // buffer
        const vertices = [];
        const normals = [];
        const uvs = [];
        const indices = [];
        // create buffer data
        generateBufferData();
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        // functions
        function generateBufferData() {
            for(let i238 = 0; i238 < tubularSegments; i238++)generateSegment(i238);
            // if the geometry is not closed, generate the last row of vertices and normals
            // at the regular position on the given path
            //
            // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
            generateSegment(closed === false ? tubularSegments : 0);
            // uvs are generated in a separate function.
            // this makes it easy compute correct values for closed geometries
            generateUVs();
            // finally create faces
            generateIndices();
        }
        function generateSegment(i239) {
            // we use getPointAt to sample evenly distributed points from the given path
            P = path.getPointAt(i239 / tubularSegments, P);
            // retrieve corresponding normal and binormal
            const N = frames.normals[i239];
            const B = frames.binormals[i239];
            // generate normals and vertices for the current segment
            for(let j = 0; j <= radialSegments; j++){
                const v = j / radialSegments * Math.PI * 2;
                const sin = Math.sin(v);
                const cos = -Math.cos(v);
                // normal
                normal.x = cos * N.x + sin * B.x;
                normal.y = cos * N.y + sin * B.y;
                normal.z = cos * N.z + sin * B.z;
                normal.normalize();
                normals.push(normal.x, normal.y, normal.z);
                // vertex
                vertex.x = P.x + radius * normal.x;
                vertex.y = P.y + radius * normal.y;
                vertex.z = P.z + radius * normal.z;
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
        function generateIndices() {
            for(let j = 1; j <= tubularSegments; j++)for(let i240 = 1; i240 <= radialSegments; i240++){
                const a = (radialSegments + 1) * (j - 1) + (i240 - 1);
                const b = (radialSegments + 1) * j + (i240 - 1);
                const c = (radialSegments + 1) * j + i240;
                const d = (radialSegments + 1) * (j - 1) + i240;
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        function generateUVs() {
            for(let i241 = 0; i241 <= tubularSegments; i241++)for(let j = 0; j <= radialSegments; j++){
                uv.x = i241 / tubularSegments;
                uv.y = j / radialSegments;
                uvs.push(uv.x, uv.y);
            }
        }
    }
    toJSON() {
        const data = super.toJSON();
        data.path = this.parameters.path.toJSON();
        return data;
    }
    static fromJSON(data) {
        // This only works for built-in curves (e.g. CatmullRomCurve3).
        // User defined curves or instances of CurvePath will not be deserialized.
        return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
    }
}
class WireframeGeometry extends BufferGeometry {
    constructor(geometry){
        super();
        this.type = 'WireframeGeometry';
        if (geometry.isGeometry === true) {
            console.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
            return;
        }
        // buffer
        const vertices = [];
        const edges = new Set();
        // helper variables
        const start = new Vector3();
        const end = new Vector3();
        if (geometry.index !== null) {
            // indexed BufferGeometry
            const position = geometry.attributes.position;
            const indices = geometry.index;
            let groups = geometry.groups;
            if (groups.length === 0) groups = [
                {
                    start: 0,
                    count: indices.count,
                    materialIndex: 0
                }
            ];
            // create a data structure that contains all eges without duplicates
            for(let o = 0, ol = groups.length; o < ol; ++o){
                const group = groups[o];
                const groupStart = group.start;
                const groupCount = group.count;
                for(let i242 = groupStart, l = groupStart + groupCount; i242 < l; i242 += 3)for(let j = 0; j < 3; j++){
                    const index1 = indices.getX(i242 + j);
                    const index2 = indices.getX(i242 + (j + 1) % 3);
                    start.fromBufferAttribute(position, index1);
                    end.fromBufferAttribute(position, index2);
                    if (isUniqueEdge(start, end, edges) === true) {
                        vertices.push(start.x, start.y, start.z);
                        vertices.push(end.x, end.y, end.z);
                    }
                }
            }
        } else {
            // non-indexed BufferGeometry
            const position = geometry.attributes.position;
            for(let i243 = 0, l = position.count / 3; i243 < l; i243++)for(let j = 0; j < 3; j++){
                // three edges per triangle, an edge is represented as (index1, index2)
                // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
                const index1 = 3 * i243 + j;
                const index2 = 3 * i243 + (j + 1) % 3;
                start.fromBufferAttribute(position, index1);
                end.fromBufferAttribute(position, index2);
                if (isUniqueEdge(start, end, edges) === true) {
                    vertices.push(start.x, start.y, start.z);
                    vertices.push(end.x, end.y, end.z);
                }
            }
        }
        // build geometry
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    }
}
function isUniqueEdge(start, end, edges) {
    const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
    const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge
    if (edges.has(hash1) === true || edges.has(hash2) === true) return false;
    else {
        edges.add(hash1, hash2);
        return true;
    }
}
var Geometries = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    BoxGeometry: BoxGeometry,
    BoxBufferGeometry: BoxGeometry,
    CircleGeometry: CircleGeometry,
    CircleBufferGeometry: CircleGeometry,
    ConeGeometry: ConeGeometry,
    ConeBufferGeometry: ConeGeometry,
    CylinderGeometry: CylinderGeometry,
    CylinderBufferGeometry: CylinderGeometry,
    DodecahedronGeometry: DodecahedronGeometry,
    DodecahedronBufferGeometry: DodecahedronGeometry,
    EdgesGeometry: EdgesGeometry,
    ExtrudeGeometry: ExtrudeGeometry,
    ExtrudeBufferGeometry: ExtrudeGeometry,
    IcosahedronGeometry: IcosahedronGeometry,
    IcosahedronBufferGeometry: IcosahedronGeometry,
    LatheGeometry: LatheGeometry,
    LatheBufferGeometry: LatheGeometry,
    OctahedronGeometry: OctahedronGeometry,
    OctahedronBufferGeometry: OctahedronGeometry,
    ParametricGeometry: ParametricGeometry,
    ParametricBufferGeometry: ParametricGeometry,
    PlaneGeometry: PlaneGeometry,
    PlaneBufferGeometry: PlaneGeometry,
    PolyhedronGeometry: PolyhedronGeometry,
    PolyhedronBufferGeometry: PolyhedronGeometry,
    RingGeometry: RingGeometry,
    RingBufferGeometry: RingGeometry,
    ShapeGeometry: ShapeGeometry,
    ShapeBufferGeometry: ShapeGeometry,
    SphereGeometry: SphereGeometry,
    SphereBufferGeometry: SphereGeometry,
    TetrahedronGeometry: TetrahedronGeometry,
    TetrahedronBufferGeometry: TetrahedronGeometry,
    TextGeometry: TextGeometry,
    TextBufferGeometry: TextGeometry,
    TorusGeometry: TorusGeometry,
    TorusBufferGeometry: TorusGeometry,
    TorusKnotGeometry: TorusKnotGeometry,
    TorusKnotBufferGeometry: TorusKnotGeometry,
    TubeGeometry: TubeGeometry,
    TubeBufferGeometry: TubeGeometry,
    WireframeGeometry: WireframeGeometry
});
/**
 * parameters = {
 *  color: <THREE.Color>
 * }
 */ class ShadowMaterial extends Material {
    constructor(parameters){
        super();
        this.type = 'ShadowMaterial';
        this.color = new Color(0);
        this.transparent = true;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        return this;
    }
}
ShadowMaterial.prototype.isShadowMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  flatShading: <bool>
 * }
 */ class MeshStandardMaterial extends Material {
    constructor(parameters){
        super();
        this.defines = {
            'STANDARD': ''
        };
        this.type = 'MeshStandardMaterial';
        this.color = new Color(16777215); // diffuse
        this.roughness = 1;
        this.metalness = 0;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.roughnessMap = null;
        this.metalnessMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapIntensity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.flatShading = false;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.defines = {
            'STANDARD': ''
        };
        this.color.copy(source.color);
        this.roughness = source.roughness;
        this.metalness = source.metalness;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.roughnessMap = source.roughnessMap;
        this.metalnessMap = source.metalnessMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapIntensity = source.envMapIntensity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.flatShading = source.flatShading;
        return this;
    }
}
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
/**
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  ior: <float>,
 *  reflectivity: <float>,
 *
 *  sheenTint: <Color>,
 *
 *  transmission: <float>,
 *  transmissionMap: new THREE.Texture( <Image> ),
 *
 *  thickness: <float>,
 *  thicknessMap: new THREE.Texture( <Image> ),
 *  attenuationDistance: <float>,
 *  attenuationTint: <Color>,
 *
 *  specularIntensity: <float>,
 *  specularIntensityhMap: new THREE.Texture( <Image> ),
 *  specularTint: <Color>,
 *  specularTintMap: new THREE.Texture( <Image> )
 * }
 */ class MeshPhysicalMaterial extends MeshStandardMaterial {
    constructor(parameters){
        super();
        this.defines = {
            'STANDARD': '',
            'PHYSICAL': ''
        };
        this.type = 'MeshPhysicalMaterial';
        this.clearcoatMap = null;
        this.clearcoatRoughness = 0;
        this.clearcoatRoughnessMap = null;
        this.clearcoatNormalScale = new Vector2(1, 1);
        this.clearcoatNormalMap = null;
        this.ior = 1.5;
        Object.defineProperty(this, 'reflectivity', {
            get: function() {
                return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
            },
            set: function(reflectivity) {
                this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
            }
        });
        this.sheenTint = new Color(0);
        this.transmission = 0;
        this.transmissionMap = null;
        this.thickness = 0.01;
        this.thicknessMap = null;
        this.attenuationDistance = 0;
        this.attenuationTint = new Color(1, 1, 1);
        this.specularIntensity = 1;
        this.specularIntensityMap = null;
        this.specularTint = new Color(1, 1, 1);
        this.specularTintMap = null;
        this._clearcoat = 0;
        this._transmission = 0;
        this.setValues(parameters);
    }
    get clearcoat() {
        return this._clearcoat;
    }
    set clearcoat(value) {
        if (this._clearcoat > 0 !== value > 0) this.version++;
        this._clearcoat = value;
    }
    get transmission() {
        return this._transmission;
    }
    set transmission(value) {
        if (this._transmission > 0 !== value > 0) this.version++;
        this._transmission = value;
    }
    copy(source) {
        super.copy(source);
        this.defines = {
            'STANDARD': '',
            'PHYSICAL': ''
        };
        this.clearcoat = source.clearcoat;
        this.clearcoatMap = source.clearcoatMap;
        this.clearcoatRoughness = source.clearcoatRoughness;
        this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
        this.clearcoatNormalMap = source.clearcoatNormalMap;
        this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
        this.ior = source.ior;
        this.sheenTint.copy(source.sheenTint);
        this.transmission = source.transmission;
        this.transmissionMap = source.transmissionMap;
        this.thickness = source.thickness;
        this.thicknessMap = source.thicknessMap;
        this.attenuationDistance = source.attenuationDistance;
        this.attenuationTint.copy(source.attenuationTint);
        this.specularIntensity = source.specularIntensity;
        this.specularIntensityMap = source.specularIntensityMap;
        this.specularTint.copy(source.specularTint);
        this.specularTintMap = source.specularTintMap;
        return this;
    }
}
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  flatShading: <bool>
 * }
 */ class MeshPhongMaterial extends Material {
    constructor(parameters){
        super();
        this.type = 'MeshPhongMaterial';
        this.color = new Color(16777215); // diffuse
        this.specular = new Color(1118481);
        this.shininess = 30;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.flatShading = false;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.flatShading = source.flatShading;
        return this;
    }
}
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 * }
 */ class MeshToonMaterial extends Material {
    constructor(parameters){
        super();
        this.defines = {
            'TOON': ''
        };
        this.type = 'MeshToonMaterial';
        this.color = new Color(16777215);
        this.map = null;
        this.gradientMap = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.gradientMap = source.gradientMap;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        return this;
    }
}
MeshToonMaterial.prototype.isMeshToonMaterial = true;
/**
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  flatShading: <bool>
 * }
 */ class MeshNormalMaterial extends Material {
    constructor(parameters){
        super();
        this.type = 'MeshNormalMaterial';
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.flatShading = false;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.flatShading = source.flatShading;
        return this;
    }
}
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 * }
 */ class MeshLambertMaterial extends Material {
    constructor(parameters){
        super();
        this.type = 'MeshLambertMaterial';
        this.color = new Color(16777215); // diffuse
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        return this;
    }
}
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  flatShading: <bool>
 * }
 */ class MeshMatcapMaterial extends Material {
    constructor(parameters){
        super();
        this.defines = {
            'MATCAP': ''
        };
        this.type = 'MeshMatcapMaterial';
        this.color = new Color(16777215); // diffuse
        this.matcap = null;
        this.map = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.flatShading = false;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.defines = {
            'MATCAP': ''
        };
        this.color.copy(source.color);
        this.matcap = source.matcap;
        this.map = source.map;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.flatShading = source.flatShading;
        return this;
    }
}
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */ class LineDashedMaterial extends LineBasicMaterial {
    constructor(parameters){
        super();
        this.type = 'LineDashedMaterial';
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
        return this;
    }
}
LineDashedMaterial.prototype.isLineDashedMaterial = true;
var Materials = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ShadowMaterial: ShadowMaterial,
    SpriteMaterial: SpriteMaterial,
    RawShaderMaterial: RawShaderMaterial,
    ShaderMaterial: ShaderMaterial,
    PointsMaterial: PointsMaterial,
    MeshPhysicalMaterial: MeshPhysicalMaterial,
    MeshStandardMaterial: MeshStandardMaterial,
    MeshPhongMaterial: MeshPhongMaterial,
    MeshToonMaterial: MeshToonMaterial,
    MeshNormalMaterial: MeshNormalMaterial,
    MeshLambertMaterial: MeshLambertMaterial,
    MeshDepthMaterial: MeshDepthMaterial,
    MeshDistanceMaterial: MeshDistanceMaterial,
    MeshBasicMaterial: MeshBasicMaterial,
    MeshMatcapMaterial: MeshMatcapMaterial,
    LineDashedMaterial: LineDashedMaterial,
    LineBasicMaterial: LineBasicMaterial,
    Material: Material
});
const AnimationUtils = {
    // same as Array.prototype.slice, but also works on typed arrays
    arraySlice: function(array, from, to) {
        if (AnimationUtils.isTypedArray(array)) // in ios9 array.subarray(from, undefined) will return empty array
        // but array.subarray(from) or array.subarray(from, len) is correct
        return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
        return array.slice(from, to);
    },
    // converts an array to a specific type
    convertArray: function(array, type, forceClone) {
        if (!array || !forceClone && array.constructor === type) return array;
        if (typeof type.BYTES_PER_ELEMENT === 'number') return new type(array); // create typed array
        return Array.prototype.slice.call(array); // create Array
    },
    isTypedArray: function(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    // returns an array by which times and values can be sorted
    getKeyframeOrder: function(times) {
        function compareTime(i245, j) {
            return times[i245] - times[j];
        }
        const n = times.length;
        const result = new Array(n);
        for(let i244 = 0; i244 !== n; ++i244)result[i244] = i244;
        result.sort(compareTime);
        return result;
    },
    // uses the array previously returned by 'getKeyframeOrder' to sort data
    sortedArray: function(values, stride, order) {
        const nValues = values.length;
        const result = new values.constructor(nValues);
        for(let i246 = 0, dstOffset = 0; dstOffset !== nValues; ++i246){
            const srcOffset = order[i246] * stride;
            for(let j = 0; j !== stride; ++j)result[dstOffset++] = values[srcOffset + j];
        }
        return result;
    },
    // function for parsing AOS keyframe formats
    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
        let i247 = 1, key = jsonKeys[0];
        while(key !== undefined && key[valuePropertyName] === undefined)key = jsonKeys[i247++];
        if (key === undefined) return; // no data
        let value = key[valuePropertyName];
        if (value === undefined) return; // no data
        if (Array.isArray(value)) do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                values.push.apply(values, value); // push all elements
            }
            key = jsonKeys[i247++];
        }while (key !== undefined)
        else if (value.toArray !== undefined) // ...assume THREE.Math-ish
        do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                value.toArray(values, values.length);
            }
            key = jsonKeys[i247++];
        }while (key !== undefined)
        else // otherwise push as-is
        do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                values.push(value);
            }
            key = jsonKeys[i247++];
        }while (key !== undefined)
    },
    subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
        const clip = sourceClip.clone();
        clip.name = name;
        const tracks = [];
        for(let i250 = 0; i250 < clip.tracks.length; ++i250){
            const track = clip.tracks[i250];
            const valueSize = track.getValueSize();
            const times = [];
            const values = [];
            for(let j = 0; j < track.times.length; ++j){
                const frame = track.times[j] * fps;
                if (frame < startFrame || frame >= endFrame) continue;
                times.push(track.times[j]);
                for(let k = 0; k < valueSize; ++k)values.push(track.values[j * valueSize + k]);
            }
            if (times.length === 0) continue;
            track.times = AnimationUtils.convertArray(times, track.times.constructor);
            track.values = AnimationUtils.convertArray(values, track.values.constructor);
            tracks.push(track);
        }
        clip.tracks = tracks;
        // find minimum .times value across all tracks in the trimmed clip
        let minStartTime = Infinity;
        for(let i248 = 0; i248 < clip.tracks.length; ++i248)if (minStartTime > clip.tracks[i248].times[0]) minStartTime = clip.tracks[i248].times[0];
        // shift all tracks such that clip begins at t=0
        for(let i249 = 0; i249 < clip.tracks.length; ++i249)clip.tracks[i249].shift(-1 * minStartTime);
        clip.resetDuration();
        return clip;
    },
    makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
        if (fps <= 0) fps = 30;
        const numTracks = referenceClip.tracks.length;
        const referenceTime = referenceFrame / fps;
        // Make each track's values relative to the values at the reference frame
        for(let i251 = 0; i251 < numTracks; ++i251){
            const referenceTrack = referenceClip.tracks[i251];
            const referenceTrackType = referenceTrack.ValueTypeName;
            // Skip this track if it's non-numeric
            if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue;
            // Find the track in the target clip whose name and type matches the reference track
            const targetTrack = targetClip.tracks.find(function(track) {
                return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
            });
            if (targetTrack === undefined) continue;
            let referenceOffset = 0;
            const referenceValueSize = referenceTrack.getValueSize();
            if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) referenceOffset = referenceValueSize / 3;
            let targetOffset = 0;
            const targetValueSize = targetTrack.getValueSize();
            if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) targetOffset = targetValueSize / 3;
            const lastIndex = referenceTrack.times.length - 1;
            let referenceValue;
            // Find the value to subtract out of the track
            if (referenceTime <= referenceTrack.times[0]) {
                // Reference frame is earlier than the first keyframe, so just use the first keyframe
                const startIndex = referenceOffset;
                const endIndex = referenceValueSize - referenceOffset;
                referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else if (referenceTime >= referenceTrack.times[lastIndex]) {
                // Reference frame is after the last keyframe, so just use the last keyframe
                const startIndex = lastIndex * referenceValueSize + referenceOffset;
                const endIndex = startIndex + referenceValueSize - referenceOffset;
                referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else {
                // Interpolate to the reference value
                const interpolant = referenceTrack.createInterpolant();
                const startIndex = referenceOffset;
                const endIndex = referenceValueSize - referenceOffset;
                interpolant.evaluate(referenceTime);
                referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
            }
            // Conjugate the quaternion
            if (referenceTrackType === 'quaternion') {
                const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
                referenceQuat.toArray(referenceValue);
            }
            // Subtract the reference value from all of the track values
            const numTimes = targetTrack.times.length;
            for(let j = 0; j < numTimes; ++j){
                const valueStart = j * targetValueSize + targetOffset;
                if (referenceTrackType === 'quaternion') // Multiply the conjugate for quaternion track types
                Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
                else {
                    const valueEnd = targetValueSize - targetOffset * 2;
                    // Subtract each value for all other numeric track types
                    for(let k = 0; k < valueEnd; ++k)targetTrack.values[valueStart + k] -= referenceValue[k];
                }
            }
        }
        targetClip.blendMode = AdditiveAnimationBlendMode;
        return targetClip;
    }
};
/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */ class Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){
        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;
        this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;
        this.settings = null;
        this.DefaultSettings_ = {};
    }
    evaluate(t) {
        const pp = this.parameterPositions;
        let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
        validate_interval: {
            seek: {
                let right;
                linear_scan: {
                    //- See http://jsperf.com/comparison-to-undefined/3
                    //- slower code:
                    //-
                    //- 				if ( t >= t1 || t1 === undefined ) {
                    forward_scan: if (!(t < t1)) {
                        for(let giveUpAt = i1 + 2;;){
                            if (t1 === undefined) {
                                if (t < t0) break forward_scan;
                                // after end
                                i1 = pp.length;
                                this._cachedIndex = i1;
                                return this.afterEnd_(i1 - 1, t, t0);
                            }
                            if (i1 === giveUpAt) break; // this loop
                            t0 = t1;
                            t1 = pp[++i1];
                            if (t < t1) break seek;
                        }
                        // prepare binary search on the right side of the index
                        right = pp.length;
                        break linear_scan;
                    }
                    //- slower code:
                    //-					if ( t < t0 || t0 === undefined ) {
                    if (!(t >= t0)) {
                        // looping?
                        const t1global = pp[1];
                        if (t < t1global) {
                            i1 = 2; // + 1, using the scan for the details
                            t0 = t1global;
                        }
                        // linear reverse scan
                        for(let giveUpAt = i1 - 2;;){
                            if (t0 === undefined) {
                                // before start
                                this._cachedIndex = 0;
                                return this.beforeStart_(0, t, t1);
                            }
                            if (i1 === giveUpAt) break; // this loop
                            t1 = t0;
                            t0 = pp[--i1 - 1];
                            if (t >= t0) break seek;
                        }
                        // prepare binary search on the left side of the index
                        right = i1;
                        i1 = 0;
                        break linear_scan;
                    }
                    break validate_interval;
                } // linear scan
                // binary search
                while(i1 < right){
                    const mid = i1 + right >>> 1;
                    if (t < pp[mid]) right = mid;
                    else i1 = mid + 1;
                }
                t1 = pp[i1];
                t0 = pp[i1 - 1];
                // check boundary cases, again
                if (t0 === undefined) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t, t1);
                }
                if (t1 === undefined) {
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.afterEnd_(i1 - 1, t0, t);
                }
            } // seek
            this._cachedIndex = i1;
            this.intervalChanged_(i1, t0, t1);
        } // validate_interval
        return this.interpolate_(i1, t0, t, t1);
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(index) {
        // copies a sample value to the result buffer
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
        for(let i252 = 0; i252 !== stride; ++i252)result[i252] = values[offset + i252];
        return result;
    }
    // Template methods for derived classes:
    interpolate_() {
        throw new Error('call to abstract method');
    // implementations shall return this.resultBuffer
    }
    intervalChanged_() {
    // empty
    }
}
// ALIAS DEFINITIONS
Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */ class CubicInterpolant extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        this._weightPrev = -0;
        this._offsetPrev = -0;
        this._weightNext = -0;
        this._offsetNext = -0;
        this.DefaultSettings_ = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        };
    }
    intervalChanged_(i1, t0, t1) {
        const pp = this.parameterPositions;
        let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === undefined) switch(this.getSettings_().endingStart){
            case ZeroSlopeEnding:
                // f'(t0) = 0
                iPrev = i1;
                tPrev = 2 * t0 - t1;
                break;
            case WrapAroundEnding:
                // use the other end of the curve
                iPrev = pp.length - 2;
                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;
            default:
                // f''(t0) = 0 a.k.a. Natural Spline
                iPrev = i1;
                tPrev = t1;
        }
        if (tNext === undefined) switch(this.getSettings_().endingEnd){
            case ZeroSlopeEnding:
                // f'(tN) = 0
                iNext = i1;
                tNext = 2 * t1 - t0;
                break;
            case WrapAroundEnding:
                // use the other end of the curve
                iNext = 1;
                tNext = t1 + pp[1] - pp[0];
                break;
            default:
                // f''(tN) = 0, a.k.a. Natural Spline
                iNext = i1 - 1;
                tNext = t0;
        }
        const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
    }
    interpolate_(i1, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
        // evaluate polynomials
        const sP = -wP * ppp + 2 * wP * pp - wP * p;
        const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
        const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
        const sN = wN * ppp - wN * pp;
        // combine data linearly
        for(let i253 = 0; i253 !== stride; ++i253)result[i253] = sP * values[oP + i253] + s0 * values[o0 + i253] + s1 * values[o1 + i253] + sN * values[oN + i253];
        return result;
    }
}
class LinearInterpolant extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
        for(let i254 = 0; i254 !== stride; ++i254)result[i254] = values[offset0 + i254] * weight0 + values[offset1 + i254] * weight1;
        return result;
    }
}
/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */ class DiscreteInterpolant extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1 /*, t0, t, t1 */ ) {
        return this.copySampleValue_(i1 - 1);
    }
}
class KeyframeTrack {
    constructor(name, times, values, interpolation){
        if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
        if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
        this.name = name;
        this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
        this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
        this.setInterpolation(interpolation || this.DefaultInterpolation);
    }
    // Serialization (in static context, because of constructor invocation
    // and automatic invocation of .toJSON):
    static toJSON(track) {
        const trackType = track.constructor;
        let json;
        // derived classes can define a static toJSON method
        if (trackType.toJSON !== this.toJSON) json = trackType.toJSON(track);
        else {
            // by default, we assume the data can be serialized as-is
            json = {
                'name': track.name,
                'times': AnimationUtils.convertArray(track.times, Array),
                'values': AnimationUtils.convertArray(track.values, Array)
            };
            const interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) json.interpolation = interpolation;
        }
        json.type = track.ValueTypeName; // mandatory
        return json;
    }
    InterpolantFactoryMethodDiscrete(result) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodLinear(result) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodSmooth(result) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    setInterpolation(interpolation) {
        let factoryMethod;
        switch(interpolation){
            case InterpolateDiscrete:
                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                break;
            case InterpolateLinear:
                factoryMethod = this.InterpolantFactoryMethodLinear;
                break;
            case InterpolateSmooth:
                factoryMethod = this.InterpolantFactoryMethodSmooth;
                break;
        }
        if (factoryMethod === undefined) {
            const message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
            if (this.createInterpolant === undefined) {
                // fall back to default, unless the default itself is messed up
                if (interpolation !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(message); // fatal, in this case
            }
            console.warn('THREE.KeyframeTrack:', message);
            return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
    }
    getInterpolation() {
        switch(this.createInterpolant){
            case this.InterpolantFactoryMethodDiscrete:
                return InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
                return InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
                return InterpolateSmooth;
        }
    }
    getValueSize() {
        return this.values.length / this.times.length;
    }
    // move all keyframes either forwards or backwards in time
    shift(timeOffset) {
        if (timeOffset !== 0) {
            const times = this.times;
            for(let i255 = 0, n = times.length; i255 !== n; ++i255)times[i255] += timeOffset;
        }
        return this;
    }
    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    scale(timeScale) {
        if (timeScale !== 1) {
            const times = this.times;
            for(let i256 = 0, n = times.length; i256 !== n; ++i256)times[i256] *= timeScale;
        }
        return this;
    }
    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    trim(startTime, endTime) {
        const times = this.times, nKeys = times.length;
        let from = 0, to = nKeys - 1;
        while(from !== nKeys && times[from] < startTime)++from;
        while(to !== -1 && times[to] > endTime)--to;
        ++to; // inclusive -> exclusive bound
        if (from !== 0 || to !== nKeys) {
            // empty tracks are forbidden, so keep at least one keyframe
            if (from >= to) {
                to = Math.max(to, 1);
                from = to - 1;
            }
            const stride = this.getValueSize();
            this.times = AnimationUtils.arraySlice(times, from, to);
            this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
        }
        return this;
    }
    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    validate() {
        let valid = true;
        const valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
            console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
            valid = false;
        }
        const times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
            console.error('THREE.KeyframeTrack: Track is empty.', this);
            valid = false;
        }
        let prevTime = null;
        for(let i257 = 0; i257 !== nKeys; i257++){
            const currTime = times[i257];
            if (typeof currTime === 'number' && isNaN(currTime)) {
                console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i257, currTime);
                valid = false;
                break;
            }
            if (prevTime !== null && prevTime > currTime) {
                console.error('THREE.KeyframeTrack: Out of order keys.', this, i257, currTime, prevTime);
                valid = false;
                break;
            }
            prevTime = currTime;
        }
        if (values !== undefined) {
            if (AnimationUtils.isTypedArray(values)) for(let i258 = 0, n = values.length; i258 !== n; ++i258){
                const value = values[i258];
                if (isNaN(value)) {
                    console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i258, value);
                    valid = false;
                    break;
                }
            }
        }
        return valid;
    }
    // removes equivalent sequential keys as common in morph target sequences
    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    optimize() {
        // times or values may be shared with other tracks, so overwriting is unsafe
        const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
        let writeIndex = 1;
        for(let i259 = 1; i259 < lastIndex; ++i259){
            let keep = false;
            const time = times[i259];
            const timeNext = times[i259 + 1];
            // remove adjacent keyframes scheduled at the same time
            if (time !== timeNext && (i259 !== 1 || time !== times[0])) {
                if (!smoothInterpolation) {
                    // remove unnecessary keyframes same as their neighbors
                    const offset = i259 * stride, offsetP = offset - stride, offsetN = offset + stride;
                    for(let j = 0; j !== stride; ++j){
                        const value = values[offset + j];
                        if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                            keep = true;
                            break;
                        }
                    }
                } else keep = true;
            }
            // in-place compaction
            if (keep) {
                if (i259 !== writeIndex) {
                    times[writeIndex] = times[i259];
                    const readOffset = i259 * stride, writeOffset = writeIndex * stride;
                    for(let j = 0; j !== stride; ++j)values[writeOffset + j] = values[readOffset + j];
                }
                ++writeIndex;
            }
        }
        // flush last keyframe (compaction looks ahead)
        if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for(let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j)values[writeOffset + j] = values[readOffset + j];
            ++writeIndex;
        }
        if (writeIndex !== times.length) {
            this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
        } else {
            this.times = times;
            this.values = values;
        }
        return this;
    }
    clone() {
        const times = AnimationUtils.arraySlice(this.times, 0);
        const values = AnimationUtils.arraySlice(this.values, 0);
        const TypedKeyframeTrack = this.constructor;
        const track = new TypedKeyframeTrack(this.name, times, values);
        // Interpolant argument to constructor is not saved, so copy the factory method directly.
        track.createInterpolant = this.createInterpolant;
        return track;
    }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
/**
 * A Track of Boolean keyframe values.
 */ class BooleanKeyframeTrack extends KeyframeTrack {
}
BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
/**
 * A Track of keyframe values that represent color.
 */ class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = 'color';
/**
 * A Track of numeric keyframe values.
 */ class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = 'number';
/**
 * Spherical linear unit quaternion interpolant.
 */ class QuaternionLinearInterpolant extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
        let offset = i1 * stride;
        for(let end = offset + stride; offset !== end; offset += 4)Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        return result;
    }
}
/**
 * A Track of quaternion keyframe values.
 */ class QuaternionKeyframeTrack extends KeyframeTrack {
    InterpolantFactoryMethodLinear(result) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
// ValueBufferType is inherited
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
/**
 * A Track that interpolates Strings
 */ class StringKeyframeTrack extends KeyframeTrack {
}
StringKeyframeTrack.prototype.ValueTypeName = 'string';
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
/**
 * A Track of vectored keyframe values.
 */ class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = 'vector';
class AnimationClip {
    constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode){
        this.name = name;
        this.tracks = tracks;
        this.duration = duration;
        this.blendMode = blendMode;
        this.uuid = generateUUID();
        // this means it should figure out its duration by scanning the tracks
        if (this.duration < 0) this.resetDuration();
    }
    static parse(json) {
        const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
        for(let i260 = 0, n = jsonTracks.length; i260 !== n; ++i260)tracks.push(parseKeyframeTrack(jsonTracks[i260]).scale(frameTime));
        const clip = new this(json.name, json.duration, tracks, json.blendMode);
        clip.uuid = json.uuid;
        return clip;
    }
    static toJSON(clip) {
        const tracks = [], clipTracks = clip.tracks;
        const json = {
            'name': clip.name,
            'duration': clip.duration,
            'tracks': tracks,
            'uuid': clip.uuid,
            'blendMode': clip.blendMode
        };
        for(let i261 = 0, n = clipTracks.length; i261 !== n; ++i261)tracks.push(KeyframeTrack.toJSON(clipTracks[i261]));
        return json;
    }
    static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
        const numMorphTargets = morphTargetSequence.length;
        const tracks = [];
        for(let i262 = 0; i262 < numMorphTargets; i262++){
            let times = [];
            let values = [];
            times.push((i262 + numMorphTargets - 1) % numMorphTargets, i262, (i262 + 1) % numMorphTargets);
            values.push(0, 1, 0);
            const order = AnimationUtils.getKeyframeOrder(times);
            times = AnimationUtils.sortedArray(times, 1, order);
            values = AnimationUtils.sortedArray(values, 1, order);
            // if there is a key at the first frame, duplicate it as the
            // last frame as well for perfect loop.
            if (!noLoop && times[0] === 0) {
                times.push(numMorphTargets);
                values.push(values[0]);
            }
            tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i262].name + ']', times, values).scale(1 / fps));
        }
        return new this(name, -1, tracks);
    }
    static findByName(objectOrClipArray, name) {
        let clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
            const o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for(let i263 = 0; i263 < clipArray.length; i263++){
            if (clipArray[i263].name === name) return clipArray[i263];
        }
        return null;
    }
    static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
        const animationToMorphTargets = {};
        // tested with https://regex101.com/ on trick sequences
        // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
        const pattern = /^([\w-]*?)([\d]+)$/;
        // sort morph target names into animation groups based
        // patterns like Walk_001, Walk_002, Run_001, Run_002
        for(let i264 = 0, il = morphTargets.length; i264 < il; i264++){
            const morphTarget = morphTargets[i264];
            const parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
                const name = parts[1];
                let animationMorphTargets = animationToMorphTargets[name];
                if (!animationMorphTargets) animationToMorphTargets[name] = animationMorphTargets = [];
                animationMorphTargets.push(morphTarget);
            }
        }
        const clips = [];
        for(const name in animationToMorphTargets)clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
        return clips;
    }
    // parse the animation.hierarchy format
    static parseAnimation(animation, bones) {
        if (!animation) {
            console.error('THREE.AnimationClip: No animation in JSONLoader data.');
            return null;
        }
        const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            // only return track if there are actually keys.
            if (animationKeys.length !== 0) {
                const times = [];
                const values = [];
                AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
                // empty keys are filtered out, so check again
                if (times.length !== 0) destTracks.push(new trackType(trackName, times, values));
            }
        };
        const tracks = [];
        const clipName = animation.name || 'default';
        const fps = animation.fps || 30;
        const blendMode = animation.blendMode;
        // automatic length determination in AnimationClip.
        let duration = animation.length || -1;
        const hierarchyTracks = animation.hierarchy || [];
        for(let h = 0; h < hierarchyTracks.length; h++){
            const animationKeys = hierarchyTracks[h].keys;
            // skip empty tracks
            if (!animationKeys || animationKeys.length === 0) continue;
            // process morph targets
            if (animationKeys[0].morphTargets) {
                // figure out all morph targets used in this track
                const morphTargetNames = {};
                let k;
                for(k = 0; k < animationKeys.length; k++){
                    if (animationKeys[k].morphTargets) for(let m = 0; m < animationKeys[k].morphTargets.length; m++)morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                }
                // create a track for each morph target with all zero
                // morphTargetInfluences except for the keys in which
                // the morphTarget is named.
                for(const morphTargetName in morphTargetNames){
                    const times = [];
                    const values = [];
                    for(let m = 0; m !== animationKeys[k].morphTargets.length; ++m){
                        const animationKey = animationKeys[k];
                        times.push(animationKey.time);
                        values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                    }
                    tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                }
                duration = morphTargetNames.length * (fps || 1);
            } else {
                // ...assume skeletal animation
                const boneName = '.bones[' + bones[h].name + ']';
                addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
                addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
                addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
            }
        }
        if (tracks.length === 0) return null;
        const clip = new this(clipName, duration, tracks, blendMode);
        return clip;
    }
    resetDuration() {
        const tracks = this.tracks;
        let duration = 0;
        for(let i265 = 0, n = tracks.length; i265 !== n; ++i265){
            const track = this.tracks[i265];
            duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
        return this;
    }
    trim() {
        for(let i266 = 0; i266 < this.tracks.length; i266++)this.tracks[i266].trim(0, this.duration);
        return this;
    }
    validate() {
        let valid = true;
        for(let i267 = 0; i267 < this.tracks.length; i267++)valid = valid && this.tracks[i267].validate();
        return valid;
    }
    optimize() {
        for(let i268 = 0; i268 < this.tracks.length; i268++)this.tracks[i268].optimize();
        return this;
    }
    clone() {
        const tracks = [];
        for(let i269 = 0; i269 < this.tracks.length; i269++)tracks.push(this.tracks[i269].clone());
        return new this.constructor(this.name, this.duration, tracks, this.blendMode);
    }
    toJSON() {
        return this.constructor.toJSON(this);
    }
}
function getTrackTypeForValueTypeName(typeName) {
    switch(typeName.toLowerCase()){
        case 'scalar':
        case 'double':
        case 'float':
        case 'number':
        case 'integer':
            return NumberKeyframeTrack;
        case 'vector':
        case 'vector2':
        case 'vector3':
        case 'vector4':
            return VectorKeyframeTrack;
        case 'color':
            return ColorKeyframeTrack;
        case 'quaternion':
            return QuaternionKeyframeTrack;
        case 'bool':
        case 'boolean':
            return BooleanKeyframeTrack;
        case 'string':
            return StringKeyframeTrack;
    }
    throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
}
function parseKeyframeTrack(json) {
    if (json.type === undefined) throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
    const trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === undefined) {
        const times = [], values = [];
        AnimationUtils.flattenJSON(json.keys, times, values, 'value');
        json.times = times;
        json.values = values;
    }
    // derived classes can define a static parse method
    if (trackType.parse !== undefined) return trackType.parse(json);
    else // by default, we assume a constructor compatible with the base
    return new trackType(json.name, json.times, json.values, json.interpolation);
}
const Cache = {
    enabled: false,
    files: {},
    add: function(key, file) {
        if (this.enabled === false) return;
        // console.log( 'THREE.Cache', 'Adding key:', key );
        this.files[key] = file;
    },
    get: function(key) {
        if (this.enabled === false) return;
        // console.log( 'THREE.Cache', 'Checking key:', key );
        return this.files[key];
    },
    remove: function(key) {
        delete this.files[key];
    },
    clear: function() {
        this.files = {};
    }
};
class LoadingManager {
    constructor(onLoad, onProgress, onError){
        const scope = this;
        let isLoading = false;
        let itemsLoaded = 0;
        let itemsTotal = 0;
        let urlModifier = undefined;
        const handlers = [];
        // Refer to #5689 for the reason why we don't set .onStart
        // in the constructor
        this.onStart = undefined;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;
        this.itemStart = function(url) {
            itemsTotal++;
            if (isLoading === false) {
                if (scope.onStart !== undefined) scope.onStart(url, itemsLoaded, itemsTotal);
            }
            isLoading = true;
        };
        this.itemEnd = function(url) {
            itemsLoaded++;
            if (scope.onProgress !== undefined) scope.onProgress(url, itemsLoaded, itemsTotal);
            if (itemsLoaded === itemsTotal) {
                isLoading = false;
                if (scope.onLoad !== undefined) scope.onLoad();
            }
        };
        this.itemError = function(url) {
            if (scope.onError !== undefined) scope.onError(url);
        };
        this.resolveURL = function(url) {
            if (urlModifier) return urlModifier(url);
            return url;
        };
        this.setURLModifier = function(transform) {
            urlModifier = transform;
            return this;
        };
        this.addHandler = function(regex, loader) {
            handlers.push(regex, loader);
            return this;
        };
        this.removeHandler = function(regex) {
            const index = handlers.indexOf(regex);
            if (index !== -1) handlers.splice(index, 2);
            return this;
        };
        this.getHandler = function(file) {
            for(let i270 = 0, l = handlers.length; i270 < l; i270 += 2){
                const regex = handlers[i270];
                const loader = handlers[i270 + 1];
                if (regex.global) regex.lastIndex = 0; // see #17920
                if (regex.test(file)) return loader;
            }
            return null;
        };
    }
}
const DefaultLoadingManager = new LoadingManager();
class Loader {
    constructor(manager){
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
        this.crossOrigin = 'anonymous';
        this.withCredentials = false;
        this.path = '';
        this.resourcePath = '';
        this.requestHeader = {};
    }
    load() {}
    loadAsync(url, onProgress) {
        const scope = this;
        return new Promise(function(resolve, reject) {
            scope.load(url, resolve, onProgress, reject);
        });
    }
    parse() {}
    setCrossOrigin(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
    }
    setWithCredentials(value) {
        this.withCredentials = value;
        return this;
    }
    setPath(path) {
        this.path = path;
        return this;
    }
    setResourcePath(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
    }
    setRequestHeader(requestHeader) {
        this.requestHeader = requestHeader;
        return this;
    }
}
const loading = {};
class FileLoader extends Loader {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        if (url === undefined) url = '';
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        // Check if request is duplicate
        if (loading[url] !== undefined) {
            loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            return;
        }
        // Check for data: URI
        const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
        const dataUriRegexResult = url.match(dataUriRegex);
        let request;
        // Safari can not handle Data URIs through XMLHttpRequest so process manually
        if (dataUriRegexResult) {
            const mimeType = dataUriRegexResult[1];
            const isBase64 = !!dataUriRegexResult[2];
            let data = dataUriRegexResult[3];
            data = decodeURIComponent(data);
            if (isBase64) data = atob(data);
            try {
                let response;
                const responseType = (this.responseType || '').toLowerCase();
                switch(responseType){
                    case 'arraybuffer':
                    case 'blob':
                        const view = new Uint8Array(data.length);
                        for(let i271 = 0; i271 < data.length; i271++)view[i271] = data.charCodeAt(i271);
                        if (responseType === 'blob') response = new Blob([
                            view.buffer
                        ], {
                            type: mimeType
                        });
                        else response = view.buffer;
                        break;
                    case 'document':
                        const parser = new DOMParser();
                        response = parser.parseFromString(data, mimeType);
                        break;
                    case 'json':
                        response = JSON.parse(data);
                        break;
                    default:
                        response = data;
                        break;
                }
                // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                setTimeout(function() {
                    if (onLoad) onLoad(response);
                    scope.manager.itemEnd(url);
                }, 0);
            } catch (error) {
                // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                setTimeout(function() {
                    if (onError) onError(error);
                    scope.manager.itemError(url);
                    scope.manager.itemEnd(url);
                }, 0);
            }
        } else {
            // Initialise array for duplicate requests
            loading[url] = [];
            loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            request = new XMLHttpRequest();
            request.open('GET', url, true);
            request.addEventListener('load', function(event) {
                const response = this.response;
                const callbacks = loading[url];
                delete loading[url];
                if (this.status === 200 || this.status === 0) {
                    // Some browsers return HTTP Status 0 when using non-http protocol
                    // e.g. 'file://' or 'data://'. Handle as success.
                    if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.');
                    // Add to cache only on HTTP success, so that we do not cache
                    // error response bodies as proper responses to requests.
                    Cache.add(url, response);
                    for(let i272 = 0, il = callbacks.length; i272 < il; i272++){
                        const callback = callbacks[i272];
                        if (callback.onLoad) callback.onLoad(response);
                    }
                    scope.manager.itemEnd(url);
                } else {
                    for(let i273 = 0, il = callbacks.length; i273 < il; i273++){
                        const callback = callbacks[i273];
                        if (callback.onError) callback.onError(event);
                    }
                    scope.manager.itemError(url);
                    scope.manager.itemEnd(url);
                }
            }, false);
            request.addEventListener('progress', function(event) {
                const callbacks = loading[url];
                for(let i274 = 0, il = callbacks.length; i274 < il; i274++){
                    const callback = callbacks[i274];
                    if (callback.onProgress) callback.onProgress(event);
                }
            }, false);
            request.addEventListener('error', function(event) {
                const callbacks = loading[url];
                delete loading[url];
                for(let i275 = 0, il = callbacks.length; i275 < il; i275++){
                    const callback = callbacks[i275];
                    if (callback.onError) callback.onError(event);
                }
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            }, false);
            request.addEventListener('abort', function(event) {
                const callbacks = loading[url];
                delete loading[url];
                for(let i276 = 0, il = callbacks.length; i276 < il; i276++){
                    const callback = callbacks[i276];
                    if (callback.onError) callback.onError(event);
                }
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            }, false);
            if (this.responseType !== undefined) request.responseType = this.responseType;
            if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
            if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');
            for(const header in this.requestHeader)request.setRequestHeader(header, this.requestHeader[header]);
            request.send(null);
        }
        scope.manager.itemStart(url);
        return request;
    }
    setResponseType(value) {
        this.responseType = value;
        return this;
    }
    setMimeType(value) {
        this.mimeType = value;
        return this;
    }
}
class AnimationLoader extends Loader {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(json) {
        const animations = [];
        for(let i277 = 0; i277 < json.length; i277++){
            const clip = AnimationClip.parse(json[i277]);
            animations.push(clip);
        }
        return animations;
    }
}
/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */ class CompressedTextureLoader extends Loader {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const images = [];
        const texture = new CompressedTexture();
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setResponseType('arraybuffer');
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        let loaded = 0;
        function loadTexture(i279) {
            loader.load(url[i279], function(buffer) {
                const texDatas = scope.parse(buffer, true);
                images[i279] = {
                    width: texDatas.width,
                    height: texDatas.height,
                    format: texDatas.format,
                    mipmaps: texDatas.mipmaps
                };
                loaded += 1;
                if (loaded === 6) {
                    if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
                    texture.image = images;
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, onProgress, onError);
        }
        if (Array.isArray(url)) for(let i278 = 0, il = url.length; i278 < il; ++i278)loadTexture(i278);
        else // compressed cubemap texture stored in a single DDS file
        loader.load(url, function(buffer) {
            const texDatas = scope.parse(buffer, true);
            if (texDatas.isCubemap) {
                const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                for(let f = 0; f < faces; f++){
                    images[f] = {
                        mipmaps: []
                    };
                    for(let i280 = 0; i280 < texDatas.mipmapCount; i280++){
                        images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i280]);
                        images[f].format = texDatas.format;
                        images[f].width = texDatas.width;
                        images[f].height = texDatas.height;
                    }
                }
                texture.image = images;
            } else {
                texture.image.width = texDatas.width;
                texture.image.height = texDatas.height;
                texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
        }, onProgress, onError);
        return texture;
    }
}
class ImageLoader extends Loader {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
        function onImageLoad() {
            image.removeEventListener('load', onImageLoad, false);
            image.removeEventListener('error', onImageError, false);
            Cache.add(url, this);
            if (onLoad) onLoad(this);
            scope.manager.itemEnd(url);
        }
        function onImageError(event) {
            image.removeEventListener('load', onImageLoad, false);
            image.removeEventListener('error', onImageError, false);
            if (onError) onError(event);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
        }
        image.addEventListener('load', onImageLoad, false);
        image.addEventListener('error', onImageError, false);
        if (url.substr(0, 5) !== 'data:') {
            if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
        }
        scope.manager.itemStart(url);
        image.src = url;
        return image;
    }
}
class CubeTextureLoader extends Loader {
    constructor(manager){
        super(manager);
    }
    load(urls, onLoad, onProgress, onError) {
        const texture = new CubeTexture();
        const loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        let loaded = 0;
        function loadTexture(i282) {
            loader.load(urls[i282], function(image) {
                texture.images[i282] = image;
                loaded++;
                if (loaded === 6) {
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, undefined, onError);
        }
        for(let i281 = 0; i281 < urls.length; ++i281)loadTexture(i281);
        return texture;
    }
}
/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */ class DataTextureLoader extends Loader {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const texture = new DataTexture();
        const loader = new FileLoader(this.manager);
        loader.setResponseType('arraybuffer');
        loader.setRequestHeader(this.requestHeader);
        loader.setPath(this.path);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(buffer) {
            const texData = scope.parse(buffer);
            if (!texData) return;
            if (texData.image !== undefined) texture.image = texData.image;
            else if (texData.data !== undefined) {
                texture.image.width = texData.width;
                texture.image.height = texData.height;
                texture.image.data = texData.data;
            }
            texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
            texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
            texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
            texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
            texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
            if (texData.encoding !== undefined) texture.encoding = texData.encoding;
            if (texData.flipY !== undefined) texture.flipY = texData.flipY;
            if (texData.format !== undefined) texture.format = texData.format;
            if (texData.type !== undefined) texture.type = texData.type;
            if (texData.mipmaps !== undefined) {
                texture.mipmaps = texData.mipmaps;
                texture.minFilter = LinearMipmapLinearFilter; // presumably...
            }
            if (texData.mipmapCount === 1) texture.minFilter = LinearFilter;
            if (texData.generateMipmaps !== undefined) texture.generateMipmaps = texData.generateMipmaps;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
    }
}
class TextureLoader extends Loader {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const texture = new Texture();
        const loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        loader.load(url, function(image) {
            texture.image = image;
            // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
            const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
            texture.format = isJPEG ? RGBFormat : RGBAFormat;
            texture.needsUpdate = true;
            if (onLoad !== undefined) onLoad(texture);
        }, onProgress, onError);
        return texture;
    }
}
/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/ class CurvePath extends Curve {
    constructor(){
        super();
        this.type = 'CurvePath';
        this.curves = [];
        this.autoClose = false; // Automatically closes the path
    }
    add(curve) {
        this.curves.push(curve);
    }
    closePath() {
        // Add a line curve if start and end of lines are not connected
        const startPoint = this.curves[0].getPoint(0);
        const endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) this.curves.push(new LineCurve(endPoint, startPoint));
    }
    // To get accurate point with reference to
    // entire path distance at time t,
    // following has to be done:
    // 1. Length of each sub path have to be known
    // 2. Locate and identify type of curve
    // 3. Get t for the curve
    // 4. Return curve.getPointAt(t')
    getPoint(t) {
        const d = t * this.getLength();
        const curveLengths = this.getCurveLengths();
        let i283 = 0;
        // To think about boundaries points.
        while(i283 < curveLengths.length){
            if (curveLengths[i283] >= d) {
                const diff = curveLengths[i283] - d;
                const curve = this.curves[i283];
                const segmentLength = curve.getLength();
                const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                return curve.getPointAt(u);
            }
            i283++;
        }
        return null;
    // loop where sum != 0, sum > d , sum+1 <d
    }
    // We cannot use the default THREE.Curve getPoint() with getLength() because in
    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    // getPoint() depends on getLength
    getLength() {
        const lens = this.getCurveLengths();
        return lens[lens.length - 1];
    }
    // cacheLengths must be recalculated.
    updateArcLengths() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
    }
    // Compute lengths and cache them
    // We cannot overwrite getLengths() because UtoT mapping uses it.
    getCurveLengths() {
        // We use cache values if curves and cache array are same length
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        // Get length of sub-curve
        // Push sums into cached array
        const lengths = [];
        let sums = 0;
        for(let i284 = 0, l = this.curves.length; i284 < l; i284++){
            sums += this.curves[i284].getLength();
            lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
    }
    getSpacedPoints(divisions = 40) {
        const points = [];
        for(let i285 = 0; i285 <= divisions; i285++)points.push(this.getPoint(i285 / divisions));
        if (this.autoClose) points.push(points[0]);
        return points;
    }
    getPoints(divisions = 12) {
        const points = [];
        let last;
        for(let i286 = 0, curves = this.curves; i286 < curves.length; i286++){
            const curve = curves[i286];
            const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
            const pts = curve.getPoints(resolution);
            for(let j = 0; j < pts.length; j++){
                const point = pts[j];
                if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates
                points.push(point);
                last = point;
            }
        }
        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) points.push(points[0]);
        return points;
    }
    copy(source) {
        super.copy(source);
        this.curves = [];
        for(let i287 = 0, l = source.curves.length; i287 < l; i287++){
            const curve = source.curves[i287];
            this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.autoClose = this.autoClose;
        data.curves = [];
        for(let i288 = 0, l = this.curves.length; i288 < l; i288++){
            const curve = this.curves[i288];
            data.curves.push(curve.toJSON());
        }
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for(let i289 = 0, l = json.curves.length; i289 < l; i289++){
            const curve = json.curves[i289];
            this.curves.push(new Curves[curve.type]().fromJSON(curve));
        }
        return this;
    }
}
class Path extends CurvePath {
    constructor(points){
        super();
        this.type = 'Path';
        this.currentPoint = new Vector2();
        if (points) this.setFromPoints(points);
    }
    setFromPoints(points) {
        this.moveTo(points[0].x, points[0].y);
        for(let i290 = 1, l = points.length; i290 < l; i290++)this.lineTo(points[i290].x, points[i290].y);
        return this;
    }
    moveTo(x, y) {
        this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
        return this;
    }
    lineTo(x, y) {
        const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
        this.curves.push(curve);
        this.currentPoint.set(x, y);
        return this;
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
        const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    }
    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    }
    splineThru(pts /*Array of Vector*/ ) {
        const npts = [
            this.currentPoint.clone()
        ].concat(pts);
        const curve = new SplineCurve(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
        return this;
    }
    arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    }
    absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    }
    ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        return this;
    }
    absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
            // if a previous curve is present, attempt to join
            const firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) this.lineTo(firstPoint.x, firstPoint.y);
        }
        this.curves.push(curve);
        const lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
        return this;
    }
    copy(source) {
        super.copy(source);
        this.currentPoint.copy(source.currentPoint);
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.currentPoint = this.currentPoint.toArray();
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
    }
}
class Shape extends Path {
    constructor(points){
        super(points);
        this.uuid = generateUUID();
        this.type = 'Shape';
        this.holes = [];
    }
    getPointsHoles(divisions) {
        const holesPts = [];
        for(let i291 = 0, l = this.holes.length; i291 < l; i291++)holesPts[i291] = this.holes[i291].getPoints(divisions);
        return holesPts;
    }
    // get points of shape and holes (keypoints based on segments parameter)
    extractPoints(divisions) {
        return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
        };
    }
    copy(source) {
        super.copy(source);
        this.holes = [];
        for(let i292 = 0, l = source.holes.length; i292 < l; i292++){
            const hole = source.holes[i292];
            this.holes.push(hole.clone());
        }
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.uuid = this.uuid;
        data.holes = [];
        for(let i293 = 0, l = this.holes.length; i293 < l; i293++){
            const hole = this.holes[i293];
            data.holes.push(hole.toJSON());
        }
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.uuid = json.uuid;
        this.holes = [];
        for(let i294 = 0, l = json.holes.length; i294 < l; i294++){
            const hole = json.holes[i294];
            this.holes.push(new Path().fromJSON(hole));
        }
        return this;
    }
}
class Light extends Object3D {
    constructor(color, intensity = 1){
        super();
        this.type = 'Light';
        this.color = new Color(color);
        this.intensity = intensity;
    }
    dispose() {
    // Empty here in base class; some subclasses override.
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== undefined) data.object.distance = this.distance;
        if (this.angle !== undefined) data.object.angle = this.angle;
        if (this.decay !== undefined) data.object.decay = this.decay;
        if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
        if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
        return data;
    }
}
Light.prototype.isLight = true;
class HemisphereLight extends Light {
    constructor(skyColor, groundColor, intensity){
        super(skyColor, intensity);
        this.type = 'HemisphereLight';
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.groundColor = new Color(groundColor);
    }
    copy(source) {
        Light.prototype.copy.call(this, source);
        this.groundColor.copy(source.groundColor);
        return this;
    }
}
HemisphereLight.prototype.isHemisphereLight = true;
const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
const _lookTarget$1 = /*@__PURE__*/ new Vector3();
class LightShadow {
    constructor(camera){
        this.camera = camera;
        this.bias = 0;
        this.normalBias = 0;
        this.radius = 1;
        this.blurSamples = 8;
        this.mapSize = new Vector2(512, 512);
        this.map = null;
        this.mapPass = null;
        this.matrix = new Matrix4();
        this.autoUpdate = true;
        this.needsUpdate = false;
        this._frustum = new Frustum();
        this._frameExtents = new Vector2(1, 1);
        this._viewportCount = 1;
        this._viewports = [
            new Vector4(0, 0, 1, 1)
        ];
    }
    getViewportCount() {
        return this._viewportCount;
    }
    getFrustum() {
        return this._frustum;
    }
    updateMatrices(light) {
        const shadowCamera = this.camera;
        const shadowMatrix = this.matrix;
        _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy(_lightPositionWorld$1);
        _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(_lookTarget$1);
        shadowCamera.updateMatrixWorld();
        _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
        shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
    }
    getViewport(viewportIndex) {
        return this._viewports[viewportIndex];
    }
    getFrameExtents() {
        return this._frameExtents;
    }
    dispose() {
        if (this.map) this.map.dispose();
        if (this.mapPass) this.mapPass.dispose();
    }
    copy(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    toJSON() {
        const object = {};
        if (this.bias !== 0) object.bias = this.bias;
        if (this.normalBias !== 0) object.normalBias = this.normalBias;
        if (this.radius !== 1) object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
    }
}
class SpotLightShadow extends LightShadow {
    constructor(){
        super(new PerspectiveCamera(50, 1, 0.5, 500));
        this.focus = 1;
    }
    updateMatrices(light) {
        const camera = this.camera;
        const fov3 = RAD2DEG * 2 * light.angle * this.focus;
        const aspect3 = this.mapSize.width / this.mapSize.height;
        const far = light.distance || camera.far;
        if (fov3 !== camera.fov || aspect3 !== camera.aspect || far !== camera.far) {
            camera.fov = fov3;
            camera.aspect = aspect3;
            camera.far = far;
            camera.updateProjectionMatrix();
        }
        super.updateMatrices(light);
    }
    copy(source) {
        super.copy(source);
        this.focus = source.focus;
        return this;
    }
}
SpotLightShadow.prototype.isSpotLightShadow = true;
class SpotLight extends Light {
    constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1){
        super(color, intensity);
        this.type = 'SpotLight';
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        this.distance = distance;
        this.angle = angle;
        this.penumbra = penumbra;
        this.decay = decay; // for physically correct lights, should be 2.
        this.shadow = new SpotLightShadow();
    }
    get power() {
        // compute the light's luminous power (in lumens) from its intensity (in candela)
        // by convention for a spotlight, luminous power (lm) = Ï€ * luminous intensity (cd)
        return this.intensity * Math.PI;
    }
    set power(power) {
        // set the light's intensity (in candela) from the desired luminous power (in lumens)
        this.intensity = power / Math.PI;
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(source) {
        super.copy(source);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
}
SpotLight.prototype.isSpotLight = true;
const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld = /*@__PURE__*/ new Vector3();
const _lookTarget = /*@__PURE__*/ new Vector3();
class PointLightShadow extends LightShadow {
    constructor(){
        super(new PerspectiveCamera(90, 1, 0.5, 500));
        this._frameExtents = new Vector2(4, 2);
        this._viewportCount = 6;
        this._viewports = [
            // These viewports map a cube-map onto a 2D texture with the
            // following orientation:
            //
            //  xzXZ
            //   y Y
            //
            // X - Positive x direction
            // x - Negative x direction
            // Y - Positive y direction
            // y - Negative y direction
            // Z - Positive z direction
            // z - Negative z direction
            // positive X
            new Vector4(2, 1, 1, 1),
            // negative X
            new Vector4(0, 1, 1, 1),
            // positive Z
            new Vector4(3, 1, 1, 1),
            // negative Z
            new Vector4(1, 1, 1, 1),
            // positive Y
            new Vector4(3, 0, 1, 1),
            // negative Y
            new Vector4(1, 0, 1, 1)
        ];
        this._cubeDirections = [
            new Vector3(1, 0, 0),
            new Vector3(-1, 0, 0),
            new Vector3(0, 0, 1),
            new Vector3(0, 0, -1),
            new Vector3(0, 1, 0),
            new Vector3(0, -1, 0)
        ];
        this._cubeUps = [
            new Vector3(0, 1, 0),
            new Vector3(0, 1, 0),
            new Vector3(0, 1, 0),
            new Vector3(0, 1, 0),
            new Vector3(0, 0, 1),
            new Vector3(0, 0, -1)
        ];
    }
    updateMatrices(light, viewportIndex = 0) {
        const camera = this.camera;
        const shadowMatrix = this.matrix;
        const far = light.distance || camera.far;
        if (far !== camera.far) {
            camera.far = far;
            camera.updateProjectionMatrix();
        }
        _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        camera.position.copy(_lightPositionWorld);
        _lookTarget.copy(camera.position);
        _lookTarget.add(this._cubeDirections[viewportIndex]);
        camera.up.copy(this._cubeUps[viewportIndex]);
        camera.lookAt(_lookTarget);
        camera.updateMatrixWorld();
        shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(_projScreenMatrix);
    }
}
PointLightShadow.prototype.isPointLightShadow = true;
class PointLight extends Light {
    constructor(color, intensity, distance = 0, decay = 1){
        super(color, intensity);
        this.type = 'PointLight';
        this.distance = distance;
        this.decay = decay; // for physically correct lights, should be 2.
        this.shadow = new PointLightShadow();
    }
    get power() {
        // compute the light's luminous power (in lumens) from its intensity (in candela)
        // for an isotropic light source, luminous power (lm) = 4 Ï€ luminous intensity (cd)
        return this.intensity * 4 * Math.PI;
    }
    set power(power) {
        // set the light's intensity (in candela) from the desired luminous power (in lumens)
        this.intensity = power / (4 * Math.PI);
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(source) {
        super.copy(source);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
    }
}
PointLight.prototype.isPointLight = true;
class DirectionalLightShadow extends LightShadow {
    constructor(){
        super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    }
}
DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
class DirectionalLight extends Light {
    constructor(color, intensity){
        super(color, intensity);
        this.type = 'DirectionalLight';
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        this.shadow = new DirectionalLightShadow();
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(source) {
        super.copy(source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
}
DirectionalLight.prototype.isDirectionalLight = true;
class AmbientLight extends Light {
    constructor(color, intensity){
        super(color, intensity);
        this.type = 'AmbientLight';
    }
}
AmbientLight.prototype.isAmbientLight = true;
class RectAreaLight extends Light {
    constructor(color, intensity, width = 10, height = 10){
        super(color, intensity);
        this.type = 'RectAreaLight';
        this.width = width;
        this.height = height;
    }
    get power() {
        // compute the light's luminous power (in lumens) from its intensity (in nits)
        return this.intensity * this.width * this.height * Math.PI;
    }
    set power(power) {
        // set the light's intensity (in nits) from the desired luminous power (in lumens)
        this.intensity = power / (this.width * this.height * Math.PI);
    }
    copy(source) {
        super.copy(source);
        this.width = source.width;
        this.height = source.height;
        return this;
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.width = this.width;
        data.object.height = this.height;
        return data;
    }
}
RectAreaLight.prototype.isRectAreaLight = true;
/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */ // 3-band SH defined by 9 coefficients
class SphericalHarmonics3 {
    constructor(){
        this.coefficients = [];
        for(let i295 = 0; i295 < 9; i295++)this.coefficients.push(new Vector3());
    }
    set(coefficients) {
        for(let i296 = 0; i296 < 9; i296++)this.coefficients[i296].copy(coefficients[i296]);
        return this;
    }
    zero() {
        for(let i297 = 0; i297 < 9; i297++)this.coefficients[i297].set(0, 0, 0);
        return this;
    }
    // get the radiance in the direction of the normal
    // target is a Vector3
    getAt(normal, target) {
        // normal is assumed to be unit length
        const x = normal.x, y = normal.y, z = normal.z;
        const coeff = this.coefficients;
        // band 0
        target.copy(coeff[0]).multiplyScalar(0.282095);
        // band 1
        target.addScaledVector(coeff[1], 0.488603 * y);
        target.addScaledVector(coeff[2], 0.488603 * z);
        target.addScaledVector(coeff[3], 0.488603 * x);
        // band 2
        target.addScaledVector(coeff[4], 1.092548 * (x * y));
        target.addScaledVector(coeff[5], 1.092548 * (y * z));
        target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
        target.addScaledVector(coeff[7], 1.092548 * (x * z));
        target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
        return target;
    }
    // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
    // target is a Vector3
    // https://graphics.stanford.edu/papers/envmap/envmap.pdf
    getIrradianceAt(normal, target) {
        // normal is assumed to be unit length
        const x = normal.x, y = normal.y, z = normal.z;
        const coeff = this.coefficients;
        // band 0
        target.copy(coeff[0]).multiplyScalar(0.886227); // Ï€ * 0.282095
        // band 1
        target.addScaledVector(coeff[1], 1.023328 * y); // ( 2 * Ï€ / 3 ) * 0.488603
        target.addScaledVector(coeff[2], 1.023328 * z);
        target.addScaledVector(coeff[3], 1.023328 * x);
        // band 2
        target.addScaledVector(coeff[4], 0.858086 * x * y); // ( Ï€ / 4 ) * 1.092548
        target.addScaledVector(coeff[5], 0.858086 * y * z);
        target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( Ï€ / 4 ) * 0.315392 * 3
        target.addScaledVector(coeff[7], 0.858086 * x * z);
        target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( Ï€ / 4 ) * 0.546274
        return target;
    }
    add(sh) {
        for(let i298 = 0; i298 < 9; i298++)this.coefficients[i298].add(sh.coefficients[i298]);
        return this;
    }
    addScaledSH(sh, s) {
        for(let i299 = 0; i299 < 9; i299++)this.coefficients[i299].addScaledVector(sh.coefficients[i299], s);
        return this;
    }
    scale(s) {
        for(let i300 = 0; i300 < 9; i300++)this.coefficients[i300].multiplyScalar(s);
        return this;
    }
    lerp(sh, alpha) {
        for(let i301 = 0; i301 < 9; i301++)this.coefficients[i301].lerp(sh.coefficients[i301], alpha);
        return this;
    }
    equals(sh) {
        for(let i302 = 0; i302 < 9; i302++){
            if (!this.coefficients[i302].equals(sh.coefficients[i302])) return false;
        }
        return true;
    }
    copy(sh) {
        return this.set(sh.coefficients);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
        const coefficients = this.coefficients;
        for(let i303 = 0; i303 < 9; i303++)coefficients[i303].fromArray(array, offset + i303 * 3);
        return this;
    }
    toArray(array = [], offset = 0) {
        const coefficients = this.coefficients;
        for(let i304 = 0; i304 < 9; i304++)coefficients[i304].toArray(array, offset + i304 * 3);
        return array;
    }
    // evaluate the basis functions
    // shBasis is an Array[ 9 ]
    static getBasisAt(normal, shBasis) {
        // normal is assumed to be unit length
        const x = normal.x, y = normal.y, z = normal.z;
        // band 0
        shBasis[0] = 0.282095;
        // band 1
        shBasis[1] = 0.488603 * y;
        shBasis[2] = 0.488603 * z;
        shBasis[3] = 0.488603 * x;
        // band 2
        shBasis[4] = 1.092548 * x * y;
        shBasis[5] = 1.092548 * y * z;
        shBasis[6] = 0.315392 * (3 * z * z - 1);
        shBasis[7] = 1.092548 * x * z;
        shBasis[8] = 0.546274 * (x * x - y * y);
    }
}
SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
class LightProbe extends Light {
    constructor(sh = new SphericalHarmonics3(), intensity = 1){
        super(undefined, intensity);
        this.sh = sh;
    }
    copy(source) {
        super.copy(source);
        this.sh.copy(source.sh);
        return this;
    }
    fromJSON(json) {
        this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
        this.sh.fromArray(json.sh);
        return this;
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.sh = this.sh.toArray();
        return data;
    }
}
LightProbe.prototype.isLightProbe = true;
class MaterialLoader extends Loader {
    constructor(manager){
        super(manager);
        this.textures = {};
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(json) {
        const textures = this.textures;
        function getTexture(name) {
            if (textures[name] === undefined) console.warn('THREE.MaterialLoader: Undefined texture', name);
            return textures[name];
        }
        const material = new Materials[json.type]();
        if (json.uuid !== undefined) material.uuid = json.uuid;
        if (json.name !== undefined) material.name = json.name;
        if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
        if (json.roughness !== undefined) material.roughness = json.roughness;
        if (json.metalness !== undefined) material.metalness = json.metalness;
        if (json.sheenTint !== undefined) material.sheenTint = new Color().setHex(json.sheenTint);
        if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
        if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
        if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;
        if (json.specularTint !== undefined && material.specularTint !== undefined) material.specularTint.setHex(json.specularTint);
        if (json.shininess !== undefined) material.shininess = json.shininess;
        if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
        if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
        if (json.transmission !== undefined) material.transmission = json.transmission;
        if (json.thickness !== undefined) material.thickness = json.thickness;
        if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;
        if (json.attenuationTint !== undefined && material.attenuationTint !== undefined) material.attenuationTint.setHex(json.attenuationTint);
        if (json.fog !== undefined) material.fog = json.fog;
        if (json.flatShading !== undefined) material.flatShading = json.flatShading;
        if (json.blending !== undefined) material.blending = json.blending;
        if (json.combine !== undefined) material.combine = json.combine;
        if (json.side !== undefined) material.side = json.side;
        if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
        if (json.opacity !== undefined) material.opacity = json.opacity;
        if (json.format !== undefined) material.format = json.format;
        if (json.transparent !== undefined) material.transparent = json.transparent;
        if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
        if (json.depthTest !== undefined) material.depthTest = json.depthTest;
        if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
        if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
        if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
        if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
        if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
        if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
        if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
        if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
        if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
        if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
        if (json.wireframe !== undefined) material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
        if (json.rotation !== undefined) material.rotation = json.rotation;
        if (json.linewidth !== 1) material.linewidth = json.linewidth;
        if (json.dashSize !== undefined) material.dashSize = json.dashSize;
        if (json.gapSize !== undefined) material.gapSize = json.gapSize;
        if (json.scale !== undefined) material.scale = json.scale;
        if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
        if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
        if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
        if (json.dithering !== undefined) material.dithering = json.dithering;
        if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
        if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
        if (json.visible !== undefined) material.visible = json.visible;
        if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
        if (json.userData !== undefined) material.userData = json.userData;
        if (json.vertexColors !== undefined) {
            if (typeof json.vertexColors === 'number') material.vertexColors = json.vertexColors > 0 ? true : false;
            else material.vertexColors = json.vertexColors;
        }
        // Shader Material
        if (json.uniforms !== undefined) for(const name4 in json.uniforms){
            const uniform = json.uniforms[name4];
            material.uniforms[name4] = {};
            switch(uniform.type){
                case 't':
                    material.uniforms[name4].value = getTexture(uniform.value);
                    break;
                case 'c':
                    material.uniforms[name4].value = new Color().setHex(uniform.value);
                    break;
                case 'v2':
                    material.uniforms[name4].value = new Vector2().fromArray(uniform.value);
                    break;
                case 'v3':
                    material.uniforms[name4].value = new Vector3().fromArray(uniform.value);
                    break;
                case 'v4':
                    material.uniforms[name4].value = new Vector4().fromArray(uniform.value);
                    break;
                case 'm3':
                    material.uniforms[name4].value = new Matrix3().fromArray(uniform.value);
                    break;
                case 'm4':
                    material.uniforms[name4].value = new Matrix4().fromArray(uniform.value);
                    break;
                default:
                    material.uniforms[name4].value = uniform.value;
            }
        }
        if (json.defines !== undefined) material.defines = json.defines;
        if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
        if (json.extensions !== undefined) for(const key in json.extensions)material.extensions[key] = json.extensions[key];
        // Deprecated
        if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
        // for PointsMaterial
        if (json.size !== undefined) material.size = json.size;
        if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
        // maps
        if (json.map !== undefined) material.map = getTexture(json.map);
        if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
        if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
        if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
        if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
        if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
        if (json.normalScale !== undefined) {
            let normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) // Blender exporter used to export a scalar. See #7459
            normalScale = [
                normalScale,
                normalScale
            ];
            material.normalScale = new Vector2().fromArray(normalScale);
        }
        if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
        if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
        if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
        if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);
        if (json.specularTintMap !== undefined) material.specularTintMap = getTexture(json.specularTintMap);
        if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
        if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
        if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
        if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
        if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
        if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
        if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
        if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
        if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
        if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
        if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
        if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);
        return material;
    }
    setTextures(value) {
        this.textures = value;
        return this;
    }
}
class LoaderUtils {
    static decodeText(array) {
        if (typeof TextDecoder !== 'undefined') return new TextDecoder().decode(array);
        // Avoid the String.fromCharCode.apply(null, array) shortcut, which
        // throws a "maximum call stack size exceeded" error for large arrays.
        let s = '';
        for(let i305 = 0, il = array.length; i305 < il; i305++)// Implicitly assumes little-endian.
        s += String.fromCharCode(array[i305]);
        try {
            // merges multi-byte utf-8 characters.
            return decodeURIComponent(escape(s));
        } catch (e) {
            return s;
        }
    }
    static extractUrlBase(url) {
        const index = url.lastIndexOf('/');
        if (index === -1) return './';
        return url.substr(0, index + 1);
    }
}
class InstancedBufferGeometry extends BufferGeometry {
    constructor(){
        super();
        this.type = 'InstancedBufferGeometry';
        this.instanceCount = Infinity;
    }
    copy(source) {
        super.copy(source);
        this.instanceCount = source.instanceCount;
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    toJSON() {
        const data = super.toJSON(this);
        data.instanceCount = this.instanceCount;
        data.isInstancedBufferGeometry = true;
        return data;
    }
}
InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
class BufferGeometryLoader extends Loader {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(json1) {
        const interleavedBufferMap = {};
        const arrayBufferMap = {};
        function getInterleavedBuffer(json, uuid) {
            if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
            const interleavedBuffers = json.interleavedBuffers;
            const interleavedBuffer = interleavedBuffers[uuid];
            const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
            const array = getTypedArray(interleavedBuffer.type, buffer);
            const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
            ib.uuid = interleavedBuffer.uuid;
            interleavedBufferMap[uuid] = ib;
            return ib;
        }
        function getArrayBuffer(json, uuid) {
            if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
            const arrayBuffers = json.arrayBuffers;
            const arrayBuffer = arrayBuffers[uuid];
            const ab = new Uint32Array(arrayBuffer).buffer;
            arrayBufferMap[uuid] = ab;
            return ab;
        }
        const geometry = json1.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
        const index = json1.data.index;
        if (index !== undefined) {
            const typedArray = getTypedArray(index.type, index.array);
            geometry.setIndex(new BufferAttribute(typedArray, 1));
        }
        const attributes = json1.data.attributes;
        for(const key in attributes){
            const attribute = attributes[key];
            let bufferAttribute;
            if (attribute.isInterleavedBufferAttribute) {
                const interleavedBuffer = getInterleavedBuffer(json1.data, attribute.data);
                bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
            } else {
                const typedArray = getTypedArray(attribute.type, attribute.array);
                const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
                bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
            }
            if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
            if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);
            if (attribute.updateRange !== undefined) {
                bufferAttribute.updateRange.offset = attribute.updateRange.offset;
                bufferAttribute.updateRange.count = attribute.updateRange.count;
            }
            geometry.setAttribute(key, bufferAttribute);
        }
        const morphAttributes = json1.data.morphAttributes;
        if (morphAttributes) for(const key2 in morphAttributes){
            const attributeArray = morphAttributes[key2];
            const array = [];
            for(let i306 = 0, il = attributeArray.length; i306 < il; i306++){
                const attribute = attributeArray[i306];
                let bufferAttribute;
                if (attribute.isInterleavedBufferAttribute) {
                    const interleavedBuffer = getInterleavedBuffer(json1.data, attribute.data);
                    bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                    const typedArray = getTypedArray(attribute.type, attribute.array);
                    bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
                }
                if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
                array.push(bufferAttribute);
            }
            geometry.morphAttributes[key2] = array;
        }
        const morphTargetsRelative = json1.data.morphTargetsRelative;
        if (morphTargetsRelative) geometry.morphTargetsRelative = true;
        const groups = json1.data.groups || json1.data.drawcalls || json1.data.offsets;
        if (groups !== undefined) for(let i307 = 0, n = groups.length; i307 !== n; ++i307){
            const group = groups[i307];
            geometry.addGroup(group.start, group.count, group.materialIndex);
        }
        const boundingSphere = json1.data.boundingSphere;
        if (boundingSphere !== undefined) {
            const center = new Vector3();
            if (boundingSphere.center !== undefined) center.fromArray(boundingSphere.center);
            geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
        }
        if (json1.name) geometry.name = json1.name;
        if (json1.userData) geometry.userData = json1.userData;
        return geometry;
    }
}
class ObjectLoader extends Loader {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text) {
            let json = null;
            try {
                json = JSON.parse(text);
            } catch (error) {
                if (onError !== undefined) onError(error);
                console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
                return;
            }
            const metadata = json.metadata;
            if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                console.error('THREE.ObjectLoader: Can\'t load ' + url);
                return;
            }
            scope.parse(json, onLoad);
        }, onProgress, onError);
    }
    async loadAsync(url, onProgress) {
        const scope = this;
        const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        const text = await loader.loadAsync(url, onProgress);
        const json = JSON.parse(text);
        const metadata = json.metadata;
        if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') throw new Error('THREE.ObjectLoader: Can\'t load ' + url);
        return await scope.parseAsync(json);
    }
    parse(json, onLoad) {
        const animations = this.parseAnimations(json.animations);
        const shapes = this.parseShapes(json.shapes);
        const geometries = this.parseGeometries(json.geometries, shapes);
        const images = this.parseImages(json.images, function() {
            if (onLoad !== undefined) onLoad(object);
        });
        const textures = this.parseTextures(json.textures, images);
        const materials = this.parseMaterials(json.materials, textures);
        const object = this.parseObject(json.object, geometries, materials, textures, animations);
        const skeletons = this.parseSkeletons(json.skeletons, object);
        this.bindSkeletons(object, skeletons);
        //
        if (onLoad !== undefined) {
            let hasImages = false;
            for(const uuid in images)if (images[uuid] instanceof HTMLImageElement) {
                hasImages = true;
                break;
            }
            if (hasImages === false) onLoad(object);
        }
        return object;
    }
    async parseAsync(json) {
        const animations = this.parseAnimations(json.animations);
        const shapes = this.parseShapes(json.shapes);
        const geometries = this.parseGeometries(json.geometries, shapes);
        const images = await this.parseImagesAsync(json.images);
        const textures = this.parseTextures(json.textures, images);
        const materials = this.parseMaterials(json.materials, textures);
        const object = this.parseObject(json.object, geometries, materials, textures, animations);
        const skeletons = this.parseSkeletons(json.skeletons, object);
        this.bindSkeletons(object, skeletons);
        return object;
    }
    parseShapes(json) {
        const shapes = {};
        if (json !== undefined) for(let i308 = 0, l = json.length; i308 < l; i308++){
            const shape = new Shape().fromJSON(json[i308]);
            shapes[shape.uuid] = shape;
        }
        return shapes;
    }
    parseSkeletons(json, object) {
        const skeletons = {};
        const bones = {};
        // generate bone lookup table
        object.traverse(function(child) {
            if (child.isBone) bones[child.uuid] = child;
        });
        // create skeletons
        if (json !== undefined) for(let i309 = 0, l = json.length; i309 < l; i309++){
            const skeleton = new Skeleton().fromJSON(json[i309], bones);
            skeletons[skeleton.uuid] = skeleton;
        }
        return skeletons;
    }
    parseGeometries(json, shapes) {
        const geometries = {};
        if (json !== undefined) {
            const bufferGeometryLoader = new BufferGeometryLoader();
            for(let i310 = 0, l = json.length; i310 < l; i310++){
                let geometry;
                const data = json[i310];
                switch(data.type){
                    case 'BufferGeometry':
                    case 'InstancedBufferGeometry':
                        geometry = bufferGeometryLoader.parse(data);
                        break;
                    case 'Geometry':
                        console.error('THREE.ObjectLoader: The legacy Geometry type is no longer supported.');
                        break;
                    default:
                        if (data.type in Geometries) geometry = Geometries[data.type].fromJSON(data, shapes);
                        else console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
                }
                geometry.uuid = data.uuid;
                if (data.name !== undefined) geometry.name = data.name;
                if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
                geometries[data.uuid] = geometry;
            }
        }
        return geometries;
    }
    parseMaterials(json, textures) {
        const cache = {}; // MultiMaterial
        const materials = {};
        if (json !== undefined) {
            const loader = new MaterialLoader();
            loader.setTextures(textures);
            for(let i311 = 0, l = json.length; i311 < l; i311++){
                const data = json[i311];
                if (data.type === 'MultiMaterial') {
                    // Deprecated
                    const array = [];
                    for(let j = 0; j < data.materials.length; j++){
                        const material = data.materials[j];
                        if (cache[material.uuid] === undefined) cache[material.uuid] = loader.parse(material);
                        array.push(cache[material.uuid]);
                    }
                    materials[data.uuid] = array;
                } else {
                    if (cache[data.uuid] === undefined) cache[data.uuid] = loader.parse(data);
                    materials[data.uuid] = cache[data.uuid];
                }
            }
        }
        return materials;
    }
    parseAnimations(json) {
        const animations = {};
        if (json !== undefined) for(let i312 = 0; i312 < json.length; i312++){
            const data = json[i312];
            const clip = AnimationClip.parse(data);
            animations[clip.uuid] = clip;
        }
        return animations;
    }
    parseImages(json, onLoad) {
        const scope = this;
        const images = {};
        let loader;
        function loadImage(url) {
            scope.manager.itemStart(url);
            return loader.load(url, function() {
                scope.manager.itemEnd(url);
            }, undefined, function() {
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            });
        }
        function deserializeImage(image) {
            if (typeof image === 'string') {
                const url = image;
                const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
                return loadImage(path);
            } else {
                if (image.data) return {
                    data: getTypedArray(image.type, image.data),
                    width: image.width,
                    height: image.height
                };
                else return null;
            }
        }
        if (json !== undefined && json.length > 0) {
            const manager = new LoadingManager(onLoad);
            loader = new ImageLoader(manager);
            loader.setCrossOrigin(this.crossOrigin);
            for(let i313 = 0, il = json.length; i313 < il; i313++){
                const image = json[i313];
                const url = image.url;
                if (Array.isArray(url)) {
                    // load array of images e.g CubeTexture
                    images[image.uuid] = [];
                    for(let j = 0, jl = url.length; j < jl; j++){
                        const currentUrl = url[j];
                        const deserializedImage = deserializeImage(currentUrl);
                        if (deserializedImage !== null) {
                            if (deserializedImage instanceof HTMLImageElement) images[image.uuid].push(deserializedImage);
                            else // special case: handle array of data textures for cube textures
                            images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                        }
                    }
                } else {
                    // load single image
                    const deserializedImage = deserializeImage(image.url);
                    if (deserializedImage !== null) images[image.uuid] = deserializedImage;
                }
            }
        }
        return images;
    }
    async parseImagesAsync(json) {
        const scope = this;
        const images = {};
        let loader;
        async function deserializeImage(image) {
            if (typeof image === 'string') {
                const url = image;
                const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
                return await loader.loadAsync(path);
            } else {
                if (image.data) return {
                    data: getTypedArray(image.type, image.data),
                    width: image.width,
                    height: image.height
                };
                else return null;
            }
        }
        if (json !== undefined && json.length > 0) {
            loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            for(let i314 = 0, il = json.length; i314 < il; i314++){
                const image = json[i314];
                const url = image.url;
                if (Array.isArray(url)) {
                    // load array of images e.g CubeTexture
                    images[image.uuid] = [];
                    for(let j = 0, jl = url.length; j < jl; j++){
                        const currentUrl = url[j];
                        const deserializedImage = await deserializeImage(currentUrl);
                        if (deserializedImage !== null) {
                            if (deserializedImage instanceof HTMLImageElement) images[image.uuid].push(deserializedImage);
                            else // special case: handle array of data textures for cube textures
                            images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                        }
                    }
                } else {
                    // load single image
                    const deserializedImage = await deserializeImage(image.url);
                    if (deserializedImage !== null) images[image.uuid] = deserializedImage;
                }
            }
        }
        return images;
    }
    parseTextures(json, images) {
        function parseConstant(value, type) {
            if (typeof value === 'number') return value;
            console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
            return type[value];
        }
        const textures = {};
        if (json !== undefined) for(let i315 = 0, l = json.length; i315 < l; i315++){
            const data = json[i315];
            if (data.image === undefined) console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
            if (images[data.image] === undefined) console.warn('THREE.ObjectLoader: Undefined image', data.image);
            let texture;
            const image = images[data.image];
            if (Array.isArray(image)) {
                texture = new CubeTexture(image);
                if (image.length === 6) texture.needsUpdate = true;
            } else {
                if (image && image.data) texture = new DataTexture(image.data, image.width, image.height);
                else texture = new Texture(image);
                if (image) texture.needsUpdate = true; // textures can have undefined image data
            }
            texture.uuid = data.uuid;
            if (data.name !== undefined) texture.name = data.name;
            if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
            if (data.offset !== undefined) texture.offset.fromArray(data.offset);
            if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
            if (data.center !== undefined) texture.center.fromArray(data.center);
            if (data.rotation !== undefined) texture.rotation = data.rotation;
            if (data.wrap !== undefined) {
                texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
            }
            if (data.format !== undefined) texture.format = data.format;
            if (data.type !== undefined) texture.type = data.type;
            if (data.encoding !== undefined) texture.encoding = data.encoding;
            if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
            if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
            if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
            if (data.flipY !== undefined) texture.flipY = data.flipY;
            if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
            if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
            textures[data.uuid] = texture;
        }
        return textures;
    }
    parseObject(data, geometries, materials, textures, animations) {
        let object;
        function getGeometry(name) {
            if (geometries[name] === undefined) console.warn('THREE.ObjectLoader: Undefined geometry', name);
            return geometries[name];
        }
        function getMaterial(name) {
            if (name === undefined) return undefined;
            if (Array.isArray(name)) {
                const array = [];
                for(let i316 = 0, l = name.length; i316 < l; i316++){
                    const uuid = name[i316];
                    if (materials[uuid] === undefined) console.warn('THREE.ObjectLoader: Undefined material', uuid);
                    array.push(materials[uuid]);
                }
                return array;
            }
            if (materials[name] === undefined) console.warn('THREE.ObjectLoader: Undefined material', name);
            return materials[name];
        }
        function getTexture(uuid) {
            if (textures[uuid] === undefined) console.warn('THREE.ObjectLoader: Undefined texture', uuid);
            return textures[uuid];
        }
        let geometry, material;
        switch(data.type){
            case 'Scene':
                object = new Scene();
                if (data.background !== undefined) {
                    if (Number.isInteger(data.background)) object.background = new Color(data.background);
                    else object.background = getTexture(data.background);
                }
                if (data.environment !== undefined) object.environment = getTexture(data.environment);
                if (data.fog !== undefined) {
                    if (data.fog.type === 'Fog') object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                    else if (data.fog.type === 'FogExp2') object.fog = new FogExp2(data.fog.color, data.fog.density);
                }
                break;
            case 'PerspectiveCamera':
                object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                if (data.focus !== undefined) object.focus = data.focus;
                if (data.zoom !== undefined) object.zoom = data.zoom;
                if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                if (data.view !== undefined) object.view = Object.assign({}, data.view);
                break;
            case 'OrthographicCamera':
                object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                if (data.zoom !== undefined) object.zoom = data.zoom;
                if (data.view !== undefined) object.view = Object.assign({}, data.view);
                break;
            case 'AmbientLight':
                object = new AmbientLight(data.color, data.intensity);
                break;
            case 'DirectionalLight':
                object = new DirectionalLight(data.color, data.intensity);
                break;
            case 'PointLight':
                object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                break;
            case 'RectAreaLight':
                object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                break;
            case 'SpotLight':
                object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                break;
            case 'HemisphereLight':
                object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                break;
            case 'LightProbe':
                object = new LightProbe().fromJSON(data);
                break;
            case 'SkinnedMesh':
                geometry = getGeometry(data.geometry);
                material = getMaterial(data.material);
                object = new SkinnedMesh(geometry, material);
                if (data.bindMode !== undefined) object.bindMode = data.bindMode;
                if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
                if (data.skeleton !== undefined) object.skeleton = data.skeleton;
                break;
            case 'Mesh':
                geometry = getGeometry(data.geometry);
                material = getMaterial(data.material);
                object = new Mesh(geometry, material);
                break;
            case 'InstancedMesh':
                geometry = getGeometry(data.geometry);
                material = getMaterial(data.material);
                const count = data.count;
                const instanceMatrix = data.instanceMatrix;
                const instanceColor = data.instanceColor;
                object = new InstancedMesh(geometry, material, count);
                object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
                if (instanceColor !== undefined) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
                break;
            case 'LOD':
                object = new LOD();
                break;
            case 'Line':
                object = new Line(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'LineLoop':
                object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'LineSegments':
                object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'PointCloud':
            case 'Points':
                object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'Sprite':
                object = new Sprite(getMaterial(data.material));
                break;
            case 'Group':
                object = new Group();
                break;
            case 'Bone':
                object = new Bone();
                break;
            default:
                object = new Object3D();
        }
        object.uuid = data.uuid;
        if (data.name !== undefined) object.name = data.name;
        if (data.matrix !== undefined) {
            object.matrix.fromArray(data.matrix);
            if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
            if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
        } else {
            if (data.position !== undefined) object.position.fromArray(data.position);
            if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
            if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
            if (data.scale !== undefined) object.scale.fromArray(data.scale);
        }
        if (data.castShadow !== undefined) object.castShadow = data.castShadow;
        if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
        if (data.shadow) {
            if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
            if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
            if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
            if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
            if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
        }
        if (data.visible !== undefined) object.visible = data.visible;
        if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
        if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
        if (data.userData !== undefined) object.userData = data.userData;
        if (data.layers !== undefined) object.layers.mask = data.layers;
        if (data.children !== undefined) {
            const children = data.children;
            for(let i317 = 0; i317 < children.length; i317++)object.add(this.parseObject(children[i317], geometries, materials, textures, animations));
        }
        if (data.animations !== undefined) {
            const objectAnimations = data.animations;
            for(let i318 = 0; i318 < objectAnimations.length; i318++){
                const uuid = objectAnimations[i318];
                object.animations.push(animations[uuid]);
            }
        }
        if (data.type === 'LOD') {
            if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
            const levels = data.levels;
            for(let l = 0; l < levels.length; l++){
                const level = levels[l];
                const child = object.getObjectByProperty('uuid', level.object);
                if (child !== undefined) object.addLevel(child, level.distance);
            }
        }
        return object;
    }
    bindSkeletons(object, skeletons) {
        if (Object.keys(skeletons).length === 0) return;
        object.traverse(function(child) {
            if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
                const skeleton = skeletons[child.skeleton];
                if (skeleton === undefined) console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
                else child.bind(skeleton, child.bindMatrix);
            }
        });
    }
    /* DEPRECATED */ setTexturePath(value) {
        console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
        return this.setResourcePath(value);
    }
}
const TEXTURE_MAPPING = {
    UVMapping: UVMapping,
    CubeReflectionMapping: CubeReflectionMapping,
    CubeRefractionMapping: CubeRefractionMapping,
    EquirectangularReflectionMapping: EquirectangularReflectionMapping,
    EquirectangularRefractionMapping: EquirectangularRefractionMapping,
    CubeUVReflectionMapping: CubeUVReflectionMapping,
    CubeUVRefractionMapping: CubeUVRefractionMapping
};
const TEXTURE_WRAPPING = {
    RepeatWrapping: RepeatWrapping,
    ClampToEdgeWrapping: ClampToEdgeWrapping,
    MirroredRepeatWrapping: MirroredRepeatWrapping
};
const TEXTURE_FILTER = {
    NearestFilter: NearestFilter,
    NearestMipmapNearestFilter: NearestMipmapNearestFilter,
    NearestMipmapLinearFilter: NearestMipmapLinearFilter,
    LinearFilter: LinearFilter,
    LinearMipmapNearestFilter: LinearMipmapNearestFilter,
    LinearMipmapLinearFilter: LinearMipmapLinearFilter
};
class ImageBitmapLoader extends Loader {
    constructor(manager){
        super(manager);
        if (typeof createImageBitmap === 'undefined') console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
        if (typeof fetch === 'undefined') console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
        this.options = {
            premultiplyAlpha: 'none'
        };
    }
    setOptions(options) {
        this.options = options;
        return this;
    }
    load(url, onLoad, onProgress, onError) {
        if (url === undefined) url = '';
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        const fetchOptions = {};
        fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
        fetchOptions.headers = this.requestHeader;
        fetch(url, fetchOptions).then(function(res) {
            return res.blob();
        }).then(function(blob) {
            return createImageBitmap(blob, Object.assign(scope.options, {
                colorSpaceConversion: 'none'
            }));
        }).then(function(imageBitmap) {
            Cache.add(url, imageBitmap);
            if (onLoad) onLoad(imageBitmap);
            scope.manager.itemEnd(url);
        }).catch(function(e) {
            if (onError) onError(e);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
        });
        scope.manager.itemStart(url);
    }
}
ImageBitmapLoader.prototype.isImageBitmapLoader = true;
class ShapePath {
    constructor(){
        this.type = 'ShapePath';
        this.color = new Color();
        this.subPaths = [];
        this.currentPath = null;
    }
    moveTo(x, y) {
        this.currentPath = new Path();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x, y);
        return this;
    }
    lineTo(x, y) {
        this.currentPath.lineTo(x, y);
        return this;
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
    }
    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
    }
    splineThru(pts) {
        this.currentPath.splineThru(pts);
        return this;
    }
    toShapes(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
            const shapes = [];
            for(let i321 = 0, l = inSubpaths.length; i321 < l; i321++){
                const tmpPath = inSubpaths[i321];
                const tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
            }
            return shapes;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            // inPt on polygon contour => immediate success    or
            // toggling of inside/outside at every single! intersection point of an edge
            //  with the horizontal line through inPt, left of inPt
            //  not counting lowerY endpoints of edges and whole edges on that line
            let inside = false;
            for(let p = polyLen - 1, q = 0; q < polyLen; p = q++){
                let edgeLowPt = inPolygon[p];
                let edgeHighPt = inPolygon[q];
                let edgeDx = edgeHighPt.x - edgeLowPt.x;
                let edgeDy = edgeHighPt.y - edgeLowPt.y;
                if (Math.abs(edgeDy) > Number.EPSILON) {
                    // not parallel
                    if (edgeDy < 0) {
                        edgeLowPt = inPolygon[q];
                        edgeDx = -edgeDx;
                        edgeHighPt = inPolygon[p];
                        edgeDy = -edgeDy;
                    }
                    if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                    if (inPt.y === edgeLowPt.y) {
                        if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
                    // continue;				// no intersection or edgeLowPt => doesn't count !!!
                    } else {
                        const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                        if (perpEdge === 0) return true; // inPt is on contour ?
                        if (perpEdge < 0) continue;
                        inside = !inside; // true intersection left of inPt
                    }
                } else {
                    // parallel or collinear
                    if (inPt.y !== edgeLowPt.y) continue; // parallel
                    // edge lies on the same horizontal line as inPt
                    if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
                // continue;
                }
            }
            return inside;
        }
        const isClockWise = ShapeUtils.isClockWise;
        const subPaths = this.subPaths;
        if (subPaths.length === 0) return [];
        if (noHoles === true) return toShapesNoHoles(subPaths);
        let solid, tmpPath1, tmpShape1;
        const shapes1 = [];
        if (subPaths.length === 1) {
            tmpPath1 = subPaths[0];
            tmpShape1 = new Shape();
            tmpShape1.curves = tmpPath1.curves;
            shapes1.push(tmpShape1);
            return shapes1;
        }
        let holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        // console.log("Holes first", holesFirst);
        const betterShapeHoles = [];
        const newShapes = [];
        let newShapeHoles = [];
        let mainIdx = 0;
        let tmpPoints;
        newShapes[mainIdx] = undefined;
        newShapeHoles[mainIdx] = [];
        for(let i320 = 0, l6 = subPaths.length; i320 < l6; i320++){
            tmpPath1 = subPaths[i320];
            tmpPoints = tmpPath1.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
                if (!holesFirst && newShapes[mainIdx]) mainIdx++;
                newShapes[mainIdx] = {
                    s: new Shape(),
                    p: tmpPoints
                };
                newShapes[mainIdx].s.curves = tmpPath1.curves;
                if (holesFirst) mainIdx++;
                newShapeHoles[mainIdx] = [];
            //console.log('cw', i);
            } else newShapeHoles[mainIdx].push({
                h: tmpPath1,
                p: tmpPoints[0]
            });
        }
        // only Holes? -> probably all Shapes with wrong orientation
        if (!newShapes[0]) return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
            let ambiguous = false;
            const toChange = [];
            for(let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++)betterShapeHoles[sIdx] = [];
            for(let sIdx1 = 0, sLen1 = newShapes.length; sIdx1 < sLen1; sIdx1++){
                const sho = newShapeHoles[sIdx1];
                for(let hIdx = 0; hIdx < sho.length; hIdx++){
                    const ho = sho[hIdx];
                    let hole_unassigned = true;
                    for(let s2Idx = 0; s2Idx < newShapes.length; s2Idx++)if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                        if (sIdx1 !== s2Idx) toChange.push({
                            froms: sIdx1,
                            tos: s2Idx,
                            hole: hIdx
                        });
                        if (hole_unassigned) {
                            hole_unassigned = false;
                            betterShapeHoles[s2Idx].push(ho);
                        } else ambiguous = true;
                    }
                    if (hole_unassigned) betterShapeHoles[sIdx1].push(ho);
                }
            }
            // console.log("ambiguous: ", ambiguous);
            if (toChange.length > 0) // console.log("to change: ", toChange);
            {
                if (!ambiguous) newShapeHoles = betterShapeHoles;
            }
        }
        let tmpHoles;
        for(let i319 = 0, il = newShapes.length; i319 < il; i319++){
            tmpShape1 = newShapes[i319].s;
            shapes1.push(tmpShape1);
            tmpHoles = newShapeHoles[i319];
            for(let j = 0, jl = tmpHoles.length; j < jl; j++)tmpShape1.holes.push(tmpHoles[j].h);
        }
        //console.log("shape", shapes);
        return shapes1;
    }
}
class Font {
    constructor(data){
        this.type = 'Font';
        this.data = data;
    }
    generateShapes(text, size = 100) {
        const shapes = [];
        const paths = createPaths(text, size, this.data);
        for(let p = 0, pl = paths.length; p < pl; p++)Array.prototype.push.apply(shapes, paths[p].toShapes());
        return shapes;
    }
}
function createPaths(text, size, data) {
    const chars = Array.from(text);
    const scale = size / data.resolution;
    const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
    const paths = [];
    let offsetX = 0, offsetY = 0;
    for(let i322 = 0; i322 < chars.length; i322++){
        const char = chars[i322];
        if (char === '\n') {
            offsetX = 0;
            offsetY -= line_height;
        } else {
            const ret = createPath(char, scale, offsetX, offsetY, data);
            offsetX += ret.offsetX;
            paths.push(ret.path);
        }
    }
    return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
    const glyph = data.glyphs[char] || data.glyphs['?'];
    if (!glyph) {
        console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
        return;
    }
    const path = new ShapePath();
    let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
    if (glyph.o) {
        const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
        for(let i323 = 0, l = outline.length; i323 < l;){
            const action = outline[i323++];
            switch(action){
                case 'm':
                    x = outline[i323++] * scale + offsetX;
                    y = outline[i323++] * scale + offsetY;
                    path.moveTo(x, y);
                    break;
                case 'l':
                    x = outline[i323++] * scale + offsetX;
                    y = outline[i323++] * scale + offsetY;
                    path.lineTo(x, y);
                    break;
                case 'q':
                    cpx = outline[i323++] * scale + offsetX;
                    cpy = outline[i323++] * scale + offsetY;
                    cpx1 = outline[i323++] * scale + offsetX;
                    cpy1 = outline[i323++] * scale + offsetY;
                    path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                    break;
                case 'b':
                    cpx = outline[i323++] * scale + offsetX;
                    cpy = outline[i323++] * scale + offsetY;
                    cpx1 = outline[i323++] * scale + offsetX;
                    cpy1 = outline[i323++] * scale + offsetY;
                    cpx2 = outline[i323++] * scale + offsetX;
                    cpy2 = outline[i323++] * scale + offsetY;
                    path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                    break;
            }
        }
    }
    return {
        offsetX: glyph.ha * scale,
        path: path
    };
}
Font.prototype.isFont = true;
class FontLoader extends Loader {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
            let json;
            try {
                json = JSON.parse(text);
            } catch (e) {
                console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                json = JSON.parse(text.substring(65, text.length - 2));
            }
            const font = scope.parse(json);
            if (onLoad) onLoad(font);
        }, onProgress, onError);
    }
    parse(json) {
        return new Font(json);
    }
}
let _context;
const AudioContext = {
    getContext: function() {
        if (_context === undefined) _context = new (window.AudioContext || window.webkitAudioContext)();
        return _context;
    },
    setContext: function(value) {
        _context = value;
    }
};
class AudioLoader extends Loader {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(this.manager);
        loader.setResponseType('arraybuffer');
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(buffer) {
            try {
                // Create a copy of the buffer. The `decodeAudioData` method
                // detaches the buffer when complete, preventing reuse.
                const bufferCopy = buffer.slice(0);
                const context = AudioContext.getContext();
                context.decodeAudioData(bufferCopy, function(audioBuffer) {
                    onLoad(audioBuffer);
                });
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
}
class HemisphereLightProbe extends LightProbe {
    constructor(skyColor, groundColor, intensity = 1){
        super(undefined, intensity);
        const color1 = new Color().set(skyColor);
        const color2 = new Color().set(groundColor);
        const sky = new Vector3(color1.r, color1.g, color1.b);
        const ground = new Vector3(color2.r, color2.g, color2.b);
        // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
        const c0 = Math.sqrt(Math.PI);
        const c1 = c0 * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
        this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
    }
}
HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
class AmbientLightProbe extends LightProbe {
    constructor(color, intensity = 1){
        super(undefined, intensity);
        const color1 = new Color().set(color);
        // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
        this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
}
AmbientLightProbe.prototype.isAmbientLightProbe = true;
const _eyeRight = /*@__PURE__*/ new Matrix4();
const _eyeLeft = /*@__PURE__*/ new Matrix4();
class StereoCamera {
    constructor(){
        this.type = 'StereoCamera';
        this.aspect = 1;
        this.eyeSep = 0.064;
        this.cameraL = new PerspectiveCamera();
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = false;
        this.cameraR = new PerspectiveCamera();
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = false;
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        };
    }
    update(camera) {
        const cache = this._cache;
        const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
        if (needsUpdate) {
            cache.focus = camera.focus;
            cache.fov = camera.fov;
            cache.aspect = camera.aspect * this.aspect;
            cache.near = camera.near;
            cache.far = camera.far;
            cache.zoom = camera.zoom;
            cache.eyeSep = this.eyeSep;
            // Off-axis stereoscopic effect based on
            // http://paulbourke.net/stereographics/stereorender/
            const projectionMatrix = camera.projectionMatrix.clone();
            const eyeSepHalf = cache.eyeSep / 2;
            const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
            const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
            let xmin, xmax;
            // translate xOffset
            _eyeLeft.elements[12] = -eyeSepHalf;
            _eyeRight.elements[12] = eyeSepHalf;
            // for left eye
            xmin = -ymax * cache.aspect + eyeSepOnProjection;
            xmax = ymax * cache.aspect + eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraL.projectionMatrix.copy(projectionMatrix);
            // for right eye
            xmin = -ymax * cache.aspect - eyeSepOnProjection;
            xmax = ymax * cache.aspect - eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraR.projectionMatrix.copy(projectionMatrix);
        }
        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
    }
}
class Clock {
    constructor(autoStart = true){
        this.autoStart = autoStart;
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
    }
    start() {
        this.startTime = now();
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
    }
    stop() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
    }
    getElapsedTime() {
        this.getDelta();
        return this.elapsedTime;
    }
    getDelta() {
        let diff = 0;
        if (this.autoStart && !this.running) {
            this.start();
            return 0;
        }
        if (this.running) {
            const newTime = now();
            diff = (newTime - this.oldTime) / 1000;
            this.oldTime = newTime;
            this.elapsedTime += diff;
        }
        return diff;
    }
}
function now() {
    return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
}
const _position$1 = /*@__PURE__*/ new Vector3();
const _quaternion$1 = /*@__PURE__*/ new Quaternion();
const _scale$1 = /*@__PURE__*/ new Vector3();
const _orientation$1 = /*@__PURE__*/ new Vector3();
class AudioListener extends Object3D {
    constructor(){
        super();
        this.type = 'AudioListener';
        this.context = AudioContext.getContext();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null;
        this.timeDelta = 0;
        // private
        this._clock = new Clock();
    }
    getInput() {
        return this.gain;
    }
    removeFilter() {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
            this.gain.connect(this.context.destination);
            this.filter = null;
        }
        return this;
    }
    getFilter() {
        return this.filter;
    }
    setFilter(value) {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
        } else this.gain.disconnect(this.context.destination);
        this.filter = value;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
        return this;
    }
    getMasterVolume() {
        return this.gain.gain.value;
    }
    setMasterVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        const listener = this.context.listener;
        const up = this.up;
        this.timeDelta = this._clock.getDelta();
        this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
        _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
        if (listener.positionX) {
            // code path for Chrome (see #14393)
            const endTime = this.context.currentTime + this.timeDelta;
            listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
            listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
            listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
            listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
            listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
            listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
            listener.upX.linearRampToValueAtTime(up.x, endTime);
            listener.upY.linearRampToValueAtTime(up.y, endTime);
            listener.upZ.linearRampToValueAtTime(up.z, endTime);
        } else {
            listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
            listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
        }
    }
}
class Audio extends Object3D {
    constructor(listener){
        super();
        this.type = 'Audio';
        this.listener = listener;
        this.context = listener.context;
        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());
        this.autoplay = false;
        this.buffer = null;
        this.detune = 0;
        this.loop = false;
        this.loopStart = 0;
        this.loopEnd = 0;
        this.offset = 0;
        this.duration = undefined;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.source = null;
        this.sourceType = 'empty';
        this._startedAt = 0;
        this._progress = 0;
        this._connected = false;
        this.filters = [];
    }
    getOutput() {
        return this.gain;
    }
    setNodeSource(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = 'audioNode';
        this.source = audioNode;
        this.connect();
        return this;
    }
    setMediaElementSource(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = 'mediaNode';
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
    }
    setMediaStreamSource(mediaStream) {
        this.hasPlaybackControl = false;
        this.sourceType = 'mediaStreamNode';
        this.source = this.context.createMediaStreamSource(mediaStream);
        this.connect();
        return this;
    }
    setBuffer(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = 'buffer';
        if (this.autoplay) this.play();
        return this;
    }
    play(delay = 0) {
        if (this.isPlaying === true) {
            console.warn('THREE.Audio: Audio is already playing.');
            return;
        }
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this._startedAt = this.context.currentTime + delay;
        const source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.loop = this.loop;
        source.loopStart = this.loopStart;
        source.loopEnd = this.loopEnd;
        source.onended = this.onEnded.bind(this);
        source.start(this._startedAt, this._progress + this.offset, this.duration);
        this.isPlaying = true;
        this.source = source;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
    }
    pause() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        if (this.isPlaying === true) {
            // update current progress
            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
            if (this.loop === true) // ensure _progress does not exceed duration with looped audios
            this._progress = this._progress % (this.duration || this.buffer.duration);
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
        }
        return this;
    }
    stop() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this._progress = 0;
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
        return this;
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for(let i324 = 1, l = this.filters.length; i324 < l; i324++)this.filters[i324 - 1].connect(this.filters[i324]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        this._connected = true;
        return this;
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for(let i325 = 1, l = this.filters.length; i325 < l; i325++)this.filters[i325 - 1].disconnect(this.filters[i325]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        this._connected = false;
        return this;
    }
    getFilters() {
        return this.filters;
    }
    setFilters(value) {
        if (!value) value = [];
        if (this._connected === true) {
            this.disconnect();
            this.filters = value.slice();
            this.connect();
        } else this.filters = value.slice();
        return this;
    }
    setDetune(value) {
        this.detune = value;
        if (this.source.detune === undefined) return; // only set detune when available
        if (this.isPlaying === true) this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        return this;
    }
    getDetune() {
        return this.detune;
    }
    getFilter() {
        return this.getFilters()[0];
    }
    setFilter(filter) {
        return this.setFilters(filter ? [
            filter
        ] : []);
    }
    setPlaybackRate(value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        return this;
    }
    getPlaybackRate() {
        return this.playbackRate;
    }
    onEnded() {
        this.isPlaying = false;
    }
    getLoop() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return false;
        }
        return this.loop;
    }
    setLoop(value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.loop = value;
        if (this.isPlaying === true) this.source.loop = this.loop;
        return this;
    }
    setLoopStart(value) {
        this.loopStart = value;
        return this;
    }
    setLoopEnd(value) {
        this.loopEnd = value;
        return this;
    }
    getVolume() {
        return this.gain.gain.value;
    }
    setVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    }
}
const _position = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new Quaternion();
const _scale = /*@__PURE__*/ new Vector3();
const _orientation = /*@__PURE__*/ new Vector3();
class PositionalAudio extends Audio {
    constructor(listener){
        super(listener);
        this.panner = this.context.createPanner();
        this.panner.panningModel = 'HRTF';
        this.panner.connect(this.gain);
    }
    getOutput() {
        return this.panner;
    }
    getRefDistance() {
        return this.panner.refDistance;
    }
    setRefDistance(value) {
        this.panner.refDistance = value;
        return this;
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor;
    }
    setRolloffFactor(value) {
        this.panner.rolloffFactor = value;
        return this;
    }
    getDistanceModel() {
        return this.panner.distanceModel;
    }
    setDistanceModel(value) {
        this.panner.distanceModel = value;
        return this;
    }
    getMaxDistance() {
        return this.panner.maxDistance;
    }
    setMaxDistance(value) {
        this.panner.maxDistance = value;
        return this;
    }
    setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        this.panner.coneInnerAngle = coneInnerAngle;
        this.panner.coneOuterAngle = coneOuterAngle;
        this.panner.coneOuterGain = coneOuterGain;
        return this;
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        if (this.hasPlaybackControl === true && this.isPlaying === false) return;
        this.matrixWorld.decompose(_position, _quaternion, _scale);
        _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
        const panner = this.panner;
        if (panner.positionX) {
            // code path for Chrome and Firefox (see #14393)
            const endTime = this.context.currentTime + this.listener.timeDelta;
            panner.positionX.linearRampToValueAtTime(_position.x, endTime);
            panner.positionY.linearRampToValueAtTime(_position.y, endTime);
            panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
            panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
            panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
            panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
        } else {
            panner.setPosition(_position.x, _position.y, _position.z);
            panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
        }
    }
}
class AudioAnalyser {
    constructor(audio, fftSize = 2048){
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        audio.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
    }
    getAverageFrequency() {
        let value = 0;
        const data = this.getFrequencyData();
        for(let i326 = 0; i326 < data.length; i326++)value += data[i326];
        return value / data.length;
    }
}
class PropertyMixer {
    constructor(binding, typeName, valueSize){
        this.binding = binding;
        this.valueSize = valueSize;
        let mixFunction, mixFunctionAdditive, setIdentity;
        // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
        //
        // interpolators can use .buffer as their .result
        // the data then goes to 'incoming'
        //
        // 'accu0' and 'accu1' are used frame-interleaved for
        // the cumulative result and are compared to detect
        // changes
        //
        // 'orig' stores the original state of the property
        //
        // 'add' is used for additive cumulative results
        //
        // 'work' is optional and is only present for quaternion types. It is used
        // to store intermediate quaternion multiplication results
        switch(typeName){
            case 'quaternion':
                mixFunction = this._slerp;
                mixFunctionAdditive = this._slerpAdditive;
                setIdentity = this._setAdditiveIdentityQuaternion;
                this.buffer = new Float64Array(valueSize * 6);
                this._workIndex = 5;
                break;
            case 'string':
            case 'bool':
                mixFunction = this._select;
                // Use the regular mix function and for additive on these types,
                // additive is not relevant for non-numeric types
                mixFunctionAdditive = this._select;
                setIdentity = this._setAdditiveIdentityOther;
                this.buffer = new Array(valueSize * 5);
                break;
            default:
                mixFunction = this._lerp;
                mixFunctionAdditive = this._lerpAdditive;
                setIdentity = this._setAdditiveIdentityNumeric;
                this.buffer = new Float64Array(valueSize * 5);
        }
        this._mixBufferRegion = mixFunction;
        this._mixBufferRegionAdditive = mixFunctionAdditive;
        this._setIdentity = setIdentity;
        this._origIndex = 3;
        this._addIndex = 4;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        this.useCount = 0;
        this.referenceCount = 0;
    }
    // accumulate data in the 'incoming' region into 'accu<i>'
    accumulate(accuIndex, weight) {
        // note: happily accumulating nothing when weight = 0, the caller knows
        // the weight and shouldn't have made the call in the first place
        const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
        let currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
            // accuN := incoming * weight
            for(let i327 = 0; i327 !== stride; ++i327)buffer[offset + i327] = buffer[i327];
            currentWeight = weight;
        } else {
            // accuN := accuN + incoming * weight
            currentWeight += weight;
            const mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
    }
    // accumulate data in the 'incoming' region into 'add'
    accumulateAdditive(weight) {
        const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
        if (this.cumulativeWeightAdditive === 0) // add = identity
        this._setIdentity();
        // add := add + incoming * weight
        this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
        this.cumulativeWeightAdditive += weight;
    }
    // apply the state of 'accu<i>' to the binding when accus differ
    apply(accuIndex) {
        const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        if (weight < 1) {
            // accuN := accuN + original * ( 1 - cumulativeWeight )
            const originalValueOffset = stride * this._origIndex;
            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
        }
        if (weightAdditive > 0) // accuN := accuN + additive accuN
        this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
        for(let i328 = stride, e = stride + stride; i328 !== e; ++i328)if (buffer[i328] !== buffer[i328 + stride]) {
            // value has changed -> update scene graph
            binding.setValue(buffer, offset);
            break;
        }
    }
    // remember the state of the bound property and copy it to both accus
    saveOriginalState() {
        const binding = this.binding;
        const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
        binding.getValue(buffer, originalValueOffset);
        // accu[0..1] := orig -- initially detect changes against the original
        for(let i329 = stride, e = originalValueOffset; i329 !== e; ++i329)buffer[i329] = buffer[originalValueOffset + i329 % stride];
        // Add to identity for additive
        this._setIdentity();
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
    }
    // apply the state previously taken via 'saveOriginalState' to the binding
    restoreOriginalState() {
        const originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
    }
    _setAdditiveIdentityNumeric() {
        const startIndex = this._addIndex * this.valueSize;
        const endIndex = startIndex + this.valueSize;
        for(let i330 = startIndex; i330 < endIndex; i330++)this.buffer[i330] = 0;
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric();
        this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
        const startIndex = this._origIndex * this.valueSize;
        const targetIndex = this._addIndex * this.valueSize;
        for(let i331 = 0; i331 < this.valueSize; i331++)this.buffer[targetIndex + i331] = this.buffer[startIndex + i331];
    }
    // mix functions
    _select(buffer, dstOffset, srcOffset, t, stride) {
        if (t >= 0.5) for(let i332 = 0; i332 !== stride; ++i332)buffer[dstOffset + i332] = buffer[srcOffset + i332];
    }
    _slerp(buffer, dstOffset, srcOffset, t) {
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
    }
    _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
        const workOffset = this._workIndex * stride;
        // Store result in intermediate buffer offset
        Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
        // Slerp to the intermediate result
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
    }
    _lerp(buffer, dstOffset, srcOffset, t, stride) {
        const s = 1 - t;
        for(let i333 = 0; i333 !== stride; ++i333){
            const j = dstOffset + i333;
            buffer[j] = buffer[j] * s + buffer[srcOffset + i333] * t;
        }
    }
    _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
        for(let i334 = 0; i334 !== stride; ++i334){
            const j = dstOffset + i334;
            buffer[j] = buffer[j] + buffer[srcOffset + i334] * t;
        }
    }
}
// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');
// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';
// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);
// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);
// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);
// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
const _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');
const _supportedObjectNames = [
    'material',
    'materials',
    'bones'
];
class Composite {
    constructor(targetGroup, path, optionalParsedPath){
        const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
        this._targetGroup = targetGroup;
        this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    getValue(array, offset) {
        this.bind(); // bind all binding
        const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        // and only call .getValue on the first
        if (binding !== undefined) binding.getValue(array, offset);
    }
    setValue(array, offset) {
        const bindings = this._bindings;
        for(let i335 = this._targetGroup.nCachedObjects_, n = bindings.length; i335 !== n; ++i335)bindings[i335].setValue(array, offset);
    }
    bind() {
        const bindings = this._bindings;
        for(let i336 = this._targetGroup.nCachedObjects_, n = bindings.length; i336 !== n; ++i336)bindings[i336].bind();
    }
    unbind() {
        const bindings = this._bindings;
        for(let i337 = this._targetGroup.nCachedObjects_, n = bindings.length; i337 !== n; ++i337)bindings[i337].unbind();
    }
}
// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
class PropertyBinding {
    constructor(rootNode, path, parsedPath){
        this.path = path;
        this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
        this.rootNode = rootNode;
        // initial state of these methods that calls 'bind'
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
    }
    static create(root, path, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) return new PropertyBinding(root, path, parsedPath);
        else return new PropertyBinding.Composite(root, path, parsedPath);
    }
    /**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */ static sanitizeNodeName(name) {
        return name.replace(/\s/g, '_').replace(_reservedRe, '');
    }
    static parseTrackName(trackName) {
        const matches = _trackRe.exec(trackName);
        if (!matches) throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
        const results = {
            // directoryName: matches[ 1 ], // (tschw) currently unused
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
        };
        const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
        if (lastDot !== undefined && lastDot !== -1) {
            const objectName = results.nodeName.substring(lastDot + 1);
            // Object names must be checked against an allowlist. Otherwise, there
            // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
            // 'bar' could be the objectName, or part of a nodeName (which can
            // include '.' characters).
            if (_supportedObjectNames.indexOf(objectName) !== -1) {
                results.nodeName = results.nodeName.substring(0, lastDot);
                results.objectName = objectName;
            }
        }
        if (results.propertyName === null || results.propertyName.length === 0) throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
        return results;
    }
    static findNode(root, nodeName) {
        if (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) return root;
        // search into skeleton bones.
        if (root.skeleton) {
            const bone = root.skeleton.getBoneByName(nodeName);
            if (bone !== undefined) return bone;
        }
        // search into node subtree.
        if (root.children) {
            const searchNodeSubtree = function(children) {
                for(let i338 = 0; i338 < children.length; i338++){
                    const childNode = children[i338];
                    if (childNode.name === nodeName || childNode.uuid === nodeName) return childNode;
                    const result = searchNodeSubtree(childNode.children);
                    if (result) return result;
                }
                return null;
            };
            const subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) return subTreeNode;
        }
        return null;
    }
    // these are used to "bind" a nonexistent property
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    // Getters
    _getValue_direct(buffer, offset) {
        buffer[offset] = this.targetObject[this.propertyName];
    }
    _getValue_array(buffer, offset) {
        const source = this.resolvedProperty;
        for(let i339 = 0, n = source.length; i339 !== n; ++i339)buffer[offset++] = source[i339];
    }
    _getValue_arrayElement(buffer, offset) {
        buffer[offset] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(buffer, offset) {
        this.resolvedProperty.toArray(buffer, offset);
    }
    // Direct
    _setValue_direct(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
    }
    _setValue_direct_setNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // EntireArray
    _setValue_array(buffer, offset) {
        const dest = this.resolvedProperty;
        for(let i340 = 0, n = dest.length; i340 !== n; ++i340)dest[i340] = buffer[offset++];
    }
    _setValue_array_setNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for(let i341 = 0, n = dest.length; i341 !== n; ++i341)dest[i341] = buffer[offset++];
        this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for(let i342 = 0, n = dest.length; i342 !== n; ++i342)dest[i342] = buffer[offset++];
        this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // ArrayElement
    _setValue_arrayElement(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
    }
    _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // HasToFromArray
    _setValue_fromArray(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
    }
    _setValue_fromArray_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
    }
    _setValue_unbound(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
    }
    // create getter / setter pair for a property in the scene graph
    bind() {
        let targetObject = this.node;
        const parsedPath = this.parsedPath;
        const objectName = parsedPath.objectName;
        const propertyName = parsedPath.propertyName;
        let propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
        }
        // set fail state so we can just 'return' on error
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        // ensure there is a value node
        if (!targetObject) {
            console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
            return;
        }
        if (objectName) {
            let objectIndex = parsedPath.objectIndex;
            // special cases were we need to reach deeper into the hierarchy to get the face materials....
            switch(objectName){
                case 'materials':
                    if (!targetObject.material) {
                        console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                        return;
                    }
                    if (!targetObject.material.materials) {
                        console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                        return;
                    }
                    targetObject = targetObject.material.materials;
                    break;
                case 'bones':
                    if (!targetObject.skeleton) {
                        console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                        return;
                    }
                    // potential future optimization: skip this if propertyIndex is already an integer
                    // and convert the integer string to a true integer.
                    targetObject = targetObject.skeleton.bones;
                    // support resolving morphTarget names into indices.
                    for(let i343 = 0; i343 < targetObject.length; i343++)if (targetObject[i343].name === objectIndex) {
                        objectIndex = i343;
                        break;
                    }
                    break;
                default:
                    if (targetObject[objectName] === undefined) {
                        console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                        return;
                    }
                    targetObject = targetObject[objectName];
            }
            if (objectIndex !== undefined) {
                if (targetObject[objectIndex] === undefined) {
                    console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                    return;
                }
                targetObject = targetObject[objectIndex];
            }
        }
        // resolve property
        const nodeProperty = targetObject[propertyName];
        if (nodeProperty === undefined) {
            const nodeName = parsedPath.nodeName;
            console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
            return;
        }
        // determine versioning scheme
        let versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== undefined) versioning = this.Versioning.NeedsUpdate;
        else if (targetObject.matrixWorldNeedsUpdate !== undefined) versioning = this.Versioning.MatrixWorldNeedsUpdate;
        // determine how the property gets bound
        let bindingType = this.BindingType.Direct;
        if (propertyIndex !== undefined) {
            // access a sub element of the property array (only primitives are supported right now)
            if (propertyName === 'morphTargetInfluences') {
                // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
                // support resolving morphTarget names into indices.
                if (!targetObject.geometry) {
                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                    return;
                }
                if (targetObject.geometry.isBufferGeometry) {
                    if (!targetObject.geometry.morphAttributes) {
                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                        return;
                    }
                    if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                } else {
                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
                    return;
                }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
            // must use copy for Object3D.Euler/Quaternion
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
        } else this.propertyName = propertyName;
        // select getter / setter
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    }
    unbind() {
        this.node = null;
        // back to the prototype version of getValue / setValue
        // note: avoiding to mutate the shape of 'this' via 'delete'
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
    }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
    PropertyBinding.prototype._getValue_direct,
    PropertyBinding.prototype._getValue_array,
    PropertyBinding.prototype._getValue_arrayElement,
    PropertyBinding.prototype._getValue_toArray, 
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
    [
        // Direct
        PropertyBinding.prototype._setValue_direct,
        PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
        PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate, 
    ],
    [
        // EntireArray
        PropertyBinding.prototype._setValue_array,
        PropertyBinding.prototype._setValue_array_setNeedsUpdate,
        PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate, 
    ],
    [
        // ArrayElement
        PropertyBinding.prototype._setValue_arrayElement,
        PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
        PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate, 
    ],
    [
        // HasToFromArray
        PropertyBinding.prototype._setValue_fromArray,
        PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
        PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate, 
    ]
];
/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */ class AnimationObjectGroup {
    constructor(){
        this.uuid = generateUUID();
        // cached objects followed by the active ones
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0; // threshold
        // note: read by PropertyBinding.Composite
        const indices = {};
        this._indicesByUUID = indices; // for bookkeeping
        for(let i344 = 0, n = arguments.length; i344 !== n; ++i344)indices[arguments[i344].uuid] = i344;
        this._paths = []; // inside: string
        this._parsedPaths = []; // inside: { we don't care, here }
        this._bindings = []; // inside: Array< PropertyBinding >
        this._bindingsIndicesByPath = {}; // inside: indices in these arrays
        const scope = this;
        this.stats = {
            objects: {
                get total () {
                    return scope._objects.length;
                },
                get inUse () {
                    return this.total - scope.nCachedObjects_;
                }
            },
            get bindingsPerObject () {
                return scope._bindings.length;
            }
        };
    }
    add() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
        let knownObject = undefined, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
        for(let i345 = 0, n = arguments.length; i345 !== n; ++i345){
            const object = arguments[i345], uuid = object.uuid;
            let index = indicesByUUID[uuid];
            if (index === undefined) {
                // unknown object -> add it to the ACTIVE region
                index = nObjects++;
                indicesByUUID[uuid] = index;
                objects.push(object);
                // accounting is done, now do the same for all bindings
                for(let j = 0, m = nBindings; j !== m; ++j)bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
            } else if (index < nCachedObjects) {
                knownObject = objects[index];
                // move existing object to the ACTIVE region
                const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                indicesByUUID[lastCachedObject.uuid] = index;
                objects[index] = lastCachedObject;
                indicesByUUID[uuid] = firstActiveIndex;
                objects[firstActiveIndex] = object;
                // accounting is done, now do the same for all bindings
                for(let j = 0, m = nBindings; j !== m; ++j){
                    const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
                    let binding = bindingsForPath[index];
                    bindingsForPath[index] = lastCached;
                    if (binding === undefined) // since we do not bother to create new bindings
                    // for objects that are cached, the binding may
                    // or may not exist
                    binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                    bindingsForPath[firstActiveIndex] = binding;
                }
            } else if (objects[index] !== knownObject) console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
             // else the object is already where we want it to be
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    }
    remove() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_;
        for(let i346 = 0, n = arguments.length; i346 !== n; ++i346){
            const object = arguments[i346], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== undefined && index >= nCachedObjects) {
                // move existing object into the CACHED region
                const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                indicesByUUID[firstActiveObject.uuid] = index;
                objects[index] = firstActiveObject;
                indicesByUUID[uuid] = lastCachedIndex;
                objects[lastCachedIndex] = object;
                // accounting is done, now do the same for all bindings
                for(let j = 0, m = nBindings; j !== m; ++j){
                    const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                    bindingsForPath[index] = firstActive;
                    bindingsForPath[lastCachedIndex] = binding;
                }
            }
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    }
    // remove & forget
    uncache() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
        for(let i347 = 0, n = arguments.length; i347 !== n; ++i347){
            const object = arguments[i347], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== undefined) {
                delete indicesByUUID[uuid];
                if (index < nCachedObjects) {
                    // object is cached, shrink the CACHED region
                    const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                    // last cached object takes this object's place
                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;
                    // last object goes to the activated slot and pop
                    indicesByUUID[lastObject.uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for(let j = 0, m = nBindings; j !== m; ++j){
                        const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                        bindingsForPath[index] = lastCached;
                        bindingsForPath[firstActiveIndex] = last;
                        bindingsForPath.pop();
                    }
                } else {
                    // object is active, just swap with the last and pop
                    const lastIndex = --nObjects, lastObject = objects[lastIndex];
                    if (lastIndex > 0) indicesByUUID[lastObject.uuid] = index;
                    objects[index] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for(let j = 0, m = nBindings; j !== m; ++j){
                        const bindingsForPath = bindings[j];
                        bindingsForPath[index] = bindingsForPath[lastIndex];
                        bindingsForPath.pop();
                    }
                } // cached or active
            } // if object is known
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    }
    // Internal interface used by befriended PropertyBinding.Composite:
    subscribe_(path, parsedPath) {
        // returns an array of bindings for the given path that is changed
        // according to the contained objects in the group
        const indicesByPath = this._bindingsIndicesByPath;
        let index = indicesByPath[path];
        const bindings = this._bindings;
        if (index !== undefined) return bindings[index];
        const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index = bindings.length;
        indicesByPath[path] = index;
        paths.push(path);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for(let i348 = nCachedObjects, n = objects.length; i348 !== n; ++i348){
            const object = objects[i348];
            bindingsForPath[i348] = new PropertyBinding(object, path, parsedPath);
        }
        return bindingsForPath;
    }
    unsubscribe_(path) {
        // tells the group to forget about a property path and no longer
        // update the array previously obtained with 'subscribe_'
        const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
        if (index !== undefined) {
            const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index;
            bindings[index] = lastBindings;
            bindings.pop();
            parsedPaths[index] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index] = paths[lastBindingsIndex];
            paths.pop();
        }
    }
}
AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
class AnimationAction {
    constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode){
        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot;
        this.blendMode = blendMode;
        const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
        const interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        };
        for(let i349 = 0; i349 !== nTracks; ++i349){
            const interpolant = tracks[i349].createInterpolant(null);
            interpolants[i349] = interpolant;
            interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings;
        this._interpolants = interpolants; // bound by the mixer
        // inside: PropertyMixer (managed by the mixer)
        this._propertyBindings = new Array(nTracks);
        this._cacheIndex = null; // for the memory manager
        this._byClipCacheIndex = null; // for the memory manager
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
        this.loop = LoopRepeat;
        this._loopCount = -1;
        // global mixer time when the action is to be started
        // it's set back to 'null' upon start of the action
        this._startTime = null;
        // scaled local time of the action
        // gets clamped or wrapped to 0..clip.duration according to loop
        this.time = 0;
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
        this.weight = 1;
        this._effectiveWeight = 1;
        this.repetitions = Infinity; // no. of repetitions when looping
        this.paused = false; // true -> zero effective time scale
        this.enabled = true; // false -> zero effective weight
        this.clampWhenFinished = false; // keep feeding the last frame?
        this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
        this.zeroSlopeAtEnd = true; // clips for start, loop and end
    }
    // State & Scheduling
    play() {
        this._mixer._activateAction(this);
        return this;
    }
    stop() {
        this._mixer._deactivateAction(this);
        return this.reset();
    }
    reset() {
        this.paused = false;
        this.enabled = true;
        this.time = 0; // restart clip
        this._loopCount = -1; // forget previous loops
        this._startTime = null; // forget scheduling
        return this.stopFading().stopWarping();
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    // return true when play has been called
    isScheduled() {
        return this._mixer._isActiveAction(this);
    }
    startAt(time) {
        this._startTime = time;
        return this;
    }
    setLoop(mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
    }
    // Weight
    // set the weight stopping any scheduled fading
    // although .enabled = false yields an effective weight of zero, this
    // method does *not* change .enabled, because it would be confusing
    setEffectiveWeight(weight) {
        this.weight = weight;
        // note: same logic as when updated at runtime
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
    }
    // return the weight considering fading and .enabled
    getEffectiveWeight() {
        return this._effectiveWeight;
    }
    fadeIn(duration) {
        return this._scheduleFading(duration, 0, 1);
    }
    fadeOut(duration) {
        return this._scheduleFading(duration, 1, 0);
    }
    crossFadeFrom(fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
            const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1, startEndRatio, duration);
            this.warp(endStartRatio, 1, duration);
        }
        return this;
    }
    crossFadeTo(fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
    }
    stopFading() {
        const weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
    }
    // Time Scale Control
    // set the time scale stopping any scheduled warping
    // although .paused = true yields an effective time scale of zero, this
    // method does *not* change .paused, because it would be confusing
    setEffectiveTimeScale(timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
    }
    // return the time scale considering warping and .paused
    getEffectiveTimeScale() {
        return this._effectiveTimeScale;
    }
    setDuration(duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
    }
    syncWith(action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
    }
    halt(duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
    }
    warp(startTimeScale, endTimeScale, duration) {
        const mixer = this._mixer, now1 = mixer.time, timeScale = this.timeScale;
        let interpolant = this._timeScaleInterpolant;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now1;
        times[1] = now1 + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
    }
    stopWarping() {
        const timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
    }
    // Object Accessors
    getMixer() {
        return this._mixer;
    }
    getClip() {
        return this._clip;
    }
    getRoot() {
        return this._localRoot || this._mixer._root;
    }
    // Interna
    _update(time, deltaTime, timeDirection, accuIndex) {
        // called by the mixer
        if (!this.enabled) {
            // call ._updateWeight() to update ._effectiveWeight
            this._updateWeight(time);
            return;
        }
        const startTime = this._startTime;
        if (startTime !== null) {
            // check for scheduled start of action
            const timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) return; // yet to come / don't decide when delta = 0
            // start
            this._startTime = null; // unschedule
            deltaTime = timeDirection * timeRunning;
        }
        // apply time scale and advance time
        deltaTime *= this._updateTimeScale(time);
        const clipTime = this._updateTime(deltaTime);
        // note: _updateTime may disable the action resulting in
        // an effective weight of 0
        const weight = this._updateWeight(time);
        if (weight > 0) {
            const interpolants = this._interpolants;
            const propertyMixers = this._propertyBindings;
            switch(this.blendMode){
                case AdditiveAnimationBlendMode:
                    for(let j = 0, m = interpolants.length; j !== m; ++j){
                        interpolants[j].evaluate(clipTime);
                        propertyMixers[j].accumulateAdditive(weight);
                    }
                    break;
                case NormalAnimationBlendMode:
                default:
                    for(let j4 = 0, m1 = interpolants.length; j4 !== m1; ++j4){
                        interpolants[j4].evaluate(clipTime);
                        propertyMixers[j4].accumulate(accuIndex, weight);
                    }
            }
        }
    }
    _updateWeight(time) {
        let weight = 0;
        if (this.enabled) {
            weight = this.weight;
            const interpolant = this._weightInterpolant;
            if (interpolant !== null) {
                const interpolantValue = interpolant.evaluate(time)[0];
                weight *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopFading();
                    if (interpolantValue === 0) // faded out, disable
                    this.enabled = false;
                }
            }
        }
        this._effectiveWeight = weight;
        return weight;
    }
    _updateTimeScale(time) {
        let timeScale = 0;
        if (!this.paused) {
            timeScale = this.timeScale;
            const interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
                const interpolantValue = interpolant.evaluate(time)[0];
                timeScale *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopWarping();
                    if (timeScale === 0) // motion has halted, pause
                    this.paused = true;
                    else // warp done - apply final time scale
                    this.timeScale = timeScale;
                }
            }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
    }
    _updateTime(deltaTime) {
        const duration = this._clip.duration;
        const loop = this.loop;
        let time = this.time + deltaTime;
        let loopCount = this._loopCount;
        const pingPong = loop === LoopPingPong;
        if (deltaTime === 0) {
            if (loopCount === -1) return time;
            return pingPong && (loopCount & 1) === 1 ? duration - time : time;
        }
        if (loop === LoopOnce) {
            if (loopCount === -1) {
                // just started
                this._loopCount = 0;
                this._setEndings(true, true, false);
            }
            handle_stop: {
                if (time >= duration) time = duration;
                else if (time < 0) time = 0;
                else {
                    this.time = time;
                    break handle_stop;
                }
                if (this.clampWhenFinished) this.paused = true;
                else this.enabled = false;
                this.time = time;
                this._mixer.dispatchEvent({
                    type: 'finished',
                    action: this,
                    direction: deltaTime < 0 ? -1 : 1
                });
            }
        } else {
            if (loopCount === -1) {
                // just started
                if (deltaTime >= 0) {
                    loopCount = 0;
                    this._setEndings(true, this.repetitions === 0, pingPong);
                } else // when looping in reverse direction, the initial
                // transition through zero counts as a repetition,
                // so leave loopCount at -1
                this._setEndings(this.repetitions === 0, true, pingPong);
            }
            if (time >= duration || time < 0) {
                // wrap around
                const loopDelta = Math.floor(time / duration); // signed
                time -= duration * loopDelta;
                loopCount += Math.abs(loopDelta);
                const pending = this.repetitions - loopCount;
                if (pending <= 0) {
                    // have to stop (switch state, clamp time, fire event)
                    if (this.clampWhenFinished) this.paused = true;
                    else this.enabled = false;
                    time = deltaTime > 0 ? duration : 0;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: 'finished',
                        action: this,
                        direction: deltaTime > 0 ? 1 : -1
                    });
                } else {
                    // keep running
                    if (pending === 1) {
                        // entering the last round
                        const atStart = deltaTime < 0;
                        this._setEndings(atStart, !atStart, pingPong);
                    } else this._setEndings(false, false, pingPong);
                    this._loopCount = loopCount;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: 'loop',
                        action: this,
                        loopDelta: loopDelta
                    });
                }
            } else this.time = time;
            if (pingPong && (loopCount & 1) === 1) // invert time for the "pong round"
            return duration - time;
        }
        return time;
    }
    _setEndings(atStart, atEnd, pingPong) {
        const settings = this._interpolantSettings;
        if (pingPong) {
            settings.endingStart = ZeroSlopeEnding;
            settings.endingEnd = ZeroSlopeEnding;
        } else {
            // assuming for LoopOnce atStart == atEnd == true
            if (atStart) settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
            else settings.endingStart = WrapAroundEnding;
            if (atEnd) settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
            else settings.endingEnd = WrapAroundEnding;
        }
    }
    _scheduleFading(duration, weightNow, weightThen) {
        const mixer = this._mixer, now2 = mixer.time;
        let interpolant = this._weightInterpolant;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._weightInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now2;
        values[0] = weightNow;
        times[1] = now2 + duration;
        values[1] = weightThen;
        return this;
    }
}
class AnimationMixer extends EventDispatcher {
    constructor(root){
        super();
        this._root = root;
        this._initMemoryManager();
        this._accuIndex = 0;
        this.time = 0;
        this.timeScale = 1;
    }
    _bindAction(action, prototypeAction) {
        const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
        let bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === undefined) {
            bindingsByName = {};
            bindingsByRoot[rootUuid] = bindingsByName;
        }
        for(let i350 = 0; i350 !== nTracks; ++i350){
            const track = tracks[i350], trackName = track.name;
            let binding = bindingsByName[trackName];
            if (binding !== undefined) bindings[i350] = binding;
            else {
                binding = bindings[i350];
                if (binding !== undefined) {
                    // existing binding, make sure the cache knows
                    if (binding._cacheIndex === null) {
                        ++binding.referenceCount;
                        this._addInactiveBinding(binding, rootUuid, trackName);
                    }
                    continue;
                }
                const path = prototypeAction && prototypeAction._propertyBindings[i350].binding.parsedPath;
                binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
                bindings[i350] = binding;
            }
            interpolants[i350].resultBuffer = binding.buffer;
        }
    }
    _activateAction(action) {
        if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
                // this action has been forgotten by the cache, but the user
                // appears to be still using it -> rebind
                const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                this._addInactiveAction(action, clipUuid, rootUuid);
            }
            const bindings = action._propertyBindings;
            // increment reference counts / sort out state
            for(let i351 = 0, n = bindings.length; i351 !== n; ++i351){
                const binding = bindings[i351];
                if ((binding.useCount++) === 0) {
                    this._lendBinding(binding);
                    binding.saveOriginalState();
                }
            }
            this._lendAction(action);
        }
    }
    _deactivateAction(action) {
        if (this._isActiveAction(action)) {
            const bindings = action._propertyBindings;
            // decrement reference counts / sort out state
            for(let i352 = 0, n = bindings.length; i352 !== n; ++i352){
                const binding = bindings[i352];
                if (--binding.useCount === 0) {
                    binding.restoreOriginalState();
                    this._takeBackBinding(binding);
                }
            }
            this._takeBackAction(action);
        }
    }
    // Memory manager
    _initMemoryManager() {
        this._actions = []; // 'nActiveActions' followed by inactive ones
        this._nActiveActions = 0;
        this._actionsByClip = {};
        // inside:
        // {
        // 	knownActions: Array< AnimationAction > - used as prototypes
        // 	actionByRoot: AnimationAction - lookup
        // }
        this._bindings = []; // 'nActiveBindings' followed by inactive ones
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
        this._controlInterpolants = []; // same game as above
        this._nActiveControlInterpolants = 0;
        const scope = this;
        this.stats = {
            actions: {
                get total () {
                    return scope._actions.length;
                },
                get inUse () {
                    return scope._nActiveActions;
                }
            },
            bindings: {
                get total () {
                    return scope._bindings.length;
                },
                get inUse () {
                    return scope._nActiveBindings;
                }
            },
            controlInterpolants: {
                get total () {
                    return scope._controlInterpolants.length;
                },
                get inUse () {
                    return scope._nActiveControlInterpolants;
                }
            }
        };
    }
    // Memory management for AnimationAction objects
    _isActiveAction(action) {
        const index = action._cacheIndex;
        return index !== null && index < this._nActiveActions;
    }
    _addInactiveAction(action, clipUuid, rootUuid) {
        const actions = this._actions, actionsByClip = this._actionsByClip;
        let actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === undefined) {
            actionsForClip = {
                knownActions: [
                    action
                ],
                actionByRoot: {}
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
        } else {
            const knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
    }
    _removeInactiveAction(action) {
        const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) delete actionsByClip[clipUuid];
        this._removeInactiveBindingsForAction(action);
    }
    _removeInactiveBindingsForAction(action) {
        const bindings = action._propertyBindings;
        for(let i353 = 0, n = bindings.length; i353 !== n; ++i353){
            const binding = bindings[i353];
            if (--binding.referenceCount === 0) this._removeInactiveBinding(binding);
        }
    }
    _lendAction(action) {
        // [ active actions |  inactive actions  ]
        // [  active actions >| inactive actions ]
        //                 s        a
        //                  <-swap->
        //                 a        s
        const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
    }
    _takeBackAction(action) {
        // [  active actions  | inactive actions ]
        // [ active actions |< inactive actions  ]
        //        a        s
        //         <-swap->
        //        s        a
        const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
    }
    // Memory management for PropertyMixer objects
    _addInactiveBinding(binding, rootUuid, trackName) {
        const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
        let bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName === undefined) {
            bindingByName = {};
            bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
    }
    _removeInactiveBinding(binding) {
        const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        if (Object.keys(bindingByName).length === 0) delete bindingsByRoot[rootUuid];
    }
    _lendBinding(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
    }
    _takeBackBinding(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
    }
    // Memory management of Interpolants for weight and time scale
    _lendControlInterpolant() {
        const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
        let interpolant = interpolants[lastActiveIndex];
        if (interpolant === undefined) {
            interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants[lastActiveIndex] = interpolant;
        }
        return interpolant;
    }
    _takeBackControlInterpolant(interpolant) {
        const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants[prevIndex] = lastActiveInterpolant;
    }
    // return an action for a clip optionally using a custom root target
    // object (this method allocates a lot of dynamic memory in case a
    // previously unknown clip/root combination is specified)
    clipAction(clip, optionalRoot, blendMode) {
        const root = optionalRoot || this._root, rootUuid = root.uuid;
        let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
        const clipUuid = clipObject !== null ? clipObject.uuid : clip;
        const actionsForClip = this._actionsByClip[clipUuid];
        let prototypeAction = null;
        if (blendMode === undefined) {
            if (clipObject !== null) blendMode = clipObject.blendMode;
            else blendMode = NormalAnimationBlendMode;
        }
        if (actionsForClip !== undefined) {
            const existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== undefined && existingAction.blendMode === blendMode) return existingAction;
            // we know the clip, so we don't have to parse all
            // the bindings again but can just copy
            prototypeAction = actionsForClip.knownActions[0];
            // also, take the clip from the prototype action
            if (clipObject === null) clipObject = prototypeAction._clip;
        }
        // clip must be known when specified via string
        if (clipObject === null) return null;
        // allocate all resources required to run it
        const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
        this._bindAction(newAction, prototypeAction);
        // and make the action known to the memory manager
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
    }
    // get an existing action
    existingAction(clip, optionalRoot) {
        const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== undefined) return actionsForClip.actionByRoot[rootUuid] || null;
        return null;
    }
    // deactivates all previously scheduled actions
    stopAllAction() {
        const actions = this._actions, nActions = this._nActiveActions;
        for(let i354 = nActions - 1; i354 >= 0; --i354)actions[i354].stop();
        return this;
    }
    // advance the time and update apply the animation
    update(deltaTime) {
        deltaTime *= this.timeScale;
        const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
        // run active actions
        for(let i356 = 0; i356 !== nActions; ++i356){
            const action = actions[i356];
            action._update(time, deltaTime, timeDirection, accuIndex);
        }
        // update scene graph
        const bindings = this._bindings, nBindings = this._nActiveBindings;
        for(let i355 = 0; i355 !== nBindings; ++i355)bindings[i355].apply(accuIndex);
        return this;
    }
    // Allows you to seek to a specific time in an animation.
    setTime(timeInSeconds) {
        this.time = 0; // Zero out time attribute for AnimationMixer object;
        for(let i357 = 0; i357 < this._actions.length; i357++)this._actions[i357].time = 0; // Zero out time attribute for all associated AnimationAction objects.
        return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
    }
    // return this mixer's root target object
    getRoot() {
        return this._root;
    }
    // free all resources specific to a particular clip
    uncacheClip(clip) {
        const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== undefined) {
            // note: just calling _removeInactiveAction would mess up the
            // iteration state and also require updating the state we can
            // just throw away
            const actionsToRemove = actionsForClip.knownActions;
            for(let i358 = 0, n = actionsToRemove.length; i358 !== n; ++i358){
                const action = actionsToRemove[i358];
                this._deactivateAction(action);
                const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                action._cacheIndex = null;
                action._byClipCacheIndex = null;
                lastInactiveAction._cacheIndex = cacheIndex;
                actions[cacheIndex] = lastInactiveAction;
                actions.pop();
                this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
        }
    }
    // free all resources specific to a particular root target object
    uncacheRoot(root) {
        const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for(const clipUuid in actionsByClip){
            const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== undefined) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
        const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== undefined) for(const trackName in bindingByName){
            const binding = bindingByName[trackName];
            binding.restoreOriginalState();
            this._removeInactiveBinding(binding);
        }
    }
    // remove a targeted clip from the cache
    uncacheAction(clip, optionalRoot) {
        const action = this.existingAction(clip, optionalRoot);
        if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
        }
    }
}
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
class Uniform {
    constructor(value){
        if (typeof value === 'string') {
            console.warn('THREE.Uniform: Type parameter is no longer needed.');
            value = arguments[1];
        }
        this.value = value;
    }
    clone() {
        return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
    }
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
    constructor(array, stride, meshPerAttribute = 1){
        super(array, stride);
        this.meshPerAttribute = meshPerAttribute;
    }
    copy(source) {
        super.copy(source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    }
    clone(data) {
        const ib = super.clone(data);
        ib.meshPerAttribute = this.meshPerAttribute;
        return ib;
    }
    toJSON(data) {
        const json = super.toJSON(data);
        json.isInstancedInterleavedBuffer = true;
        json.meshPerAttribute = this.meshPerAttribute;
        return json;
    }
}
InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
class GLBufferAttribute {
    constructor(buffer, type, itemSize, elementSize, count){
        this.buffer = buffer;
        this.type = type;
        this.itemSize = itemSize;
        this.elementSize = elementSize;
        this.count = count;
        this.version = 0;
    }
    set needsUpdate(value) {
        if (value === true) this.version++;
    }
    setBuffer(buffer) {
        this.buffer = buffer;
        return this;
    }
    setType(type, elementSize) {
        this.type = type;
        this.elementSize = elementSize;
        return this;
    }
    setItemSize(itemSize) {
        this.itemSize = itemSize;
        return this;
    }
    setCount(count) {
        this.count = count;
        return this;
    }
}
GLBufferAttribute.prototype.isGLBufferAttribute = true;
class Raycaster {
    constructor(origin, direction, near = 0, far = Infinity){
        this.ray = new Ray(origin, direction);
        // direction is assumed to be normalized (for accurate distance calculations)
        this.near = near;
        this.far = far;
        this.camera = null;
        this.layers = new Layers();
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        };
    }
    set(origin, direction) {
        // direction is assumed to be normalized (for accurate distance calculations)
        this.ray.set(origin, direction);
    }
    setFromCamera(coords, camera) {
        if (camera && camera.isPerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            this.camera = camera;
        } else if (camera && camera.isOrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            this.camera = camera;
        } else console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
    }
    intersectObject(object, recursive = false, intersects8 = []) {
        intersectObject(object, this, intersects8, recursive);
        intersects8.sort(ascSort);
        return intersects8;
    }
    intersectObjects(objects, recursive = false, intersects9 = []) {
        for(let i359 = 0, l = objects.length; i359 < l; i359++)intersectObject(objects[i359], this, intersects9, recursive);
        intersects9.sort(ascSort);
        return intersects9;
    }
}
function ascSort(a, b) {
    return a.distance - b.distance;
}
function intersectObject(object, raycaster, intersects10, recursive) {
    if (object.layers.test(raycaster.layers)) object.raycast(raycaster, intersects10);
    if (recursive === true) {
        const children = object.children;
        for(let i360 = 0, l = children.length; i360 < l; i360++)intersectObject(children[i360], raycaster, intersects10, true);
    }
}
/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */ class Spherical {
    constructor(radius = 1, phi = 0, theta = 0){
        this.radius = radius;
        this.phi = phi; // polar angle
        this.theta = theta; // azimuthal angle
        return this;
    }
    set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
    }
    copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
    }
    // restrict phi to be betwee EPS and PI-EPS
    makeSafe() {
        const EPS = 0.000001;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
    }
    setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
    setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + y * y + z * z);
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        } else {
            this.theta = Math.atan2(x, z);
            this.phi = Math.acos(clamp(y / this.radius, -1, 1));
        }
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */ class Cylindrical {
    constructor(radius = 1, theta = 0, y = 0){
        this.radius = radius; // distance from the origin to a point in the x-z plane
        this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
        this.y = y; // height above the x-z plane
        return this;
    }
    set(radius, theta, y) {
        this.radius = radius;
        this.theta = theta;
        this.y = y;
        return this;
    }
    copy(other) {
        this.radius = other.radius;
        this.theta = other.theta;
        this.y = other.y;
        return this;
    }
    setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
    setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + z * z);
        this.theta = Math.atan2(x, z);
        this.y = y;
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const _vector$4 = /*@__PURE__*/ new Vector2();
class Box2 {
    constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)){
        this.min = min;
        this.max = max;
    }
    set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    }
    setFromPoints(points) {
        this.makeEmpty();
        for(let i361 = 0, il = points.length; i361 < il; i361++)this.expandByPoint(points[i361]);
        return this;
    }
    setFromCenterAndSize(center, size) {
        const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    }
    makeEmpty() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
    }
    isEmpty() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(target) {
        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    }
    expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    }
    expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    }
    containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    }
    containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    }
    getParameter(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(box) {
        // using 4 splitting planes to rule out intersections
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    }
    clampPoint(point, target) {
        return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
        const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    }
    intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
    }
    union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    }
    translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    }
    equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
}
Box2.prototype.isBox2 = true;
const _startP = /*@__PURE__*/ new Vector3();
const _startEnd = /*@__PURE__*/ new Vector3();
class Line3 {
    constructor(start = new Vector3(), end = new Vector3()){
        this.start = start;
        this.end = end;
    }
    set(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
    }
    copy(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
    }
    getCenter(target) {
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(target) {
        return target.subVectors(this.end, this.start);
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end);
    }
    distance() {
        return this.start.distanceTo(this.end);
    }
    at(t, target) {
        return this.delta(target).multiplyScalar(t).add(this.start);
    }
    closestPointToPointParameter(point, clampToLine) {
        _startP.subVectors(point, this.start);
        _startEnd.subVectors(this.end, this.start);
        const startEnd2 = _startEnd.dot(_startEnd);
        const startEnd_startP = _startEnd.dot(_startP);
        let t = startEnd_startP / startEnd2;
        if (clampToLine) t = clamp(t, 0, 1);
        return t;
    }
    closestPointToPoint(point, clampToLine, target) {
        const t = this.closestPointToPointParameter(point, clampToLine);
        return this.delta(target).multiplyScalar(t).add(this.start);
    }
    applyMatrix4(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
    }
    equals(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
class ImmediateRenderObject extends Object3D {
    constructor(material){
        super();
        this.material = material;
        this.render = function() {};
        this.hasPositions = false;
        this.hasNormals = false;
        this.hasColors = false;
        this.hasUvs = false;
        this.positionArray = null;
        this.normalArray = null;
        this.colorArray = null;
        this.uvArray = null;
        this.count = 0;
    }
}
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
const _vector$3 = /*@__PURE__*/ new Vector3();
class SpotLightHelper extends Object3D {
    constructor(light, color){
        super();
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        const geometry = new BufferGeometry();
        const positions = [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            -1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            -1,
            1
        ];
        for(let i362 = 0, j = 1, l = 32; i362 < l; i362++, j++){
            const p1 = i362 / l * Math.PI * 2;
            const p2 = j / l * Math.PI * 2;
            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
        }
        geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
        const material = new LineBasicMaterial({
            fog: false,
            toneMapped: false
        });
        this.cone = new LineSegments(geometry, material);
        this.add(this.cone);
        this.update();
    }
    dispose() {
        this.cone.geometry.dispose();
        this.cone.material.dispose();
    }
    update() {
        this.light.updateMatrixWorld();
        const coneLength = this.light.distance ? this.light.distance : 1000;
        const coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(_vector$3);
        if (this.color !== undefined) this.cone.material.color.set(this.color);
        else this.cone.material.color.copy(this.light.color);
    }
}
const _vector$2 = /*@__PURE__*/ new Vector3();
const _boneMatrix = /*@__PURE__*/ new Matrix4();
const _matrixWorldInv = /*@__PURE__*/ new Matrix4();
class SkeletonHelper extends LineSegments {
    constructor(object){
        const bones = getBoneList(object);
        const geometry = new BufferGeometry();
        const vertices = [];
        const colors = [];
        const color1 = new Color(0, 0, 1);
        const color2 = new Color(0, 1, 0);
        for(let i363 = 0; i363 < bones.length; i363++){
            const bone = bones[i363];
            if (bone.parent && bone.parent.isBone) {
                vertices.push(0, 0, 0);
                vertices.push(0, 0, 0);
                colors.push(color1.r, color1.g, color1.b);
                colors.push(color2.r, color2.g, color2.b);
            }
        }
        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({
            vertexColors: true,
            depthTest: false,
            depthWrite: false,
            toneMapped: false,
            transparent: true
        });
        super(geometry, material);
        this.type = 'SkeletonHelper';
        this.isSkeletonHelper = true;
        this.root = object;
        this.bones = bones;
        this.matrix = object.matrixWorld;
        this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(force) {
        const bones = this.bones;
        const geometry = this.geometry;
        const position = geometry.getAttribute('position');
        _matrixWorldInv.copy(this.root.matrixWorld).invert();
        for(let i364 = 0, j = 0; i364 < bones.length; i364++){
            const bone = bones[i364];
            if (bone.parent && bone.parent.isBone) {
                _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
                _vector$2.setFromMatrixPosition(_boneMatrix);
                position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
                _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
                _vector$2.setFromMatrixPosition(_boneMatrix);
                position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
                j += 2;
            }
        }
        geometry.getAttribute('position').needsUpdate = true;
        super.updateMatrixWorld(force);
    }
}
function getBoneList(object) {
    const boneList = [];
    if (object && object.isBone) boneList.push(object);
    for(let i365 = 0; i365 < object.children.length; i365++)boneList.push.apply(boneList, getBoneList(object.children[i365]));
    return boneList;
}
class PointLightHelper extends Mesh {
    constructor(light, sphereSize, color){
        const geometry = new SphereGeometry(sphereSize, 4, 2);
        const material = new MeshBasicMaterial({
            wireframe: true,
            fog: false,
            toneMapped: false
        });
        super(geometry, material);
        this.light = light;
        this.light.updateMatrixWorld();
        this.color = color;
        this.type = 'PointLightHelper';
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.update();
    /*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/ }
    dispose() {
        this.geometry.dispose();
        this.material.dispose();
    }
    update() {
        if (this.color !== undefined) this.material.color.set(this.color);
        else this.material.color.copy(this.light.color);
    /*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/ }
}
const _vector$1 = /*@__PURE__*/ new Vector3();
const _color1 = /*@__PURE__*/ new Color();
const _color2 = /*@__PURE__*/ new Color();
class HemisphereLightHelper extends Object3D {
    constructor(light, size, color){
        super();
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        const geometry = new OctahedronGeometry(size);
        geometry.rotateY(Math.PI * 0.5);
        this.material = new MeshBasicMaterial({
            wireframe: true,
            fog: false,
            toneMapped: false
        });
        if (this.color === undefined) this.material.vertexColors = true;
        const position = geometry.getAttribute('position');
        const colors = new Float32Array(position.count * 3);
        geometry.setAttribute('color', new BufferAttribute(colors, 3));
        this.add(new Mesh(geometry, this.material));
        this.update();
    }
    dispose() {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
    }
    update() {
        const mesh = this.children[0];
        if (this.color !== undefined) this.material.color.set(this.color);
        else {
            const colors = mesh.geometry.getAttribute('color');
            _color1.copy(this.light.color);
            _color2.copy(this.light.groundColor);
            for(let i366 = 0, l = colors.count; i366 < l; i366++){
                const color = i366 < l / 2 ? _color1 : _color2;
                colors.setXYZ(i366, color.r, color.g, color.b);
            }
            colors.needsUpdate = true;
        }
        mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
}
class GridHelper extends LineSegments {
    constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848){
        color1 = new Color(color1);
        color2 = new Color(color2);
        const center = divisions / 2;
        const step = size / divisions;
        const halfSize = size / 2;
        const vertices = [], colors = [];
        for(let i367 = 0, j = 0, k = -halfSize; i367 <= divisions; i367++, k += step){
            vertices.push(-halfSize, 0, k, halfSize, 0, k);
            vertices.push(k, 0, -halfSize, k, 0, halfSize);
            const color = i367 === center ? color1 : color2;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
        }
        const geometry = new BufferGeometry();
        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry, material);
        this.type = 'GridHelper';
    }
}
class PolarGridHelper extends LineSegments {
    constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 4473924, color2 = 8947848){
        color1 = new Color(color1);
        color2 = new Color(color2);
        const vertices = [];
        const colors = [];
        // create the radials
        for(let i369 = 0; i369 <= radials; i369++){
            const v = i369 / radials * (Math.PI * 2);
            const x = Math.sin(v) * radius;
            const z = Math.cos(v) * radius;
            vertices.push(0, 0, 0);
            vertices.push(x, 0, z);
            const color = i369 & 1 ? color1 : color2;
            colors.push(color.r, color.g, color.b);
            colors.push(color.r, color.g, color.b);
        }
        // create the circles
        for(let i368 = 0; i368 <= circles; i368++){
            const color = i368 & 1 ? color1 : color2;
            const r = radius - radius / circles * i368;
            for(let j = 0; j < divisions; j++){
                // first vertex
                let v = j / divisions * (Math.PI * 2);
                let x = Math.sin(v) * r;
                let z = Math.cos(v) * r;
                vertices.push(x, 0, z);
                colors.push(color.r, color.g, color.b);
                // second vertex
                v = (j + 1) / divisions * (Math.PI * 2);
                x = Math.sin(v) * r;
                z = Math.cos(v) * r;
                vertices.push(x, 0, z);
                colors.push(color.r, color.g, color.b);
            }
        }
        const geometry = new BufferGeometry();
        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry, material);
        this.type = 'PolarGridHelper';
    }
}
const _v1 = /*@__PURE__*/ new Vector3();
const _v2 = /*@__PURE__*/ new Vector3();
const _v3 = /*@__PURE__*/ new Vector3();
class DirectionalLightHelper extends Object3D {
    constructor(light, size, color){
        super();
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        if (size === undefined) size = 1;
        let geometry = new BufferGeometry();
        geometry.setAttribute('position', new Float32BufferAttribute([
            -size,
            size,
            0,
            size,
            size,
            0,
            size,
            -size,
            0,
            -size,
            -size,
            0,
            -size,
            size,
            0
        ], 3));
        const material = new LineBasicMaterial({
            fog: false,
            toneMapped: false
        });
        this.lightPlane = new Line(geometry, material);
        this.add(this.lightPlane);
        geometry = new BufferGeometry();
        geometry.setAttribute('position', new Float32BufferAttribute([
            0,
            0,
            0,
            0,
            0,
            1
        ], 3));
        this.targetLine = new Line(geometry, material);
        this.add(this.targetLine);
        this.update();
    }
    dispose() {
        this.lightPlane.geometry.dispose();
        this.lightPlane.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose();
    }
    update() {
        _v1.setFromMatrixPosition(this.light.matrixWorld);
        _v2.setFromMatrixPosition(this.light.target.matrixWorld);
        _v3.subVectors(_v2, _v1);
        this.lightPlane.lookAt(_v2);
        if (this.color !== undefined) {
            this.lightPlane.material.color.set(this.color);
            this.targetLine.material.color.set(this.color);
        } else {
            this.lightPlane.material.color.copy(this.light.color);
            this.targetLine.material.color.copy(this.light.color);
        }
        this.targetLine.lookAt(_v2);
        this.targetLine.scale.z = _v3.length();
    }
}
const _vector = /*@__PURE__*/ new Vector3();
const _camera = /*@__PURE__*/ new Camera();
/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */ class CameraHelper extends LineSegments {
    constructor(camera){
        const geometry = new BufferGeometry();
        const material = new LineBasicMaterial({
            color: 16777215,
            vertexColors: true,
            toneMapped: false
        });
        const vertices = [];
        const colors = [];
        const pointMap = {};
        // colors
        const colorFrustum = new Color(16755200);
        const colorCone = new Color(16711680);
        const colorUp = new Color(43775);
        const colorTarget = new Color(16777215);
        const colorCross = new Color(3355443);
        // near
        addLine('n1', 'n2', colorFrustum);
        addLine('n2', 'n4', colorFrustum);
        addLine('n4', 'n3', colorFrustum);
        addLine('n3', 'n1', colorFrustum);
        // far
        addLine('f1', 'f2', colorFrustum);
        addLine('f2', 'f4', colorFrustum);
        addLine('f4', 'f3', colorFrustum);
        addLine('f3', 'f1', colorFrustum);
        // sides
        addLine('n1', 'f1', colorFrustum);
        addLine('n2', 'f2', colorFrustum);
        addLine('n3', 'f3', colorFrustum);
        addLine('n4', 'f4', colorFrustum);
        // cone
        addLine('p', 'n1', colorCone);
        addLine('p', 'n2', colorCone);
        addLine('p', 'n3', colorCone);
        addLine('p', 'n4', colorCone);
        // up
        addLine('u1', 'u2', colorUp);
        addLine('u2', 'u3', colorUp);
        addLine('u3', 'u1', colorUp);
        // target
        addLine('c', 't', colorTarget);
        addLine('p', 'c', colorCross);
        // cross
        addLine('cn1', 'cn2', colorCross);
        addLine('cn3', 'cn4', colorCross);
        addLine('cf1', 'cf2', colorCross);
        addLine('cf3', 'cf4', colorCross);
        function addLine(a, b, color) {
            addPoint(a, color);
            addPoint(b, color);
        }
        function addPoint(id, color) {
            vertices.push(0, 0, 0);
            colors.push(color.r, color.g, color.b);
            if (pointMap[id] === undefined) pointMap[id] = [];
            pointMap[id].push(vertices.length / 3 - 1);
        }
        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
        super(geometry, material);
        this.type = 'CameraHelper';
        this.camera = camera;
        if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
        this.matrix = camera.matrixWorld;
        this.matrixAutoUpdate = false;
        this.pointMap = pointMap;
        this.update();
    }
    update() {
        const geometry = this.geometry;
        const pointMap = this.pointMap;
        const w = 1, h = 1;
        // we need just camera projection matrix inverse
        // world matrix must be identity
        _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
        // center / target
        setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
        setPoint('t', pointMap, geometry, _camera, 0, 0, 1);
        // near
        setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
        setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
        setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
        setPoint('n4', pointMap, geometry, _camera, w, h, -1);
        // far
        setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
        setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
        setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
        setPoint('f4', pointMap, geometry, _camera, w, h, 1);
        // up
        setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
        setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
        setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1);
        // cross
        setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
        setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
        setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
        setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
        setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
        setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
        setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
        setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
        geometry.getAttribute('position').needsUpdate = true;
    }
    dispose() {
        this.geometry.dispose();
        this.material.dispose();
    }
}
function setPoint(point, pointMap, geometry, camera, x, y, z) {
    _vector.set(x, y, z).unproject(camera);
    const points = pointMap[point];
    if (points !== undefined) {
        const position = geometry.getAttribute('position');
        for(let i370 = 0, l = points.length; i370 < l; i370++)position.setXYZ(points[i370], _vector.x, _vector.y, _vector.z);
    }
}
const _box = /*@__PURE__*/ new Box3();
class BoxHelper extends LineSegments {
    constructor(object, color = 16776960){
        const indices = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7
        ]);
        const positions = new Float32Array(24);
        const geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.setAttribute('position', new BufferAttribute(positions, 3));
        super(geometry, new LineBasicMaterial({
            color: color,
            toneMapped: false
        }));
        this.object = object;
        this.type = 'BoxHelper';
        this.matrixAutoUpdate = false;
        this.update();
    }
    update(object) {
        if (object !== undefined) console.warn('THREE.BoxHelper: .update() has no longer arguments.');
        if (this.object !== undefined) _box.setFromObject(this.object);
        if (_box.isEmpty()) return;
        const min = _box.min;
        const max = _box.max;
        /*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/ const position = this.geometry.attributes.position;
        const array = position.array;
        array[0] = max.x;
        array[1] = max.y;
        array[2] = max.z;
        array[3] = min.x;
        array[4] = max.y;
        array[5] = max.z;
        array[6] = min.x;
        array[7] = min.y;
        array[8] = max.z;
        array[9] = max.x;
        array[10] = min.y;
        array[11] = max.z;
        array[12] = max.x;
        array[13] = max.y;
        array[14] = min.z;
        array[15] = min.x;
        array[16] = max.y;
        array[17] = min.z;
        array[18] = min.x;
        array[19] = min.y;
        array[20] = min.z;
        array[21] = max.x;
        array[22] = min.y;
        array[23] = min.z;
        position.needsUpdate = true;
        this.geometry.computeBoundingSphere();
    }
    setFromObject(object) {
        this.object = object;
        this.update();
        return this;
    }
    copy(source) {
        LineSegments.prototype.copy.call(this, source);
        this.object = source.object;
        return this;
    }
}
class Box3Helper extends LineSegments {
    constructor(box, color = 16776960){
        const indices = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7
        ]);
        const positions = [
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            -1
        ];
        const geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
        super(geometry, new LineBasicMaterial({
            color: color,
            toneMapped: false
        }));
        this.box = box;
        this.type = 'Box3Helper';
        this.geometry.computeBoundingSphere();
    }
    updateMatrixWorld(force) {
        const box = this.box;
        if (box.isEmpty()) return;
        box.getCenter(this.position);
        box.getSize(this.scale);
        this.scale.multiplyScalar(0.5);
        super.updateMatrixWorld(force);
    }
}
class PlaneHelper extends Line {
    constructor(plane, size = 1, hex = 16776960){
        const color = hex;
        const positions = [
            1,
            -1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ];
        const geometry = new BufferGeometry();
        geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
        geometry.computeBoundingSphere();
        super(geometry, new LineBasicMaterial({
            color: color,
            toneMapped: false
        }));
        this.type = 'PlaneHelper';
        this.plane = plane;
        this.size = size;
        const positions2 = [
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1
        ];
        const geometry2 = new BufferGeometry();
        geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
        geometry2.computeBoundingSphere();
        this.add(new Mesh(geometry2, new MeshBasicMaterial({
            color: color,
            opacity: 0.2,
            transparent: true,
            depthWrite: false,
            toneMapped: false
        })));
    }
    updateMatrixWorld(force) {
        let scale = -this.plane.constant;
        if (Math.abs(scale) < 0.00000001) scale = 0.00000001; // sign does not matter
        this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
        this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here
        this.lookAt(this.plane.normal);
        super.updateMatrixWorld(force);
    }
}
const _axis = /*@__PURE__*/ new Vector3();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
    // dir is assumed to be normalized
    constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 16776960, headLength = length * 0.2, headWidth = headLength * 0.2){
        super();
        this.type = 'ArrowHelper';
        if (_lineGeometry === undefined) {
            _lineGeometry = new BufferGeometry();
            _lineGeometry.setAttribute('position', new Float32BufferAttribute([
                0,
                0,
                0,
                0,
                1,
                0
            ], 3));
            _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
            _coneGeometry.translate(0, -0.5, 0);
        }
        this.position.copy(origin);
        this.line = new Line(_lineGeometry, new LineBasicMaterial({
            color: color,
            toneMapped: false
        }));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
        this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
            color: color,
            toneMapped: false
        }));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
    }
    setDirection(dir) {
        // dir is assumed to be normalized
        if (dir.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
        else if (dir.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
        else {
            _axis.set(dir.z, 0, -dir.x).normalize();
            const radians = Math.acos(dir.y);
            this.quaternion.setFromAxisAngle(_axis, radians);
        }
    }
    setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
        this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
        this.line.updateMatrix();
        this.cone.scale.set(headWidth, headLength, headWidth);
        this.cone.position.y = length;
        this.cone.updateMatrix();
    }
    setColor(color) {
        this.line.material.color.set(color);
        this.cone.material.color.set(color);
    }
    copy(source) {
        super.copy(source, false);
        this.line.copy(source.line);
        this.cone.copy(source.cone);
        return this;
    }
}
class AxesHelper extends LineSegments {
    constructor(size = 1){
        const vertices = [
            0,
            0,
            0,
            size,
            0,
            0,
            0,
            0,
            0,
            0,
            size,
            0,
            0,
            0,
            0,
            0,
            0,
            size
        ];
        const colors = [
            1,
            0,
            0,
            1,
            0.6,
            0,
            0,
            1,
            0,
            0.6,
            1,
            0,
            0,
            0,
            1,
            0,
            0.6,
            1
        ];
        const geometry = new BufferGeometry();
        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry, material);
        this.type = 'AxesHelper';
    }
    setColors(xAxisColor, yAxisColor, zAxisColor) {
        const color = new Color();
        const array = this.geometry.attributes.color.array;
        color.set(xAxisColor);
        color.toArray(array, 0);
        color.toArray(array, 3);
        color.set(yAxisColor);
        color.toArray(array, 6);
        color.toArray(array, 9);
        color.set(zAxisColor);
        color.toArray(array, 12);
        color.toArray(array, 15);
        this.geometry.attributes.color.needsUpdate = true;
        return this;
    }
    dispose() {
        this.geometry.dispose();
        this.material.dispose();
    }
}
const _floatView = new Float32Array(1);
const _int32View = new Int32Array(_floatView.buffer);
class DataUtils {
    // Converts float32 to float16 (stored as uint16 value).
    static toHalfFloat(val) {
        // Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410
        /* This method is faster than the OpenEXR implementation (very often
		* used, eg. in Ogre), with the additional benefit of rounding, inspired
		* by James Tursa?s half-precision code. */ _floatView[0] = val;
        const x = _int32View[0];
        let bits = x >> 16 & 32768; /* Get the sign */ 
        let m = x >> 12 & 2047; /* Keep one extra bit for rounding */ 
        const e = x >> 23 & 255; /* Using int is faster here */ 
        /* If zero, or denormal, or exponent underflows too much for a denormal
			* half, return signed zero. */ if (e < 103) return bits;
        /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */ if (e > 142) {
            bits |= 31744;
            /* If exponent was 0xff and one mantissa bit was set, it means NaN,
						* not Inf, so make sure we set one mantissa bit too. */ bits |= (e == 255 ? 0 : 1) && x & 8388607;
            return bits;
        }
        /* If exponent underflows but not too much, return a denormal */ if (e < 113) {
            m |= 2048;
            /* Extra rounding may overflow and set mantissa to 0 and exponent
				* to 1, which is OK. */ bits |= (m >> 114 - e) + (m >> 113 - e & 1);
            return bits;
        }
        bits |= e - 112 << 10 | m >> 1;
        /* Extra rounding. An overflow will set mantissa to 0 and increment
			* the exponent, which is OK. */ bits += m & 1;
        return bits;
    }
}
const LineStrip = 0;
const LinePieces = 1;
const NoColors = 0;
const FaceColors = 1;
const VertexColors = 2;
function MeshFaceMaterial(materials) {
    console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
    return materials;
}
function MultiMaterial(materials = []) {
    console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
    materials.isMultiMaterial = true;
    materials.materials = materials;
    materials.clone = function() {
        return materials.slice();
    };
    return materials;
}
function PointCloud(geometry, material) {
    console.warn('THREE.PointCloud has been renamed to THREE.Points.');
    return new Points(geometry, material);
}
function Particle(material) {
    console.warn('THREE.Particle has been renamed to THREE.Sprite.');
    return new Sprite(material);
}
function ParticleSystem(geometry, material) {
    console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
    return new Points(geometry, material);
}
function PointCloudMaterial(parameters) {
    console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
    return new PointsMaterial(parameters);
}
function ParticleBasicMaterial(parameters) {
    console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
    return new PointsMaterial(parameters);
}
function ParticleSystemMaterial(parameters) {
    console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
    return new PointsMaterial(parameters);
}
function Vertex(x, y, z) {
    console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
    return new Vector3(x, y, z);
}
//
function DynamicBufferAttribute(array, itemSize) {
    console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
    return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
}
function Int8Attribute(array, itemSize) {
    console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
    return new Int8BufferAttribute(array, itemSize);
}
function Uint8Attribute(array, itemSize) {
    console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
    return new Uint8BufferAttribute(array, itemSize);
}
function Uint8ClampedAttribute(array, itemSize) {
    console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
    return new Uint8ClampedBufferAttribute(array, itemSize);
}
function Int16Attribute(array, itemSize) {
    console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
    return new Int16BufferAttribute(array, itemSize);
}
function Uint16Attribute(array, itemSize) {
    console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
    return new Uint16BufferAttribute(array, itemSize);
}
function Int32Attribute(array, itemSize) {
    console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
    return new Int32BufferAttribute(array, itemSize);
}
function Uint32Attribute(array, itemSize) {
    console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
    return new Uint32BufferAttribute(array, itemSize);
}
function Float32Attribute(array, itemSize) {
    console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
    return new Float32BufferAttribute(array, itemSize);
}
function Float64Attribute(array, itemSize) {
    console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
    return new Float64BufferAttribute(array, itemSize);
}
//
Curve.create = function(construct, getPoint) {
    console.log('THREE.Curve.create() has been deprecated');
    construct.prototype = Object.create(Curve.prototype);
    construct.prototype.constructor = construct;
    construct.prototype.getPoint = getPoint;
    return construct;
};
//
Path.prototype.fromPoints = function(points) {
    console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
    return this.setFromPoints(points);
};
//
function AxisHelper(size) {
    console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
    return new AxesHelper(size);
}
function BoundingBoxHelper(object, color) {
    console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
    return new BoxHelper(object, color);
}
function EdgesHelper(object, hex) {
    console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
    return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
        color: hex !== undefined ? hex : 16777215
    }));
}
GridHelper.prototype.setColors = function() {
    console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
};
SkeletonHelper.prototype.update = function() {
    console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
};
function WireframeHelper(object, hex) {
    console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
    return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
        color: hex !== undefined ? hex : 16777215
    }));
}
//
Loader.prototype.extractUrlBase = function(url) {
    console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
    return LoaderUtils.extractUrlBase(url);
};
Loader.Handlers = {
    add: function() {
        console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
    },
    get: function() {
        console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
    }
};
function XHRLoader(manager) {
    console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
    return new FileLoader(manager);
}
function BinaryTextureLoader(manager) {
    console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
    return new DataTextureLoader(manager);
}
//
Box2.prototype.center = function(optionalTarget) {
    console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
};
Box2.prototype.empty = function() {
    console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
};
Box2.prototype.isIntersectionBox = function(box) {
    console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
};
Box2.prototype.size = function(optionalTarget) {
    console.warn('THREE.Box2: .size() has been renamed to .getSize().');
    return this.getSize(optionalTarget);
};
//
Box3.prototype.center = function(optionalTarget) {
    console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
};
Box3.prototype.empty = function() {
    console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(box) {
    console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
};
Box3.prototype.isIntersectionSphere = function(sphere) {
    console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
    return this.intersectsSphere(sphere);
};
Box3.prototype.size = function(optionalTarget) {
    console.warn('THREE.Box3: .size() has been renamed to .getSize().');
    return this.getSize(optionalTarget);
};
//
Sphere.prototype.empty = function() {
    console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
};
//
Frustum.prototype.setFromMatrix = function(m) {
    console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
    return this.setFromProjectionMatrix(m);
};
//
Line3.prototype.center = function(optionalTarget) {
    console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
};
//
Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
    console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
    return this.toArray(array, offset);
};
Matrix3.prototype.multiplyVector3 = function(vector) {
    console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
    return vector.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
    console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
};
Matrix3.prototype.applyToBufferAttribute = function(attribute) {
    console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
    return attribute.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
    console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
};
Matrix3.prototype.getInverse = function(matrix) {
    console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
    return this.copy(matrix).invert();
};
//
Matrix4.prototype.extractPosition = function(m) {
    console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
    return this.copyPosition(m);
};
Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
    console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
    return this.toArray(array, offset);
};
Matrix4.prototype.getPosition = function() {
    console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
    return new Vector3().setFromMatrixColumn(this, 3);
};
Matrix4.prototype.setRotationFromQuaternion = function(q) {
    console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
    return this.makeRotationFromQuaternion(q);
};
Matrix4.prototype.multiplyToArray = function() {
    console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
};
Matrix4.prototype.multiplyVector3 = function(vector) {
    console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector4 = function(vector) {
    console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector3Array = function() {
    console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
};
Matrix4.prototype.rotateAxis = function(v) {
    console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
    v.transformDirection(this);
};
Matrix4.prototype.crossVector = function(vector) {
    console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
};
Matrix4.prototype.translate = function() {
    console.error('THREE.Matrix4: .translate() has been removed.');
};
Matrix4.prototype.rotateX = function() {
    console.error('THREE.Matrix4: .rotateX() has been removed.');
};
Matrix4.prototype.rotateY = function() {
    console.error('THREE.Matrix4: .rotateY() has been removed.');
};
Matrix4.prototype.rotateZ = function() {
    console.error('THREE.Matrix4: .rotateZ() has been removed.');
};
Matrix4.prototype.rotateByAxis = function() {
    console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
};
Matrix4.prototype.applyToBufferAttribute = function(attribute) {
    console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
    return attribute.applyMatrix4(this);
};
Matrix4.prototype.applyToVector3Array = function() {
    console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
};
Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
    console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
    return this.makePerspective(left, right, top, bottom, near, far);
};
Matrix4.prototype.getInverse = function(matrix) {
    console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
    return this.copy(matrix).invert();
};
//
Plane.prototype.isIntersectionLine = function(line) {
    console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
    return this.intersectsLine(line);
};
//
Quaternion.prototype.multiplyVector3 = function(vector) {
    console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
    return vector.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
    console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');
    return this.invert();
};
//
Ray.prototype.isIntersectionBox = function(box) {
    console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
};
Ray.prototype.isIntersectionPlane = function(plane) {
    console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
    return this.intersectsPlane(plane);
};
Ray.prototype.isIntersectionSphere = function(sphere) {
    console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
    return this.intersectsSphere(sphere);
};
//
Triangle.prototype.area = function() {
    console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
    return this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(point, target) {
    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
    return this.getBarycoord(point, target);
};
Triangle.prototype.midpoint = function(target) {
    console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
    return this.getMidpoint(target);
};
Triangle.prototypenormal = function(target) {
    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
    return this.getNormal(target);
};
Triangle.prototype.plane = function(target) {
    console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
    return this.getPlane(target);
};
Triangle.barycoordFromPoint = function(point, a, b, c, target) {
    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
    return Triangle.getBarycoord(point, a, b, c, target);
};
Triangle.normal = function(a, b, c, target) {
    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
    return Triangle.getNormal(a, b, c, target);
};
//
Shape.prototype.extractAllPoints = function(divisions) {
    console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
    return this.extractPoints(divisions);
};
Shape.prototype.extrude = function(options) {
    console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
    return new ExtrudeGeometry(this, options);
};
Shape.prototype.makeGeometry = function(options) {
    console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
    return new ShapeGeometry(this, options);
};
//
Vector2.prototype.fromAttribute = function(attribute, index, offset) {
    console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
};
Vector2.prototype.distanceToManhattan = function(v) {
    console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
    return this.manhattanDistanceTo(v);
};
Vector2.prototype.lengthManhattan = function() {
    console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
};
//
Vector3.prototype.setEulerFromRotationMatrix = function() {
    console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
};
Vector3.prototype.setEulerFromQuaternion = function() {
    console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
};
Vector3.prototype.getPositionFromMatrix = function(m) {
    console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
    return this.setFromMatrixPosition(m);
};
Vector3.prototype.getScaleFromMatrix = function(m) {
    console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
    return this.setFromMatrixScale(m);
};
Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
    console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
    return this.setFromMatrixColumn(matrix, index);
};
Vector3.prototype.applyProjection = function(m) {
    console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
    return this.applyMatrix4(m);
};
Vector3.prototype.fromAttribute = function(attribute, index, offset) {
    console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
};
Vector3.prototype.distanceToManhattan = function(v) {
    console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
    return this.manhattanDistanceTo(v);
};
Vector3.prototype.lengthManhattan = function() {
    console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
};
//
Vector4.prototype.fromAttribute = function(attribute, index, offset) {
    console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
};
Vector4.prototype.lengthManhattan = function() {
    console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
};
//
Object3D.prototype.getChildByName = function(name) {
    console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
    return this.getObjectByName(name);
};
Object3D.prototype.renderDepth = function() {
    console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
};
Object3D.prototype.translate = function(distance, axis) {
    console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
    return this.translateOnAxis(axis, distance);
};
Object3D.prototype.getWorldRotation = function() {
    console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
};
Object3D.prototype.applyMatrix = function(matrix) {
    console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
    return this.applyMatrix4(matrix);
};
Object.defineProperties(Object3D.prototype, {
    eulerOrder: {
        get: function() {
            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
            return this.rotation.order;
        },
        set: function(value) {
            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
            this.rotation.order = value;
        }
    },
    useQuaternion: {
        get: function() {
            console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
        },
        set: function() {
            console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
        }
    }
});
Mesh.prototype.setDrawMode = function() {
    console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
};
Object.defineProperties(Mesh.prototype, {
    drawMode: {
        get: function() {
            console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
            return TrianglesDrawMode;
        },
        set: function() {
            console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
        }
    }
});
SkinnedMesh.prototype.initBones = function() {
    console.error('THREE.SkinnedMesh: initBones() has been removed.');
};
//
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
    if (filmGauge !== undefined) this.filmGauge = filmGauge;
    this.setFocalLength(focalLength);
};
//
Object.defineProperties(Light.prototype, {
    onlyShadow: {
        set: function() {
            console.warn('THREE.Light: .onlyShadow has been removed.');
        }
    },
    shadowCameraFov: {
        set: function(value) {
            console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
            this.shadow.camera.fov = value;
        }
    },
    shadowCameraLeft: {
        set: function(value) {
            console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
            this.shadow.camera.left = value;
        }
    },
    shadowCameraRight: {
        set: function(value) {
            console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
            this.shadow.camera.right = value;
        }
    },
    shadowCameraTop: {
        set: function(value) {
            console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
            this.shadow.camera.top = value;
        }
    },
    shadowCameraBottom: {
        set: function(value) {
            console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
            this.shadow.camera.bottom = value;
        }
    },
    shadowCameraNear: {
        set: function(value) {
            console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
            this.shadow.camera.near = value;
        }
    },
    shadowCameraFar: {
        set: function(value) {
            console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
            this.shadow.camera.far = value;
        }
    },
    shadowCameraVisible: {
        set: function() {
            console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
        }
    },
    shadowBias: {
        set: function(value) {
            console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
            this.shadow.bias = value;
        }
    },
    shadowDarkness: {
        set: function() {
            console.warn('THREE.Light: .shadowDarkness has been removed.');
        }
    },
    shadowMapWidth: {
        set: function(value) {
            console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
            this.shadow.mapSize.width = value;
        }
    },
    shadowMapHeight: {
        set: function(value) {
            console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
            this.shadow.mapSize.height = value;
        }
    }
});
//
Object.defineProperties(BufferAttribute.prototype, {
    length: {
        get: function() {
            console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
            return this.array.length;
        }
    },
    dynamic: {
        get: function() {
            console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
            return this.usage === DynamicDrawUsage;
        },
        set: function() {
            console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
            this.setUsage(DynamicDrawUsage);
        }
    }
});
BufferAttribute.prototype.setDynamic = function(value) {
    console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
    return this;
};
BufferAttribute.prototype.copyIndicesArray = function() {
    console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
}, BufferAttribute.prototype.setArray = function() {
    console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
};
//
BufferGeometry.prototype.addIndex = function(index) {
    console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
    this.setIndex(index);
};
BufferGeometry.prototype.addAttribute = function(name, attribute) {
    console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');
    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
        console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
        return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
    }
    if (name === 'index') {
        console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
        this.setIndex(attribute);
        return this;
    }
    return this.setAttribute(name, attribute);
};
BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
    if (indexOffset !== undefined) console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
    console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
    this.addGroup(start, count);
};
BufferGeometry.prototype.clearDrawCalls = function() {
    console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
    this.clearGroups();
};
BufferGeometry.prototype.computeOffsets = function() {
    console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
};
BufferGeometry.prototype.removeAttribute = function(name) {
    console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
    return this.deleteAttribute(name);
};
BufferGeometry.prototype.applyMatrix = function(matrix) {
    console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
    return this.applyMatrix4(matrix);
};
Object.defineProperties(BufferGeometry.prototype, {
    drawcalls: {
        get: function() {
            console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
            return this.groups;
        }
    },
    offsets: {
        get: function() {
            console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
            return this.groups;
        }
    }
});
InterleavedBuffer.prototype.setDynamic = function(value) {
    console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
    return this;
};
InterleavedBuffer.prototype.setArray = function() {
    console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
};
//
ExtrudeGeometry.prototype.getArrays = function() {
    console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
};
ExtrudeGeometry.prototype.addShapeList = function() {
    console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
};
ExtrudeGeometry.prototype.addShape = function() {
    console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
};
//
Scene.prototype.dispose = function() {
    console.error('THREE.Scene: .dispose() has been removed.');
};
//
Uniform.prototype.onUpdate = function() {
    console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
    return this;
};
//
Object.defineProperties(Material.prototype, {
    wrapAround: {
        get: function() {
            console.warn('THREE.Material: .wrapAround has been removed.');
        },
        set: function() {
            console.warn('THREE.Material: .wrapAround has been removed.');
        }
    },
    overdraw: {
        get: function() {
            console.warn('THREE.Material: .overdraw has been removed.');
        },
        set: function() {
            console.warn('THREE.Material: .overdraw has been removed.');
        }
    },
    wrapRGB: {
        get: function() {
            console.warn('THREE.Material: .wrapRGB has been removed.');
            return new Color();
        }
    },
    shading: {
        get: function() {
            console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
        },
        set: function(value) {
            console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
            this.flatShading = value === FlatShading;
        }
    },
    stencilMask: {
        get: function() {
            console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
            return this.stencilFuncMask;
        },
        set: function(value) {
            console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
            this.stencilFuncMask = value;
        }
    },
    vertexTangents: {
        get: function() {
            console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
        },
        set: function() {
            console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
        }
    }
});
Object.defineProperties(ShaderMaterial.prototype, {
    derivatives: {
        get: function() {
            console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
            return this.extensions.derivatives;
        },
        set: function(value) {
            console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
            this.extensions.derivatives = value;
        }
    }
});
//
WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
    console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
};
WebGLRenderer.prototype.animate = function(callback) {
    console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
    this.setAnimationLoop(callback);
};
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
    console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
    return this.getRenderTarget();
};
WebGLRenderer.prototype.getMaxAnisotropy = function() {
    console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
    return this.capabilities.getMaxAnisotropy();
};
WebGLRenderer.prototype.getPrecision = function() {
    console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
    return this.capabilities.precision;
};
WebGLRenderer.prototype.resetGLState = function() {
    console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
    return this.state.reset();
};
WebGLRenderer.prototype.supportsFloatTextures = function() {
    console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
    return this.extensions.get('OES_texture_float');
};
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
    console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
    return this.extensions.get('OES_texture_half_float');
};
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
    console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
    return this.extensions.get('OES_standard_derivatives');
};
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
    console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
    return this.extensions.get('WEBGL_compressed_texture_s3tc');
};
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
    console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
    return this.extensions.get('WEBGL_compressed_texture_pvrtc');
};
WebGLRenderer.prototype.supportsBlendMinMax = function() {
    console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
    return this.extensions.get('EXT_blend_minmax');
};
WebGLRenderer.prototype.supportsVertexTextures = function() {
    console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
    return this.capabilities.vertexTextures;
};
WebGLRenderer.prototype.supportsInstancedArrays = function() {
    console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
    return this.extensions.get('ANGLE_instanced_arrays');
};
WebGLRenderer.prototype.enableScissorTest = function(boolean) {
    console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
    this.setScissorTest(boolean);
};
WebGLRenderer.prototype.initMaterial = function() {
    console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
};
WebGLRenderer.prototype.addPrePlugin = function() {
    console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
};
WebGLRenderer.prototype.addPostPlugin = function() {
    console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
};
WebGLRenderer.prototype.updateShadowMap = function() {
    console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
};
WebGLRenderer.prototype.setFaceCulling = function() {
    console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
};
WebGLRenderer.prototype.allocTextureUnit = function() {
    console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
};
WebGLRenderer.prototype.setTexture = function() {
    console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
};
WebGLRenderer.prototype.setTexture2D = function() {
    console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
};
WebGLRenderer.prototype.setTextureCube = function() {
    console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
};
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
    console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
    return this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer.prototype, {
    shadowMapEnabled: {
        get: function() {
            return this.shadowMap.enabled;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
            this.shadowMap.enabled = value;
        }
    },
    shadowMapType: {
        get: function() {
            return this.shadowMap.type;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
            this.shadowMap.type = value;
        }
    },
    shadowMapCullFace: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
        }
    },
    context: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
            return this.getContext();
        }
    },
    vr: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
            return this.xr;
        }
    },
    gammaInput: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
            return false;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
        }
    },
    gammaOutput: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
            return false;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
            this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
        }
    },
    toneMappingWhitePoint: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
            return 1;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
        }
    }
});
Object.defineProperties(WebGLShadowMap.prototype, {
    cullFace: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
        }
    },
    renderReverseSided: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
        }
    },
    renderSingleSided: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
        }
    }
});
function WebGLRenderTargetCube(width, height, options) {
    console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
    return new WebGLCubeRenderTarget(width, options);
}
//
Object.defineProperties(WebGLRenderTarget.prototype, {
    wrapS: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
            return this.texture.wrapS;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
            this.texture.wrapS = value;
        }
    },
    wrapT: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
            return this.texture.wrapT;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
            this.texture.wrapT = value;
        }
    },
    magFilter: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
            return this.texture.magFilter;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
            this.texture.magFilter = value;
        }
    },
    minFilter: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
            return this.texture.minFilter;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
            this.texture.minFilter = value;
        }
    },
    anisotropy: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
            return this.texture.anisotropy;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
            this.texture.anisotropy = value;
        }
    },
    offset: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
            return this.texture.offset;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
            this.texture.offset = value;
        }
    },
    repeat: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
            return this.texture.repeat;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
            this.texture.repeat = value;
        }
    },
    format: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
            return this.texture.format;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
            this.texture.format = value;
        }
    },
    type: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
            return this.texture.type;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
            this.texture.type = value;
        }
    },
    generateMipmaps: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
            return this.texture.generateMipmaps;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
            this.texture.generateMipmaps = value;
        }
    }
});
//
Audio.prototype.load = function(file) {
    console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
    const scope = this;
    const audioLoader = new AudioLoader();
    audioLoader.load(file, function(buffer) {
        scope.setBuffer(buffer);
    });
    return this;
};
AudioAnalyser.prototype.getData = function() {
    console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
    return this.getFrequencyData();
};
//
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
    console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
    return this.update(renderer, scene);
};
CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
    console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');
    return this.renderTarget.clear(renderer, color, depth, stencil);
};
ImageUtils.crossOrigin = undefined;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
    console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
    const loader = new TextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    const texture = loader.load(url, onLoad, undefined, onError);
    if (mapping) texture.mapping = mapping;
    return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
    console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
    const loader = new CubeTextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    const texture = loader.load(urls, onLoad, undefined, onError);
    if (mapping) texture.mapping = mapping;
    return texture;
};
ImageUtils.loadCompressedTexture = function() {
    console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
};
ImageUtils.loadCompressedTextureCube = function() {
    console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
};
//
function CanvasRenderer() {
    console.error('THREE.CanvasRenderer has been removed');
}
//
function JSONLoader() {
    console.error('THREE.JSONLoader has been removed.');
}
//
const SceneUtils = {
    createMultiMaterialObject: function() {
        console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
    },
    detach: function() {
        console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
    },
    attach: function() {
        console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
    }
};
//
function LensFlare() {
    console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
}
if (typeof __THREE_DEVTOOLS__ !== 'undefined') /* eslint-disable no-undef */ __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
    detail: {
        revision: REVISION
    }
}));
if (typeof window !== 'undefined') {
    if (window.__THREE__) console.warn('WARNING: Multiple instances of Three.js being imported.');
    else window.__THREE__ = REVISION;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"7mqRv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OrbitControls", ()=>OrbitControls
);
parcelHelpers.export(exports, "MapControls", ()=>MapControls
);
var _three = require("three");
// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move
const _changeEvent = {
    type: 'change'
};
const _startEvent = {
    type: 'start'
};
const _endEvent = {
    type: 'end'
};
class OrbitControls extends _three.EventDispatcher {
    constructor(object, domElement1){
        super();
        if (domElement1 === undefined) console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
        if (domElement1 === document) console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
        this.object = object;
        this.domElement = domElement1;
        this.domElement.style.touchAction = 'none'; // disable touch scroll
        // Set to false to disable this control
        this.enabled = true;
        // "target" sets the location of focus, where the object orbits around
        this.target = new _three.Vector3();
        // How far you can dolly in and out ( PerspectiveCamera only )
        this.minDistance = 0;
        this.maxDistance = Infinity;
        // How far you can zoom in and out ( OrthographicCamera only )
        this.minZoom = 0;
        this.maxZoom = Infinity;
        // How far you can orbit vertically, upper and lower limits.
        // Range is 0 to Math.PI radians.
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians
        // How far you can orbit horizontally, upper and lower limits.
        // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
        this.minAzimuthAngle = -Infinity; // radians
        this.maxAzimuthAngle = Infinity; // radians
        // Set to true to enable damping (inertia)
        // If damping is enabled, you must call controls.update() in your animation loop
        this.enableDamping = false;
        this.dampingFactor = 0.05;
        // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
        // Set to false to disable zooming
        this.enableZoom = true;
        this.zoomSpeed = 1;
        // Set to false to disable rotating
        this.enableRotate = true;
        this.rotateSpeed = 1;
        // Set to false to disable panning
        this.enablePan = true;
        this.panSpeed = 1;
        this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
        this.keyPanSpeed = 7; // pixels moved per arrow key push
        // Set to true to automatically rotate around the target
        // If auto-rotate is enabled, you must call controls.update() in your animation loop
        this.autoRotate = false;
        this.autoRotateSpeed = 2; // 30 seconds per orbit when fps is 60
        // The four arrow keys
        this.keys = {
            LEFT: 'ArrowLeft',
            UP: 'ArrowUp',
            RIGHT: 'ArrowRight',
            BOTTOM: 'ArrowDown'
        };
        // Mouse buttons
        this.mouseButtons = {
            LEFT: _three.MOUSE.ROTATE,
            MIDDLE: _three.MOUSE.DOLLY,
            RIGHT: _three.MOUSE.PAN
        };
        // Touch fingers
        this.touches = {
            ONE: _three.TOUCH.ROTATE,
            TWO: _three.TOUCH.DOLLY_PAN
        };
        // for reset
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.zoom;
        // the target DOM element for key events
        this._domElementKeyEvents = null;
        //
        // public methods
        //
        this.getPolarAngle = function() {
            return spherical.phi;
        };
        this.getAzimuthalAngle = function() {
            return spherical.theta;
        };
        this.getDistance = function() {
            return this.object.position.distanceTo(this.target);
        };
        this.listenToKeyEvents = function(domElement) {
            domElement.addEventListener('keydown', onKeyDown);
            this._domElementKeyEvents = domElement;
        };
        this.saveState = function() {
            scope.target0.copy(scope.target);
            scope.position0.copy(scope.object.position);
            scope.zoom0 = scope.object.zoom;
        };
        this.reset = function() {
            scope.target.copy(scope.target0);
            scope.object.position.copy(scope.position0);
            scope.object.zoom = scope.zoom0;
            scope.object.updateProjectionMatrix();
            scope.dispatchEvent(_changeEvent);
            scope.update();
            state = STATE.NONE;
        };
        // this method is exposed, but perhaps it would be better if we can make it private...
        this.update = function() {
            const offset = new _three.Vector3();
            // so camera.up is the orbit axis
            const quat = new _three.Quaternion().setFromUnitVectors(object.up, new _three.Vector3(0, 1, 0));
            const quatInverse = quat.clone().invert();
            const lastPosition = new _three.Vector3();
            const lastQuaternion = new _three.Quaternion();
            const twoPI = 2 * Math.PI;
            return function update() {
                const position = scope.object.position;
                offset.copy(position).sub(scope.target);
                // rotate offset to "y-axis-is-up" space
                offset.applyQuaternion(quat);
                // angle from z-axis around y-axis
                spherical.setFromVector3(offset);
                if (scope.autoRotate && state === STATE.NONE) rotateLeft(getAutoRotationAngle());
                if (scope.enableDamping) {
                    spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                    spherical.phi += sphericalDelta.phi * scope.dampingFactor;
                } else {
                    spherical.theta += sphericalDelta.theta;
                    spherical.phi += sphericalDelta.phi;
                }
                // restrict theta to be between desired limits
                let min = scope.minAzimuthAngle;
                let max = scope.maxAzimuthAngle;
                if (isFinite(min) && isFinite(max)) {
                    if (min < -Math.PI) min += twoPI;
                    else if (min > Math.PI) min -= twoPI;
                    if (max < -Math.PI) max += twoPI;
                    else if (max > Math.PI) max -= twoPI;
                    if (min <= max) spherical.theta = Math.max(min, Math.min(max, spherical.theta));
                    else spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
                }
                // restrict phi to be between desired limits
                spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
                spherical.makeSafe();
                spherical.radius *= scale;
                // restrict radius to be between desired limits
                spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
                // move target to panned location
                if (scope.enableDamping === true) scope.target.addScaledVector(panOffset, scope.dampingFactor);
                else scope.target.add(panOffset);
                offset.setFromSpherical(spherical);
                // rotate offset back to "camera-up-vector-is-up" space
                offset.applyQuaternion(quatInverse);
                position.copy(scope.target).add(offset);
                scope.object.lookAt(scope.target);
                if (scope.enableDamping === true) {
                    sphericalDelta.theta *= 1 - scope.dampingFactor;
                    sphericalDelta.phi *= 1 - scope.dampingFactor;
                    panOffset.multiplyScalar(1 - scope.dampingFactor);
                } else {
                    sphericalDelta.set(0, 0, 0);
                    panOffset.set(0, 0, 0);
                }
                scale = 1;
                // update condition is:
                // min(camera displacement, camera rotation in radians)^2 > EPS
                // using small-angle approximation cos(x/2) = 1 - x^2 / 8
                if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
                    scope.dispatchEvent(_changeEvent);
                    lastPosition.copy(scope.object.position);
                    lastQuaternion.copy(scope.object.quaternion);
                    zoomChanged = false;
                    return true;
                }
                return false;
            };
        }();
        this.dispose = function() {
            scope.domElement.removeEventListener('contextmenu', onContextMenu);
            scope.domElement.removeEventListener('pointerdown', onPointerDown);
            scope.domElement.removeEventListener('pointercancel', onPointerCancel);
            scope.domElement.removeEventListener('wheel', onMouseWheel);
            scope.domElement.removeEventListener('pointermove', onPointerMove);
            scope.domElement.removeEventListener('pointerup', onPointerUp);
            if (scope._domElementKeyEvents !== null) scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown);
        //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
        };
        //
        // internals
        //
        const scope = this;
        const STATE = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
        };
        let state = STATE.NONE;
        const EPS = 0.000001;
        // current position in spherical coordinates
        const spherical = new _three.Spherical();
        const sphericalDelta = new _three.Spherical();
        let scale = 1;
        const panOffset = new _three.Vector3();
        let zoomChanged = false;
        const rotateStart = new _three.Vector2();
        const rotateEnd = new _three.Vector2();
        const rotateDelta = new _three.Vector2();
        const panStart = new _three.Vector2();
        const panEnd = new _three.Vector2();
        const panDelta = new _three.Vector2();
        const dollyStart = new _three.Vector2();
        const dollyEnd = new _three.Vector2();
        const dollyDelta = new _three.Vector2();
        const pointers = [];
        const pointerPositions = {};
        function getAutoRotationAngle() {
            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
        }
        function getZoomScale() {
            return Math.pow(0.95, scope.zoomSpeed);
        }
        function rotateLeft(angle) {
            sphericalDelta.theta -= angle;
        }
        function rotateUp(angle) {
            sphericalDelta.phi -= angle;
        }
        const panLeft = function() {
            const v = new _three.Vector3();
            return function panLeft(distance, objectMatrix) {
                v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
                v.multiplyScalar(-distance);
                panOffset.add(v);
            };
        }();
        const panUp = function() {
            const v = new _three.Vector3();
            return function panUp(distance, objectMatrix) {
                if (scope.screenSpacePanning === true) v.setFromMatrixColumn(objectMatrix, 1);
                else {
                    v.setFromMatrixColumn(objectMatrix, 0);
                    v.crossVectors(scope.object.up, v);
                }
                v.multiplyScalar(distance);
                panOffset.add(v);
            };
        }();
        // deltaX and deltaY are in pixels; right and down are positive
        const pan = function() {
            const offset = new _three.Vector3();
            return function pan(deltaX, deltaY) {
                const element = scope.domElement;
                if (scope.object.isPerspectiveCamera) {
                    // perspective
                    const position = scope.object.position;
                    offset.copy(position).sub(scope.target);
                    let targetDistance = offset.length();
                    // half of the fov is center to top of screen
                    targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
                    // we use only clientHeight here so aspect ratio does not distort speed
                    panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
                    panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
                } else if (scope.object.isOrthographicCamera) {
                    // orthographic
                    panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
                    panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
                } else {
                    // camera neither orthographic nor perspective
                    console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
                    scope.enablePan = false;
                }
            };
        }();
        function dollyOut(dollyScale) {
            if (scope.object.isPerspectiveCamera) scale /= dollyScale;
            else if (scope.object.isOrthographicCamera) {
                scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
                scope.object.updateProjectionMatrix();
                zoomChanged = true;
            } else {
                console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
                scope.enableZoom = false;
            }
        }
        function dollyIn(dollyScale) {
            if (scope.object.isPerspectiveCamera) scale *= dollyScale;
            else if (scope.object.isOrthographicCamera) {
                scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
                scope.object.updateProjectionMatrix();
                zoomChanged = true;
            } else {
                console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
                scope.enableZoom = false;
            }
        }
        //
        // event callbacks - update the object state
        //
        function handleMouseDownRotate(event) {
            rotateStart.set(event.clientX, event.clientY);
        }
        function handleMouseDownDolly(event) {
            dollyStart.set(event.clientX, event.clientY);
        }
        function handleMouseDownPan(event) {
            panStart.set(event.clientX, event.clientY);
        }
        function handleMouseMoveRotate(event) {
            rotateEnd.set(event.clientX, event.clientY);
            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
            const element = scope.domElement;
            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height
            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
            rotateStart.copy(rotateEnd);
            scope.update();
        }
        function handleMouseMoveDolly(event) {
            dollyEnd.set(event.clientX, event.clientY);
            dollyDelta.subVectors(dollyEnd, dollyStart);
            if (dollyDelta.y > 0) dollyOut(getZoomScale());
            else if (dollyDelta.y < 0) dollyIn(getZoomScale());
            dollyStart.copy(dollyEnd);
            scope.update();
        }
        function handleMouseMovePan(event) {
            panEnd.set(event.clientX, event.clientY);
            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
            pan(panDelta.x, panDelta.y);
            panStart.copy(panEnd);
            scope.update();
        }
        function handleMouseUp() {
        // no-op
        }
        function handleMouseWheel(event) {
            if (event.deltaY < 0) dollyIn(getZoomScale());
            else if (event.deltaY > 0) dollyOut(getZoomScale());
            scope.update();
        }
        function handleKeyDown(event) {
            let needsUpdate = false;
            switch(event.code){
                case scope.keys.UP:
                    pan(0, scope.keyPanSpeed);
                    needsUpdate = true;
                    break;
                case scope.keys.BOTTOM:
                    pan(0, -scope.keyPanSpeed);
                    needsUpdate = true;
                    break;
                case scope.keys.LEFT:
                    pan(scope.keyPanSpeed, 0);
                    needsUpdate = true;
                    break;
                case scope.keys.RIGHT:
                    pan(-scope.keyPanSpeed, 0);
                    needsUpdate = true;
                    break;
            }
            if (needsUpdate) {
                // prevent the browser from scrolling on cursor keys
                event.preventDefault();
                scope.update();
            }
        }
        function handleTouchStartRotate() {
            if (pointers.length === 1) rotateStart.set(pointers[0].pageX, pointers[0].pageY);
            else {
                const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
                const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
                rotateStart.set(x, y);
            }
        }
        function handleTouchStartPan() {
            if (pointers.length === 1) panStart.set(pointers[0].pageX, pointers[0].pageY);
            else {
                const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
                const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
                panStart.set(x, y);
            }
        }
        function handleTouchStartDolly() {
            const dx = pointers[0].pageX - pointers[1].pageX;
            const dy = pointers[0].pageY - pointers[1].pageY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            dollyStart.set(0, distance);
        }
        function handleTouchStartDollyPan() {
            if (scope.enableZoom) handleTouchStartDolly();
            if (scope.enablePan) handleTouchStartPan();
        }
        function handleTouchStartDollyRotate() {
            if (scope.enableZoom) handleTouchStartDolly();
            if (scope.enableRotate) handleTouchStartRotate();
        }
        function handleTouchMoveRotate(event) {
            if (pointers.length == 1) rotateEnd.set(event.pageX, event.pageY);
            else {
                const position = getSecondPointerPosition(event);
                const x = 0.5 * (event.pageX + position.x);
                const y = 0.5 * (event.pageY + position.y);
                rotateEnd.set(x, y);
            }
            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
            const element = scope.domElement;
            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height
            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
            rotateStart.copy(rotateEnd);
        }
        function handleTouchMovePan(event) {
            if (pointers.length === 1) panEnd.set(event.pageX, event.pageY);
            else {
                const position = getSecondPointerPosition(event);
                const x = 0.5 * (event.pageX + position.x);
                const y = 0.5 * (event.pageY + position.y);
                panEnd.set(x, y);
            }
            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
            pan(panDelta.x, panDelta.y);
            panStart.copy(panEnd);
        }
        function handleTouchMoveDolly(event) {
            const position = getSecondPointerPosition(event);
            const dx = event.pageX - position.x;
            const dy = event.pageY - position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            dollyEnd.set(0, distance);
            dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
            dollyOut(dollyDelta.y);
            dollyStart.copy(dollyEnd);
        }
        function handleTouchMoveDollyPan(event) {
            if (scope.enableZoom) handleTouchMoveDolly(event);
            if (scope.enablePan) handleTouchMovePan(event);
        }
        function handleTouchMoveDollyRotate(event) {
            if (scope.enableZoom) handleTouchMoveDolly(event);
            if (scope.enableRotate) handleTouchMoveRotate(event);
        }
        function handleTouchEnd() {
        // no-op
        }
        //
        // event handlers - FSM: listen for events and reset state
        //
        function onPointerDown(event) {
            if (scope.enabled === false) return;
            if (pointers.length === 0) {
                scope.domElement.setPointerCapture(event.pointerId);
                scope.domElement.addEventListener('pointermove', onPointerMove);
                scope.domElement.addEventListener('pointerup', onPointerUp);
            }
            //
            addPointer(event);
            if (event.pointerType === 'touch') onTouchStart(event);
            else onMouseDown(event);
        }
        function onPointerMove(event) {
            if (scope.enabled === false) return;
            if (event.pointerType === 'touch') onTouchMove(event);
            else onMouseMove(event);
        }
        function onPointerUp(event) {
            if (scope.enabled === false) return;
            if (event.pointerType === 'touch') onTouchEnd();
            else onMouseUp(event);
            removePointer(event);
            //
            if (pointers.length === 0) {
                scope.domElement.releasePointerCapture(event.pointerId);
                scope.domElement.removeEventListener('pointermove', onPointerMove);
                scope.domElement.removeEventListener('pointerup', onPointerUp);
            }
        }
        function onPointerCancel(event) {
            removePointer(event);
        }
        function onMouseDown(event) {
            let mouseAction;
            switch(event.button){
                case 0:
                    mouseAction = scope.mouseButtons.LEFT;
                    break;
                case 1:
                    mouseAction = scope.mouseButtons.MIDDLE;
                    break;
                case 2:
                    mouseAction = scope.mouseButtons.RIGHT;
                    break;
                default:
                    mouseAction = -1;
            }
            switch(mouseAction){
                case _three.MOUSE.DOLLY:
                    if (scope.enableZoom === false) return;
                    handleMouseDownDolly(event);
                    state = STATE.DOLLY;
                    break;
                case _three.MOUSE.ROTATE:
                    if (event.ctrlKey || event.metaKey || event.shiftKey) {
                        if (scope.enablePan === false) return;
                        handleMouseDownPan(event);
                        state = STATE.PAN;
                    } else {
                        if (scope.enableRotate === false) return;
                        handleMouseDownRotate(event);
                        state = STATE.ROTATE;
                    }
                    break;
                case _three.MOUSE.PAN:
                    if (event.ctrlKey || event.metaKey || event.shiftKey) {
                        if (scope.enableRotate === false) return;
                        handleMouseDownRotate(event);
                        state = STATE.ROTATE;
                    } else {
                        if (scope.enablePan === false) return;
                        handleMouseDownPan(event);
                        state = STATE.PAN;
                    }
                    break;
                default:
                    state = STATE.NONE;
            }
            if (state !== STATE.NONE) scope.dispatchEvent(_startEvent);
        }
        function onMouseMove(event) {
            if (scope.enabled === false) return;
            switch(state){
                case STATE.ROTATE:
                    if (scope.enableRotate === false) return;
                    handleMouseMoveRotate(event);
                    break;
                case STATE.DOLLY:
                    if (scope.enableZoom === false) return;
                    handleMouseMoveDolly(event);
                    break;
                case STATE.PAN:
                    if (scope.enablePan === false) return;
                    handleMouseMovePan(event);
                    break;
            }
        }
        function onMouseUp(event) {
            handleMouseUp(event);
            scope.dispatchEvent(_endEvent);
            state = STATE.NONE;
        }
        function onMouseWheel(event) {
            if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;
            event.preventDefault();
            scope.dispatchEvent(_startEvent);
            handleMouseWheel(event);
            scope.dispatchEvent(_endEvent);
        }
        function onKeyDown(event) {
            if (scope.enabled === false || scope.enablePan === false) return;
            handleKeyDown(event);
        }
        function onTouchStart(event) {
            trackPointer(event);
            switch(pointers.length){
                case 1:
                    switch(scope.touches.ONE){
                        case _three.TOUCH.ROTATE:
                            if (scope.enableRotate === false) return;
                            handleTouchStartRotate();
                            state = STATE.TOUCH_ROTATE;
                            break;
                        case _three.TOUCH.PAN:
                            if (scope.enablePan === false) return;
                            handleTouchStartPan();
                            state = STATE.TOUCH_PAN;
                            break;
                        default:
                            state = STATE.NONE;
                    }
                    break;
                case 2:
                    switch(scope.touches.TWO){
                        case _three.TOUCH.DOLLY_PAN:
                            if (scope.enableZoom === false && scope.enablePan === false) return;
                            handleTouchStartDollyPan();
                            state = STATE.TOUCH_DOLLY_PAN;
                            break;
                        case _three.TOUCH.DOLLY_ROTATE:
                            if (scope.enableZoom === false && scope.enableRotate === false) return;
                            handleTouchStartDollyRotate();
                            state = STATE.TOUCH_DOLLY_ROTATE;
                            break;
                        default:
                            state = STATE.NONE;
                    }
                    break;
                default:
                    state = STATE.NONE;
            }
            if (state !== STATE.NONE) scope.dispatchEvent(_startEvent);
        }
        function onTouchMove(event) {
            trackPointer(event);
            switch(state){
                case STATE.TOUCH_ROTATE:
                    if (scope.enableRotate === false) return;
                    handleTouchMoveRotate(event);
                    scope.update();
                    break;
                case STATE.TOUCH_PAN:
                    if (scope.enablePan === false) return;
                    handleTouchMovePan(event);
                    scope.update();
                    break;
                case STATE.TOUCH_DOLLY_PAN:
                    if (scope.enableZoom === false && scope.enablePan === false) return;
                    handleTouchMoveDollyPan(event);
                    scope.update();
                    break;
                case STATE.TOUCH_DOLLY_ROTATE:
                    if (scope.enableZoom === false && scope.enableRotate === false) return;
                    handleTouchMoveDollyRotate(event);
                    scope.update();
                    break;
                default:
                    state = STATE.NONE;
            }
        }
        function onTouchEnd(event) {
            handleTouchEnd(event);
            scope.dispatchEvent(_endEvent);
            state = STATE.NONE;
        }
        function onContextMenu(event) {
            if (scope.enabled === false) return;
            event.preventDefault();
        }
        function addPointer(event) {
            pointers.push(event);
        }
        function removePointer(event) {
            delete pointerPositions[event.pointerId];
            for(let i = 0; i < pointers.length; i++)if (pointers[i].pointerId == event.pointerId) {
                pointers.splice(i, 1);
                return;
            }
        }
        function trackPointer(event) {
            let position = pointerPositions[event.pointerId];
            if (position === undefined) {
                position = new _three.Vector2();
                pointerPositions[event.pointerId] = position;
            }
            position.set(event.pageX, event.pageY);
        }
        function getSecondPointerPosition(event) {
            const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
            return pointerPositions[pointer.pointerId];
        }
        //
        scope.domElement.addEventListener('contextmenu', onContextMenu);
        scope.domElement.addEventListener('pointerdown', onPointerDown);
        scope.domElement.addEventListener('pointercancel', onPointerCancel);
        scope.domElement.addEventListener('wheel', onMouseWheel, {
            passive: false
        });
        // force an update at start
        this.update();
    }
}
// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
// This is very similar to OrbitControls, another set of touch behavior
//
//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - left mouse, or arrow keys / touch: one-finger move
class MapControls extends OrbitControls {
    constructor(object, domElement){
        super(object, domElement);
        this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up
        this.mouseButtons.LEFT = _three.MOUSE.PAN;
        this.mouseButtons.RIGHT = _three.MOUSE.ROTATE;
        this.touches.ONE = _three.TOUCH.PAN;
        this.touches.TWO = _three.TOUCH.DOLLY_ROTATE;
    }
}

},{"three":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aru41":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Reflector", ()=>Reflector
);
var _three = require("three");
var _effectComposer = require("three/examples/jsm/postprocessing/EffectComposer");
var _renderPassJs = require("three/examples/jsm/postprocessing/RenderPass.js");
var _bloomPass = require("three/examples/jsm/postprocessing/BloomPass");
class Reflector extends _three.Mesh {
    constructor(geometry, options = {}){
        super(geometry);
        this.type = "Reflector";
        const scope = this;
        const color = options.color !== undefined ? new _three.Color(options.color) : new _three.Color(8355711);
        const textureWidth = options.textureWidth || 512;
        const textureHeight = options.textureHeight || 512;
        const clipBias = options.clipBias || 0;
        const shader = options.shader || Reflector.ReflectorShader;
        //
        const reflectorPlane = new _three.Plane();
        const normal = new _three.Vector3();
        const reflectorWorldPosition = new _three.Vector3();
        const cameraWorldPosition = new _three.Vector3();
        const rotationMatrix = new _three.Matrix4();
        const lookAtPosition = new _three.Vector3(0, 0, -1);
        const clipPlane = new _three.Vector4();
        const view = new _three.Vector3();
        const target = new _three.Vector3();
        const q = new _three.Vector4();
        const textureMatrix = new _three.Matrix4();
        const virtualCamera = new _three.PerspectiveCamera();
        const parameters = {
            minFilter: _three.LinearFilter,
            magFilter: _three.LinearFilter,
            format: _three.RGBFormat
        };
        const renderTarget = new _three.WebGLRenderTarget(textureWidth, textureHeight, parameters);
        renderTarget.texture.name = "reflector-render-target";
        const composer = new _effectComposer.EffectComposer(null, renderTarget);
        composer.swapBuffers(); // Move renderTarget into the read buffer.
        composer.renderToScreen = false;
        const renderPass = new _renderPassJs.RenderPass();
        composer.addPass(renderPass);
        const bloomPass = new _bloomPass.BloomPass(1, 25, 4, 1024);
        // Achieve blur effect by clearing render target instead of superimposing on top of
        // rendered scene.
        bloomPass.clear = true;
        composer.addPass(bloomPass);
        if (!_three.MathUtils.isPowerOfTwo(textureWidth) || !_three.MathUtils.isPowerOfTwo(textureHeight)) renderTarget.texture.generateMipmaps = false;
        const material = new _three.ShaderMaterial({
            uniforms: _three.UniformsUtils.clone(shader.uniforms),
            fragmentShader: shader.fragmentShader,
            vertexShader: shader.vertexShader,
            transparent: options.transparent,
            opacity: options.opacity
        });
        material.uniforms["tDiffuse"].value = renderTarget.texture;
        material.uniforms["color"].value = color;
        material.uniforms["opacity"].value = material.opacity || 1;
        material.uniforms["textureMatrix"].value = textureMatrix;
        material.uniforms["textureWidth"].value = textureWidth;
        material.uniforms["textureHeight"].value = textureHeight;
        this.material = material;
        this.onBeforeRender = function(renderer, scene, camera) {
            reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
            cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
            rotationMatrix.extractRotation(scope.matrixWorld);
            normal.set(0, 0, 1);
            normal.applyMatrix4(rotationMatrix);
            view.subVectors(reflectorWorldPosition, cameraWorldPosition);
            // Avoid rendering when reflector is facing away
            if (view.dot(normal) > 0) return;
            view.reflect(normal).negate();
            view.add(reflectorWorldPosition);
            rotationMatrix.extractRotation(camera.matrixWorld);
            lookAtPosition.set(0, 0, -1);
            lookAtPosition.applyMatrix4(rotationMatrix);
            lookAtPosition.add(cameraWorldPosition);
            target.subVectors(reflectorWorldPosition, lookAtPosition);
            target.reflect(normal).negate();
            target.add(reflectorWorldPosition);
            virtualCamera.position.copy(view);
            virtualCamera.up.set(0, 1, 0);
            virtualCamera.up.applyMatrix4(rotationMatrix);
            virtualCamera.up.reflect(normal);
            virtualCamera.lookAt(target);
            virtualCamera.far = camera.far; // Used in WebGLBackground
            virtualCamera.updateMatrixWorld();
            virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
            // Update the texture matrix
            textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
            textureMatrix.multiply(virtualCamera.projectionMatrix);
            textureMatrix.multiply(virtualCamera.matrixWorldInverse);
            textureMatrix.multiply(scope.matrixWorld);
            // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
            // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
            reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);
            reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
            clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
            const projectionMatrix = virtualCamera.projectionMatrix;
            q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
            q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
            q.z = -1;
            q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
            // Calculate the scaled plane vector
            clipPlane.multiplyScalar(2 / clipPlane.dot(q));
            // Replacing the third row of the projection matrix
            projectionMatrix.elements[2] = clipPlane.x;
            projectionMatrix.elements[6] = clipPlane.y;
            projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;
            projectionMatrix.elements[14] = clipPlane.w;
            // Render
            renderTarget.texture.encoding = renderer.outputEncoding;
            scope.visible = false;
            const currentRenderTarget = renderer.getRenderTarget();
            const currentXrEnabled = renderer.xr.enabled;
            const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
            renderer.xr.enabled = false; // Avoid camera modification
            renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows
            renderer.setRenderTarget(renderTarget);
            renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897
            if (renderer.autoClear === false) renderer.clear();
            renderPass.needsSwap = false;
            renderPass.camera = virtualCamera;
            renderPass.scene = scene;
            composer.renderer = renderer;
            composer.render();
            renderer.xr.enabled = currentXrEnabled;
            renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
            renderer.setRenderTarget(currentRenderTarget);
            // Restore viewport
            const viewport = camera.viewport;
            if (viewport !== undefined) renderer.state.viewport(viewport);
            scope.visible = true;
        };
        this.getRenderTarget = function() {
            return renderTarget;
        };
    }
}
Reflector.prototype.isReflector = true;
Reflector.ReflectorShader = {
    uniforms: {
        color: {
            value: null
        },
        tDiffuse: {
            value: null
        },
        textureMatrix: {
            value: null
        },
        textureWidth: {
            value: null
        },
        textureHeight: {
            value: null
        },
        opacity: {
            value: null
        }
    },
    vertexShader: /* glsl */ `
		uniform mat4 textureMatrix;
		varying vec4 vUv;
		varying vec2 originalUv;
		#include <common>
		#include <logdepthbuf_pars_vertex>
		void main() {
			originalUv = uv;
			vUv = textureMatrix * vec4( position, 1.0 );
			vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * mvPosition;
			#include <logdepthbuf_vertex>
		}`,
    fragmentShader: /* glsl */ `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		uniform float textureWidth;
		uniform float textureHeight;
		uniform float opacity;
		varying vec4 vUv;
		varying vec2 originalUv;
		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {
			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );
		}
		vec3 blendOverlay( vec3 base, vec3 blend ) {
			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );
		}
		void main() {
			#include <logdepthbuf_fragment>
			vec2 vUv2d = (vUv.xy / vUv.q);

			vec4 base = texture2D(tDiffuse, vUv2d);
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), opacity );
		}`
};

},{"three":"ktPTu","three/examples/jsm/postprocessing/EffectComposer":"e5jie","three/examples/jsm/postprocessing/RenderPass.js":"hXnUO","three/examples/jsm/postprocessing/BloomPass":"jGhGM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e5jie":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectComposer", ()=>EffectComposer
);
parcelHelpers.export(exports, "Pass", ()=>Pass
);
parcelHelpers.export(exports, "FullScreenQuad", ()=>FullScreenQuad
);
var _three = require("three");
var _copyShaderJs = require("../shaders/CopyShader.js");
var _shaderPassJs = require("../postprocessing/ShaderPass.js");
var _maskPassJs = require("../postprocessing/MaskPass.js");
class EffectComposer {
    constructor(renderer, renderTarget){
        this.renderer = renderer;
        if (renderTarget === undefined) {
            const parameters = {
                minFilter: _three.LinearFilter,
                magFilter: _three.LinearFilter,
                format: _three.RGBAFormat
            };
            const size = renderer.getSize(new _three.Vector2());
            this._pixelRatio = renderer.getPixelRatio();
            this._width = size.width;
            this._height = size.height;
            renderTarget = new _three.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);
            renderTarget.texture.name = 'EffectComposer.rt1';
        } else {
            this._pixelRatio = 1;
            this._width = renderTarget.width;
            this._height = renderTarget.height;
        }
        this.renderTarget1 = renderTarget;
        this.renderTarget2 = renderTarget.clone();
        this.renderTarget2.texture.name = 'EffectComposer.rt2';
        this.writeBuffer = this.renderTarget1;
        this.readBuffer = this.renderTarget2;
        this.renderToScreen = true;
        this.passes = [];
        // dependencies
        if (_copyShaderJs.CopyShader === undefined) console.error('THREE.EffectComposer relies on CopyShader');
        if (_shaderPassJs.ShaderPass === undefined) console.error('THREE.EffectComposer relies on ShaderPass');
        this.copyPass = new _shaderPassJs.ShaderPass(_copyShaderJs.CopyShader);
        this.clock = new _three.Clock();
    }
    swapBuffers() {
        const tmp = this.readBuffer;
        this.readBuffer = this.writeBuffer;
        this.writeBuffer = tmp;
    }
    addPass(pass) {
        this.passes.push(pass);
        pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    insertPass(pass, index) {
        this.passes.splice(index, 0, pass);
        pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    removePass(pass) {
        const index = this.passes.indexOf(pass);
        if (index !== -1) this.passes.splice(index, 1);
    }
    isLastEnabledPass(passIndex) {
        for(let i = passIndex + 1; i < this.passes.length; i++){
            if (this.passes[i].enabled) return false;
        }
        return true;
    }
    render(deltaTime) {
        // deltaTime value is in seconds
        if (deltaTime === undefined) deltaTime = this.clock.getDelta();
        const currentRenderTarget = this.renderer.getRenderTarget();
        let maskActive = false;
        for(let i = 0, il = this.passes.length; i < il; i++){
            const pass = this.passes[i];
            if (pass.enabled === false) continue;
            pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
            pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
            if (pass.needsSwap) {
                if (maskActive) {
                    const context = this.renderer.getContext();
                    const stencil = this.renderer.state.buffers.stencil;
                    //context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
                    stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
                    this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
                    //context.stencilFunc( context.EQUAL, 1, 0xffffffff );
                    stencil.setFunc(context.EQUAL, 1, 4294967295);
                }
                this.swapBuffers();
            }
            if (_maskPassJs.MaskPass !== undefined) {
                if (pass instanceof _maskPassJs.MaskPass) maskActive = true;
                else if (pass instanceof _maskPassJs.ClearMaskPass) maskActive = false;
            }
        }
        this.renderer.setRenderTarget(currentRenderTarget);
    }
    reset(renderTarget) {
        if (renderTarget === undefined) {
            const size = this.renderer.getSize(new _three.Vector2());
            this._pixelRatio = this.renderer.getPixelRatio();
            this._width = size.width;
            this._height = size.height;
            renderTarget = this.renderTarget1.clone();
            renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
        }
        this.renderTarget1.dispose();
        this.renderTarget2.dispose();
        this.renderTarget1 = renderTarget;
        this.renderTarget2 = renderTarget.clone();
        this.writeBuffer = this.renderTarget1;
        this.readBuffer = this.renderTarget2;
    }
    setSize(width, height) {
        this._width = width;
        this._height = height;
        const effectiveWidth = this._width * this._pixelRatio;
        const effectiveHeight = this._height * this._pixelRatio;
        this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
        this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
        for(let i = 0; i < this.passes.length; i++)this.passes[i].setSize(effectiveWidth, effectiveHeight);
    }
    setPixelRatio(pixelRatio) {
        this._pixelRatio = pixelRatio;
        this.setSize(this._width, this._height);
    }
}
class Pass {
    constructor(){
        // if set to true, the pass is processed by the composer
        this.enabled = true;
        // if set to true, the pass indicates to swap read and write buffer after rendering
        this.needsSwap = true;
        // if set to true, the pass clears its buffer before rendering
        this.clear = false;
        // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
        this.renderToScreen = false;
    }
    setSize() {}
    render() {
        console.error('THREE.Pass: .render() must be implemented in derived pass.');
    }
}
// Helper for passes that need to fill the viewport with a single quad.
const _camera = new _three.OrthographicCamera(-1, 1, 1, -1, 0, 1);
// https://github.com/mrdoob/three.js/pull/21358
const _geometry = new _three.BufferGeometry();
_geometry.setAttribute('position', new _three.Float32BufferAttribute([
    -1,
    3,
    0,
    -1,
    -1,
    0,
    3,
    -1,
    0
], 3));
_geometry.setAttribute('uv', new _three.Float32BufferAttribute([
    0,
    2,
    0,
    0,
    2,
    0
], 2));
class FullScreenQuad {
    constructor(material){
        this._mesh = new _three.Mesh(_geometry, material);
    }
    dispose() {
        this._mesh.geometry.dispose();
    }
    render(renderer) {
        renderer.render(this._mesh, _camera);
    }
    get material() {
        return this._mesh.material;
    }
    set material(value) {
        this._mesh.material = value;
    }
}

},{"three":"ktPTu","../shaders/CopyShader.js":"d0PyX","../postprocessing/ShaderPass.js":"5IxTN","../postprocessing/MaskPass.js":"jn76N","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d0PyX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CopyShader", ()=>CopyShader
);
/**
 * Full-screen textured quad shader
 */ var CopyShader = {
    uniforms: {
        'tDiffuse': {
            value: null
        },
        'opacity': {
            value: 1
        }
    },
    vertexShader: /* glsl */ `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: /* glsl */ `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}`
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5IxTN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ShaderPass", ()=>ShaderPass
);
var _three = require("three");
var _passJs = require("../postprocessing/Pass.js");
class ShaderPass extends _passJs.Pass {
    constructor(shader, textureID){
        super();
        this.textureID = textureID !== undefined ? textureID : 'tDiffuse';
        if (shader instanceof _three.ShaderMaterial) {
            this.uniforms = shader.uniforms;
            this.material = shader;
        } else if (shader) {
            this.uniforms = _three.UniformsUtils.clone(shader.uniforms);
            this.material = new _three.ShaderMaterial({
                defines: Object.assign({}, shader.defines),
                uniforms: this.uniforms,
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader
            });
        }
        this.fsQuad = new _passJs.FullScreenQuad(this.material);
    }
    render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {
        if (this.uniforms[this.textureID]) this.uniforms[this.textureID].value = readBuffer.texture;
        this.fsQuad.material = this.material;
        if (this.renderToScreen) {
            renderer.setRenderTarget(null);
            this.fsQuad.render(renderer);
        } else {
            renderer.setRenderTarget(writeBuffer);
            // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
            if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
            this.fsQuad.render(renderer);
        }
    }
}

},{"three":"ktPTu","../postprocessing/Pass.js":"i2IfB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i2IfB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Pass", ()=>Pass
);
parcelHelpers.export(exports, "FullScreenQuad", ()=>FullScreenQuad
);
var _three = require("three");
class Pass {
    constructor(){
        // if set to true, the pass is processed by the composer
        this.enabled = true;
        // if set to true, the pass indicates to swap read and write buffer after rendering
        this.needsSwap = true;
        // if set to true, the pass clears its buffer before rendering
        this.clear = false;
        // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
        this.renderToScreen = false;
    }
    setSize() {}
    render() {
        console.error('THREE.Pass: .render() must be implemented in derived pass.');
    }
}
// Helper for passes that need to fill the viewport with a single quad.
const _camera = new _three.OrthographicCamera(-1, 1, 1, -1, 0, 1);
// https://github.com/mrdoob/three.js/pull/21358
const _geometry = new _three.BufferGeometry();
_geometry.setAttribute('position', new _three.Float32BufferAttribute([
    -1,
    3,
    0,
    -1,
    -1,
    0,
    3,
    -1,
    0
], 3));
_geometry.setAttribute('uv', new _three.Float32BufferAttribute([
    0,
    2,
    0,
    0,
    2,
    0
], 2));
class FullScreenQuad {
    constructor(material){
        this._mesh = new _three.Mesh(_geometry, material);
    }
    dispose() {
        this._mesh.geometry.dispose();
    }
    render(renderer) {
        renderer.render(this._mesh, _camera);
    }
    get material() {
        return this._mesh.material;
    }
    set material(value) {
        this._mesh.material = value;
    }
}

},{"three":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jn76N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MaskPass", ()=>MaskPass
);
parcelHelpers.export(exports, "ClearMaskPass", ()=>ClearMaskPass
);
var _passJs = require("../postprocessing/Pass.js");
class MaskPass extends _passJs.Pass {
    constructor(scene, camera){
        super();
        this.scene = scene;
        this.camera = camera;
        this.clear = true;
        this.needsSwap = false;
        this.inverse = false;
    }
    render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {
        const context = renderer.getContext();
        const state = renderer.state;
        // don't update color or depth
        state.buffers.color.setMask(false);
        state.buffers.depth.setMask(false);
        // lock buffers
        state.buffers.color.setLocked(true);
        state.buffers.depth.setLocked(true);
        // set up stencil
        let writeValue, clearValue;
        if (this.inverse) {
            writeValue = 0;
            clearValue = 1;
        } else {
            writeValue = 1;
            clearValue = 0;
        }
        state.buffers.stencil.setTest(true);
        state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
        state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
        state.buffers.stencil.setClear(clearValue);
        state.buffers.stencil.setLocked(true);
        // draw into the stencil buffer
        renderer.setRenderTarget(readBuffer);
        if (this.clear) renderer.clear();
        renderer.render(this.scene, this.camera);
        renderer.setRenderTarget(writeBuffer);
        if (this.clear) renderer.clear();
        renderer.render(this.scene, this.camera);
        // unlock color and depth buffer for subsequent rendering
        state.buffers.color.setLocked(false);
        state.buffers.depth.setLocked(false);
        // only render where stencil is set to 1
        state.buffers.stencil.setLocked(false);
        state.buffers.stencil.setFunc(context.EQUAL, 1, 4294967295); // draw if == 1
        state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
        state.buffers.stencil.setLocked(true);
    }
}
class ClearMaskPass extends _passJs.Pass {
    constructor(){
        super();
        this.needsSwap = false;
    }
    render(renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {
        renderer.state.buffers.stencil.setLocked(false);
        renderer.state.buffers.stencil.setTest(false);
    }
}

},{"../postprocessing/Pass.js":"i2IfB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hXnUO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RenderPass", ()=>RenderPass
);
var _three = require("three");
var _passJs = require("../postprocessing/Pass.js");
class RenderPass extends _passJs.Pass {
    constructor(scene, camera, overrideMaterial, clearColor, clearAlpha){
        super();
        this.scene = scene;
        this.camera = camera;
        this.overrideMaterial = overrideMaterial;
        this.clearColor = clearColor;
        this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
        this.clear = true;
        this.clearDepth = false;
        this.needsSwap = false;
        this._oldClearColor = new _three.Color();
    }
    render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {
        const oldAutoClear = renderer.autoClear;
        renderer.autoClear = false;
        let oldClearAlpha, oldOverrideMaterial;
        if (this.overrideMaterial !== undefined) {
            oldOverrideMaterial = this.scene.overrideMaterial;
            this.scene.overrideMaterial = this.overrideMaterial;
        }
        if (this.clearColor) {
            renderer.getClearColor(this._oldClearColor);
            oldClearAlpha = renderer.getClearAlpha();
            renderer.setClearColor(this.clearColor, this.clearAlpha);
        }
        if (this.clearDepth) renderer.clearDepth();
        renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
        // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
        if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        renderer.render(this.scene, this.camera);
        if (this.clearColor) renderer.setClearColor(this._oldClearColor, oldClearAlpha);
        if (this.overrideMaterial !== undefined) this.scene.overrideMaterial = oldOverrideMaterial;
        renderer.autoClear = oldAutoClear;
    }
}

},{"three":"ktPTu","../postprocessing/Pass.js":"i2IfB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jGhGM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BloomPass", ()=>BloomPass
);
var _three = require("three");
var _passJs = require("../postprocessing/Pass.js");
var _copyShaderJs = require("../shaders/CopyShader.js");
var _convolutionShaderJs = require("../shaders/ConvolutionShader.js");
class BloomPass extends _passJs.Pass {
    constructor(strength = 1, kernelSize = 25, sigma = 4, resolution = 256){
        super();
        // render targets
        const pars = {
            minFilter: _three.LinearFilter,
            magFilter: _three.LinearFilter,
            format: _three.RGBAFormat
        };
        this.renderTargetX = new _three.WebGLRenderTarget(resolution, resolution, pars);
        this.renderTargetX.texture.name = 'BloomPass.x';
        this.renderTargetY = new _three.WebGLRenderTarget(resolution, resolution, pars);
        this.renderTargetY.texture.name = 'BloomPass.y';
        // copy material
        if (_copyShaderJs.CopyShader === undefined) console.error('THREE.BloomPass relies on CopyShader');
        const copyShader = _copyShaderJs.CopyShader;
        this.copyUniforms = _three.UniformsUtils.clone(copyShader.uniforms);
        this.copyUniforms['opacity'].value = strength;
        this.materialCopy = new _three.ShaderMaterial({
            uniforms: this.copyUniforms,
            vertexShader: copyShader.vertexShader,
            fragmentShader: copyShader.fragmentShader,
            blending: _three.AdditiveBlending,
            transparent: true
        });
        // convolution material
        if (_convolutionShaderJs.ConvolutionShader === undefined) console.error('THREE.BloomPass relies on ConvolutionShader');
        const convolutionShader = _convolutionShaderJs.ConvolutionShader;
        this.convolutionUniforms = _three.UniformsUtils.clone(convolutionShader.uniforms);
        this.convolutionUniforms['uImageIncrement'].value = BloomPass.blurX;
        this.convolutionUniforms['cKernel'].value = _convolutionShaderJs.ConvolutionShader.buildKernel(sigma);
        this.materialConvolution = new _three.ShaderMaterial({
            uniforms: this.convolutionUniforms,
            vertexShader: convolutionShader.vertexShader,
            fragmentShader: convolutionShader.fragmentShader,
            defines: {
                'KERNEL_SIZE_FLOAT': kernelSize.toFixed(1),
                'KERNEL_SIZE_INT': kernelSize.toFixed(0)
            }
        });
        this.needsSwap = false;
        this.fsQuad = new _passJs.FullScreenQuad(null);
    }
    render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
        if (maskActive) renderer.state.buffers.stencil.setTest(false);
        // Render quad with blured scene into texture (convolution pass 1)
        this.fsQuad.material = this.materialConvolution;
        this.convolutionUniforms['tDiffuse'].value = readBuffer.texture;
        this.convolutionUniforms['uImageIncrement'].value = BloomPass.blurX;
        renderer.setRenderTarget(this.renderTargetX);
        renderer.clear();
        this.fsQuad.render(renderer);
        // Render quad with blured scene into texture (convolution pass 2)
        this.convolutionUniforms['tDiffuse'].value = this.renderTargetX.texture;
        this.convolutionUniforms['uImageIncrement'].value = BloomPass.blurY;
        renderer.setRenderTarget(this.renderTargetY);
        renderer.clear();
        this.fsQuad.render(renderer);
        // Render original scene with superimposed blur to texture
        this.fsQuad.material = this.materialCopy;
        this.copyUniforms['tDiffuse'].value = this.renderTargetY.texture;
        if (maskActive) renderer.state.buffers.stencil.setTest(true);
        renderer.setRenderTarget(readBuffer);
        if (this.clear) renderer.clear();
        this.fsQuad.render(renderer);
    }
}
BloomPass.blurX = new _three.Vector2(0.001953125, 0);
BloomPass.blurY = new _three.Vector2(0, 0.001953125);

},{"three":"ktPTu","../postprocessing/Pass.js":"i2IfB","../shaders/CopyShader.js":"d0PyX","../shaders/ConvolutionShader.js":"6A8hi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6A8hi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConvolutionShader", ()=>ConvolutionShader
);
var _three = require("three");
/**
 * Convolution shader
 * ported from o3d sample to WebGL / GLSL
 * http://o3d.googlecode.com/svn/trunk/samples/convolution.html
 */ const ConvolutionShader = {
    defines: {
        'KERNEL_SIZE_FLOAT': '25.0',
        'KERNEL_SIZE_INT': '25'
    },
    uniforms: {
        'tDiffuse': {
            value: null
        },
        'uImageIncrement': {
            value: new _three.Vector2(0.001953125, 0)
        },
        'cKernel': {
            value: []
        }
    },
    vertexShader: /* glsl */ `

		uniform vec2 uImageIncrement;

		varying vec2 vUv;

		void main() {

			vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: /* glsl */ `

		uniform float cKernel[ KERNEL_SIZE_INT ];

		uniform sampler2D tDiffuse;
		uniform vec2 uImageIncrement;

		varying vec2 vUv;

		void main() {

			vec2 imageCoord = vUv;
			vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );

			for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {

				sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];
				imageCoord += uImageIncrement;

			}

			gl_FragColor = sum;

		}`,
    buildKernel: function(sigma) {
        // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.
        const kMaxKernelSize = 25;
        let kernelSize = 2 * Math.ceil(sigma * 3) + 1;
        if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;
        const halfWidth = (kernelSize - 1) * 0.5;
        const values = new Array(kernelSize);
        let sum = 0;
        for(let i = 0; i < kernelSize; ++i){
            values[i] = gauss(i - halfWidth, sigma);
            sum += values[i];
        }
        // normalize the kernel
        for(let i1 = 0; i1 < kernelSize; ++i1)values[i1] /= sum;
        return values;
    }
};
function gauss(x, sigma) {
    return Math.exp(-(x * x) / (2 * sigma * sigma));
}

},{"three":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kWNzB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RectAreaLightUniformsLib", ()=>RectAreaLightUniformsLib
);
var _three = require("three");
/**
 * Uniforms library for RectAreaLight shared webgl shaders
 *
 * NOTE: This is a temporary location for the BRDF approximation texture data
 *       based off of Eric Heitz's work (see citation below).  BRDF data for
 *       RectAreaLight is currently approximated using a precomputed texture
 *       of roughly 80kb in size.  The hope is to find a better way to include
 *       the large texture data before including the full RectAreaLight implementation
 *       in the main build files.
 *
 * TODO: figure out a way to compress the LTC BRDF data
 */ // Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/
class RectAreaLightUniformsLib {
    static init() {
        // source: https://github.com/selfshadow/ltc_code/tree/master/fit/results/ltc.js
        const LTC_MAT_1 = [
            1,
            0,
            0,
            0.00002,
            1,
            0,
            0,
            0.000503905,
            1,
            0,
            0,
            0.00201562,
            1,
            0,
            0,
            0.00453516,
            1,
            0,
            0,
            0.00806253,
            1,
            0,
            0,
            0.0125978,
            1,
            0,
            0,
            0.018141,
            1,
            0,
            0,
            0.0246924,
            1,
            0,
            0,
            0.0322525,
            1,
            0,
            0,
            0.0408213,
            1,
            0,
            0,
            0.0503999,
            1,
            0,
            0,
            0.0609894,
            1,
            0,
            0,
            0.0725906,
            1,
            0,
            0,
            0.0852058,
            1,
            0,
            0,
            0.0988363,
            1,
            0,
            0,
            0.113484,
            1,
            0,
            0,
            0.129153,
            1,
            0,
            0,
            0.145839,
            1,
            0,
            0,
            0.163548,
            1,
            0,
            0,
            0.182266,
            1,
            0,
            0,
            0.201942,
            1,
            0,
            0,
            0.222314,
            1,
            0,
            0,
            0.241906,
            1,
            0,
            0,
            0.262314,
            1,
            0,
            0,
            0.285754,
            1,
            0,
            0,
            0.310159,
            1,
            0,
            0,
            0.335426,
            1,
            0,
            0,
            0.361341,
            1,
            0,
            0,
            0.387445,
            1,
            0,
            0,
            0.412784,
            1,
            0,
            0,
            0.438197,
            1,
            0,
            0,
            0.466966,
            1,
            0,
            0,
            0.49559,
            1,
            0,
            0,
            0.523448,
            1,
            0,
            0,
            0.549938,
            1,
            0,
            0,
            0.57979,
            1,
            0,
            0,
            0.608746,
            1,
            0,
            0,
            0.636185,
            1,
            0,
            0,
            0.664748,
            1,
            0,
            0,
            0.69313,
            1,
            0,
            0,
            0.71966,
            1,
            0,
            0,
            0.747662,
            1,
            0,
            0,
            0.774023,
            1,
            0,
            0,
            0.799775,
            1,
            0,
            0,
            0.825274,
            1,
            0,
            0,
            0.849156,
            1,
            0,
            0,
            0.873248,
            1,
            0,
            0,
            0.89532,
            1,
            0,
            0,
            0.917565,
            1,
            0,
            0,
            0.937863,
            1,
            0,
            0,
            0.958139,
            1,
            0,
            0,
            0.976563,
            1,
            0,
            0,
            0.994658,
            1,
            0,
            0,
            1.0112,
            1,
            0,
            0,
            1.02712,
            1,
            0,
            0,
            1.04189,
            1,
            0,
            0,
            1.05568,
            1,
            0,
            0,
            1.06877,
            1,
            0,
            0,
            1.08058,
            1,
            0,
            0,
            1.09194,
            1,
            0,
            0,
            1.10191,
            1,
            0,
            0,
            1.11161,
            1,
            0,
            0,
            1.1199,
            1,
            0,
            0,
            1.12813,
            0.999547,
            -0.000000448815,
            0.0224417,
            0.0000199902,
            0.999495,
            -0.0000113079,
            0.0224406,
            0.000503651,
            0.999496,
            -0.0000452317,
            0.0224406,
            0.00201461,
            0.999496,
            -0.000101772,
            0.0224406,
            0.00453287,
            0.999495,
            -0.000180928,
            0.0224406,
            0.00805845,
            0.999497,
            -0.000282702,
            0.0224406,
            0.0125914,
            0.999496,
            -0.000407096,
            0.0224406,
            0.0181319,
            0.999498,
            -0.000554114,
            0.0224406,
            0.02468,
            0.999499,
            -0.000723768,
            0.0224406,
            0.0322363,
            0.999495,
            -0.000916058,
            0.0224405,
            0.0408009,
            0.999499,
            -0.00113101,
            0.0224408,
            0.050375,
            0.999494,
            -0.00136863,
            0.0224405,
            0.0609586,
            0.999489,
            -0.00162896,
            0.0224401,
            0.0725537,
            0.999489,
            -0.00191201,
            0.0224414,
            0.0851619,
            0.999498,
            -0.00221787,
            0.0224413,
            0.0987867,
            0.999492,
            -0.00254642,
            0.0224409,
            0.113426,
            0.999507,
            -0.00289779,
            0.0224417,
            0.129088,
            0.999494,
            -0.0032716,
            0.0224386,
            0.145767,
            0.999546,
            -0.0036673,
            0.0224424,
            0.163472,
            0.999543,
            -0.00408166,
            0.0224387,
            0.182182,
            0.999499,
            -0.00450056,
            0.0224338,
            0.201843,
            0.999503,
            -0.00483661,
            0.0224203,
            0.222198,
            0.999546,
            -0.00452928,
            0.022315,
            0.241714,
            0.999508,
            -0.00587403,
            0.0224329,
            0.262184,
            0.999509,
            -0.00638806,
            0.0224271,
            0.285609,
            0.999501,
            -0.00691028,
            0.0224166,
            0.309998,
            0.999539,
            -0.00741979,
            0.0223989,
            0.335262,
            0.999454,
            -0.00786282,
            0.0223675,
            0.361154,
            0.999529,
            -0.00811928,
            0.0222828,
            0.387224,
            0.999503,
            -0.00799941,
            0.0221063,
            0.41252,
            0.999561,
            -0.00952753,
            0.0223057,
            0.438006,
            0.999557,
            -0.0099134,
            0.0222065,
            0.466735,
            0.999541,
            -0.0100935,
            0.0220402,
            0.495332,
            0.999562,
            -0.00996821,
            0.0218067,
            0.523197,
            0.999556,
            -0.0105031,
            0.0217096,
            0.550223,
            0.999561,
            -0.0114191,
            0.0217215,
            0.579498,
            0.999588,
            -0.0111818,
            0.0213357,
            0.608416,
            0.999633,
            -0.0107725,
            0.0208689,
            0.635965,
            0.999527,
            -0.0121671,
            0.0210149,
            0.664476,
            0.999508,
            -0.0116005,
            0.020431,
            0.692786,
            0.999568,
            -0.0115604,
            0.0199791,
            0.719709,
            0.999671,
            -0.0121117,
            0.0197415,
            0.74737,
            0.999688,
            -0.0110769,
            0.0188846,
            0.773692,
            0.99962,
            -0.0122368,
            0.0188452,
            0.799534,
            0.999823,
            -0.0110325,
            0.0178001,
            0.825046,
            0.999599,
            -0.0114923,
            0.0174221,
            0.849075,
            0.999619,
            -0.0105923,
            0.0164345,
            0.872999,
            0.999613,
            -0.0105988,
            0.0158227,
            0.895371,
            0.99964,
            -0.00979861,
            0.0148131,
            0.917364,
            0.99977,
            -0.00967238,
            0.0140721,
            0.938002,
            0.999726,
            -0.00869175,
            0.0129543,
            0.957917,
            0.99973,
            -0.00866872,
            0.0122329,
            0.976557,
            0.999773,
            -0.00731956,
            0.0108958,
            0.994459,
            0.999811,
            -0.00756027,
            0.0102715,
            1.01118,
            0.999862,
            -0.00583732,
            0.00878781,
            1.02701,
            0.999835,
            -0.00631438,
            0.00827529,
            1.04186,
            0.999871,
            -0.00450785,
            0.00674583,
            1.05569,
            0.999867,
            -0.00486079,
            0.00621041,
            1.06861,
            0.999939,
            -0.00322072,
            0.00478301,
            1.08064,
            0.999918,
            -0.00318199,
            0.00406395,
            1.09181,
            1.00003,
            -0.00193348,
            0.00280682,
            1.10207,
            0.999928,
            -0.00153729,
            0.00198741,
            1.11152,
            0.999933,
            -0.000623666,
            0.000917714,
            1.12009,
            1,
            -0.00000102387,
            0.000000907581,
            1.12813,
            0.997866,
            -0.000000896716,
            0.0448334,
            0.0000199584,
            0.997987,
            -0.0000225945,
            0.0448389,
            0.000502891,
            0.997987,
            -0.0000903781,
            0.0448388,
            0.00201156,
            0.997985,
            -0.000203351,
            0.0448388,
            0.00452602,
            0.997986,
            -0.000361514,
            0.0448388,
            0.00804629,
            0.997987,
            -0.00056487,
            0.0448389,
            0.0125724,
            0.997988,
            -0.000813423,
            0.0448389,
            0.0181045,
            0.997984,
            -0.00110718,
            0.0448387,
            0.0246427,
            0.997985,
            -0.00144616,
            0.0448388,
            0.0321875,
            0.997987,
            -0.00183038,
            0.044839,
            0.0407392,
            0.997983,
            -0.00225987,
            0.0448387,
            0.0502986,
            0.997991,
            -0.00273467,
            0.0448389,
            0.0608667,
            0.997984,
            -0.00325481,
            0.0448384,
            0.0724444,
            0.998002,
            -0.00382043,
            0.044839,
            0.0850348,
            0.997997,
            -0.00443145,
            0.0448396,
            0.0986372,
            0.998007,
            -0.00508796,
            0.0448397,
            0.113255,
            0.998008,
            -0.00578985,
            0.04484,
            0.128891,
            0.998003,
            -0.00653683,
            0.0448384,
            0.145548,
            0.997983,
            -0.00732713,
            0.0448358,
            0.163221,
            0.997985,
            -0.00815454,
            0.0448358,
            0.181899,
            0.998005,
            -0.00898985,
            0.0448286,
            0.201533,
            0.998026,
            -0.00964404,
            0.0447934,
            0.221821,
            0.998055,
            -0.00922677,
            0.044611,
            0.241282,
            0.99804,
            -0.0117361,
            0.0448245,
            0.261791,
            0.998048,
            -0.0127628,
            0.0448159,
            0.285181,
            0.998088,
            -0.0138055,
            0.0447996,
            0.30954,
            0.998058,
            -0.0148206,
            0.0447669,
            0.334751,
            0.998099,
            -0.0156998,
            0.044697,
            0.36061,
            0.998116,
            -0.0161976,
            0.0445122,
            0.386603,
            0.998195,
            -0.015945,
            0.0441711,
            0.411844,
            0.998168,
            -0.0183947,
            0.0444255,
            0.43773,
            0.998184,
            -0.0197913,
            0.0443809,
            0.466009,
            0.998251,
            -0.0201426,
            0.0440689,
            0.494574,
            0.998305,
            -0.0198847,
            0.0435632,
            0.522405,
            0.998273,
            -0.0210577,
            0.043414,
            0.549967,
            0.998254,
            -0.0227901,
            0.0433943,
            0.578655,
            0.998349,
            -0.0223108,
            0.0426529,
            0.60758,
            0.99843,
            -0.0223088,
            0.042,
            0.635524,
            0.998373,
            -0.0241141,
            0.0418987,
            0.663621,
            0.998425,
            -0.0231446,
            0.0408118,
            0.691906,
            0.998504,
            -0.0233684,
            0.0400565,
            0.719339,
            0.998443,
            -0.0241652,
            0.0394634,
            0.74643,
            0.99848,
            -0.0228715,
            0.0380002,
            0.773086,
            0.998569,
            -0.023519,
            0.0372322,
            0.798988,
            0.998619,
            -0.0223108,
            0.0356468,
            0.824249,
            0.998594,
            -0.0223105,
            0.034523,
            0.848808,
            0.998622,
            -0.0213426,
            0.0328887,
            0.87227,
            0.998669,
            -0.0207912,
            0.0314374,
            0.895157,
            0.998705,
            -0.0198416,
            0.0296925,
            0.916769,
            0.998786,
            -0.0189168,
            0.0279634,
            0.937773,
            0.998888,
            -0.0178811,
            0.0261597,
            0.957431,
            0.99906,
            -0.0166845,
            0.0242159,
            0.976495,
            0.999038,
            -0.0155464,
            0.0222638,
            0.994169,
            0.999237,
            -0.0141349,
            0.0201967,
            1.01112,
            0.999378,
            -0.0129324,
            0.0181744,
            1.02692,
            0.999433,
            -0.0113192,
            0.0159898,
            1.04174,
            0.999439,
            -0.0101244,
            0.0140385,
            1.05559,
            0.999614,
            -0.00837456,
            0.0117826,
            1.06852,
            0.999722,
            -0.00721769,
            0.00983745,
            1.08069,
            0.999817,
            -0.00554067,
            0.00769002,
            1.09176,
            0.99983,
            -0.00426961,
            0.005782,
            1.10211,
            0.999964,
            -0.00273904,
            0.00374503,
            1.11152,
            1.00001,
            -0.00136739,
            0.00187176,
            1.12031,
            0.999946,
            0.0000393227,
            -0.000028919,
            1.12804,
            0.995847,
            -0.0000013435,
            0.0671785,
            0.000019916,
            0.995464,
            -0.0000338387,
            0.0671527,
            0.000501622,
            0.99547,
            -0.000135355,
            0.0671531,
            0.00200649,
            0.995471,
            -0.00030455,
            0.0671532,
            0.00451461,
            0.99547,
            -0.000541423,
            0.0671531,
            0.008026,
            0.995471,
            -0.00084598,
            0.0671531,
            0.0125407,
            0.99547,
            -0.00121823,
            0.0671531,
            0.0180589,
            0.99547,
            -0.00165817,
            0.0671531,
            0.0245806,
            0.995463,
            -0.00216583,
            0.0671526,
            0.0321062,
            0.995468,
            -0.00274127,
            0.0671527,
            0.0406366,
            0.995474,
            -0.00338447,
            0.0671534,
            0.0501717,
            0.995473,
            -0.00409554,
            0.0671533,
            0.0607131,
            0.995478,
            -0.00487451,
            0.0671531,
            0.0722618,
            0.995476,
            -0.00572148,
            0.0671532,
            0.0848191,
            0.995477,
            -0.00663658,
            0.0671539,
            0.0983882,
            0.995498,
            -0.00761986,
            0.0671541,
            0.112972,
            0.995509,
            -0.00867094,
            0.0671542,
            0.128568,
            0.995509,
            -0.00978951,
            0.0671531,
            0.145183,
            0.995503,
            -0.0109725,
            0.0671491,
            0.162808,
            0.995501,
            -0.012211,
            0.0671465,
            0.181441,
            0.99553,
            -0.0134565,
            0.0671371,
            0.201015,
            0.99555,
            -0.014391,
            0.0670831,
            0.221206,
            0.99558,
            -0.014351,
            0.0668883,
            0.240813,
            0.995577,
            -0.0173997,
            0.0671055,
            0.261257,
            0.995602,
            -0.0191111,
            0.0671178,
            0.284467,
            0.995623,
            -0.0206705,
            0.0670946,
            0.308765,
            0.995658,
            -0.022184,
            0.0670472,
            0.333905,
            0.995705,
            -0.0234832,
            0.0669417,
            0.359677,
            0.995719,
            -0.0241933,
            0.0666714,
            0.385554,
            0.995786,
            -0.0243539,
            0.066266,
            0.410951,
            0.995887,
            -0.0271866,
            0.0664367,
            0.437163,
            0.995944,
            -0.0296012,
            0.0664931,
            0.464842,
            0.996004,
            -0.0301045,
            0.0660105,
            0.49332,
            0.996128,
            -0.0298311,
            0.0652694,
            0.521131,
            0.996253,
            -0.0316426,
            0.0650739,
            0.549167,
            0.996244,
            -0.0339043,
            0.0649433,
            0.57737,
            0.996309,
            -0.033329,
            0.0638926,
            0.606073,
            0.996417,
            -0.0338935,
            0.0630849,
            0.634527,
            0.996372,
            -0.0353104,
            0.0625083,
            0.66256,
            0.996542,
            -0.0348942,
            0.0611986,
            0.690516,
            0.996568,
            -0.0351614,
            0.060069,
            0.718317,
            0.996711,
            -0.0354317,
            0.0588522,
            0.74528,
            0.996671,
            -0.0349513,
            0.0571902,
            0.772061,
            0.996865,
            -0.0345622,
            0.0555321,
            0.798089,
            0.996802,
            -0.0342566,
            0.0537816,
            0.823178,
            0.996992,
            -0.0330862,
            0.0516095,
            0.847949,
            0.996944,
            -0.0324666,
            0.0495537,
            0.871431,
            0.997146,
            -0.0309544,
            0.0470302,
            0.894357,
            0.997189,
            -0.0299372,
            0.0446043,
            0.916142,
            0.997471,
            -0.0281389,
            0.0418812,
            0.937193,
            0.997515,
            -0.0268702,
            0.0391823,
            0.957,
            0.997812,
            -0.0247166,
            0.0361338,
            0.975936,
            0.998027,
            -0.0233525,
            0.0333945,
            0.99391,
            0.998233,
            -0.0209839,
            0.0301917,
            1.01075,
            0.998481,
            -0.0194309,
            0.027271,
            1.02669,
            0.998859,
            -0.0169728,
            0.0240162,
            1.04173,
            0.99894,
            -0.0152322,
            0.0210517,
            1.05551,
            0.999132,
            -0.0127497,
            0.0178632,
            1.06856,
            0.999369,
            -0.0108282,
            0.014787,
            1.08054,
            0.999549,
            -0.00845886,
            0.0116185,
            1.09185,
            0.999805,
            -0.0063937,
            0.00867209,
            1.10207,
            0.99985,
            -0.00414582,
            0.00566823,
            1.1117,
            0.999912,
            -0.00207443,
            0.00277562,
            1.12022,
            1.00001,
            0.0000870226,
            -0.000053766,
            1.12832,
            0.991943,
            -0.00000178672,
            0.0893382,
            0.0000198384,
            0.991952,
            -0.0000450183,
            0.089339,
            0.000499849,
            0.991956,
            -0.000180074,
            0.0893394,
            0.0019994,
            0.991955,
            -0.000405167,
            0.0893393,
            0.00449867,
            0.991953,
            -0.000720298,
            0.0893391,
            0.00799764,
            0.991955,
            -0.00112548,
            0.0893393,
            0.0124964,
            0.991957,
            -0.0016207,
            0.0893395,
            0.0179951,
            0.991958,
            -0.00220601,
            0.0893396,
            0.0244939,
            0.991947,
            -0.00288137,
            0.0893385,
            0.0319929,
            0.991962,
            -0.00364693,
            0.0893399,
            0.0404933,
            0.991965,
            -0.00450264,
            0.0893399,
            0.049995,
            0.99198,
            -0.00544862,
            0.0893411,
            0.0604995,
            0.99197,
            -0.00648491,
            0.0893397,
            0.0720074,
            0.991976,
            -0.00761164,
            0.089341,
            0.0845207,
            0.99198,
            -0.00882891,
            0.0893405,
            0.0980413,
            0.991982,
            -0.0101367,
            0.0893396,
            0.112571,
            0.992008,
            -0.011535,
            0.0893415,
            0.128115,
            0.992026,
            -0.0130228,
            0.0893414,
            0.144672,
            0.992064,
            -0.0145966,
            0.0893418,
            0.162241,
            0.992041,
            -0.0162421,
            0.0893359,
            0.180801,
            0.992086,
            -0.0178888,
            0.0893214,
            0.200302,
            0.992157,
            -0.0190368,
            0.0892401,
            0.220332,
            0.992181,
            -0.0195584,
            0.0890525,
            0.240144,
            0.992175,
            -0.0227257,
            0.0892153,
            0.260728,
            0.99221,
            -0.0254195,
            0.089304,
            0.283473,
            0.99222,
            -0.0274883,
            0.0892703,
            0.307673,
            0.992317,
            -0.0294905,
            0.0892027,
            0.332729,
            0.992374,
            -0.0311861,
            0.0890577,
            0.358387,
            0.992505,
            -0.0320656,
            0.0886994,
            0.384102,
            0.992568,
            -0.0329715,
            0.0883198,
            0.409767,
            0.992675,
            -0.036006,
            0.0883602,
            0.436145,
            0.992746,
            -0.0392897,
            0.0884591,
            0.463217,
            0.992873,
            -0.0399337,
            0.0878287,
            0.491557,
            0.992934,
            -0.040231,
            0.0870108,
            0.519516,
            0.993091,
            -0.0422013,
            0.0865857,
            0.547741,
            0.993259,
            -0.0443503,
            0.0861937,
            0.575792,
            0.993455,
            -0.0446368,
            0.0851187,
            0.604233,
            0.993497,
            -0.0454299,
            0.0840576,
            0.632925,
            0.993694,
            -0.0463296,
            0.0829671,
            0.660985,
            0.993718,
            -0.0470619,
            0.0817185,
            0.688714,
            0.993973,
            -0.0468838,
            0.0800294,
            0.716743,
            0.994207,
            -0.046705,
            0.0781286,
            0.74377,
            0.994168,
            -0.0469698,
            0.0763337,
            0.77042,
            0.9945,
            -0.0456816,
            0.0738184,
            0.796659,
            0.994356,
            -0.0455518,
            0.0715545,
            0.821868,
            0.994747,
            -0.0439488,
            0.0686085,
            0.846572,
            0.994937,
            -0.0430056,
            0.065869,
            0.870435,
            0.995142,
            -0.0413414,
            0.0626446,
            0.893272,
            0.995451,
            -0.0396521,
            0.05929,
            0.915376,
            0.995445,
            -0.0378453,
            0.0558503,
            0.936196,
            0.995967,
            -0.0355219,
            0.0520949,
            0.956376,
            0.996094,
            -0.0335146,
            0.048377,
            0.975327,
            0.996622,
            -0.030682,
            0.0442575,
            0.993471,
            0.996938,
            -0.0285504,
            0.0404693,
            1.01052,
            0.997383,
            -0.0253399,
            0.0360903,
            1.02637,
            0.997714,
            -0.0231651,
            0.0322176,
            1.04139,
            0.998249,
            -0.0198138,
            0.0278433,
            1.05542,
            0.998596,
            -0.0174337,
            0.0238759,
            1.06846,
            0.998946,
            -0.0141349,
            0.0195944,
            1.08056,
            0.99928,
            -0.0115603,
            0.0156279,
            1.09181,
            0.999507,
            -0.00839065,
            0.0114607,
            1.10213,
            0.999697,
            -0.005666,
            0.00763325,
            1.11169,
            0.999869,
            -0.00269902,
            0.00364946,
            1.12042,
            1.00001,
            0.0000623836,
            -0.0000319288,
            1.12832,
            0.987221,
            -0.00000222675,
            0.111332,
            0.0000197456,
            0.98739,
            -0.0000561116,
            0.111351,
            0.000497563,
            0.987448,
            -0.000224453,
            0.111357,
            0.00199031,
            0.987441,
            -0.000505019,
            0.111357,
            0.0044782,
            0.987442,
            -0.000897816,
            0.111357,
            0.00796129,
            0.987442,
            -0.00140284,
            0.111357,
            0.0124396,
            0.987444,
            -0.00202012,
            0.111357,
            0.0179132,
            0.987442,
            -0.00274964,
            0.111357,
            0.0243824,
            0.987446,
            -0.00359147,
            0.111357,
            0.0318474,
            0.987435,
            -0.00454562,
            0.111356,
            0.0403086,
            0.987461,
            -0.00561225,
            0.111358,
            0.0497678,
            0.987458,
            -0.00679125,
            0.111358,
            0.0602239,
            0.987443,
            -0.0080828,
            0.111356,
            0.0716792,
            0.987476,
            -0.0094872,
            0.111358,
            0.0841364,
            0.98749,
            -0.0110044,
            0.111361,
            0.097597,
            0.987508,
            -0.0126344,
            0.111362,
            0.112062,
            0.987494,
            -0.0143767,
            0.111357,
            0.127533,
            0.987526,
            -0.0162307,
            0.111359,
            0.144015,
            0.987558,
            -0.0181912,
            0.111361,
            0.161502,
            0.987602,
            -0.0202393,
            0.111355,
            0.179979,
            0.987692,
            -0.022273,
            0.111346,
            0.199386,
            0.987702,
            -0.0235306,
            0.111215,
            0.219183,
            0.987789,
            -0.0247628,
            0.111061,
            0.239202,
            0.987776,
            -0.0280668,
            0.111171,
            0.259957,
            0.987856,
            -0.0316751,
            0.111327,
            0.282198,
            0.987912,
            -0.0342468,
            0.111282,
            0.306294,
            0.988,
            -0.0367205,
            0.111198,
            0.331219,
            0.988055,
            -0.0387766,
            0.110994,
            0.356708,
            0.988241,
            -0.0397722,
            0.110547,
            0.382234,
            0.988399,
            -0.0416076,
            0.110198,
            0.408227,
            0.988539,
            -0.0448192,
            0.110137,
            0.434662,
            0.988661,
            -0.0483793,
            0.110143,
            0.461442,
            0.988967,
            -0.0495895,
            0.109453,
            0.489318,
            0.989073,
            -0.0506797,
            0.108628,
            0.517516,
            0.989274,
            -0.0526953,
            0.108003,
            0.545844,
            0.989528,
            -0.054578,
            0.107255,
            0.573823,
            0.989709,
            -0.0561503,
            0.106294,
            0.601944,
            0.989991,
            -0.056866,
            0.104896,
            0.630855,
            0.990392,
            -0.0572914,
            0.103336,
            0.658925,
            0.990374,
            -0.0586224,
            0.10189,
            0.686661,
            0.990747,
            -0.0584764,
            0.099783,
            0.714548,
            0.991041,
            -0.0582662,
            0.0974309,
            0.74186,
            0.991236,
            -0.0584118,
            0.0951678,
            0.768422,
            0.991585,
            -0.0573055,
            0.0921581,
            0.794817,
            0.991984,
            -0.0564241,
            0.0891167,
            0.820336,
            0.9921,
            -0.0553608,
            0.085805,
            0.84493,
            0.992749,
            -0.0533816,
            0.0820354,
            0.868961,
            0.99288,
            -0.0518661,
            0.0782181,
            0.891931,
            0.993511,
            -0.0492492,
            0.0738935,
            0.914186,
            0.993617,
            -0.0471956,
            0.0696402,
            0.93532,
            0.99411,
            -0.044216,
            0.0649659,
            0.95543,
            0.994595,
            -0.0416654,
            0.0603177,
            0.974685,
            0.994976,
            -0.0384314,
            0.0553493,
            0.992807,
            0.995579,
            -0.0353491,
            0.0503942,
            1.00996,
            0.996069,
            -0.0319787,
            0.0452123,
            1.02606,
            0.996718,
            -0.028472,
            0.0400112,
            1.04114,
            0.997173,
            -0.0250789,
            0.0349456,
            1.05517,
            0.997818,
            -0.0213326,
            0.029653,
            1.0683,
            0.998318,
            -0.0178509,
            0.024549,
            1.0805,
            0.998853,
            -0.0141118,
            0.0194197,
            1.09177,
            0.999218,
            -0.0105914,
            0.0143869,
            1.1022,
            0.999594,
            -0.00693474,
            0.00943517,
            1.11175,
            0.99975,
            -0.00340478,
            0.00464051,
            1.12056,
            1.00001,
            0.000109172,
            -0.000112821,
            1.12853,
            0.983383,
            -0.00000266524,
            0.133358,
            0.0000196534,
            0.981942,
            -0.0000671009,
            0.133162,
            0.000494804,
            0.981946,
            -0.000268405,
            0.133163,
            0.00197923,
            0.981944,
            -0.000603912,
            0.133163,
            0.00445326,
            0.981941,
            -0.00107362,
            0.133162,
            0.00791693,
            0.981946,
            -0.00167755,
            0.133163,
            0.0123703,
            0.981944,
            -0.00241569,
            0.133162,
            0.0178135,
            0.981945,
            -0.00328807,
            0.133163,
            0.0242466,
            0.981945,
            -0.00429472,
            0.133162,
            0.03167,
            0.981955,
            -0.00543573,
            0.133164,
            0.0400846,
            0.981951,
            -0.00671105,
            0.133163,
            0.0494901,
            0.981968,
            -0.00812092,
            0.133165,
            0.0598886,
            0.981979,
            -0.00966541,
            0.133166,
            0.0712811,
            0.981996,
            -0.0113446,
            0.133168,
            0.083669,
            0.982014,
            -0.0131585,
            0.133169,
            0.0970533,
            0.982011,
            -0.0151073,
            0.133167,
            0.111438,
            0.982062,
            -0.0171906,
            0.133172,
            0.126826,
            0.9821,
            -0.0194067,
            0.133175,
            0.143215,
            0.982149,
            -0.0217502,
            0.133176,
            0.160609,
            0.982163,
            -0.0241945,
            0.133173,
            0.178981,
            0.982247,
            -0.0265907,
            0.133148,
            0.198249,
            0.982291,
            -0.027916,
            0.132974,
            0.217795,
            0.982396,
            -0.0299663,
            0.132868,
            0.238042,
            0.982456,
            -0.0334544,
            0.132934,
            0.258901,
            0.982499,
            -0.0378636,
            0.133137,
            0.280639,
            0.982617,
            -0.0409274,
            0.133085,
            0.304604,
            0.98274,
            -0.0438523,
            0.132985,
            0.329376,
            0.982944,
            -0.0462288,
            0.132728,
            0.354697,
            0.98308,
            -0.0475995,
            0.132228,
            0.380102,
            0.983391,
            -0.0501901,
            0.131924,
            0.406256,
            0.983514,
            -0.0535899,
            0.131737,
            0.432735,
            0.98373,
            -0.0571858,
            0.131567,
            0.459359,
            0.984056,
            -0.0592353,
            0.130932,
            0.486637,
            0.984234,
            -0.0610488,
            0.130092,
            0.51509,
            0.984748,
            -0.0630758,
            0.12923,
            0.543461,
            0.985073,
            -0.0647398,
            0.128174,
            0.571376,
            0.985195,
            -0.0671941,
            0.127133,
            0.599414,
            0.985734,
            -0.0681345,
            0.125576,
            0.628134,
            0.986241,
            -0.0686089,
            0.123639,
            0.656399,
            0.986356,
            -0.0698511,
            0.121834,
            0.684258,
            0.986894,
            -0.0700931,
            0.119454,
            0.711818,
            0.987382,
            -0.0698321,
            0.116718,
            0.739511,
            0.988109,
            -0.0693975,
            0.113699,
            0.766267,
            0.988363,
            -0.0689584,
            0.110454,
            0.792456,
            0.989112,
            -0.0672353,
            0.106602,
            0.81813,
            0.989241,
            -0.0662034,
            0.10267,
            0.842889,
            0.990333,
            -0.0638938,
            0.0981381,
            0.867204,
            0.990591,
            -0.0618534,
            0.0935388,
            0.89038,
            0.991106,
            -0.0593117,
            0.088553,
            0.912576,
            0.991919,
            -0.0562676,
            0.0832187,
            0.934118,
            0.992111,
            -0.0534085,
            0.0778302,
            0.954254,
            0.992997,
            -0.0495459,
            0.0720453,
            0.973722,
            0.993317,
            -0.0463707,
            0.0663458,
            0.991949,
            0.994133,
            -0.0421245,
            0.0601883,
            1.00936,
            0.994705,
            -0.0384977,
            0.0542501,
            1.02559,
            0.995495,
            -0.0340956,
            0.0479862,
            1.04083,
            0.996206,
            -0.030105,
            0.041887,
            1.05497,
            0.996971,
            -0.0256095,
            0.0355355,
            1.06824,
            0.997796,
            -0.0213932,
            0.0293655,
            1.08056,
            0.998272,
            -0.0169612,
            0.0232926,
            1.09182,
            0.998857,
            -0.0126756,
            0.0172786,
            1.10219,
            0.99939,
            -0.00832486,
            0.0113156,
            1.11192,
            0.999752,
            -0.00410826,
            0.00557892,
            1.12075,
            1,
            0.000150957,
            -0.000119101,
            1.12885,
            0.975169,
            -0.00000309397,
            0.154669,
            0.0000195073,
            0.975439,
            -0.0000779608,
            0.154712,
            0.000491534,
            0.975464,
            -0.000311847,
            0.154716,
            0.00196617,
            0.975464,
            -0.000701656,
            0.154716,
            0.00442387,
            0.975462,
            -0.0012474,
            0.154715,
            0.0078647,
            0.975461,
            -0.00194906,
            0.154715,
            0.0122886,
            0.975464,
            -0.00280667,
            0.154715,
            0.0176959,
            0.975468,
            -0.00382025,
            0.154716,
            0.0240867,
            0.975471,
            -0.00498985,
            0.154716,
            0.0314612,
            0.975472,
            -0.00631541,
            0.154717,
            0.0398199,
            0.975486,
            -0.00779719,
            0.154718,
            0.0491639,
            0.975489,
            -0.00943505,
            0.154718,
            0.0594932,
            0.975509,
            -0.0112295,
            0.154721,
            0.0708113,
            0.97554,
            -0.0131802,
            0.154724,
            0.0831176,
            0.975557,
            -0.0152876,
            0.154726,
            0.096415,
            0.975585,
            -0.0175512,
            0.154728,
            0.110705,
            0.975605,
            -0.0199713,
            0.154729,
            0.125992,
            0.975645,
            -0.0225447,
            0.154729,
            0.142272,
            0.975711,
            -0.0252649,
            0.154735,
            0.159549,
            0.975788,
            -0.0280986,
            0.154736,
            0.177805,
            0.975872,
            -0.0308232,
            0.154704,
            0.196911,
            0.975968,
            -0.0324841,
            0.154525,
            0.216324,
            0.976063,
            -0.0351281,
            0.154432,
            0.236628,
            0.976157,
            -0.0388618,
            0.15446,
            0.257539,
            0.976204,
            -0.0437704,
            0.154665,
            0.278975,
            0.976358,
            -0.047514,
            0.154652,
            0.302606,
            0.976571,
            -0.0508638,
            0.154535,
            0.327204,
            0.976725,
            -0.0534995,
            0.154221,
            0.352276,
            0.977013,
            -0.0555547,
            0.153737,
            0.377696,
            0.977294,
            -0.0586728,
            0.153403,
            0.403855,
            0.977602,
            -0.0622715,
            0.15312,
            0.430333,
            0.977932,
            -0.0658166,
            0.152755,
            0.456855,
            0.978241,
            -0.0689877,
            0.152233,
            0.483668,
            0.978602,
            -0.0712805,
            0.15132,
            0.512097,
            0.979234,
            -0.0732775,
            0.150235,
            0.540455,
            0.97977,
            -0.075163,
            0.148978,
            0.568486,
            0.979995,
            -0.0778026,
            0.147755,
            0.596524,
            0.98078,
            -0.0791854,
            0.146019,
            0.624825,
            0.981628,
            -0.0799666,
            0.143906,
            0.653403,
            0.982067,
            -0.0808532,
            0.141561,
            0.681445,
            0.98271,
            -0.0816024,
            0.139025,
            0.708918,
            0.983734,
            -0.0812511,
            0.135764,
            0.736594,
            0.98431,
            -0.0806201,
            0.132152,
            0.763576,
            0.985071,
            -0.0801605,
            0.12846,
            0.789797,
            0.98618,
            -0.0784208,
            0.124084,
            0.815804,
            0.986886,
            -0.0766643,
            0.1193,
            0.840869,
            0.987485,
            -0.0747744,
            0.114236,
            0.864952,
            0.988431,
            -0.0716701,
            0.108654,
            0.888431,
            0.988886,
            -0.0691609,
            0.102994,
            0.910963,
            0.990024,
            -0.0654048,
            0.0967278,
            0.932629,
            0.990401,
            -0.0619765,
            0.090384,
            0.95313,
            0.991093,
            -0.0579296,
            0.0837885,
            0.972587,
            0.992018,
            -0.0536576,
            0.0770171,
            0.991184,
            0.992536,
            -0.0493719,
            0.0701486,
            1.00863,
            0.993421,
            -0.0444813,
            0.062953,
            1.02494,
            0.993928,
            -0.040008,
            0.0560455,
            1.04017,
            0.994994,
            -0.0347982,
            0.04856,
            1.05463,
            0.995866,
            -0.0301017,
            0.0416152,
            1.06807,
            0.996916,
            -0.0248225,
            0.0342597,
            1.08039,
            0.997766,
            -0.0199229,
            0.0271668,
            1.09177,
            0.998479,
            -0.0147422,
            0.0201387,
            1.10235,
            0.99921,
            -0.00980173,
            0.0131944,
            1.11206,
            0.999652,
            -0.0047426,
            0.00640712,
            1.12104,
            0.999998,
            0.0000891673,
            -0.00010379,
            1.12906,
            0.967868,
            -0.00000351885,
            0.175947,
            0.0000193569,
            0.968001,
            -0.0000886733,
            0.175972,
            0.000487782,
            0.96801,
            -0.000354697,
            0.175973,
            0.00195115,
            0.968012,
            -0.000798063,
            0.175974,
            0.00439006,
            0.968011,
            -0.00141879,
            0.175973,
            0.00780461,
            0.968011,
            -0.00221686,
            0.175973,
            0.0121948,
            0.968016,
            -0.00319231,
            0.175974,
            0.0175607,
            0.968019,
            -0.00434515,
            0.175974,
            0.0239027,
            0.968018,
            -0.00567538,
            0.175974,
            0.0312208,
            0.968033,
            -0.00718308,
            0.175977,
            0.0395158,
            0.968049,
            -0.00886836,
            0.175979,
            0.0487885,
            0.968047,
            -0.0107312,
            0.175978,
            0.0590394,
            0.968072,
            -0.0127719,
            0.175981,
            0.0702705,
            0.968108,
            -0.0149905,
            0.175986,
            0.0824836,
            0.968112,
            -0.0173866,
            0.175985,
            0.0956783,
            0.968173,
            -0.0199611,
            0.175993,
            0.109862,
            0.96827,
            -0.0227128,
            0.176008,
            0.125033,
            0.968292,
            -0.025639,
            0.17601,
            0.141193,
            0.968339,
            -0.0287299,
            0.176007,
            0.158336,
            0.968389,
            -0.0319399,
            0.176001,
            0.176441,
            0.968501,
            -0.034941,
            0.175962,
            0.195359,
            0.968646,
            -0.0370812,
            0.175793,
            0.214686,
            0.968789,
            -0.0402329,
            0.175708,
            0.234973,
            0.96886,
            -0.0442601,
            0.1757,
            0.255871,
            0.969013,
            -0.049398,
            0.175876,
            0.277238,
            0.969242,
            -0.0539932,
            0.17594,
            0.300326,
            0.969419,
            -0.0577299,
            0.175781,
            0.324702,
            0.969763,
            -0.0605643,
            0.175432,
            0.349527,
            0.970093,
            -0.0634488,
            0.174992,
            0.374976,
            0.970361,
            -0.0670589,
            0.174611,
            0.401097,
            0.970825,
            -0.0708246,
            0.174226,
            0.427496,
            0.971214,
            -0.0742871,
            0.173684,
            0.453858,
            0.971622,
            -0.0782608,
            0.173186,
            0.480637,
            0.972175,
            -0.0813151,
            0.172288,
            0.508655,
            0.972944,
            -0.0832678,
            0.170979,
            0.536973,
            0.973595,
            -0.0855964,
            0.169573,
            0.565138,
            0.974345,
            -0.0882163,
            0.168152,
            0.593222,
            0.975233,
            -0.0901671,
            0.166314,
            0.621201,
            0.976239,
            -0.0912111,
            0.163931,
            0.649919,
            0.977289,
            -0.0916959,
            0.161106,
            0.678011,
            0.978076,
            -0.0927061,
            0.158272,
            0.705717,
            0.979533,
            -0.0925562,
            0.15475,
            0.733228,
            0.980335,
            -0.0918159,
            0.150638,
            0.760454,
            0.981808,
            -0.0908508,
            0.146201,
            0.786918,
            0.983061,
            -0.0896172,
            0.141386,
            0.812953,
            0.984148,
            -0.0871588,
            0.135837,
            0.838281,
            0.985047,
            -0.0850624,
            0.130135,
            0.862594,
            0.986219,
            -0.0818541,
            0.123882,
            0.88633,
            0.987043,
            -0.0784523,
            0.117126,
            0.908952,
            0.988107,
            -0.0749601,
            0.110341,
            0.930744,
            0.988955,
            -0.0703548,
            0.102885,
            0.951728,
            0.989426,
            -0.0662798,
            0.0954167,
            0.971166,
            0.990421,
            -0.0610834,
            0.0876331,
            0.989984,
            0.991032,
            -0.0562936,
            0.0797785,
            1.00765,
            0.992041,
            -0.0508154,
            0.0718166,
            1.02434,
            0.992794,
            -0.0454045,
            0.0637125,
            1.03976,
            0.993691,
            -0.0398194,
            0.0555338,
            1.05418,
            0.994778,
            -0.0341482,
            0.0473388,
            1.06772,
            0.995915,
            -0.028428,
            0.0391016,
            1.08028,
            0.997109,
            -0.022642,
            0.0309953,
            1.09185,
            0.998095,
            -0.0168738,
            0.0230288,
            1.10247,
            0.998985,
            -0.0111274,
            0.0150722,
            1.11229,
            0.999581,
            -0.00543881,
            0.00740605,
            1.12131,
            1.00003,
            0.000162239,
            -0.000105549,
            1.12946,
            0.959505,
            -0.00000393734,
            0.196876,
            0.0000191893,
            0.959599,
            -0.0000992157,
            0.196895,
            0.000483544,
            0.959641,
            -0.000396868,
            0.196903,
            0.0019342,
            0.959599,
            -0.000892948,
            0.196895,
            0.00435193,
            0.959603,
            -0.00158747,
            0.196896,
            0.0077368,
            0.959604,
            -0.00248042,
            0.196896,
            0.0120888,
            0.959605,
            -0.00357184,
            0.196896,
            0.0174082,
            0.959605,
            -0.00486169,
            0.196896,
            0.0236949,
            0.959613,
            -0.00635008,
            0.196897,
            0.0309497,
            0.959619,
            -0.00803696,
            0.196898,
            0.0391725,
            0.959636,
            -0.00992255,
            0.196901,
            0.0483649,
            0.959634,
            -0.0120067,
            0.1969,
            0.0585266,
            0.959675,
            -0.0142898,
            0.196906,
            0.0696609,
            0.959712,
            -0.0167717,
            0.196911,
            0.0817678,
            0.959752,
            -0.0194524,
            0.196918,
            0.0948494,
            0.959807,
            -0.0223321,
            0.196925,
            0.10891,
            0.959828,
            -0.0254091,
            0.196924,
            0.123947,
            0.959906,
            -0.0286815,
            0.196934,
            0.139968,
            0.960005,
            -0.0321371,
            0.196944,
            0.156968,
            0.960071,
            -0.0357114,
            0.196936,
            0.17491,
            0.960237,
            -0.0389064,
            0.196882,
            0.193597,
            0.960367,
            -0.041623,
            0.196731,
            0.21285,
            0.960562,
            -0.0452655,
            0.196654,
            0.233075,
            0.960735,
            -0.0496207,
            0.196643,
            0.253941,
            0.960913,
            -0.0549379,
            0.196774,
            0.275278,
            0.961121,
            -0.0603414,
            0.196893,
            0.297733,
            0.96139,
            -0.0644244,
            0.196717,
            0.321877,
            0.961818,
            -0.067556,
            0.196314,
            0.346476,
            0.962175,
            -0.0712709,
            0.195917,
            0.371907,
            0.96255,
            -0.0752848,
            0.1955,
            0.397916,
            0.963164,
            -0.0792073,
            0.195026,
            0.424229,
            0.963782,
            -0.0828225,
            0.194424,
            0.450637,
            0.964306,
            -0.0873119,
            0.193831,
            0.477288,
            0.964923,
            -0.0911051,
            0.192973,
            0.504716,
            0.966048,
            -0.093251,
            0.19151,
            0.533053,
            0.967024,
            -0.0958983,
            0.190013,
            0.561366,
            0.968038,
            -0.09835,
            0.188253,
            0.589464,
            0.969152,
            -0.100754,
            0.186257,
            0.617433,
            0.970557,
            -0.102239,
            0.183775,
            0.645801,
            0.972104,
            -0.102767,
            0.180645,
            0.674278,
            0.973203,
            -0.103492,
            0.177242,
            0.702004,
            0.975123,
            -0.103793,
            0.17345,
            0.729529,
            0.97641,
            -0.102839,
            0.168886,
            0.756712,
            0.978313,
            -0.101687,
            0.163892,
            0.783801,
            0.980036,
            -0.100314,
            0.158439,
            0.809671,
            0.981339,
            -0.097836,
            0.152211,
            0.835402,
            0.982794,
            -0.0950006,
            0.145679,
            0.860081,
            0.984123,
            -0.0920994,
            0.138949,
            0.883757,
            0.984918,
            -0.0878641,
            0.131283,
            0.90685,
            0.985999,
            -0.083939,
            0.123464,
            0.928786,
            0.987151,
            -0.0791234,
            0.115324,
            0.94983,
            0.987827,
            -0.0739332,
            0.106854,
            0.96962,
            0.988806,
            -0.0688088,
            0.0982691,
            0.98861,
            0.989588,
            -0.0628962,
            0.0893456,
            1.00667,
            0.990438,
            -0.0573146,
            0.0805392,
            1.02344,
            0.991506,
            -0.0509433,
            0.0713725,
            1.03933,
            0.992492,
            -0.0448724,
            0.0623732,
            1.05378,
            0.993663,
            -0.0383497,
            0.0530838,
            1.06747,
            0.994956,
            -0.0319593,
            0.0439512,
            1.08007,
            0.99634,
            -0.025401,
            0.0347803,
            1.09182,
            0.99761,
            -0.0189687,
            0.0257954,
            1.1025,
            0.99863,
            -0.0124441,
            0.0169893,
            1.11247,
            0.99947,
            -0.00614003,
            0.00829498,
            1.12151,
            1.00008,
            0.000216624,
            -0.000146107,
            1.12993,
            0.950129,
            -0.00000434955,
            0.217413,
            0.0000190081,
            0.950264,
            -0.00010957,
            0.217444,
            0.00047884,
            0.9503,
            -0.000438299,
            0.217451,
            0.00191543,
            0.950246,
            -0.000986124,
            0.21744,
            0.00430951,
            0.950246,
            -0.00175311,
            0.21744,
            0.00766137,
            0.950245,
            -0.00273923,
            0.21744,
            0.011971,
            0.950253,
            -0.00394453,
            0.217441,
            0.0172385,
            0.950258,
            -0.00536897,
            0.217442,
            0.0234641,
            0.950267,
            -0.00701262,
            0.217444,
            0.030648,
            0.950277,
            -0.00887551,
            0.217446,
            0.038791,
            0.950284,
            -0.0109576,
            0.217446,
            0.0478931,
            0.950312,
            -0.0132591,
            0.217451,
            0.0579568,
            0.950334,
            -0.01578,
            0.217454,
            0.0689821,
            0.950378,
            -0.0185204,
            0.217462,
            0.0809714,
            0.950417,
            -0.0214803,
            0.217467,
            0.0939265,
            0.950488,
            -0.0246594,
            0.217479,
            0.10785,
            0.950534,
            -0.0280565,
            0.217483,
            0.122743,
            0.950633,
            -0.0316685,
            0.217498,
            0.138611,
            0.950698,
            -0.0354787,
            0.217499,
            0.155442,
            0.950844,
            -0.0394003,
            0.217507,
            0.173208,
            0.950999,
            -0.0426812,
            0.217419,
            0.191605,
            0.951221,
            -0.0461302,
            0.217317,
            0.21084,
            0.951412,
            -0.0502131,
            0.217238,
            0.230945,
            0.951623,
            -0.0549183,
            0.21722,
            0.251745,
            0.951867,
            -0.0604493,
            0.217306,
            0.273001,
            0.952069,
            -0.0665189,
            0.217466,
            0.294874,
            0.952459,
            -0.0709179,
            0.217266,
            0.318732,
            0.952996,
            -0.0746112,
            0.216891,
            0.34318,
            0.953425,
            -0.0789252,
            0.216503,
            0.36849,
            0.953885,
            -0.0833293,
            0.216042,
            0.394373,
            0.954617,
            -0.087371,
            0.215469,
            0.420505,
            0.955429,
            -0.0914054,
            0.214802,
            0.446907,
            0.956068,
            -0.0961671,
            0.214146,
            0.473522,
            0.957094,
            -0.10048,
            0.213286,
            0.50052,
            0.958372,
            -0.103248,
            0.211796,
            0.528715,
            0.959654,
            -0.106033,
            0.21016,
            0.557065,
            0.961305,
            -0.108384,
            0.208149,
            0.585286,
            0.962785,
            -0.111122,
            0.206024,
            0.613334,
            0.964848,
            -0.112981,
            0.203442,
            0.641334,
            0.966498,
            -0.113717,
            0.19996,
            0.669955,
            0.968678,
            -0.114121,
            0.196105,
            0.698094,
            0.970489,
            -0.114524,
            0.191906,
            0.725643,
            0.972903,
            -0.113792,
            0.186963,
            0.752856,
            0.974701,
            -0.112406,
            0.181343,
            0.780013,
            0.976718,
            -0.110685,
            0.175185,
            0.806268,
            0.978905,
            -0.108468,
            0.168535,
            0.832073,
            0.980267,
            -0.105061,
            0.161106,
            0.857149,
            0.981967,
            -0.101675,
            0.153387,
            0.881145,
            0.983063,
            -0.0974492,
            0.145199,
            0.904255,
            0.984432,
            -0.0925815,
            0.136527,
            0.926686,
            0.985734,
            -0.0877983,
            0.127584,
            0.947901,
            0.986228,
            -0.081884,
            0.118125,
            0.968111,
            0.98719,
            -0.0761208,
            0.108594,
            0.98719,
            0.988228,
            -0.0698196,
            0.0989996,
            1.00559,
            0.989046,
            -0.0632739,
            0.0890074,
            1.02246,
            0.990242,
            -0.056522,
            0.0790832,
            1.03841,
            0.991252,
            -0.0495272,
            0.0689182,
            1.05347,
            0.992542,
            -0.0425373,
            0.0588592,
            1.06724,
            0.994096,
            -0.0353198,
            0.0486833,
            1.08009,
            0.995593,
            -0.028235,
            0.0385977,
            1.09177,
            0.99711,
            -0.0209511,
            0.0286457,
            1.10274,
            0.998263,
            -0.0139289,
            0.0188497,
            1.11262,
            0.999254,
            -0.0067359,
            0.009208,
            1.12191,
            0.999967,
            0.000141846,
            -0.0000657764,
            1.13024,
            0.935608,
            -0.00000474692,
            0.236466,
            0.0000187817,
            0.93996,
            -0.00011971,
            0.237568,
            0.000473646,
            0.939959,
            -0.000478845,
            0.237567,
            0.0018946,
            0.939954,
            -0.0010774,
            0.237566,
            0.00426284,
            0.939956,
            -0.00191538,
            0.237566,
            0.00757842,
            0.939954,
            -0.00299277,
            0.237566,
            0.0118413,
            0.93996,
            -0.00430961,
            0.237567,
            0.0170518,
            0.939969,
            -0.00586589,
            0.237569,
            0.02321,
            0.939982,
            -0.00766166,
            0.237572,
            0.0303164,
            0.939987,
            -0.00969686,
            0.237572,
            0.0383711,
            0.939997,
            -0.0119715,
            0.237574,
            0.0473751,
            0.940031,
            -0.0144858,
            0.237581,
            0.0573298,
            0.940073,
            -0.0172399,
            0.237589,
            0.0682366,
            0.94012,
            -0.0202335,
            0.237598,
            0.080097,
            0.940162,
            -0.0234663,
            0.237604,
            0.0929116,
            0.940237,
            -0.0269387,
            0.237615,
            0.106686,
            0.940328,
            -0.0306489,
            0.237632,
            0.121421,
            0.940419,
            -0.0345917,
            0.237645,
            0.137115,
            0.940522,
            -0.0387481,
            0.237654,
            0.153766,
            0.940702,
            -0.0429906,
            0.237661,
            0.17133,
            0.940871,
            -0.0465089,
            0.237561,
            0.189502,
            0.941103,
            -0.050531,
            0.23748,
            0.208616,
            0.941369,
            -0.0550657,
            0.237423,
            0.228595,
            0.941641,
            -0.0601337,
            0.237399,
            0.249287,
            0.941903,
            -0.0658804,
            0.237443,
            0.270467,
            0.942224,
            -0.0722674,
            0.237597,
            0.292024,
            0.942633,
            -0.0771788,
            0.237419,
            0.315272,
            0.943172,
            -0.0815623,
            0.237068,
            0.339579,
            0.943691,
            -0.0863973,
            0.236682,
            0.364717,
            0.944382,
            -0.0911536,
            0.236213,
            0.390435,
            0.945392,
            -0.0952967,
            0.235562,
            0.416425,
            0.946185,
            -0.0998948,
            0.234832,
            0.442772,
            0.947212,
            -0.104796,
            0.234114,
            0.469347,
            0.948778,
            -0.10928,
            0.233222,
            0.496162,
            0.950149,
            -0.113081,
            0.231845,
            0.523978,
            0.951989,
            -0.115893,
            0.230005,
            0.552295,
            0.953921,
            -0.11846,
            0.227862,
            0.580569,
            0.955624,
            -0.12115,
            0.225439,
            0.608698,
            0.958234,
            -0.123373,
            0.222635,
            0.636696,
            0.960593,
            -0.124519,
            0.219093,
            0.665208,
            0.963201,
            -0.124736,
            0.214749,
            0.693557,
            0.965642,
            -0.125012,
            0.210059,
            0.721334,
            0.968765,
            -0.124661,
            0.204935,
            0.748613,
            0.971753,
            -0.122996,
            0.198661,
            0.776224,
            0.973751,
            -0.120998,
            0.191823,
            0.802461,
            0.976709,
            -0.118583,
            0.184359,
            0.828399,
            0.977956,
            -0.115102,
            0.176437,
            0.853693,
            0.979672,
            -0.111077,
            0.167681,
            0.877962,
            0.981816,
            -0.10688,
            0.158872,
            0.901564,
            0.98238,
            -0.101469,
            0.149398,
            0.924057,
            0.983964,
            -0.0960013,
            0.139436,
            0.945751,
            0.984933,
            -0.0899626,
            0.12943,
            0.966272,
            0.985694,
            -0.0832973,
            0.11894,
            0.985741,
            0.986822,
            -0.0767082,
            0.108349,
            1.00407,
            0.987725,
            -0.0693614,
            0.0976026,
            1.02154,
            0.98877,
            -0.06211,
            0.086652,
            1.03757,
            0.990129,
            -0.0544143,
            0.0756182,
            1.05296,
            0.991337,
            -0.046744,
            0.0645753,
            1.06683,
            0.992978,
            -0.0387931,
            0.0534683,
            1.0798,
            0.994676,
            -0.030973,
            0.0424137,
            1.09181,
            0.99645,
            -0.0230311,
            0.0314035,
            1.10286,
            0.997967,
            -0.0152065,
            0.0206869,
            1.11291,
            0.99922,
            -0.00744837,
            0.010155,
            1.12237,
            1.00002,
            0.000240209,
            -0.0000752767,
            1.13089,
            0.922948,
            -0.00000515351,
            0.255626,
            0.0000186069,
            0.928785,
            -0.000129623,
            0.257244,
            0.000468009,
            0.928761,
            -0.00051849,
            0.257237,
            0.00187202,
            0.928751,
            -0.0011666,
            0.257235,
            0.00421204,
            0.928751,
            -0.00207395,
            0.257234,
            0.0074881,
            0.928754,
            -0.00324055,
            0.257235,
            0.0117002,
            0.92876,
            -0.00466639,
            0.257236,
            0.0168486,
            0.928763,
            -0.00635149,
            0.257237,
            0.0229334,
            0.928774,
            -0.00829584,
            0.257239,
            0.029955,
            0.928791,
            -0.0104995,
            0.257243,
            0.0379139,
            0.928804,
            -0.0129623,
            0.257245,
            0.0468108,
            0.928847,
            -0.0156846,
            0.257255,
            0.0566473,
            0.92889,
            -0.0186661,
            0.257263,
            0.0674246,
            0.928924,
            -0.0219067,
            0.257268,
            0.0791433,
            0.928989,
            -0.0254066,
            0.257282,
            0.0918076,
            0.92909,
            -0.0291651,
            0.257301,
            0.105419,
            0.92918,
            -0.0331801,
            0.257316,
            0.119978,
            0.92929,
            -0.0374469,
            0.257332,
            0.135491,
            0.929453,
            -0.041939,
            0.257357,
            0.151948,
            0.929586,
            -0.0464612,
            0.257347,
            0.169275,
            0.929858,
            -0.0503426,
            0.257269,
            0.187257,
            0.930125,
            -0.0548409,
            0.257199,
            0.206204,
            0.930403,
            -0.0598063,
            0.257149,
            0.22601,
            0.930726,
            -0.0652437,
            0.257122,
            0.246561,
            0.931098,
            -0.0712376,
            0.257153,
            0.267618,
            0.931396,
            -0.0777506,
            0.257237,
            0.288993,
            0.931947,
            -0.0832374,
            0.257124,
            0.311527,
            0.932579,
            -0.0883955,
            0.25683,
            0.335697,
            0.933194,
            -0.0937037,
            0.256444,
            0.360634,
            0.934013,
            -0.0987292,
            0.255939,
            0.386126,
            0.935307,
            -0.103215,
            0.255282,
            0.412018,
            0.936374,
            -0.108234,
            0.254538,
            0.438292,
            0.93776,
            -0.113234,
            0.253728,
            0.464805,
            0.939599,
            -0.118013,
            0.25275,
            0.491464,
            0.941036,
            -0.122661,
            0.251404,
            0.518751,
            0.94337,
            -0.125477,
            0.249435,
            0.547133,
            0.945318,
            -0.128374,
            0.247113,
            0.575456,
            0.947995,
            -0.130996,
            0.244441,
            0.60372,
            0.950818,
            -0.133438,
            0.241352,
            0.63174,
            0.954378,
            -0.135004,
            0.237849,
            0.659971,
            0.957151,
            -0.135313,
            0.233188,
            0.688478,
            0.960743,
            -0.13521,
            0.228001,
            0.716767,
            0.964352,
            -0.135007,
            0.222249,
            0.744349,
            0.967273,
            -0.133523,
            0.21542,
            0.771786,
            0.969767,
            -0.131155,
            0.208039,
            0.798639,
            0.973195,
            -0.128492,
            0.200076,
            0.824774,
            0.975557,
            -0.125094,
            0.191451,
            0.850222,
            0.977692,
            -0.120578,
            0.18184,
            0.874761,
            0.98026,
            -0.115882,
            0.172102,
            0.898497,
            0.981394,
            -0.110372,
            0.161859,
            0.921636,
            0.982386,
            -0.10415,
            0.15108,
            0.943467,
            0.983783,
            -0.0978128,
            0.140407,
            0.964045,
            0.98422,
            -0.0906171,
            0.129058,
            0.98398,
            0.985447,
            -0.0832921,
            0.117614,
            1.00276,
            0.986682,
            -0.0754412,
            0.10585,
            1.02047,
            0.987326,
            -0.0673885,
            0.0940943,
            1.03678,
            0.988707,
            -0.0592565,
            0.0822093,
            1.05218,
            0.990185,
            -0.050717,
            0.070192,
            1.06652,
            0.991866,
            -0.0423486,
            0.0582081,
            1.07965,
            0.993897,
            -0.0336118,
            0.0460985,
            1.09188,
            0.995841,
            -0.0252178,
            0.0342737,
            1.10307,
            0.997605,
            -0.0164893,
            0.0224829,
            1.11324,
            0.999037,
            -0.00817112,
            0.0110647,
            1.12262,
            1.00003,
            0.000291686,
            -0.000168673,
            1.13139,
            0.915304,
            -0.00000552675,
            0.275999,
            0.0000183285,
            0.91668,
            -0.000139285,
            0.276414,
            0.000461914,
            0.916664,
            -0.00055713,
            0.276409,
            0.00184763,
            0.916653,
            -0.00125354,
            0.276406,
            0.00415715,
            0.916651,
            -0.00222851,
            0.276405,
            0.00739053,
            0.916655,
            -0.00348205,
            0.276406,
            0.0115478,
            0.916653,
            -0.00501414,
            0.276405,
            0.0166291,
            0.916667,
            -0.00682478,
            0.276409,
            0.0226346,
            0.91668,
            -0.00891398,
            0.276412,
            0.0295648,
            0.91669,
            -0.0112817,
            0.276413,
            0.0374199,
            0.916727,
            -0.013928,
            0.276422,
            0.0462016,
            0.916759,
            -0.0168528,
            0.276429,
            0.0559101,
            0.916793,
            -0.0200558,
            0.276436,
            0.0665466,
            0.916849,
            -0.0235373,
            0.276448,
            0.0781139,
            0.916964,
            -0.0272973,
            0.276474,
            0.0906156,
            0.917047,
            -0.0313344,
            0.276491,
            0.104051,
            0.917152,
            -0.0356465,
            0.276511,
            0.118424,
            0.917286,
            -0.0402271,
            0.276533,
            0.133736,
            0.917469,
            -0.0450408,
            0.276564,
            0.149978,
            0.917686,
            -0.0497872,
            0.276563,
            0.167057,
            0.917953,
            -0.0540937,
            0.276493,
            0.184846,
            0.918228,
            -0.0590709,
            0.276437,
            0.203614,
            0.918572,
            -0.0644277,
            0.276398,
            0.223212,
            0.918918,
            -0.0702326,
            0.276362,
            0.243584,
            0.919356,
            -0.076484,
            0.276383,
            0.264465,
            0.919842,
            -0.0830808,
            0.276434,
            0.285701,
            0.920451,
            -0.0892972,
            0.276407,
            0.307559,
            0.921113,
            -0.095016,
            0.276128,
            0.331501,
            0.921881,
            -0.100771,
            0.275754,
            0.356207,
            0.923027,
            -0.106029,
            0.275254,
            0.381477,
            0.924364,
            -0.111029,
            0.274595,
            0.40722,
            0.925818,
            -0.116345,
            0.273841,
            0.433385,
            0.92746,
            -0.121424,
            0.272913,
            0.459848,
            0.929167,
            -0.12657,
            0.271837,
            0.486493,
            0.931426,
            -0.131581,
            0.270575,
            0.513432,
            0.934001,
            -0.135038,
            0.268512,
            0.541502,
            0.936296,
            -0.138039,
            0.266135,
            0.569658,
            0.939985,
            -0.140687,
            0.263271,
            0.598375,
            0.943516,
            -0.143247,
            0.260058,
            0.626563,
            0.94782,
            -0.145135,
            0.256138,
            0.654711,
            0.951023,
            -0.145733,
            0.251154,
            0.683285,
            0.955338,
            -0.145554,
            0.245562,
            0.711831,
            0.959629,
            -0.145008,
            0.239265,
            0.739573,
            0.963123,
            -0.144003,
            0.232064,
            0.767027,
            0.966742,
            -0.141289,
            0.224036,
            0.794359,
            0.969991,
            -0.138247,
            0.215305,
            0.820361,
            0.973403,
            -0.134786,
            0.206051,
            0.846548,
            0.975317,
            -0.129966,
            0.195914,
            0.871541,
            0.977647,
            -0.12471,
            0.185184,
            0.895313,
            0.980137,
            -0.119086,
            0.174161,
            0.918398,
            0.981031,
            -0.112297,
            0.162792,
            0.940679,
            0.982037,
            -0.105372,
            0.150952,
            0.961991,
            0.983164,
            -0.097821,
            0.138921,
            0.981913,
            0.983757,
            -0.0897245,
            0.126611,
            1.00109,
            0.985036,
            -0.0815974,
            0.114228,
            1.01902,
            0.986289,
            -0.0727725,
            0.101389,
            1.03604,
            0.987329,
            -0.0639323,
            0.0886476,
            1.05149,
            0.989193,
            -0.0548109,
            0.0756837,
            1.06619,
            0.990716,
            -0.045687,
            0.0627581,
            1.07948,
            0.992769,
            -0.0364315,
            0.0498337,
            1.09172,
            0.99524,
            -0.0271761,
            0.0370305,
            1.1033,
            0.997154,
            -0.0179609,
            0.0243959,
            1.11353,
            0.998845,
            -0.00878063,
            0.0119567,
            1.12319,
            1.00002,
            0.000259038,
            -0.000108146,
            1.13177,
            0.903945,
            -0.00000591681,
            0.295126,
            0.0000181226,
            0.903668,
            -0.000148672,
            0.295037,
            0.000455367,
            0.903677,
            -0.000594683,
            0.29504,
            0.00182145,
            0.903673,
            -0.00133805,
            0.295039,
            0.00409831,
            0.903666,
            -0.00237872,
            0.295036,
            0.00728584,
            0.903668,
            -0.00371676,
            0.295037,
            0.0113842,
            0.903679,
            -0.00535212,
            0.29504,
            0.0163936,
            0.903684,
            -0.00728479,
            0.295041,
            0.0223141,
            0.903698,
            -0.00951473,
            0.295044,
            0.0291462,
            0.903718,
            -0.0120419,
            0.295049,
            0.0368904,
            0.903754,
            -0.0148664,
            0.295058,
            0.0455477,
            0.903801,
            -0.017988,
            0.29507,
            0.0551194,
            0.903851,
            -0.0214064,
            0.295082,
            0.0656058,
            0.903921,
            -0.0251219,
            0.295097,
            0.0770109,
            0.904002,
            -0.0291337,
            0.295116,
            0.0893354,
            0.904111,
            -0.033441,
            0.29514,
            0.102583,
            0.904246,
            -0.0380415,
            0.295169,
            0.116755,
            0.904408,
            -0.0429258,
            0.295202,
            0.131853,
            0.904637,
            -0.0480468,
            0.295245,
            0.147869,
            0.904821,
            -0.0529208,
            0.295214,
            0.164658,
            0.905163,
            -0.0577748,
            0.295185,
            0.182274,
            0.905469,
            -0.0631763,
            0.295143,
            0.200828,
            0.905851,
            -0.068917,
            0.295112,
            0.2202,
            0.906322,
            -0.0750861,
            0.295104,
            0.240372,
            0.906761,
            -0.0815855,
            0.295086,
            0.261082,
            0.90735,
            -0.0882138,
            0.295095,
            0.282123,
            0.908087,
            -0.095082,
            0.295139,
            0.303563,
            0.908826,
            -0.101488,
            0.29492,
            0.327028,
            0.909832,
            -0.107577,
            0.294577,
            0.351464,
            0.911393,
            -0.113033,
            0.294115,
            0.376497,
            0.912804,
            -0.118629,
            0.293446,
            0.402115,
            0.914081,
            -0.124232,
            0.292581,
            0.428111,
            0.91637,
            -0.129399,
            0.29166,
            0.454442,
            0.91814,
            -0.134892,
            0.290422,
            0.481024,
            0.921179,
            -0.140069,
            0.289194,
            0.507924,
            0.924544,
            -0.144431,
            0.287421,
            0.535557,
            0.927995,
            -0.147498,
            0.284867,
            0.563984,
            0.931556,
            -0.150197,
            0.281722,
            0.5923,
            0.935777,
            -0.152711,
            0.278207,
            0.620832,
            0.940869,
            -0.154836,
            0.274148,
            0.649069,
            0.945994,
            -0.155912,
            0.269057,
            0.677746,
            0.949634,
            -0.155641,
            0.262799,
            0.706293,
            0.955032,
            -0.154809,
            0.256097,
            0.734278,
            0.95917,
            -0.153678,
            0.248618,
            0.761751,
            0.962931,
            -0.151253,
            0.239794,
            0.789032,
            0.966045,
            -0.147625,
            0.230281,
            0.815422,
            0.96971,
            -0.143964,
            0.220382,
            0.841787,
            0.972747,
            -0.139464,
            0.209846,
            0.867446,
            0.975545,
            -0.133459,
            0.198189,
            0.892004,
            0.978381,
            -0.127424,
            0.186362,
            0.915458,
            0.979935,
            -0.120506,
            0.173964,
            0.937948,
            0.980948,
            -0.11282,
            0.161429,
            0.959732,
            0.982234,
            -0.104941,
            0.148557,
            0.980118,
            0.982767,
            -0.0962905,
            0.135508,
            0.999463,
            0.983544,
            -0.0873625,
            0.122338,
            1.01756,
            0.984965,
            -0.0783447,
            0.108669,
            1.03492,
            0.986233,
            -0.0684798,
            0.0949911,
            1.05087,
            0.987796,
            -0.0590867,
            0.0811386,
            1.0656,
            0.989885,
            -0.0489145,
            0.0673099,
            1.0794,
            0.991821,
            -0.0391,
            0.0535665,
            1.09174,
            0.99448,
            -0.029087,
            0.0397529,
            1.10341,
            0.996769,
            -0.019114,
            0.0261463,
            1.11383,
            0.998641,
            -0.00947007,
            0.0128731,
            1.1237,
            0.999978,
            0.000446316,
            -0.000169093,
            1.13253,
            0.888362,
            -0.00000627064,
            0.312578,
            0.0000178215,
            0.889988,
            -0.000157791,
            0.313148,
            0.000448451,
            0.889825,
            -0.000631076,
            0.313092,
            0.00179356,
            0.88984,
            -0.00141994,
            0.313097,
            0.00403554,
            0.889828,
            -0.0025243,
            0.313092,
            0.00717429,
            0.889831,
            -0.00394421,
            0.313093,
            0.0112099,
            0.889831,
            -0.00567962,
            0.313093,
            0.0161425,
            0.889844,
            -0.00773051,
            0.313096,
            0.0219724,
            0.889858,
            -0.0100968,
            0.3131,
            0.0286999,
            0.889882,
            -0.0127786,
            0.313106,
            0.0363256,
            0.889918,
            -0.0157757,
            0.313116,
            0.0448509,
            0.889967,
            -0.0190878,
            0.313129,
            0.0542758,
            0.89003,
            -0.022715,
            0.313145,
            0.0646032,
            0.890108,
            -0.0266566,
            0.313165,
            0.0758339,
            0.890218,
            -0.0309131,
            0.313193,
            0.0879729,
            0.890351,
            -0.0354819,
            0.313226,
            0.101019,
            0.89051,
            -0.0403613,
            0.313263,
            0.114979,
            0.890672,
            -0.0455385,
            0.313294,
            0.129848,
            0.890882,
            -0.0509444,
            0.313333,
            0.145616,
            0.891189,
            -0.0559657,
            0.313324,
            0.162122,
            0.891457,
            -0.0613123,
            0.313281,
            0.179524,
            0.891856,
            -0.0671488,
            0.313281,
            0.197855,
            0.892312,
            -0.0732732,
            0.313268,
            0.216991,
            0.892819,
            -0.0797865,
            0.313263,
            0.236924,
            0.893369,
            -0.0865269,
            0.313247,
            0.257433,
            0.894045,
            -0.0931592,
            0.313205,
            0.278215,
            0.894884,
            -0.100532,
            0.313276,
            0.299467,
            0.895832,
            -0.107716,
            0.313205,
            0.322276,
            0.897043,
            -0.114099,
            0.312873,
            0.34642,
            0.898515,
            -0.119941,
            0.312331,
            0.371187,
            0.900191,
            -0.126044,
            0.311731,
            0.396656,
            0.90188,
            -0.131808,
            0.310859,
            0.422488,
            0.904359,
            -0.137289,
            0.309857,
            0.448744,
            0.906923,
            -0.142991,
            0.308714,
            0.475239,
            0.910634,
            -0.148253,
            0.307465,
            0.501983,
            0.914502,
            -0.153332,
            0.305774,
            0.529254,
            0.919046,
            -0.156646,
            0.303156,
            0.557709,
            0.923194,
            -0.159612,
            0.299928,
            0.586267,
            0.928858,
            -0.162027,
            0.296245,
            0.614925,
            0.934464,
            -0.164203,
            0.291832,
            0.643187,
            0.939824,
            -0.165602,
            0.286565,
            0.671601,
            0.944582,
            -0.165383,
            0.280073,
            0.700213,
            0.949257,
            -0.164439,
            0.272891,
            0.728432,
            0.954389,
            -0.162953,
            0.264771,
            0.756082,
            0.958595,
            -0.161007,
            0.255927,
            0.78369,
            0.962138,
            -0.157243,
            0.245769,
            0.810769,
            0.966979,
            -0.152872,
            0.235127,
            0.836999,
            0.969566,
            -0.148209,
            0.22347,
            0.862684,
            0.972372,
            -0.142211,
            0.211147,
            0.887847,
            0.975916,
            -0.135458,
            0.198606,
            0.911843,
            0.978026,
            -0.128398,
            0.185498,
            0.934795,
            0.979686,
            -0.120313,
            0.17171,
            0.956787,
            0.980748,
            -0.11166,
            0.158159,
            0.978046,
            0.981622,
            -0.103035,
            0.144399,
            0.997693,
            0.982356,
            -0.0930328,
            0.13001,
            1.01642,
            0.983308,
            -0.0834627,
            0.115778,
            1.03366,
            0.985037,
            -0.0732249,
            0.101327,
            1.05014,
            0.986493,
            -0.0628145,
            0.086554,
            1.06507,
            0.988484,
            -0.0526556,
            0.0720413,
            1.07907,
            0.991051,
            -0.0415744,
            0.0571151,
            1.09189,
            0.993523,
            -0.0314275,
            0.0426643,
            1.10369,
            0.99628,
            -0.0203603,
            0.0279325,
            1.11423,
            0.998344,
            -0.0102446,
            0.0138182,
            1.12421,
            0.999997,
            0.00042612,
            -0.000193628,
            1.1333,
            0.871555,
            -0.00000660007,
            0.329176,
            0.0000174749,
            0.875255,
            -0.000166579,
            0.330571,
            0.000441051,
            0.875644,
            -0.000666394,
            0.330718,
            0.00176441,
            0.875159,
            -0.00149903,
            0.330536,
            0.00396899,
            0.87516,
            -0.00266493,
            0.330536,
            0.007056,
            0.875158,
            -0.00416393,
            0.330535,
            0.0110251,
            0.87516,
            -0.00599598,
            0.330535,
            0.0158764,
            0.875163,
            -0.00816108,
            0.330536,
            0.0216101,
            0.875174,
            -0.0106591,
            0.330538,
            0.0282266,
            0.875199,
            -0.0134899,
            0.330545,
            0.0357266,
            0.875257,
            -0.0166538,
            0.330563,
            0.0441117,
            0.875304,
            -0.0201501,
            0.330575,
            0.0533821,
            0.875373,
            -0.0239785,
            0.330595,
            0.0635395,
            0.875464,
            -0.0281389,
            0.330619,
            0.0745872,
            0.875565,
            -0.0326301,
            0.330645,
            0.0865255,
            0.875691,
            -0.0374516,
            0.330676,
            0.0993599,
            0.875897,
            -0.0425993,
            0.330733,
            0.113093,
            0.876091,
            -0.0480576,
            0.330776,
            0.127722,
            0.876353,
            -0.0537216,
            0.330826,
            0.143227,
            0.876649,
            -0.0589807,
            0.330809,
            0.159462,
            0.877034,
            -0.0647865,
            0.330819,
            0.176642,
            0.877443,
            -0.0709789,
            0.330817,
            0.194702,
            0.877956,
            -0.0774782,
            0.330832,
            0.213577,
            0.878499,
            -0.0843175,
            0.330822,
            0.233246,
            0.879144,
            -0.0912714,
            0.330804,
            0.253512,
            0.879982,
            -0.0980824,
            0.330766,
            0.274137,
            0.88097,
            -0.105823,
            0.330864,
            0.295209,
            0.882051,
            -0.113671,
            0.330896,
            0.317226,
            0.883397,
            -0.120303,
            0.330545,
            0.341068,
            0.884987,
            -0.12667,
            0.330068,
            0.365613,
            0.886789,
            -0.133118,
            0.329418,
            0.390807,
            0.889311,
            -0.139024,
            0.328683,
            0.416494,
            0.891995,
            -0.144971,
            0.327729,
            0.442618,
            0.895106,
            -0.150747,
            0.326521,
            0.469131,
            0.899527,
            -0.156283,
            0.325229,
            0.495921,
            0.90504,
            -0.161707,
            0.32378,
            0.523162,
            0.909875,
            -0.165661,
            0.32122,
            0.55092,
            0.91561,
            -0.168755,
            0.317942,
            0.579928,
            0.921225,
            -0.171193,
            0.313983,
            0.608539,
            0.927308,
            -0.17319,
            0.309636,
            0.636854,
            0.933077,
            -0.174819,
            0.304262,
            0.66523,
            0.938766,
            -0.175002,
            0.297563,
            0.693609,
            0.943667,
            -0.173946,
            0.289613,
            0.722157,
            0.949033,
            -0.172221,
            0.281227,
            0.750021,
            0.953765,
            -0.169869,
            0.271545,
            0.777466,
            0.95804,
            -0.166578,
            0.261034,
            0.804853,
            0.962302,
            -0.161761,
            0.249434,
            0.831569,
            0.966544,
            -0.156636,
            0.237484,
            0.857779,
            0.969372,
            -0.150784,
            0.224395,
            0.883051,
            0.972486,
            -0.143672,
            0.210786,
            0.907864,
            0.975853,
            -0.135772,
            0.196556,
            0.931223,
            0.977975,
            -0.127942,
            0.182307,
            0.954061,
            0.979122,
            -0.118347,
            0.167607,
            0.97531,
            0.980719,
            -0.109112,
            0.152739,
            0.995666,
            0.981223,
            -0.0991789,
            0.137932,
            1.01475,
            0.98216,
            -0.0883553,
            0.122692,
            1.03253,
            0.983379,
            -0.0780825,
            0.107493,
            1.04917,
            0.985434,
            -0.0665646,
            0.0917791,
            1.06464,
            0.987332,
            -0.0557714,
            0.0764949,
            1.07896,
            0.990004,
            -0.0442805,
            0.060721,
            1.09199,
            0.992975,
            -0.0331676,
            0.0452284,
            1.10393,
            0.995811,
            -0.0219547,
            0.0297934,
            1.11476,
            0.9982,
            -0.0107613,
            0.0146415,
            1.12484,
            1.00002,
            0.000248678,
            -0.00014555,
            1.13413,
            0.859519,
            -0.00000693595,
            0.347264,
            0.0000171673,
            0.859843,
            -0.00017503,
            0.347394,
            0.000433219,
            0.859656,
            -0.000700076,
            0.347319,
            0.00173277,
            0.859671,
            -0.00157517,
            0.347325,
            0.00389875,
            0.859669,
            -0.00280028,
            0.347324,
            0.00693112,
            0.85967,
            -0.0043754,
            0.347324,
            0.01083,
            0.859665,
            -0.00630049,
            0.347321,
            0.0155954,
            0.859685,
            -0.0085755,
            0.347328,
            0.0212278,
            0.859694,
            -0.0112003,
            0.347329,
            0.0277273,
            0.859718,
            -0.0141747,
            0.347336,
            0.0350946,
            0.85976,
            -0.0174988,
            0.347348,
            0.0433314,
            0.85982,
            -0.0211722,
            0.347366,
            0.0524384,
            0.859892,
            -0.0251941,
            0.347387,
            0.0624168,
            0.860006,
            -0.0295649,
            0.347422,
            0.0732708,
            0.860122,
            -0.0342825,
            0.347453,
            0.0849999,
            0.860282,
            -0.0393462,
            0.347499,
            0.0976102,
            0.860482,
            -0.0447513,
            0.347554,
            0.111104,
            0.860719,
            -0.0504775,
            0.347614,
            0.125479,
            0.860998,
            -0.0563577,
            0.347666,
            0.140703,
            0.861322,
            -0.0619473,
            0.347662,
            0.156681,
            0.861724,
            -0.0681277,
            0.347684,
            0.173597,
            0.862198,
            -0.0746567,
            0.347709,
            0.191371,
            0.862733,
            -0.0815234,
            0.347727,
            0.209976,
            0.863371,
            -0.0886643,
            0.347744,
            0.229351,
            0.86414,
            -0.0957908,
            0.347734,
            0.24934,
            0.865138,
            -0.102912,
            0.34772,
            0.269797,
            0.866182,
            -0.110924,
            0.3478,
            0.290654,
            0.867436,
            -0.119223,
            0.347911,
            0.312074,
            0.869087,
            -0.126197,
            0.347649,
            0.335438,
            0.870859,
            -0.133145,
            0.347222,
            0.359732,
            0.872997,
            -0.139869,
            0.346645,
            0.38467,
            0.875939,
            -0.146089,
            0.345935,
            0.41019,
            0.879012,
            -0.152334,
            0.345012,
            0.436218,
            0.883353,
            -0.15821,
            0.343924,
            0.462641,
            0.888362,
            -0.164097,
            0.342636,
            0.489449,
            0.895026,
            -0.169528,
            0.341351,
            0.516629,
            0.900753,
            -0.174408,
            0.339115,
            0.544109,
            0.906814,
            -0.17751,
            0.335809,
            0.572857,
            0.912855,
            -0.180101,
            0.331597,
            0.601554,
            0.919438,
            -0.182116,
            0.32698,
            0.630198,
            0.925962,
            -0.183494,
            0.321449,
            0.658404,
            0.931734,
            -0.184159,
            0.314595,
            0.686625,
            0.93762,
            -0.18304,
            0.306462,
            0.71531,
            0.943858,
            -0.181323,
            0.297514,
            0.744272,
            0.948662,
            -0.178683,
            0.287447,
            0.771462,
            0.953299,
            -0.175379,
            0.276166,
            0.798593,
            0.957346,
            -0.170395,
            0.263758,
            0.8256,
            0.962565,
            -0.165042,
            0.251019,
            0.852575,
            0.966075,
            -0.158655,
            0.237011,
            0.878316,
            0.969048,
            -0.151707,
            0.222518,
            0.90329,
            0.972423,
            -0.143271,
            0.207848,
            0.927745,
            0.975833,
            -0.134824,
            0.192463,
            0.950859,
            0.977629,
            -0.125444,
            0.1768,
            0.972947,
            0.978995,
            -0.114949,
            0.161033,
            0.993263,
            0.980533,
            -0.104936,
            0.145523,
            1.01337,
            0.980745,
            -0.0935577,
            0.129799,
            1.03128,
            0.981814,
            -0.0822956,
            0.113486,
            1.04825,
            0.983943,
            -0.0710082,
            0.0972925,
            1.06405,
            0.986141,
            -0.0587931,
            0.0808138,
            1.0785,
            0.988878,
            -0.0472755,
            0.0644915,
            1.09204,
            0.992132,
            -0.0349128,
            0.0478128,
            1.10413,
            0.9953,
            -0.0232407,
            0.031621,
            1.11527,
            0.998117,
            -0.0112713,
            0.0154935,
            1.12551,
            1.00003,
            0.000339743,
            -0.000195763,
            1.13504,
            0.845441,
            -0.00000729126,
            0.364305,
            0.0000169208,
            0.843588,
            -0.000183164,
            0.363506,
            0.000425067,
            0.843412,
            -0.00073253,
            0.36343,
            0.00169999,
            0.843401,
            -0.00164818,
            0.363426,
            0.00382495,
            0.843399,
            -0.00293008,
            0.363425,
            0.00679993,
            0.843401,
            -0.00457822,
            0.363425,
            0.010625,
            0.843394,
            -0.00659249,
            0.363421,
            0.0153002,
            0.843398,
            -0.00897282,
            0.363421,
            0.0208258,
            0.843415,
            -0.0117191,
            0.363426,
            0.0272024,
            0.843438,
            -0.0148312,
            0.363432,
            0.0344305,
            0.843483,
            -0.018309,
            0.363447,
            0.0425116,
            0.84356,
            -0.0221521,
            0.363472,
            0.0514471,
            0.843646,
            -0.0263597,
            0.363499,
            0.061238,
            0.843743,
            -0.0309315,
            0.363527,
            0.0718873,
            0.84388,
            -0.0358658,
            0.363569,
            0.0833969,
            0.844079,
            -0.0411624,
            0.363631,
            0.0957742,
            0.844279,
            -0.0468128,
            0.363688,
            0.109015,
            0.844549,
            -0.0527923,
            0.363761,
            0.123124,
            0.844858,
            -0.0588204,
            0.363817,
            0.138044,
            0.84522,
            -0.0647573,
            0.36383,
            0.153755,
            0.845669,
            -0.0713181,
            0.363879,
            0.170394,
            0.846155,
            -0.0781697,
            0.363908,
            0.187861,
            0.846789,
            -0.0853913,
            0.363969,
            0.206176,
            0.847502,
            -0.0928086,
            0.363999,
            0.225244,
            0.8484,
            -0.10005,
            0.363997,
            0.244926,
            0.849461,
            -0.107615,
            0.364008,
            0.265188,
            0.850562,
            -0.115814,
            0.364055,
            0.28587,
            0.851962,
            -0.124334,
            0.364179,
            0.306926,
            0.854326,
            -0.131995,
            0.364233,
            0.329605,
            0.856295,
            -0.139338,
            0.363856,
            0.35359,
            0.858857,
            -0.146346,
            0.363347,
            0.37831,
            0.862428,
            -0.152994,
            0.362807,
            0.403722,
            0.866203,
            -0.159463,
            0.361963,
            0.429537,
            0.871629,
            -0.165623,
            0.36112,
            0.456,
            0.877365,
            -0.171649,
            0.359917,
            0.482773,
            0.883744,
            -0.177151,
            0.35848,
            0.509705,
            0.890693,
            -0.182381,
            0.356523,
            0.537215,
            0.897278,
            -0.186076,
            0.3533,
            0.565493,
            0.903958,
            -0.188602,
            0.349095,
            0.594293,
            0.910908,
            -0.190755,
            0.344215,
            0.623165,
            0.918117,
            -0.192063,
            0.338606,
            0.651573,
            0.924644,
            -0.192758,
            0.331544,
            0.679869,
            0.931054,
            -0.192238,
            0.323163,
            0.708668,
            0.937303,
            -0.190035,
            0.313529,
            0.737201,
            0.943387,
            -0.187162,
            0.303152,
            0.764977,
            0.948494,
            -0.183876,
            0.29146,
            0.792683,
            0.952546,
            -0.178901,
            0.277917,
            0.819228,
            0.958077,
            -0.173173,
            0.264753,
            0.846559,
            0.962462,
            -0.16645,
            0.25002,
            0.872962,
            0.966569,
            -0.159452,
            0.234873,
            0.898729,
            0.969108,
            -0.15074,
            0.218752,
            0.923126,
            0.973072,
            -0.141523,
            0.202673,
            0.947278,
            0.975452,
            -0.132075,
            0.186326,
            0.969938,
            0.977784,
            -0.121257,
            0.169396,
            0.991325,
            0.97899,
            -0.110182,
            0.153044,
            1.01123,
            0.979777,
            -0.0989634,
            0.136485,
            1.0299,
            0.980865,
            -0.0865894,
            0.119343,
            1.04727,
            0.982432,
            -0.0746115,
            0.102452,
            1.06341,
            0.984935,
            -0.0621822,
            0.0852423,
            1.07834,
            0.987776,
            -0.0495694,
            0.0678546,
            1.092,
            0.99103,
            -0.0372386,
            0.0506917,
            1.1043,
            0.99474,
            -0.0244353,
            0.0333316,
            1.11576,
            0.997768,
            -0.0121448,
            0.0164348,
            1.12617,
            1.00003,
            0.00031774,
            -0.000169504,
            1.13598,
            0.825551,
            -0.00000756799,
            0.378425,
            0.0000165099,
            0.82664,
            -0.000190922,
            0.378923,
            0.000416504,
            0.826323,
            -0.000763495,
            0.378779,
            0.0016656,
            0.826359,
            -0.00171789,
            0.378795,
            0.00374768,
            0.82636,
            -0.00305402,
            0.378795,
            0.00666259,
            0.826368,
            -0.00477185,
            0.378798,
            0.0104104,
            0.826364,
            -0.00687131,
            0.378795,
            0.0149912,
            0.826368,
            -0.00935232,
            0.378795,
            0.0204054,
            0.826376,
            -0.0122146,
            0.378797,
            0.0266532,
            0.826399,
            -0.0154581,
            0.378803,
            0.0337355,
            0.82646,
            -0.0190825,
            0.378824,
            0.0416537,
            0.826525,
            -0.0230873,
            0.378846,
            0.0504091,
            0.826614,
            -0.0274719,
            0.378876,
            0.0600032,
            0.82674,
            -0.0322355,
            0.378917,
            0.0704393,
            0.826888,
            -0.0373766,
            0.378964,
            0.0817195,
            0.827078,
            -0.0428936,
            0.379024,
            0.0938492,
            0.827318,
            -0.0487778,
            0.379099,
            0.106828,
            0.82764,
            -0.0549935,
            0.379199,
            0.120659,
            0.827926,
            -0.0611058,
            0.379227,
            0.13526,
            0.828325,
            -0.0675054,
            0.379275,
            0.150713,
            0.828801,
            -0.0743455,
            0.379332,
            0.167034,
            0.8294,
            -0.0815523,
            0.379415,
            0.184209,
            0.830094,
            -0.0890779,
            0.379495,
            0.202203,
            0.8309,
            -0.096736,
            0.379555,
            0.220945,
            0.831943,
            -0.104135,
            0.379577,
            0.240306,
            0.833037,
            -0.112106,
            0.379604,
            0.260317,
            0.834278,
            -0.120554,
            0.379668,
            0.2808,
            0.836192,
            -0.129128,
            0.3799,
            0.301654,
            0.838671,
            -0.137541,
            0.380109,
            0.323502,
            0.840939,
            -0.14523,
            0.379809,
            0.347176,
            0.844575,
            -0.15248,
            0.379593,
            0.371706,
            0.848379,
            -0.159607,
            0.37909,
            0.39688,
            0.853616,
            -0.166267,
            0.378617,
            0.422702,
            0.858921,
            -0.172698,
            0.377746,
            0.448919,
            0.865324,
            -0.178823,
            0.376749,
            0.475661,
            0.872207,
            -0.184542,
            0.375363,
            0.502599,
            0.880018,
            -0.189836,
            0.373657,
            0.529914,
            0.88694,
            -0.194294,
            0.370673,
            0.557683,
            0.894779,
            -0.197022,
            0.36662,
            0.586848,
            0.902242,
            -0.199108,
            0.36138,
            0.615831,
            0.909914,
            -0.200398,
            0.355434,
            0.644478,
            0.917088,
            -0.20094,
            0.348173,
            0.672905,
            0.923888,
            -0.200671,
            0.339482,
            0.701327,
            0.930495,
            -0.198773,
            0.32956,
            0.730101,
            0.937247,
            -0.195394,
            0.318363,
            0.758383,
            0.943108,
            -0.191956,
            0.306323,
            0.786539,
            0.948296,
            -0.187227,
            0.292576,
            0.813637,
            0.953472,
            -0.181165,
            0.278234,
            0.840793,
            0.958485,
            -0.174119,
            0.263054,
            0.867712,
            0.962714,
            -0.166564,
            0.246756,
            0.893635,
            0.966185,
            -0.158181,
            0.229945,
            0.919028,
            0.970146,
            -0.148275,
            0.212633,
            0.943413,
            0.973491,
            -0.138157,
            0.195229,
            0.966627,
            0.975741,
            -0.127574,
            0.178048,
            0.988817,
            0.977238,
            -0.11554,
            0.160312,
            1.00924,
            0.978411,
            -0.10364,
            0.142857,
            1.02845,
            0.979811,
            -0.0913122,
            0.125317,
            1.04648,
            0.98116,
            -0.0782558,
            0.107627,
            1.06284,
            0.983543,
            -0.0655957,
            0.0895862,
            1.07798,
            0.986789,
            -0.0520411,
            0.0713756,
            1.092,
            0.990292,
            -0.0389727,
            0.053228,
            1.10484,
            0.994187,
            -0.025808,
            0.0351945,
            1.11642,
            0.997499,
            -0.0126071,
            0.0173198,
            1.12703,
            0.999999,
            0.000275604,
            -0.000148602,
            1.13674,
            0.81075,
            -0.0000078735,
            0.394456,
            0.0000161829,
            0.808692,
            -0.000198293,
            0.393453,
            0.000407564,
            0.80846,
            -0.000792877,
            0.39334,
            0.00162965,
            0.808595,
            -0.00178416,
            0.393407,
            0.00366711,
            0.808597,
            -0.00317182,
            0.393408,
            0.00651934,
            0.808598,
            -0.00495589,
            0.393408,
            0.0101866,
            0.808591,
            -0.00713627,
            0.393403,
            0.0146689,
            0.808592,
            -0.00971285,
            0.393402,
            0.0199667,
            0.80861,
            -0.0126855,
            0.393407,
            0.0260803,
            0.808633,
            -0.0160538,
            0.393413,
            0.0330107,
            0.80868,
            -0.0198175,
            0.393429,
            0.0407589,
            0.808748,
            -0.0239758,
            0.393453,
            0.0493264,
            0.808854,
            -0.0285286,
            0.39349,
            0.0587161,
            0.808992,
            -0.0334748,
            0.39354,
            0.0689304,
            0.809141,
            -0.0388116,
            0.393588,
            0.0799707,
            0.809352,
            -0.0445375,
            0.39366,
            0.0918432,
            0.809608,
            -0.0506427,
            0.393742,
            0.104549,
            0.809915,
            -0.0570708,
            0.393834,
            0.118085,
            0.810253,
            -0.0633526,
            0.393885,
            0.132377,
            0.810687,
            -0.0700966,
            0.393953,
            0.147537,
            0.811233,
            -0.0772274,
            0.394047,
            0.163543,
            0.811865,
            -0.0847629,
            0.394148,
            0.180394,
            0.812648,
            -0.0925663,
            0.394265,
            0.198051,
            0.813583,
            -0.100416,
            0.394363,
            0.216443,
            0.814683,
            -0.108119,
            0.394402,
            0.235502,
            0.815948,
            -0.11644,
            0.394489,
            0.255242,
            0.817278,
            -0.125036,
            0.394542,
            0.275441,
            0.819605,
            -0.133655,
            0.39486,
            0.296094,
            0.822256,
            -0.142682,
            0.395248,
            0.317309,
            0.825349,
            -0.150756,
            0.395241,
            0.340516,
            0.829605,
            -0.158392,
            0.395285,
            0.364819,
            0.83391,
            -0.165801,
            0.394922,
            0.389736,
            0.839808,
            -0.172677,
            0.394691,
            0.415409,
            0.845708,
            -0.179448,
            0.394006,
            0.441546,
            0.853025,
            -0.185746,
            0.393279,
            0.46832,
            0.859666,
            -0.191684,
            0.391655,
            0.495302,
            0.86789,
            -0.197146,
            0.390068,
            0.52262,
            0.875845,
            -0.201904,
            0.38727,
            0.550336,
            0.882634,
            -0.205023,
            0.382688,
            0.578825,
            0.891076,
            -0.207098,
            0.377543,
            0.608103,
            0.900589,
            -0.208474,
            0.371752,
            0.63723,
            0.90791,
            -0.209068,
            0.364016,
            0.665769,
            0.915971,
            -0.208655,
            0.355593,
            0.694428,
            0.923455,
            -0.20729,
            0.345439,
            0.723224,
            0.931514,
            -0.203821,
            0.334099,
            0.751925,
            0.937885,
            -0.19986,
            0.321069,
            0.780249,
            0.943136,
            -0.194993,
            0.306571,
            0.8077,
            0.948818,
            -0.189132,
            0.291556,
            0.83497,
            0.954433,
            -0.181617,
            0.275745,
            0.86188,
            0.959078,
            -0.173595,
            0.258695,
            0.888562,
            0.962705,
            -0.164855,
            0.240825,
            0.914008,
            0.966753,
            -0.155129,
            0.22268,
            0.939145,
            0.970704,
            -0.144241,
            0.204542,
            0.963393,
            0.973367,
            -0.133188,
            0.185927,
            0.985983,
            0.975984,
            -0.121146,
            0.167743,
            1.00704,
            0.976994,
            -0.108366,
            0.149218,
            1.02715,
            0.978485,
            -0.0956746,
            0.13131,
            1.0455,
            0.980074,
            -0.0820733,
            0.112513,
            1.06221,
            0.98225,
            -0.0684061,
            0.0938323,
            1.07782,
            0.98553,
            -0.0549503,
            0.0749508,
            1.09199,
            0.989529,
            -0.0407857,
            0.055848,
            1.10508,
            0.993536,
            -0.0271978,
            0.0368581,
            1.11684,
            0.997247,
            -0.0132716,
            0.0181845,
            1.12789,
            1,
            0.000431817,
            -0.000198809,
            1.13792,
            0.785886,
            -0.00000812608,
            0.405036,
            0.0000157669,
            0.790388,
            -0.000205278,
            0.407355,
            0.000398297,
            0.790145,
            -0.000820824,
            0.407231,
            0.00159263,
            0.790135,
            -0.00184681,
            0.407226,
            0.00358336,
            0.790119,
            -0.00328316,
            0.407218,
            0.00637039,
            0.790126,
            -0.00512988,
            0.40722,
            0.0099539,
            0.79013,
            -0.00738684,
            0.407221,
            0.0143339,
            0.790135,
            -0.0100538,
            0.407221,
            0.0195107,
            0.790134,
            -0.0131306,
            0.407217,
            0.0254848,
            0.79016,
            -0.0166169,
            0.407224,
            0.0322572,
            0.790197,
            -0.020512,
            0.407236,
            0.0398284,
            0.790273,
            -0.0248157,
            0.407263,
            0.0482014,
            0.790381,
            -0.029527,
            0.407304,
            0.0573777,
            0.790521,
            -0.0346446,
            0.407355,
            0.0673602,
            0.790704,
            -0.0401665,
            0.40742,
            0.0781522,
            0.790925,
            -0.0460896,
            0.407499,
            0.0897582,
            0.791195,
            -0.0524017,
            0.407589,
            0.10218,
            0.791522,
            -0.0590121,
            0.407691,
            0.11541,
            0.791878,
            -0.0654876,
            0.407748,
            0.12939,
            0.792361,
            -0.0725207,
            0.407849,
            0.144237,
            0.792942,
            -0.0799844,
            0.407963,
            0.159924,
            0.79362,
            -0.0877896,
            0.408087,
            0.176425,
            0.794529,
            -0.0958451,
            0.408259,
            0.193733,
            0.795521,
            -0.103827,
            0.408362,
            0.211756,
            0.796778,
            -0.111937,
            0.408482,
            0.230524,
            0.798027,
            -0.120521,
            0.408547,
            0.249967,
            0.799813,
            -0.129242,
            0.408721,
            0.269926,
            0.802387,
            -0.138048,
            0.409148,
            0.290338,
            0.805279,
            -0.147301,
            0.409641,
            0.311193,
            0.809251,
            -0.155895,
            0.410154,
            0.333611,
            0.813733,
            -0.163942,
            0.410297,
            0.357615,
            0.819081,
            -0.171666,
            0.410373,
            0.382339,
            0.825427,
            -0.178905,
            0.410348,
            0.407828,
            0.83172,
            -0.185812,
            0.409486,
            0.434034,
            0.83877,
            -0.192318,
            0.408776,
            0.460493,
            0.845817,
            -0.198249,
            0.407176,
            0.487346,
            0.854664,
            -0.204034,
            0.405719,
            0.514832,
            0.863495,
            -0.208908,
            0.403282,
            0.542401,
            0.871883,
            -0.212765,
            0.399293,
            0.570683,
            0.88065,
            -0.214911,
            0.393803,
            0.599947,
            0.89004,
            -0.216214,
            0.387536,
            0.62932,
            0.898476,
            -0.216745,
            0.379846,
            0.658319,
            0.906738,
            -0.216387,
            0.370625,
            0.687138,
            0.914844,
            -0.215053,
            0.360139,
            0.71601,
            0.923877,
            -0.212007,
            0.348849,
            0.745124,
            0.931925,
            -0.207481,
            0.335639,
            0.773366,
            0.938054,
            -0.202418,
            0.320798,
            0.801636,
            0.943895,
            -0.196507,
            0.304772,
            0.829055,
            0.949468,
            -0.189009,
            0.288033,
            0.856097,
            0.955152,
            -0.180539,
            0.270532,
            0.88301,
            0.959403,
            -0.171437,
            0.251639,
            0.909296,
            0.963309,
            -0.161661,
            0.232563,
            0.934868,
            0.967399,
            -0.150425,
            0.213231,
            0.959662,
            0.972009,
            -0.138659,
            0.194247,
            0.98302,
            0.97433,
            -0.126595,
            0.174718,
            1.00517,
            0.975823,
            -0.113205,
            0.155518,
            1.02566,
            0.976371,
            -0.0996096,
            0.136709,
            1.04418,
            0.978705,
            -0.0860754,
            0.117571,
            1.06146,
            0.981477,
            -0.0714438,
            0.0980046,
            1.07777,
            0.984263,
            -0.0572304,
            0.0782181,
            1.09214,
            0.988423,
            -0.0428875,
            0.0584052,
            1.10553,
            0.993,
            -0.0282442,
            0.038522,
            1.11758,
            0.99704,
            -0.0140183,
            0.0190148,
            1.12864,
            0.999913,
            0.000369494,
            -0.000145203,
            1.13901,
            0.777662,
            -0.0000084153,
            0.423844,
            0.0000154403,
            0.770458,
            -0.000211714,
            0.419915,
            0.00038845,
            0.770716,
            -0.000846888,
            0.420055,
            0.00155386,
            0.770982,
            -0.00190567,
            0.420202,
            0.00349653,
            0.770981,
            -0.00338782,
            0.420201,
            0.00621606,
            0.77098,
            -0.00529338,
            0.4202,
            0.00971274,
            0.770983,
            -0.00762223,
            0.4202,
            0.0139867,
            0.770985,
            -0.0103741,
            0.420198,
            0.0190381,
            0.770996,
            -0.0135489,
            0.4202,
            0.0248677,
            0.771029,
            -0.0171461,
            0.420212,
            0.0314764,
            0.771052,
            -0.0211647,
            0.420215,
            0.0388648,
            0.771131,
            -0.0256048,
            0.420245,
            0.047036,
            0.771235,
            -0.0304647,
            0.420284,
            0.0559911,
            0.771383,
            -0.0357436,
            0.420341,
            0.0657346,
            0.771591,
            -0.0414392,
            0.420423,
            0.0762694,
            0.771819,
            -0.0475462,
            0.420506,
            0.0875984,
            0.772123,
            -0.0540506,
            0.420617,
            0.099727,
            0.772464,
            -0.060797,
            0.42072,
            0.112637,
            0.772855,
            -0.0675393,
            0.420799,
            0.126313,
            0.773317,
            -0.0748323,
            0.420893,
            0.140824,
            0.773981,
            -0.0825681,
            0.421058,
            0.15617,
            0.774746,
            -0.0906307,
            0.421226,
            0.172322,
            0.77566,
            -0.0988982,
            0.421397,
            0.189253,
            0.776837,
            -0.106994,
            0.421569,
            0.206912,
            0.778097,
            -0.115528,
            0.421704,
            0.225359,
            0.779588,
            -0.124317,
            0.421849,
            0.24447,
            0.781574,
            -0.133139,
            0.422097,
            0.264156,
            0.784451,
            -0.142179,
            0.422615,
            0.284318,
            0.787682,
            -0.15165,
            0.423269,
            0.304902,
            0.792433,
            -0.160771,
            0.424396,
            0.3265,
            0.797359,
            -0.169166,
            0.424772,
            0.35014,
            0.803986,
            -0.177149,
            0.425475,
            0.374768,
            0.809504,
            -0.184745,
            0.424996,
            0.399928,
            0.815885,
            -0.19173,
            0.424247,
            0.425796,
            0.823513,
            -0.198525,
            0.423515,
            0.452287,
            0.832549,
            -0.204709,
            0.422787,
            0.479321,
            0.841653,
            -0.210447,
            0.421187,
            0.506718,
            0.850401,
            -0.215501,
            0.418519,
            0.53432,
            0.859854,
            -0.219752,
            0.414715,
            0.56242,
            0.869364,
            -0.222305,
            0.409462,
            0.591558,
            0.878837,
            -0.223744,
            0.402926,
            0.621074,
            0.888636,
            -0.224065,
            0.395043,
            0.650538,
            0.898132,
            -0.223742,
            0.38564,
            0.679538,
            0.907181,
            -0.222308,
            0.375378,
            0.708674,
            0.915621,
            -0.219837,
            0.363212,
            0.737714,
            0.9239,
            -0.215233,
            0.349313,
            0.767014,
            0.931644,
            -0.209592,
            0.334162,
            0.795133,
            0.938887,
            -0.203644,
            0.317943,
            0.823228,
            0.945282,
            -0.196349,
            0.300581,
            0.850822,
            0.950758,
            -0.18742,
            0.282195,
            0.877594,
            0.956146,
            -0.177879,
            0.262481,
            0.904564,
            0.960355,
            -0.167643,
            0.242487,
            0.930741,
            0.965256,
            -0.156671,
            0.222668,
            0.955868,
            0.968029,
            -0.144123,
            0.201907,
            0.979869,
            0.97251,
            -0.131305,
            0.18202,
            1.00291,
            0.974925,
            -0.118335,
            0.161909,
            1.02392,
            0.975402,
            -0.103714,
            0.142129,
            1.0433,
            0.976987,
            -0.089415,
            0.122447,
            1.06089,
            0.979677,
            -0.0748858,
            0.102248,
            1.07713,
            0.983184,
            -0.0596086,
            0.0814851,
            1.09218,
            0.987466,
            -0.0447671,
            0.0609484,
            1.10585,
            0.992348,
            -0.0295217,
            0.0401835,
            1.11829,
            0.996674,
            -0.0143917,
            0.0198163,
            1.12966,
            1.00003,
            0.000321364,
            -0.000149983,
            1.1402,
            0.757901,
            -0.00000869074,
            0.436176,
            0.0000151011,
            0.751195,
            -0.000217848,
            0.432317,
            0.000378533,
            0.751178,
            -0.000871373,
            0.432307,
            0.0015141,
            0.751195,
            -0.00196061,
            0.432317,
            0.0034068,
            0.751198,
            -0.00348552,
            0.432318,
            0.00605659,
            0.751195,
            -0.00544599,
            0.432315,
            0.00946353,
            0.751207,
            -0.00784203,
            0.43232,
            0.013628,
            0.751213,
            -0.0106732,
            0.43232,
            0.0185499,
            0.751221,
            -0.0139393,
            0.432319,
            0.0242302,
            0.751244,
            -0.0176398,
            0.432325,
            0.0306694,
            0.7513,
            -0.0217743,
            0.432348,
            0.0378698,
            0.751358,
            -0.0263412,
            0.432367,
            0.0458321,
            0.751458,
            -0.0313396,
            0.432404,
            0.0545587,
            0.751608,
            -0.0367682,
            0.432464,
            0.0640543,
            0.7518,
            -0.0426246,
            0.43254,
            0.0743222,
            0.752065,
            -0.0489031,
            0.432645,
            0.0853668,
            0.752376,
            -0.0555828,
            0.432762,
            0.0971911,
            0.752715,
            -0.0623861,
            0.432859,
            0.109768,
            0.753137,
            -0.069415,
            0.432958,
            0.123126,
            0.753676,
            -0.0770039,
            0.433099,
            0.137308,
            0.754345,
            -0.084971,
            0.433272,
            0.15229,
            0.755235,
            -0.0932681,
            0.433504,
            0.168075,
            0.756186,
            -0.10171,
            0.433693,
            0.184625,
            0.757363,
            -0.110019,
            0.433857,
            0.201897,
            0.75884,
            -0.11887,
            0.434102,
            0.220014,
            0.760467,
            -0.127881,
            0.434306,
            0.238778,
            0.762969,
            -0.136766,
            0.434751,
            0.258172,
            0.765823,
            -0.14612,
            0.43529,
            0.278062,
            0.769676,
            -0.15566,
            0.436236,
            0.298437,
            0.774909,
            -0.165177,
            0.437754,
            0.319532,
            0.77994,
            -0.17402,
            0.438343,
            0.342505,
            0.785757,
            -0.182201,
            0.438609,
            0.366693,
            0.792487,
            -0.190104,
            0.438762,
            0.391668,
            0.80038,
            -0.197438,
            0.438795,
            0.417494,
            0.808494,
            -0.204365,
            0.438226,
            0.443933,
            0.817695,
            -0.210714,
            0.437283,
            0.470929,
            0.828111,
            -0.216651,
            0.436087,
            0.498569,
            0.837901,
            -0.221804,
            0.433717,
            0.526165,
            0.847813,
            -0.226318,
            0.430133,
            0.554155,
            0.858314,
            -0.229297,
            0.425213,
            0.582822,
            0.868891,
            -0.230999,
            0.418576,
            0.612847,
            0.878941,
            -0.231155,
            0.410405,
            0.642445,
            0.888809,
            -0.230935,
            0.400544,
            0.672024,
            0.898089,
            -0.229343,
            0.389613,
            0.701366,
            0.908081,
            -0.226886,
            0.377197,
            0.730763,
            0.916819,
            -0.222676,
            0.363397,
            0.759642,
            0.924968,
            -0.216835,
            0.347437,
            0.788775,
            0.932906,
            -0.210245,
            0.32995,
            0.817135,
            0.940025,
            -0.202992,
            0.312262,
            0.844912,
            0.946101,
            -0.19436,
            0.293313,
            0.872164,
            0.952835,
            -0.184125,
            0.273638,
            0.899443,
            0.957347,
            -0.173657,
            0.252385,
            0.926389,
            0.961434,
            -0.162204,
            0.231038,
            0.951947,
            0.965522,
            -0.14979,
            0.209834,
            0.976751,
            0.969412,
            -0.136307,
            0.188821,
            1.00022,
            0.973902,
            -0.122527,
            0.168013,
            1.02229,
            0.974045,
            -0.108213,
            0.147634,
            1.04199,
            0.975775,
            -0.0927397,
            0.12705,
            1.06019,
            0.978383,
            -0.0778212,
            0.106309,
            1.07711,
            0.98211,
            -0.0621216,
            0.0849279,
            1.09245,
            0.986517,
            -0.0463847,
            0.0633519,
            1.10651,
            0.991696,
            -0.0309353,
            0.0419698,
            1.11903,
            0.996349,
            -0.0150914,
            0.0206272,
            1.13073,
            1.00003,
            0.000442449,
            -0.000231396,
            1.14146,
            0.727498,
            -0.00000885074,
            0.441528,
            0.0000145832,
            0.730897,
            -0.000223525,
            0.443589,
            0.000368298,
            0.730796,
            -0.000893996,
            0.443528,
            0.00147303,
            0.730805,
            -0.00201149,
            0.443533,
            0.00331433,
            0.730814,
            -0.00357596,
            0.443538,
            0.00589222,
            0.730815,
            -0.00558734,
            0.443538,
            0.00920678,
            0.730822,
            -0.00804544,
            0.44354,
            0.0132582,
            0.730836,
            -0.0109501,
            0.443545,
            0.0180468,
            0.730848,
            -0.0143008,
            0.443546,
            0.0235732,
            0.730871,
            -0.0180969,
            0.443552,
            0.0298382,
            0.730915,
            -0.022338,
            0.443567,
            0.0368438,
            0.730982,
            -0.0270225,
            0.443591,
            0.044591,
            0.731076,
            -0.0321491,
            0.443627,
            0.0530831,
            0.731245,
            -0.0377166,
            0.443699,
            0.0623243,
            0.73144,
            -0.0437216,
            0.443777,
            0.0723181,
            0.7317,
            -0.0501576,
            0.443881,
            0.0830691,
            0.732034,
            -0.0569942,
            0.444014,
            0.0945809,
            0.732388,
            -0.0638756,
            0.444113,
            0.106825,
            0.732853,
            -0.071203,
            0.444247,
            0.119859,
            0.733473,
            -0.0790076,
            0.444442,
            0.13369,
            0.734195,
            -0.0871937,
            0.444645,
            0.148304,
            0.735069,
            -0.095696,
            0.444877,
            0.163702,
            0.736169,
            -0.10426,
            0.445133,
            0.179861,
            0.73747,
            -0.112853,
            0.44537,
            0.196778,
            0.738991,
            -0.12199,
            0.445651,
            0.214496,
            0.740865,
            -0.131153,
            0.445958,
            0.232913,
            0.743637,
            -0.140245,
            0.446548,
            0.251977,
            0.746797,
            -0.149722,
            0.447246,
            0.271551,
            0.751517,
            -0.159341,
            0.448656,
            0.291774,
            0.756156,
            -0.169106,
            0.449866,
            0.312455,
            0.761519,
            -0.178436,
            0.450919,
            0.334552,
            0.768295,
            -0.186904,
            0.451776,
            0.358491,
            0.776613,
            -0.195117,
            0.452832,
            0.383446,
            0.783966,
            -0.202695,
            0.45249,
            0.408945,
            0.793542,
            -0.20985,
            0.452587,
            0.435364,
            0.803192,
            -0.216403,
            0.451852,
            0.462336,
            0.813892,
            -0.22251,
            0.450708,
            0.48987,
            0.824968,
            -0.227676,
            0.4486,
            0.517697,
            0.835859,
            -0.232443,
            0.445156,
            0.545975,
            0.846825,
            -0.235775,
            0.440351,
            0.574483,
            0.858085,
            -0.237897,
            0.433641,
            0.604246,
            0.868825,
            -0.238074,
            0.425354,
            0.634101,
            0.879638,
            -0.237661,
            0.415383,
            0.664201,
            0.889966,
            -0.236186,
            0.404136,
            0.693918,
            0.899479,
            -0.233599,
            0.390917,
            0.723481,
            0.908769,
            -0.229737,
            0.376352,
            0.75258,
            0.917966,
            -0.223836,
            0.360372,
            0.781764,
            0.926304,
            -0.217067,
            0.342551,
            0.811139,
            0.934626,
            -0.209309,
            0.324238,
            0.839585,
            0.941841,
            -0.20071,
            0.304484,
            0.867044,
            0.94789,
            -0.190602,
            0.283607,
            0.894579,
            0.954196,
            -0.179253,
            0.262205,
            0.921743,
            0.958383,
            -0.167646,
            0.239847,
            0.948026,
            0.963119,
            -0.155073,
            0.218078,
            0.973296,
            0.966941,
            -0.141426,
            0.195899,
            0.998135,
            0.970836,
            -0.126849,
            0.174121,
            1.02021,
            0.973301,
            -0.112296,
            0.153052,
            1.04085,
            0.97448,
            -0.0964965,
            0.131733,
            1.05946,
            0.977045,
            -0.080489,
            0.10997,
            1.07693,
            0.980751,
            -0.064844,
            0.0881657,
            1.09254,
            0.985475,
            -0.0481938,
            0.0657987,
            1.10697,
            0.991089,
            -0.0319185,
            0.0435215,
            1.12004,
            0.996122,
            -0.0158088,
            0.0214779,
            1.13173,
            1.00001,
            0.000372455,
            -0.000200295,
            1.14291,
            0.708622,
            -0.00000907597,
            0.45304,
            0.0000141962,
            0.711162,
            -0.000228911,
            0.454662,
            0.000358052,
            0.709812,
            -0.000914446,
            0.453797,
            0.00143034,
            0.709865,
            -0.00205819,
            0.453834,
            0.00321935,
            0.709864,
            -0.00365894,
            0.453833,
            0.00572331,
            0.709855,
            -0.00571692,
            0.453826,
            0.00894278,
            0.709862,
            -0.00823201,
            0.453828,
            0.012878,
            0.709875,
            -0.011204,
            0.453832,
            0.0175295,
            0.709896,
            -0.0146323,
            0.453839,
            0.0228978,
            0.709925,
            -0.0185163,
            0.453847,
            0.0289839,
            0.709974,
            -0.0228551,
            0.453866,
            0.0357894,
            0.710045,
            -0.0276473,
            0.453892,
            0.0433161,
            0.710133,
            -0.032891,
            0.453924,
            0.0515665,
            0.710292,
            -0.0385851,
            0.453992,
            0.0605458,
            0.710485,
            -0.0447254,
            0.45407,
            0.0702574,
            0.710769,
            -0.0513051,
            0.454192,
            0.0807077,
            0.711106,
            -0.0582733,
            0.454329,
            0.091896,
            0.711516,
            -0.0652866,
            0.45446,
            0.103814,
            0.712071,
            -0.0728426,
            0.454653,
            0.116508,
            0.712676,
            -0.0808307,
            0.45484,
            0.129968,
            0.713476,
            -0.0892216,
            0.455096,
            0.144206,
            0.714377,
            -0.0979047,
            0.455346,
            0.159212,
            0.715579,
            -0.106531,
            0.455647,
            0.174973,
            0.716977,
            -0.115492,
            0.455961,
            0.191504,
            0.71862,
            -0.124821,
            0.456315,
            0.208835,
            0.72084,
            -0.134079,
            0.4568,
            0.226869,
            0.723786,
            -0.143427,
            0.457521,
            0.245582,
            0.727464,
            -0.153061,
            0.458475,
            0.264957,
            0.732771,
            -0.162768,
            0.460239,
            0.284948,
            0.736515,
            -0.172627,
            0.460899,
            0.30522,
            0.743519,
            -0.182487,
            0.463225,
            0.326717,
            0.750041,
            -0.191295,
            0.464027,
            0.350113,
            0.758589,
            -0.199746,
            0.465227,
            0.374782,
            0.767703,
            -0.207584,
            0.465877,
            0.400226,
            0.777484,
            -0.214973,
            0.465996,
            0.426442,
            0.788792,
            -0.221796,
            0.466019,
            0.453688,
            0.800194,
            -0.228038,
            0.465083,
            0.481246,
            0.811234,
            -0.233346,
            0.462506,
            0.509086,
            0.822859,
            -0.238073,
            0.459257,
            0.537338,
            0.835082,
            -0.241764,
            0.454863,
            0.566108,
            0.846332,
            -0.244241,
            0.448163,
            0.595126,
            0.858355,
            -0.244736,
            0.439709,
            0.625574,
            0.87034,
            -0.244278,
            0.429837,
            0.65617,
            0.881027,
            -0.24255,
            0.418002,
            0.686029,
            0.891007,
            -0.239912,
            0.404325,
            0.716039,
            0.900874,
            -0.236133,
            0.389222,
            0.745518,
            0.911072,
            -0.230672,
            0.373269,
            0.775026,
            0.920359,
            -0.22356,
            0.355083,
            0.804521,
            0.928604,
            -0.215591,
            0.335533,
            0.834045,
            0.937175,
            -0.206503,
            0.315278,
            0.861612,
            0.942825,
            -0.196684,
            0.293653,
            0.889131,
            0.949805,
            -0.185116,
            0.271503,
            0.916853,
            0.955535,
            -0.172703,
            0.248821,
            0.943541,
            0.959843,
            -0.159978,
            0.225591,
            0.970132,
            0.964393,
            -0.146375,
            0.202719,
            0.994709,
            0.968008,
            -0.131269,
            0.179928,
            1.0186,
            0.971013,
            -0.11569,
            0.158007,
            1.03928,
            0.973334,
            -0.1003,
            0.13624,
            1.05887,
            0.975775,
            -0.0833352,
            0.1138,
            1.07652,
            0.979579,
            -0.0668981,
            0.0913141,
            1.09297,
            0.984323,
            -0.0500902,
            0.0683051,
            1.10734,
            0.990351,
            -0.0332377,
            0.0451771,
            1.12084,
            0.995823,
            -0.0161491,
            0.0221705,
            1.13296,
            1.0001,
            0.000234083,
            -0.000108712,
            1.14441,
            0.683895,
            -0.00000924677,
            0.46015,
            0.0000137429,
            0.68833,
            -0.000233383,
            0.463134,
            0.000346865,
            0.688368,
            -0.000933547,
            0.463159,
            0.00138748,
            0.688367,
            -0.00210049,
            0.463159,
            0.00312187,
            0.688369,
            -0.00373415,
            0.463159,
            0.00555004,
            0.688377,
            -0.00583449,
            0.463163,
            0.00867216,
            0.688386,
            -0.00840128,
            0.463166,
            0.0124884,
            0.688398,
            -0.0114343,
            0.463169,
            0.0169993,
            0.688418,
            -0.0149329,
            0.463175,
            0.0222054,
            0.688453,
            -0.0188964,
            0.463188,
            0.028108,
            0.688515,
            -0.0233239,
            0.463214,
            0.0347085,
            0.68857,
            -0.0282136,
            0.463231,
            0.0420091,
            0.688679,
            -0.033564,
            0.463276,
            0.0500132,
            0.688854,
            -0.0393733,
            0.463356,
            0.0587255,
            0.689038,
            -0.0456354,
            0.46343,
            0.0681476,
            0.689321,
            -0.0523433,
            0.463553,
            0.0782897,
            0.689662,
            -0.059412,
            0.463693,
            0.0891501,
            0.690188,
            -0.0665736,
            0.4639,
            0.100735,
            0.690755,
            -0.0743106,
            0.464107,
            0.113074,
            0.691405,
            -0.0824722,
            0.464329,
            0.126161,
            0.692198,
            -0.0910484,
            0.464585,
            0.140007,
            0.693196,
            -0.0998778,
            0.464893,
            0.154612,
            0.69454,
            -0.108651,
            0.465285,
            0.169984,
            0.695921,
            -0.117855,
            0.465596,
            0.186106,
            0.697749,
            -0.12734,
            0.466056,
            0.203034,
            0.700375,
            -0.136714,
            0.466771,
            0.220703,
            0.703395,
            -0.146386,
            0.467579,
            0.239062,
            0.707904,
            -0.156096,
            0.469067,
            0.258188,
            0.711673,
            -0.165904,
            0.469851,
            0.277759,
            0.717489,
            -0.175812,
            0.471815,
            0.297935,
            0.724051,
            -0.185931,
            0.47389,
            0.318916,
            0.731965,
            -0.195238,
            0.47587,
            0.341591,
            0.741151,
            -0.204021,
            0.477523,
            0.366062,
            0.751416,
            -0.212113,
            0.478881,
            0.391396,
            0.761848,
            -0.21979,
            0.479226,
            0.417599,
            0.771886,
            -0.2267,
            0.478495,
            0.444401,
            0.783998,
            -0.232991,
            0.477622,
            0.472084,
            0.796523,
            -0.238645,
            0.475833,
            0.500193,
            0.808851,
            -0.243396,
            0.472568,
            0.52865,
            0.821191,
            -0.247226,
            0.467857,
            0.557362,
            0.834261,
            -0.250102,
            0.461871,
            0.586768,
            0.846762,
            -0.251056,
            0.453543,
            0.617085,
            0.859867,
            -0.250604,
            0.443494,
            0.647659,
            0.871948,
            -0.248783,
            0.431711,
            0.678119,
            0.882967,
            -0.245855,
            0.417911,
            0.708399,
            0.892826,
            -0.242168,
            0.401993,
            0.738256,
            0.90332,
            -0.237062,
            0.385371,
            0.767999,
            0.913633,
            -0.22997,
            0.366837,
            0.798191,
            0.922774,
            -0.221687,
            0.346372,
            0.827756,
            0.931371,
            -0.212345,
            0.325682,
            0.856425,
            0.938929,
            -0.20206,
            0.303665,
            0.884299,
            0.944821,
            -0.190981,
            0.280786,
            0.912023,
            0.951792,
            -0.178065,
            0.2573,
            0.939669,
            0.957712,
            -0.164634,
            0.233448,
            0.96655,
            0.961912,
            -0.150863,
            0.209504,
            0.992366,
            0.966382,
            -0.13577,
            0.18597,
            1.01633,
            0.969588,
            -0.119593,
            0.162905,
            1.03843,
            0.971777,
            -0.103203,
            0.14053,
            1.05841,
            0.97433,
            -0.0865888,
            0.117909,
            1.07632,
            0.978686,
            -0.0690829,
            0.0944101,
            1.09326,
            0.983281,
            -0.0516568,
            0.0705671,
            1.10796,
            0.989562,
            -0.034558,
            0.0468592,
            1.12182,
            0.995465,
            -0.0167808,
            0.0229846,
            1.1342,
            0.999991,
            0.000373016,
            -0.000235606,
            1.1459,
            0.662251,
            -0.00000939016,
            0.468575,
            0.0000132714,
            0.666634,
            -0.000237624,
            0.471675,
            0.000335842,
            0.666411,
            -0.000950385,
            0.471516,
            0.00134321,
            0.666399,
            -0.00213833,
            0.471509,
            0.00302221,
            0.666386,
            -0.0038014,
            0.471499,
            0.00537283,
            0.666405,
            -0.00593958,
            0.471511,
            0.00839533,
            0.666406,
            -0.00855253,
            0.471508,
            0.0120898,
            0.666428,
            -0.0116401,
            0.471519,
            0.0164569,
            0.666444,
            -0.0152015,
            0.471522,
            0.0214971,
            0.66649,
            -0.0192362,
            0.471543,
            0.027212,
            0.666537,
            -0.0237428,
            0.471558,
            0.033603,
            0.666617,
            -0.0287198,
            0.471591,
            0.0406728,
            0.666718,
            -0.0341647,
            0.471631,
            0.0484238,
            0.666889,
            -0.0400759,
            0.47171,
            0.0568621,
            0.667104,
            -0.0464479,
            0.471805,
            0.0659915,
            0.667374,
            -0.0532677,
            0.471923,
            0.0758178,
            0.667772,
            -0.0603805,
            0.472098,
            0.0863425,
            0.668371,
            -0.0677392,
            0.472363,
            0.0975917,
            0.668971,
            -0.0756028,
            0.472596,
            0.109567,
            0.669696,
            -0.0839293,
            0.472869,
            0.122272,
            0.670481,
            -0.0926683,
            0.473126,
            0.135718,
            0.6715,
            -0.1016,
            0.473442,
            0.149914,
            0.672911,
            -0.110566,
            0.47389,
            0.164882,
            0.674512,
            -0.119984,
            0.474354,
            0.180602,
            0.67651,
            -0.129574,
            0.474922,
            0.19711,
            0.679292,
            -0.139106,
            0.475764,
            0.214371,
            0.682798,
            -0.148993,
            0.476886,
            0.232405,
            0.686955,
            -0.158737,
            0.478179,
            0.251153,
            0.691406,
            -0.168754,
            0.479432,
            0.270436,
            0.697438,
            -0.178703,
            0.481481,
            0.290374,
            0.704761,
            -0.188955,
            0.484143,
            0.311044,
            0.713599,
            -0.198814,
            0.487007,
            0.333003,
            0.723194,
            -0.207869,
            0.488962,
            0.357144,
            0.732601,
            -0.216189,
            0.489815,
            0.382169,
            0.744193,
            -0.22398,
            0.490888,
            0.408227,
            0.754907,
            -0.231156,
            0.490355,
            0.434928,
            0.767403,
            -0.23747,
            0.489548,
            0.462599,
            0.78107,
            -0.243503,
            0.488274,
            0.490908,
            0.793893,
            -0.248114,
            0.484843,
            0.519421,
            0.807296,
            -0.25222,
            0.4803,
            0.548561,
            0.820529,
            -0.255265,
            0.474097,
            0.577772,
            0.833716,
            -0.256741,
            0.466041,
            0.607782,
            0.848403,
            -0.25637,
            0.456547,
            0.638807,
            0.860755,
            -0.254804,
            0.443946,
            0.670058,
            0.874012,
            -0.251834,
            0.430852,
            0.700749,
            0.885619,
            -0.247867,
            0.414903,
            0.731446,
            0.896069,
            -0.242634,
            0.397276,
            0.761191,
            0.906266,
            -0.236093,
            0.378535,
            0.791053,
            0.916759,
            -0.227543,
            0.358038,
            0.821298,
            0.92523,
            -0.21783,
            0.335705,
            0.850747,
            0.93436,
            -0.207534,
            0.313797,
            0.879258,
            0.941631,
            -0.195983,
            0.289671,
            0.907734,
            0.947564,
            -0.183567,
            0.265319,
            0.935206,
            0.953681,
            -0.169345,
            0.240815,
            0.962739,
            0.960008,
            -0.154909,
            0.216119,
            0.989227,
            0.964145,
            -0.140161,
            0.192096,
            1.01465,
            0.968171,
            -0.123411,
            0.167855,
            1.03737,
            0.969859,
            -0.106525,
            0.144817,
            1.05767,
            0.972666,
            -0.0891023,
            0.12149,
            1.0761,
            0.977055,
            -0.0718094,
            0.0975306,
            1.09336,
            0.982527,
            -0.0534213,
            0.0730217,
            1.10878,
            0.989001,
            -0.0355579,
            0.0483366,
            1.12285,
            0.99512,
            -0.0176383,
            0.023938,
            1.13548,
            1.00007,
            0.000368831,
            -0.000211581,
            1.14744,
            0.651047,
            -0.00000960845,
            0.484101,
            0.000012922,
            0.644145,
            -0.000241347,
            0.478968,
            0.000324578,
            0.64396,
            -0.000965142,
            0.478831,
            0.00129798,
            0.64396,
            -0.00217154,
            0.47883,
            0.00292046,
            0.643968,
            -0.00386049,
            0.478835,
            0.00519202,
            0.643974,
            -0.00603186,
            0.478838,
            0.0081128,
            0.643977,
            -0.0086854,
            0.478836,
            0.011683,
            0.643982,
            -0.0118207,
            0.478834,
            0.0159031,
            0.644024,
            -0.0154374,
            0.478856,
            0.0207743,
            0.644059,
            -0.0195343,
            0.478868,
            0.0262975,
            0.644122,
            -0.0241103,
            0.478896,
            0.0324747,
            0.644207,
            -0.0291638,
            0.478933,
            0.039309,
            0.64432,
            -0.0346919,
            0.478981,
            0.0468029,
            0.644481,
            -0.0406919,
            0.479053,
            0.0549614,
            0.644722,
            -0.047159,
            0.479169,
            0.0637909,
            0.645013,
            -0.0540748,
            0.479302,
            0.0732974,
            0.645503,
            -0.0612001,
            0.479541,
            0.0834898,
            0.646117,
            -0.0687303,
            0.479829,
            0.0943873,
            0.646707,
            -0.0767846,
            0.480061,
            0.105991,
            0.647431,
            -0.0852465,
            0.480343,
            0.11831,
            0.64831,
            -0.0940719,
            0.48066,
            0.131348,
            0.649486,
            -0.103056,
            0.481083,
            0.14514,
            0.650864,
            -0.112261,
            0.481528,
            0.159676,
            0.652604,
            -0.121852,
            0.482102,
            0.174979,
            0.654825,
            -0.131505,
            0.482813,
            0.191079,
            0.657876,
            -0.141189,
            0.483876,
            0.207927,
            0.661339,
            -0.151239,
            0.48499,
            0.225586,
            0.665463,
            -0.161091,
            0.486279,
            0.243947,
            0.670542,
            -0.171235,
            0.487968,
            0.262957,
            0.677361,
            -0.181347,
            0.49053,
            0.282781,
            0.685672,
            -0.191679,
            0.493862,
            0.303311,
            0.694551,
            -0.201781,
            0.49699,
            0.324607,
            0.703753,
            -0.211164,
            0.498884,
            0.347916,
            0.713703,
            -0.219675,
            0.500086,
            0.372628,
            0.725911,
            -0.227836,
            0.501554,
            0.398694,
            0.73862,
            -0.23533,
            0.502193,
            0.425529,
            0.752118,
            -0.241786,
            0.501811,
            0.453209,
            0.76579,
            -0.247865,
            0.500185,
            0.481381,
            0.779568,
            -0.252696,
            0.497159,
            0.51011,
            0.793991,
            -0.256802,
            0.492765,
            0.539322,
            0.808182,
            -0.259942,
            0.486827,
            0.569078,
            0.821698,
            -0.261703,
            0.478386,
            0.598818,
            0.836009,
            -0.262006,
            0.468772,
            0.629762,
            0.849824,
            -0.260333,
            0.456352,
            0.661366,
            0.863888,
            -0.257398,
            0.442533,
            0.69295,
            0.876585,
            -0.253264,
            0.426573,
            0.723608,
            0.888665,
            -0.248026,
            0.408964,
            0.754378,
            0.899537,
            -0.241487,
            0.389677,
            0.784761,
            0.9094,
            -0.233463,
            0.368516,
            0.814688,
            0.920166,
            -0.223397,
            0.346624,
            0.845009,
            0.928899,
            -0.21255,
            0.322717,
            0.874431,
            0.937156,
            -0.200869,
            0.298698,
            0.902922,
            0.943861,
            -0.188387,
            0.273491,
            0.931356,
            0.949557,
            -0.174341,
            0.247866,
            0.958854,
            0.955862,
            -0.158994,
            0.222496,
            0.986098,
            0.961721,
            -0.143664,
            0.197522,
            1.01229,
            0.965976,
            -0.127412,
            0.17302,
            1.03571,
            0.968652,
            -0.109798,
            0.148954,
            1.05699,
            0.971084,
            -0.0916787,
            0.125044,
            1.07587,
            0.975584,
            -0.0739634,
            0.100577,
            1.09372,
            0.98122,
            -0.055322,
            0.0753666,
            1.10948,
            0.988253,
            -0.0366825,
            0.0498899,
            1.12394,
            0.99482,
            -0.0180389,
            0.024611,
            1.13694,
            1.00001,
            0.000229839,
            -0.000188283,
            1.14919,
            0.613867,
            -0.00000964198,
            0.479449,
            0.0000123452,
            0.621485,
            -0.000244534,
            0.485399,
            0.000313091,
            0.621429,
            -0.000978202,
            0.485353,
            0.00125245,
            0.62112,
            -0.00220004,
            0.485114,
            0.00281687,
            0.621119,
            -0.0039111,
            0.485112,
            0.00500783,
            0.621122,
            -0.00611091,
            0.485112,
            0.00782498,
            0.621133,
            -0.00879922,
            0.485117,
            0.0112687,
            0.621152,
            -0.0119756,
            0.485125,
            0.0153394,
            0.621183,
            -0.0156396,
            0.485139,
            0.0200382,
            0.621227,
            -0.0197898,
            0.485158,
            0.0253663,
            0.621298,
            -0.0244253,
            0.485192,
            0.0313261,
            0.621388,
            -0.0295441,
            0.485233,
            0.0379204,
            0.621507,
            -0.0351432,
            0.485286,
            0.0451523,
            0.621693,
            -0.0412198,
            0.485378,
            0.0530277,
            0.621933,
            -0.0477673,
            0.485495,
            0.0615522,
            0.622232,
            -0.0547574,
            0.485635,
            0.0707316,
            0.622809,
            -0.0619417,
            0.485943,
            0.0805883,
            0.623407,
            -0.069625,
            0.486232,
            0.0911267,
            0.62406,
            -0.077796,
            0.486516,
            0.102354,
            0.624835,
            -0.0863731,
            0.486838,
            0.114279,
            0.625758,
            -0.095251,
            0.487188,
            0.126902,
            0.627043,
            -0.104299,
            0.487695,
            0.140285,
            0.628438,
            -0.113724,
            0.488163,
            0.154397,
            0.630325,
            -0.123417,
            0.488858,
            0.169267,
            0.632801,
            -0.133137,
            0.489754,
            0.184941,
            0.635784,
            -0.143052,
            0.490815,
            0.20136,
            0.639406,
            -0.153132,
            0.492048,
            0.218643,
            0.643872,
            -0.163143,
            0.49363,
            0.236615,
            0.6499,
            -0.17333,
            0.496009,
            0.255449,
            0.657201,
            -0.183622,
            0.498994,
            0.275006,
            0.666221,
            -0.194019,
            0.502888,
            0.295354,
            0.674419,
            -0.204192,
            0.505459,
            0.316244,
            0.683729,
            -0.21406,
            0.507771,
            0.33849,
            0.695584,
            -0.222854,
            0.510245,
            0.363166,
            0.708583,
            -0.231315,
            0.512293,
            0.389071,
            0.721233,
            -0.238911,
            0.512747,
            0.415737,
            0.735134,
            -0.245657,
            0.512482,
            0.443331,
            0.750179,
            -0.251879,
            0.511526,
            0.471891,
            0.765073,
            -0.256911,
            0.508935,
            0.500892,
            0.779794,
            -0.261144,
            0.504341,
            0.530294,
            0.794801,
            -0.264316,
            0.498515,
            0.560144,
            0.810339,
            -0.266276,
            0.491015,
            0.590213,
            0.824818,
            -0.266981,
            0.481126,
            0.620865,
            0.839375,
            -0.265778,
            0.468685,
            0.652687,
            0.853043,
            -0.262748,
            0.453925,
            0.684759,
            0.867335,
            -0.258474,
            0.437912,
            0.716209,
            0.88037,
            -0.253187,
            0.419648,
            0.747508,
            0.891711,
            -0.246476,
            0.39982,
            0.77797,
            0.902896,
            -0.238735,
            0.37879,
            0.808586,
            0.913601,
            -0.22885,
            0.355891,
            0.838843,
            0.923019,
            -0.217656,
            0.331773,
            0.869014,
            0.933432,
            -0.205539,
            0.307356,
            0.898512,
            0.939691,
            -0.192595,
            0.281321,
            0.9269,
            0.946938,
            -0.178945,
            0.255441,
            0.955297,
            0.952372,
            -0.163587,
            0.229013,
            0.983231,
            0.95909,
            -0.147214,
            0.203179,
            1.00971,
            0.963675,
            -0.13064,
            0.17792,
            1.03438,
            0.968247,
            -0.113121,
            0.152898,
            1.05625,
            0.97001,
            -0.0945824,
            0.128712,
            1.07598,
            0.974458,
            -0.0755648,
            0.103349,
            1.094,
            0.980168,
            -0.0571998,
            0.0776731,
            1.1104,
            0.987295,
            -0.0377994,
            0.0514445,
            1.12491,
            0.994432,
            -0.0186417,
            0.025429,
            1.13851,
            0.999975,
            0.000542714,
            -0.000282356,
            1.15108,
            0.592656,
            -0.00000980249,
            0.486018,
            0.0000119532,
            0.598467,
            -0.000247275,
            0.490781,
            0.000301531,
            0.597934,
            -0.000988317,
            0.490343,
            0.00120517,
            0.597903,
            -0.00222366,
            0.490319,
            0.0027116,
            0.597913,
            -0.00395315,
            0.490327,
            0.00482077,
            0.597919,
            -0.00617653,
            0.490329,
            0.00753264,
            0.597936,
            -0.00889375,
            0.490339,
            0.0108478,
            0.597956,
            -0.0121043,
            0.490347,
            0.0147668,
            0.597992,
            -0.0158073,
            0.490365,
            0.0192905,
            0.598032,
            -0.0200017,
            0.490382,
            0.0244204,
            0.598109,
            -0.0246865,
            0.49042,
            0.0301593,
            0.598215,
            -0.0298594,
            0.490474,
            0.03651,
            0.59833,
            -0.0355167,
            0.490524,
            0.0434757,
            0.598525,
            -0.0416559,
            0.490624,
            0.0510629,
            0.598778,
            -0.0482692,
            0.490753,
            0.0592781,
            0.599135,
            -0.0553114,
            0.49094,
            0.0681304,
            0.599802,
            -0.062542,
            0.491328,
            0.0776467,
            0.600361,
            -0.0703638,
            0.491598,
            0.0878184,
            0.60101,
            -0.0786256,
            0.491882,
            0.0986573,
            0.601811,
            -0.0872962,
            0.492232,
            0.11018,
            0.602861,
            -0.0962284,
            0.492684,
            0.1224,
            0.604167,
            -0.10538,
            0.493213,
            0.135354,
            0.605693,
            -0.114896,
            0.493799,
            0.149034,
            0.607682,
            -0.124654,
            0.494576,
            0.163469,
            0.610672,
            -0.13456,
            0.4959,
            0.178747,
            0.613313,
            -0.144581,
            0.496713,
            0.194723,
            0.617603,
            -0.154703,
            0.498499,
            0.211617,
            0.622174,
            -0.16489,
            0.500188,
            0.229183,
            0.628855,
            -0.175164,
            0.503072,
            0.247786,
            0.636963,
            -0.185565,
            0.506798,
            0.267116,
            0.644866,
            -0.195911,
            0.509719,
            0.28702,
            0.653741,
            -0.206104,
            0.512776,
            0.307763,
            0.664942,
            -0.216447,
            0.516812,
            0.329631,
            0.67633,
            -0.22552,
            0.519181,
            0.353515,
            0.690012,
            -0.234316,
            0.521681,
            0.379226,
            0.704243,
            -0.242032,
            0.523129,
            0.405901,
            0.719396,
            -0.249172,
            0.523768,
            0.433585,
            0.734471,
            -0.255543,
            0.522541,
            0.462085,
            0.750539,
            -0.260697,
            0.520217,
            0.491233,
            0.766365,
            -0.26501,
            0.516293,
            0.521094,
            0.781677,
            -0.268409,
            0.509708,
            0.551014,
            0.797132,
            -0.270399,
            0.501944,
            0.581463,
            0.812655,
            -0.271247,
            0.492025,
            0.612402,
            0.828592,
            -0.270708,
            0.480424,
            0.643798,
            0.844044,
            -0.268085,
            0.465955,
            0.67682,
            0.857305,
            -0.263459,
            0.448425,
            0.708496,
            0.87114,
            -0.258151,
            0.430243,
            0.74046,
            0.884936,
            -0.251171,
            0.410578,
            0.771583,
            0.895772,
            -0.243305,
            0.38862,
            0.802234,
            0.906961,
            -0.234037,
            0.365214,
            0.833179,
            0.917775,
            -0.222714,
            0.34116,
            0.86353,
            0.927883,
            -0.210175,
            0.31572,
            0.893557,
            0.936617,
            -0.196925,
            0.289159,
            0.922976,
            0.943384,
            -0.182788,
            0.261996,
            0.951606,
            0.949713,
            -0.167965,
            0.235324,
            0.979958,
            0.955818,
            -0.151109,
            0.208408,
            1.00765,
            0.961344,
            -0.133834,
            0.182591,
            1.03329,
            0.965469,
            -0.115987,
            0.156958,
            1.0557,
            0.968693,
            -0.09746,
            0.132239,
            1.07583,
            0.973165,
            -0.0778514,
            0.106195,
            1.09451,
            0.979387,
            -0.0585067,
            0.0797669,
            1.11137,
            0.98671,
            -0.0390409,
            0.0530263,
            1.12643,
            0.994093,
            -0.019408,
            0.0263163,
            1.14016,
            1.00002,
            0.000540029,
            -0.000194487,
            1.15299,
            0.574483,
            -0.00000989066,
            0.494533,
            0.0000114896,
            0.574478,
            -0.000249127,
            0.494528,
            0.000289403,
            0.574607,
            -0.000996811,
            0.494637,
            0.00115797,
            0.574396,
            -0.00224241,
            0.494458,
            0.00260498,
            0.574377,
            -0.00398632,
            0.49444,
            0.00463102,
            0.574386,
            -0.00622836,
            0.494445,
            0.00723623,
            0.574401,
            -0.0089683,
            0.494453,
            0.010421,
            0.574419,
            -0.0122056,
            0.49446,
            0.0141859,
            0.574459,
            -0.0159396,
            0.494481,
            0.0185322,
            0.574525,
            -0.0201692,
            0.49452,
            0.0234617,
            0.574587,
            -0.0248924,
            0.494547,
            0.0289762,
            0.574697,
            -0.0301074,
            0.494604,
            0.0350797,
            0.574853,
            -0.0358114,
            0.494688,
            0.0417767,
            0.575027,
            -0.041999,
            0.494772,
            0.0490718,
            0.575294,
            -0.0486618,
            0.494915,
            0.0569728,
            0.575733,
            -0.0557148,
            0.495173,
            0.0654955,
            0.576356,
            -0.0630489,
            0.495537,
            0.0746612,
            0.576944,
            -0.0709285,
            0.495836,
            0.0844615,
            0.57765,
            -0.0792723,
            0.496177,
            0.0949142,
            0.578491,
            -0.0880167,
            0.496563,
            0.10603,
            0.579639,
            -0.0969462,
            0.497096,
            0.117841,
            0.580989,
            -0.10622,
            0.497684,
            0.130367,
            0.582587,
            -0.115861,
            0.498337,
            0.143609,
            0.584951,
            -0.125605,
            0.499414,
            0.157625,
            0.587602,
            -0.135608,
            0.500518,
            0.172413,
            0.59076,
            -0.145742,
            0.501767,
            0.187999,
            0.594992,
            -0.155934,
            0.503542,
            0.20445,
            0.600656,
            -0.166303,
            0.506135,
            0.221764,
            0.607816,
            -0.176681,
            0.509542,
            0.24002,
            0.61522,
            -0.187071,
            0.51263,
            0.258992,
            0.623702,
            -0.197465,
            0.516021,
            0.278773,
            0.634192,
            -0.207816,
            0.520422,
            0.299377,
            0.644936,
            -0.218183,
            0.524073,
            0.320802,
            0.657888,
            -0.2278,
            0.528049,
            0.34384,
            0.670666,
            -0.236747,
            0.52986,
            0.36916,
            0.685626,
            -0.24484,
            0.531892,
            0.395867,
            0.701304,
            -0.252071,
            0.532727,
            0.423488,
            0.717727,
            -0.258714,
            0.532146,
            0.452201,
            0.733914,
            -0.264211,
            0.529883,
            0.481579,
            0.750529,
            -0.26859,
            0.5259,
            0.511558,
            0.76747,
            -0.272046,
            0.51999,
            0.542042,
            0.785189,
            -0.274225,
            0.513083,
            0.572799,
            0.800954,
            -0.275189,
            0.502936,
            0.603816,
            0.816962,
            -0.274946,
            0.490921,
            0.635461,
            0.83336,
            -0.272695,
            0.47684,
            0.6676,
            0.848143,
            -0.268223,
            0.459405,
            0.70051,
            0.861818,
            -0.262768,
            0.440319,
            0.732902,
            0.876828,
            -0.255872,
            0.420123,
            0.765084,
            0.889312,
            -0.247703,
            0.398379,
            0.796391,
            0.900412,
            -0.238381,
            0.374496,
            0.827333,
            0.912251,
            -0.227783,
            0.349874,
            0.858385,
            0.921792,
            -0.214832,
            0.323181,
            0.888652,
            0.931273,
            -0.200949,
            0.296624,
            0.917763,
            0.940295,
            -0.186537,
            0.269211,
            0.947878,
            0.946812,
            -0.171538,
            0.241447,
            0.977016,
            0.953588,
            -0.155254,
            0.213829,
            1.00501,
            0.958841,
            -0.137156,
            0.186807,
            1.03179,
            0.963746,
            -0.118699,
            0.160706,
            1.05502,
            0.966468,
            -0.0998358,
            0.135504,
            1.07568,
            0.971178,
            -0.0805186,
            0.109131,
            1.09479,
            0.97831,
            -0.0599348,
            0.0818293,
            1.1123,
            0.985886,
            -0.0399661,
            0.0545872,
            1.12771,
            0.994021,
            -0.0198682,
            0.0269405,
            1.14186,
            1.00009,
            0.000271022,
            -0.00012989,
            1.15514,
            0.538716,
            -0.00000990918,
            0.486732,
            0.0000109675,
            0.550656,
            -0.000250642,
            0.497518,
            0.000277412,
            0.55057,
            -0.00100265,
            0.497441,
            0.00110974,
            0.550903,
            -0.00225672,
            0.497733,
            0.00249779,
            0.550568,
            -0.00401046,
            0.497438,
            0.00443906,
            0.550574,
            -0.00626613,
            0.49744,
            0.00693637,
            0.550591,
            -0.0090226,
            0.497449,
            0.00998921,
            0.550623,
            -0.0122795,
            0.497469,
            0.0135984,
            0.550667,
            -0.0160361,
            0.497495,
            0.0177654,
            0.550724,
            -0.0202908,
            0.497526,
            0.0224915,
            0.550792,
            -0.0250421,
            0.497557,
            0.0277795,
            0.550918,
            -0.0302878,
            0.49763,
            0.0336334,
            0.551058,
            -0.0360241,
            0.497701,
            0.0400573,
            0.551276,
            -0.0422473,
            0.497824,
            0.0470585,
            0.551551,
            -0.0489441,
            0.497977,
            0.0546433,
            0.552074,
            -0.0559596,
            0.498312,
            0.0628367,
            0.552681,
            -0.0633978,
            0.498679,
            0.071646,
            0.553324,
            -0.0713176,
            0.499031,
            0.0810746,
            0.554011,
            -0.0797268,
            0.499365,
            0.091129,
            0.55488,
            -0.0885238,
            0.499779,
            0.101837,
            0.556171,
            -0.0974417,
            0.500444,
            0.113239,
            0.557498,
            -0.106841,
            0.501025,
            0.125316,
            0.559299,
            -0.116533,
            0.501864,
            0.138128,
            0.561647,
            -0.126298,
            0.502967,
            0.151695,
            0.564347,
            -0.136388,
            0.504129,
            0.16604,
            0.567863,
            -0.146576,
            0.505713,
            0.181207,
            0.572569,
            -0.156832,
            0.507953,
            0.197259,
            0.578919,
            -0.167323,
            0.511186,
            0.214258,
            0.585387,
            -0.177712,
            0.514042,
            0.232038,
            0.593134,
            -0.188184,
            0.517484,
            0.250733,
            0.603295,
            -0.198717,
            0.522345,
            0.270454,
            0.613854,
            -0.209177,
            0.526751,
            0.290807,
            0.626092,
            -0.219644,
            0.531595,
            0.312202,
            0.637868,
            -0.229494,
            0.534721,
            0.334435,
            0.652458,
            -0.238718,
            0.538304,
            0.359184,
            0.666985,
            -0.247061,
            0.539875,
            0.385637,
            0.683301,
            -0.254652,
            0.541042,
            0.41328,
            0.69998,
            -0.261376,
            0.540735,
            0.441903,
            0.717824,
            -0.267085,
            0.539139,
            0.471609,
            0.734617,
            -0.271465,
            0.534958,
            0.501446,
            0.753663,
            -0.27528,
            0.53032,
            0.532571,
            0.770512,
            -0.277617,
            0.522134,
            0.563641,
            0.787356,
            -0.278525,
            0.51206,
            0.595067,
            0.806252,
            -0.278512,
            0.50119,
            0.627226,
            0.822061,
            -0.277023,
            0.486791,
            0.659402,
            0.838959,
            -0.273175,
            0.470467,
            0.692874,
            0.85379,
            -0.267238,
            0.450688,
            0.725702,
            0.868268,
            -0.260327,
            0.429741,
            0.75832,
            0.881994,
            -0.251946,
            0.407223,
            0.790189,
            0.893885,
            -0.242432,
            0.383214,
            0.821625,
            0.905118,
            -0.231904,
            0.357297,
            0.853011,
            0.916045,
            -0.219545,
            0.330733,
            0.883773,
            0.927614,
            -0.205378,
            0.303916,
            0.914435,
            0.936005,
            -0.190388,
            0.275941,
            0.944502,
            0.944533,
            -0.1749,
            0.247493,
            0.974439,
            0.950758,
            -0.158588,
            0.218996,
            1.00286,
            0.957078,
            -0.141027,
            0.191559,
            1.0304,
            0.962448,
            -0.121507,
            0.164457,
            1.05466,
            0.964993,
            -0.102068,
            0.138636,
            1.0761,
            0.970017,
            -0.0822598,
            0.111861,
            1.09541,
            0.97661,
            -0.062033,
            0.0843438,
            1.11317,
            0.985073,
            -0.0409832,
            0.0558496,
            1.12911,
            0.993515,
            -0.020146,
            0.0275331,
            1.1438,
            1.00006,
            0.00027329,
            -0.000107883,
            1.15736,
            0.525324,
            -0.00000999341,
            0.498153,
            0.0000105385,
            0.526513,
            -0.000251605,
            0.499277,
            0.000265329,
            0.526517,
            -0.00100641,
            0.499282,
            0.0010613,
            0.526588,
            -0.00226466,
            0.499337,
            0.00238823,
            0.526539,
            -0.0040255,
            0.499302,
            0.00424535,
            0.526547,
            -0.00628954,
            0.499306,
            0.00663364,
            0.526561,
            -0.00905628,
            0.499313,
            0.00955337,
            0.526593,
            -0.0123253,
            0.499334,
            0.0130054,
            0.526642,
            -0.0160957,
            0.499365,
            0.0169911,
            0.5267,
            -0.0203661,
            0.499396,
            0.0215122,
            0.526792,
            -0.0251347,
            0.499451,
            0.0265718,
            0.526904,
            -0.0303985,
            0.499511,
            0.0321732,
            0.527079,
            -0.0361554,
            0.499617,
            0.0383231,
            0.527285,
            -0.0423982,
            0.499731,
            0.045026,
            0.527602,
            -0.0491121,
            0.499924,
            0.0522936,
            0.528166,
            -0.0561127,
            0.500306,
            0.0601528,
            0.52879,
            -0.0635988,
            0.5007,
            0.0686059,
            0.529421,
            -0.071581,
            0.501048,
            0.0776518,
            0.530144,
            -0.0799854,
            0.501421,
            0.0873148,
            0.531062,
            -0.0888032,
            0.501884,
            0.0976084,
            0.532374,
            -0.0977643,
            0.50259,
            0.108588,
            0.533828,
            -0.107197,
            0.50329,
            0.120234,
            0.53581,
            -0.116887,
            0.504312,
            0.132602,
            0.538063,
            -0.126755,
            0.505365,
            0.145721,
            0.5409,
            -0.136819,
            0.506668,
            0.159617,
            0.544882,
            -0.147117,
            0.508731,
            0.174369,
            0.550238,
            -0.157446,
            0.511601,
            0.190028,
            0.556038,
            -0.167988,
            0.514431,
            0.206587,
            0.563031,
            -0.178364,
            0.517808,
            0.224046,
            0.571543,
            -0.189007,
            0.521937,
            0.242503,
            0.582255,
            -0.199546,
            0.527415,
            0.261977,
            0.59272,
            -0.210084,
            0.531682,
            0.282162,
            0.605648,
            -0.220448,
            0.537123,
            0.303426,
            0.61785,
            -0.230593,
            0.540664,
            0.325323,
            0.632223,
            -0.240238,
            0.544467,
            0.348993,
            0.648819,
            -0.24887,
            0.547594,
            0.375462,
            0.665825,
            -0.256657,
            0.54912,
            0.403024,
            0.683389,
            -0.263711,
            0.549294,
            0.431773,
            0.701495,
            -0.269666,
            0.547649,
            0.461494,
            0.719197,
            -0.274169,
            0.543786,
            0.491623,
            0.737906,
            -0.278124,
            0.538644,
            0.522994,
            0.756652,
            -0.280632,
            0.531057,
            0.554775,
            0.775279,
            -0.281741,
            0.521972,
            0.586441,
            0.792688,
            -0.281652,
            0.509613,
            0.618596,
            0.811894,
            -0.280345,
            0.496497,
            0.651462,
            0.827938,
            -0.277128,
            0.47968,
            0.684023,
            0.844837,
            -0.271646,
            0.460688,
            0.718024,
            0.859239,
            -0.264397,
            0.438872,
            0.751207,
            0.874088,
            -0.256144,
            0.41577,
            0.784232,
            0.887693,
            -0.246311,
            0.391369,
            0.816191,
            0.899402,
            -0.235497,
            0.365872,
            0.847828,
            0.910973,
            -0.223631,
            0.338618,
            0.87934,
            0.92204,
            -0.209874,
            0.310803,
            0.910325,
            0.930987,
            -0.194265,
            0.281802,
            0.940695,
            0.94,
            -0.178125,
            0.252836,
            0.970958,
            0.948018,
            -0.161479,
            0.224239,
            1.00078,
            0.955141,
            -0.144038,
            0.195857,
            1.0288,
            0.960513,
            -0.124915,
            0.168487,
            1.05371,
            0.963964,
            -0.104284,
            0.141495,
            1.07596,
            0.968713,
            -0.0838732,
            0.114437,
            1.09628,
            0.975524,
            -0.0635579,
            0.0863105,
            1.11448,
            0.98431,
            -0.042291,
            0.0574774,
            1.13069,
            0.992916,
            -0.0209131,
            0.0284343,
            1.14568,
            0.999926,
            0.000743097,
            -0.000379265,
            1.15955,
            0.501042,
            -0.00000998428,
            0.498726,
            0.0000100306,
            0.502992,
            -0.000252112,
            0.500665,
            0.000253283,
            0.502417,
            -0.00100791,
            0.500092,
            0.00101259,
            0.502965,
            -0.00226919,
            0.500621,
            0.00227978,
            0.502318,
            -0.00403109,
            0.499994,
            0.00405011,
            0.502333,
            -0.00629832,
            0.500005,
            0.00632868,
            0.502362,
            -0.00906907,
            0.500027,
            0.00911446,
            0.502369,
            -0.0123423,
            0.500023,
            0.0124078,
            0.50243,
            -0.0161178,
            0.500066,
            0.016211,
            0.502493,
            -0.0203937,
            0.500103,
            0.0205256,
            0.502592,
            -0.0251684,
            0.500166,
            0.0253548,
            0.502707,
            -0.0304389,
            0.50023,
            0.0307029,
            0.502881,
            -0.0362015,
            0.500335,
            0.0365753,
            0.503124,
            -0.0424507,
            0.500488,
            0.0429798,
            0.503443,
            -0.0491582,
            0.500686,
            0.0499268,
            0.504083,
            -0.0561476,
            0.501155,
            0.0574541,
            0.504668,
            -0.0636846,
            0.501524,
            0.0655408,
            0.505319,
            -0.0716834,
            0.501904,
            0.0742072,
            0.50609,
            -0.0800925,
            0.502321,
            0.0834699,
            0.507122,
            -0.0888425,
            0.502896,
            0.0933603,
            0.508414,
            -0.097855,
            0.503603,
            0.10391,
            0.509955,
            -0.107304,
            0.504416,
            0.115113,
            0.512061,
            -0.116921,
            0.505565,
            0.127054,
            0.514419,
            -0.12689,
            0.506732,
            0.139709,
            0.517529,
            -0.136934,
            0.508338,
            0.153173,
            0.522085,
            -0.147327,
            0.510987,
            0.167528,
            0.526986,
            -0.157612,
            0.513527,
            0.182708,
            0.533122,
            -0.168213,
            0.516717,
            0.198881,
            0.540807,
            -0.178688,
            0.520832,
            0.215986,
            0.550687,
            -0.189511,
            0.52632,
            0.234335,
            0.560567,
            -0.199998,
            0.531009,
            0.253375,
            0.571698,
            -0.210652,
            0.535839,
            0.273499,
            0.584364,
            -0.220917,
            0.541091,
            0.294355,
            0.599066,
            -0.23137,
            0.546875,
            0.316525,
            0.614148,
            -0.241206,
            0.551306,
            0.339671,
            0.631157,
            -0.250379,
            0.555187,
            0.36531,
            0.647919,
            -0.258397,
            0.556595,
            0.392767,
            0.666112,
            -0.265528,
            0.556949,
            0.421397,
            0.686158,
            -0.271827,
            0.556617,
            0.451433,
            0.704838,
            -0.27674,
            0.552975,
            0.482131,
            0.723957,
            -0.280733,
            0.547814,
            0.513458,
            0.74262,
            -0.283359,
            0.53997,
            0.545446,
            0.762009,
            -0.284541,
            0.530422,
            0.57775,
            0.781314,
            -0.284507,
            0.518546,
            0.610434,
            0.799116,
            -0.283309,
            0.504178,
            0.643178,
            0.817604,
            -0.280378,
            0.48843,
            0.676248,
            0.83459,
            -0.275619,
            0.469457,
            0.709698,
            0.850974,
            -0.26856,
            0.447698,
            0.744245,
            0.866747,
            -0.260094,
            0.424791,
            0.777695,
            0.881412,
            -0.249929,
            0.399913,
            0.810392,
            0.8936,
            -0.239137,
            0.37308,
            0.842872,
            0.905943,
            -0.226818,
            0.345705,
            0.874677,
            0.916408,
            -0.213699,
            0.31706,
            0.906257,
            0.927215,
            -0.198428,
            0.288444,
            0.936881,
            0.935625,
            -0.181643,
            0.258329,
            0.96795,
            0.944076,
            -0.164386,
            0.228488,
            0.998216,
            0.951229,
            -0.146339,
            0.199763,
            1.02689,
            0.958793,
            -0.127709,
            0.172153,
            1.0535,
            0.963219,
            -0.107244,
            0.144989,
            1.07646,
            0.967562,
            -0.0857764,
            0.11685,
            1.09675,
            0.974866,
            -0.0645377,
            0.0880571,
            1.11576,
            0.983353,
            -0.0431732,
            0.0587352,
            1.13227,
            0.992503,
            -0.0218356,
            0.0294181,
            1.1478,
            1.00003,
            0.000605203,
            -0.000231013,
            1.16207,
            0.482935,
            -0.0000101177,
            0.504695,
            0.00000968142,
            0.477554,
            -0.000251521,
            0.499071,
            0.000240676,
            0.477904,
            -0.00100683,
            0.499436,
            0.00096342,
            0.478368,
            -0.00226636,
            0.499899,
            0.0021687,
            0.477977,
            -0.00402719,
            0.499513,
            0.00385384,
            0.477993,
            -0.00629226,
            0.499525,
            0.0060221,
            0.478011,
            -0.00906011,
            0.499536,
            0.00867289,
            0.478051,
            -0.0123305,
            0.499566,
            0.0118074,
            0.478089,
            -0.016102,
            0.499587,
            0.0154269,
            0.478171,
            -0.0203736,
            0.499645,
            0.0195341,
            0.478254,
            -0.025143,
            0.499692,
            0.0241318,
            0.47839,
            -0.0304071,
            0.499779,
            0.0292247,
            0.478588,
            -0.0361631,
            0.499911,
            0.0348196,
            0.478812,
            -0.0424023,
            0.500046,
            0.0409231,
            0.479208,
            -0.0490724,
            0.500326,
            0.047552,
            0.479841,
            -0.0560722,
            0.500805,
            0.0547377,
            0.480392,
            -0.0636125,
            0.501152,
            0.0624607,
            0.481068,
            -0.0716134,
            0.501561,
            0.0707473,
            0.481898,
            -0.0800062,
            0.502054,
            0.0796118,
            0.483022,
            -0.0886568,
            0.502728,
            0.0890974,
            0.484332,
            -0.0977553,
            0.503479,
            0.0992099,
            0.486126,
            -0.107173,
            0.504546,
            0.10999,
            0.488066,
            -0.11677,
            0.50557,
            0.121476,
            0.490521,
            -0.126725,
            0.506849,
            0.133672,
            0.494232,
            -0.136793,
            0.50911,
            0.146731,
            0.498302,
            -0.147116,
            0.511345,
            0.160577,
            0.503565,
            -0.157446,
            0.514344,
            0.175335,
            0.510902,
            -0.168121,
            0.518824,
            0.191207,
            0.519263,
            -0.178799,
            0.523666,
            0.208058,
            0.528204,
            -0.189407,
            0.528296,
            0.225875,
            0.538854,
            -0.200145,
            0.533724,
            0.244782,
            0.551278,
            -0.210701,
            0.539833,
            0.264753,
            0.565222,
            -0.221303,
            0.546131,
            0.285745,
            0.579403,
            -0.231688,
            0.551496,
            0.307592,
            0.595469,
            -0.241718,
            0.556809,
            0.330582,
            0.610929,
            -0.250992,
            0.559641,
            0.354995,
            0.629433,
            -0.259602,
            0.562379,
            0.382471,
            0.648504,
            -0.267038,
            0.563676,
            0.411126,
            0.66756,
            -0.273388,
            0.562092,
            0.440924,
            0.689143,
            -0.278788,
            0.560807,
            0.472118,
            0.709056,
            -0.282783,
            0.555701,
            0.503774,
            0.729855,
            -0.285836,
            0.548698,
            0.536364,
            0.748954,
            -0.287078,
            0.538544,
            0.56895,
            0.768373,
            -0.287133,
            0.526711,
            0.601991,
            0.78827,
            -0.285839,
            0.512511,
            0.635403,
            0.807465,
            -0.283238,
            0.496323,
            0.668797,
            0.825194,
            -0.27906,
            0.477638,
            0.702584,
            0.842203,
            -0.272286,
            0.456253,
            0.736393,
            0.857749,
            -0.263854,
            0.432412,
            0.77096,
            0.874799,
            -0.253943,
            0.407806,
            0.80489,
            0.887497,
            -0.24237,
            0.38033,
            0.83771,
            0.89966,
            -0.230278,
            0.352446,
            0.870376,
            0.911753,
            -0.21646,
            0.323268,
            0.902256,
            0.923011,
            -0.202071,
            0.294314,
            0.933306,
            0.932375,
            -0.185519,
            0.264104,
            0.965177,
            0.940537,
            -0.167604,
            0.234035,
            0.996303,
            0.948904,
            -0.149068,
            0.20412,
            1.0261,
            0.955263,
            -0.129539,
            0.175431,
            1.05304,
            0.960303,
            -0.109932,
            0.148116,
            1.07617,
            0.965512,
            -0.0880572,
            0.119693,
            1.09742,
            0.973466,
            -0.0660548,
            0.0901619,
            1.11721,
            0.98284,
            -0.0439228,
            0.0599875,
            1.13436,
            0.992216,
            -0.0219588,
            0.0298975,
            1.15006,
            0.999946,
            0.000119402,
            -0.0000208547,
            1.16471,
            0.447827,
            -0.0000100414,
            0.491543,
            0.00000914833,
            0.454778,
            -0.000251257,
            0.499172,
            0.00022891,
            0.453519,
            -0.00100342,
            0.497787,
            0.000914184,
            0.45357,
            -0.00225776,
            0.497847,
            0.00205701,
            0.453578,
            -0.00401371,
            0.497855,
            0.00365705,
            0.45357,
            -0.00627107,
            0.497841,
            0.00571453,
            0.453598,
            -0.00902968,
            0.497864,
            0.00823019,
            0.453627,
            -0.0122888,
            0.497882,
            0.0112049,
            0.453684,
            -0.0160475,
            0.497923,
            0.0146405,
            0.453764,
            -0.0203044,
            0.49798,
            0.0185394,
            0.453866,
            -0.0250576,
            0.498049,
            0.0229054,
            0.453996,
            -0.0303028,
            0.49813,
            0.0277424,
            0.454196,
            -0.0360379,
            0.498267,
            0.0330587,
            0.454457,
            -0.0422521,
            0.498445,
            0.0388613,
            0.454926,
            -0.0488393,
            0.498812,
            0.0451767,
            0.455525,
            -0.0558653,
            0.499272,
            0.0520153,
            0.456074,
            -0.0633772,
            0.499625,
            0.0593754,
            0.456752,
            -0.0713606,
            0.500049,
            0.0672751,
            0.457648,
            -0.07971,
            0.500615,
            0.0757447,
            0.458849,
            -0.0883032,
            0.501399,
            0.0848231,
            0.46029,
            -0.0974095,
            0.502293,
            0.0945135,
            0.462,
            -0.106729,
            0.503301,
            0.104848,
            0.464121,
            -0.116354,
            0.504533,
            0.115884,
            0.466889,
            -0.126214,
            0.506172,
            0.127652,
            0.470744,
            -0.136324,
            0.508667,
            0.14024,
            0.47488,
            -0.146595,
            0.510995,
            0.153673,
            0.480845,
            -0.157027,
            0.514832,
            0.168053,
            0.488262,
            -0.167658,
            0.519506,
            0.183508,
            0.496547,
            -0.178343,
            0.524347,
            0.199948,
            0.506254,
            -0.188916,
            0.52983,
            0.217503,
            0.517961,
            -0.199975,
            0.536357,
            0.236272,
            0.531484,
            -0.210624,
            0.543641,
            0.256096,
            0.545496,
            -0.221227,
            0.550048,
            0.277085,
            0.559497,
            -0.231568,
            0.555076,
            0.298615,
            0.575752,
            -0.241698,
            0.560541,
            0.321547,
            0.591999,
            -0.251172,
            0.564156,
            0.345602,
            0.610654,
            -0.260178,
            0.567607,
            0.371851,
            0.630484,
            -0.268094,
            0.56923,
            0.40076,
            0.651807,
            -0.274661,
            0.569779,
            0.430801,
            0.67239,
            -0.280331,
            0.566791,
            0.461939,
            0.693024,
            -0.284501,
            0.562007,
            0.493854,
            0.715473,
            -0.287852,
            0.555791,
            0.526992,
            0.736323,
            -0.28929,
            0.546345,
            0.560102,
            0.755771,
            -0.289405,
            0.534,
            0.593543,
            0.775424,
            -0.2881,
            0.519114,
            0.627256,
            0.795447,
            -0.285562,
            0.502543,
            0.661464,
            0.815319,
            -0.281416,
            0.484773,
            0.695206,
            0.831769,
            -0.275523,
            0.463445,
            0.729044,
            0.849464,
            -0.267516,
            0.440269,
            0.764069,
            0.866775,
            -0.257584,
            0.415049,
            0.799089,
            0.881252,
            -0.245817,
            0.388049,
            0.831948,
            0.894209,
            -0.233127,
            0.35889,
            0.865526,
            0.906922,
            -0.219579,
            0.329915,
            0.89818,
            0.919686,
            -0.204491,
            0.300441,
            0.930013,
            0.929044,
            -0.188962,
            0.269445,
            0.962061,
            0.938393,
            -0.171079,
            0.238402,
            0.994214,
            0.94661,
            -0.15199,
            0.208204,
            1.02533,
            0.953095,
            -0.131953,
            0.178653,
            1.0529,
            0.958644,
            -0.111233,
            0.150684,
            1.0771,
            0.963925,
            -0.0903098,
            0.122359,
            1.09855,
            0.971995,
            -0.0680505,
            0.0923342,
            1.11874,
            0.981658,
            -0.0448512,
            0.0614195,
            1.13635,
            0.991649,
            -0.0221931,
            0.0303582,
            1.15238,
            0.999985,
            0.000393403,
            -0.000111086,
            1.16772,
            0.396806,
            -0.00000971563,
            0.457671,
            0.00000842355,
            0.429186,
            -0.000249421,
            0.495017,
            0.00021625,
            0.429324,
            -0.000998052,
            0.495173,
            0.000865322,
            0.429175,
            -0.00224487,
            0.494999,
            0.00194637,
            0.429129,
            -0.00399041,
            0.494952,
            0.00346004,
            0.429153,
            -0.00623476,
            0.494974,
            0.00540684,
            0.429168,
            -0.0089773,
            0.494983,
            0.00778714,
            0.429207,
            -0.0122175,
            0.495012,
            0.0106022,
            0.429257,
            -0.0159542,
            0.495047,
            0.0138535,
            0.429338,
            -0.0201864,
            0.495106,
            0.0175443,
            0.429431,
            -0.0249104,
            0.495165,
            0.0216774,
            0.429587,
            -0.0301252,
            0.495279,
            0.0262594,
            0.429796,
            -0.0358249,
            0.495432,
            0.0312968,
            0.430065,
            -0.0419972,
            0.495621,
            0.0367985,
            0.430588,
            -0.0485144,
            0.496061,
            0.042798,
            0.43113,
            -0.0555028,
            0.496472,
            0.0492914,
            0.431743,
            -0.0629852,
            0.496904,
            0.0562907,
            0.432448,
            -0.0709256,
            0.497369,
            0.0638056,
            0.433414,
            -0.0791942,
            0.498032,
            0.071885,
            0.434638,
            -0.0877346,
            0.498854,
            0.0805517,
            0.43611,
            -0.0968056,
            0.499812,
            0.0898047,
            0.437859,
            -0.106002,
            0.500891,
            0.0997142,
            0.440017,
            -0.115648,
            0.502198,
            0.110289,
            0.443236,
            -0.125427,
            0.504389,
            0.121644,
            0.44697,
            -0.135492,
            0.506809,
            0.133769,
            0.451689,
            -0.145746,
            0.509858,
            0.146787,
            0.45811,
            -0.156219,
            0.514247,
            0.160793,
            0.465305,
            -0.166834,
            0.518816,
            0.175791,
            0.474085,
            -0.177546,
            0.524331,
            0.191906,
            0.484808,
            -0.188262,
            0.53104,
            0.209199,
            0.49732,
            -0.199346,
            0.538511,
            0.227825,
            0.509693,
            -0.209951,
            0.544554,
            0.247269,
            0.524367,
            -0.220533,
            0.551616,
            0.267978,
            0.539228,
            -0.231082,
            0.557368,
            0.289672,
            0.55644,
            -0.241342,
            0.563782,
            0.31268,
            0.574204,
            -0.250964,
            0.568851,
            0.33651,
            0.593388,
            -0.260306,
            0.57312,
            0.362219,
            0.613358,
            -0.268667,
            0.574916,
            0.390322,
            0.634512,
            -0.275591,
            0.575053,
            0.420478,
            0.65563,
            -0.281328,
            0.572404,
            0.451614,
            0.678265,
            -0.285948,
            0.568893,
            0.484112,
            0.70011,
            -0.289408,
            0.561878,
            0.517348,
            0.723005,
            -0.291328,
            0.55359,
            0.551355,
            0.743744,
            -0.291418,
            0.541099,
            0.585109,
            0.763949,
            -0.290252,
            0.526489,
            0.619487,
            0.784186,
            -0.287648,
            0.509496,
            0.65404,
            0.804304,
            -0.283782,
            0.491484,
            0.688649,
            0.823629,
            -0.278067,
            0.470517,
            0.723133,
            0.84094,
            -0.270588,
            0.44705,
            0.757163,
            0.857852,
            -0.261188,
            0.421252,
            0.792816,
            0.874934,
            -0.249313,
            0.394191,
            0.827248,
            0.888709,
            -0.236492,
            0.365359,
            0.861074,
            0.902589,
            -0.222185,
            0.336016,
            0.894417,
            0.914201,
            -0.207314,
            0.30527,
            0.926825,
            0.925978,
            -0.191146,
            0.274532,
            0.9595,
            0.93512,
            -0.174135,
            0.243393,
            0.991583,
            0.943656,
            -0.155231,
            0.212414,
            1.02356,
            0.951719,
            -0.134403,
            0.182005,
            1.05239,
            0.957164,
            -0.113023,
            0.153043,
            1.07754,
            0.962656,
            -0.0914493,
            0.124186,
            1.09984,
            0.970695,
            -0.0694179,
            0.0941654,
            1.12,
            0.980749,
            -0.0466199,
            0.0629671,
            1.13849,
            0.991205,
            -0.0227032,
            0.0311146,
            1.15494,
            0.999884,
            0.000632388,
            -0.000254483,
            1.1706,
            0.379821,
            -0.00000957289,
            0.460637,
            0.00000789337,
            0.405188,
            -0.000247483,
            0.491396,
            0.000204064,
            0.404796,
            -0.000989434,
            0.490914,
            0.000815853,
            0.40483,
            -0.00222607,
            0.490949,
            0.00183559,
            0.40473,
            -0.00395723,
            0.49084,
            0.00326332,
            0.404731,
            -0.00618287,
            0.490836,
            0.00509945,
            0.404768,
            -0.00890258,
            0.490871,
            0.00734463,
            0.404791,
            -0.0121156,
            0.490883,
            0.00999992,
            0.404857,
            -0.0158214,
            0.490938,
            0.0130676,
            0.404943,
            -0.0200178,
            0.491004,
            0.0165503,
            0.405059,
            -0.0247027,
            0.491093,
            0.0204521,
            0.405213,
            -0.0298729,
            0.491205,
            0.0247788,
            0.405399,
            -0.0355226,
            0.491333,
            0.0295373,
            0.405731,
            -0.0416352,
            0.491604,
            0.034741,
            0.406303,
            -0.0480807,
            0.492116,
            0.0404255,
            0.406814,
            -0.0550458,
            0.492506,
            0.0465732,
            0.407404,
            -0.0624652,
            0.492926,
            0.0532058,
            0.408149,
            -0.0702958,
            0.493442,
            0.0603442,
            0.409128,
            -0.0784623,
            0.494136,
            0.0680297,
            0.410408,
            -0.087007,
            0.495054,
            0.0762786,
            0.411813,
            -0.0959639,
            0.495962,
            0.0851046,
            0.413735,
            -0.105075,
            0.497257,
            0.0945878,
            0.416137,
            -0.114646,
            0.498882,
            0.104725,
            0.41934,
            -0.124394,
            0.501132,
            0.11563,
            0.423326,
            -0.134328,
            0.503883,
            0.127325,
            0.428419,
            -0.14458,
            0.50747,
            0.139911,
            0.43484,
            -0.154979,
            0.511964,
            0.153481,
            0.442641,
            -0.165628,
            0.517328,
            0.168114,
            0.452511,
            -0.176365,
            0.524258,
            0.183995,
            0.463473,
            -0.187298,
            0.531248,
            0.200953,
            0.475564,
            -0.198244,
            0.538367,
            0.219176,
            0.488664,
            -0.208938,
            0.545175,
            0.238514,
            0.504073,
            -0.219599,
            0.553227,
            0.259129,
            0.520832,
            -0.230378,
            0.560653,
            0.280997,
            0.538455,
            -0.240703,
            0.567523,
            0.303821,
            0.55709,
            -0.250548,
            0.573287,
            0.327948,
            0.576646,
            -0.259964,
            0.577795,
            0.353362,
            0.596705,
            -0.268721,
            0.580077,
            0.380336,
            0.618053,
            -0.276054,
            0.58018,
            0.4101,
            0.640303,
            -0.282176,
            0.578747,
            0.44161,
            0.662365,
            -0.286931,
            0.574294,
            0.474106,
            0.684542,
            -0.290521,
            0.567035,
            0.507549,
            0.707984,
            -0.292672,
            0.558687,
            0.541853,
            0.730913,
            -0.293189,
            0.547606,
            0.576581,
            0.752948,
            -0.292199,
            0.533471,
            0.61172,
            0.773452,
            -0.289508,
            0.516395,
            0.646339,
            0.794715,
            -0.285716,
            0.497873,
            0.682131,
            0.814251,
            -0.280051,
            0.476845,
            0.716396,
            0.833057,
            -0.272873,
            0.453449,
            0.751503,
            0.84959,
            -0.263982,
            0.427857,
            0.786085,
            0.867022,
            -0.252745,
            0.400335,
            0.821355,
            0.882277,
            -0.239655,
            0.371304,
            0.85646,
            0.895375,
            -0.225386,
            0.340397,
            0.890828,
            0.909347,
            -0.209587,
            0.310005,
            0.923532,
            0.921885,
            -0.193433,
            0.2796,
            0.956419,
            0.932127,
            -0.176135,
            0.247276,
            0.989445,
            0.941869,
            -0.157872,
            0.216186,
            1.02221,
            0.949735,
            -0.137577,
            0.185602,
            1.05195,
            0.956617,
            -0.115285,
            0.155767,
            1.07822,
            0.961974,
            -0.0928418,
            0.126103,
            1.10149,
            0.96972,
            -0.0700592,
            0.0956758,
            1.12207,
            0.98012,
            -0.0474671,
            0.0643269,
            1.1408,
            0.990825,
            -0.0238113,
            0.0320863,
            1.1577,
            0.999876,
            0.000381574,
            -0.0000812203,
            1.17403,
            0.367636,
            -0.00000961342,
            0.469176,
            0.00000753287,
            0.380377,
            -0.000244772,
            0.485434,
            0.000191797,
            0.380416,
            -0.000978857,
            0.485475,
            0.000767015,
            0.380376,
            -0.00220165,
            0.485435,
            0.00172522,
            0.380419,
            -0.00391408,
            0.485487,
            0.00306734,
            0.380438,
            -0.00611549,
            0.485505,
            0.00479332,
            0.380462,
            -0.00880558,
            0.485525,
            0.00690391,
            0.380496,
            -0.0119837,
            0.485551,
            0.00940039,
            0.38056,
            -0.0156487,
            0.485605,
            0.0122848,
            0.38064,
            -0.0197988,
            0.485666,
            0.0155601,
            0.380767,
            -0.0244324,
            0.48577,
            0.0192313,
            0.380909,
            -0.0295444,
            0.485871,
            0.0233032,
            0.381142,
            -0.0351321,
            0.48606,
            0.0277861,
            0.381472,
            -0.0411535,
            0.486336,
            0.0326939,
            0.382015,
            -0.0475408,
            0.486833,
            0.0380565,
            0.382523,
            -0.0544395,
            0.487231,
            0.0438615,
            0.383129,
            -0.061784,
            0.487683,
            0.0501332,
            0.383952,
            -0.0695085,
            0.488313,
            0.0568996,
            0.38498,
            -0.0775819,
            0.489077,
            0.0641952,
            0.386331,
            -0.0860443,
            0.490113,
            0.0720324,
            0.387788,
            -0.0948406,
            0.491099,
            0.0804379,
            0.389808,
            -0.103899,
            0.492566,
            0.0894899,
            0.39252,
            -0.113313,
            0.494601,
            0.0992098,
            0.395493,
            -0.123007,
            0.496619,
            0.109641,
            0.399826,
            -0.132859,
            0.499912,
            0.120919,
            0.405341,
            -0.143077,
            0.504061,
            0.133107,
            0.411932,
            -0.153465,
            0.508905,
            0.146263,
            0.420591,
            -0.164108,
            0.515482,
            0.160544,
            0.43101,
            -0.174893,
            0.523191,
            0.176123,
            0.441881,
            -0.185839,
            0.53026,
            0.192757,
            0.453919,
            -0.196633,
            0.537295,
            0.210535,
            0.468715,
            -0.207611,
            0.546156,
            0.229886,
            0.485182,
            -0.218517,
            0.555173,
            0.250543,
            0.501926,
            -0.229249,
            0.562728,
            0.27221,
            0.51785,
            -0.239481,
            0.567494,
            0.294892,
            0.536947,
            -0.249395,
            0.573889,
            0.318987,
            0.557115,
            -0.259,
            0.578831,
            0.344348,
            0.577966,
            -0.268075,
            0.582055,
            0.371223,
            0.599489,
            -0.276115,
            0.583307,
            0.399834,
            0.62479,
            -0.282523,
            0.583902,
            0.431415,
            0.647504,
            -0.287663,
            0.57953,
            0.464301,
            0.670601,
            -0.291538,
            0.573103,
            0.498123,
            0.693539,
            -0.293842,
            0.563731,
            0.532662,
            0.717385,
            -0.294681,
            0.553169,
            0.567925,
            0.741533,
            -0.293717,
            0.539908,
            0.603502,
            0.762142,
            -0.291156,
            0.521902,
            0.639074,
            0.783014,
            -0.28719,
            0.502815,
            0.674439,
            0.805158,
            -0.281773,
            0.482598,
            0.710497,
            0.823646,
            -0.274682,
            0.458949,
            0.7456,
            0.841879,
            -0.266184,
            0.433129,
            0.781085,
            0.859515,
            -0.255682,
            0.406064,
            0.816,
            0.875335,
            -0.242849,
            0.376509,
            0.851074,
            0.890147,
            -0.228329,
            0.345502,
            0.886473,
            0.903144,
            -0.212491,
            0.31428,
            0.920751,
            0.916618,
            -0.195695,
            0.282994,
            0.954606,
            0.927953,
            -0.178267,
            0.251091,
            0.988402,
            0.937414,
            -0.159549,
            0.219107,
            1.02141,
            0.946823,
            -0.140022,
            0.18896,
            1.05167,
            0.954651,
            -0.118154,
            0.158667,
            1.07819,
            0.959955,
            -0.0946636,
            0.128808,
            1.1025,
            0.96858,
            -0.0711792,
            0.0973787,
            1.12391,
            0.97938,
            -0.0475046,
            0.0650965,
            1.14322,
            0.990498,
            -0.024059,
            0.0326267,
            1.16077,
            0.999844,
            -0.0000512408,
            0.000112444,
            1.17727,
            0.316912,
            -0.00000934977,
            0.425996,
            0.00000695559,
            0.356423,
            -0.000241372,
            0.479108,
            0.000179562,
            0.356272,
            -0.000965292,
            0.478897,
            0.00071811,
            0.356262,
            -0.00217182,
            0.478894,
            0.00161574,
            0.356265,
            -0.00386092,
            0.478895,
            0.00287261,
            0.356278,
            -0.0060324,
            0.478905,
            0.00448907,
            0.356293,
            -0.00868565,
            0.478914,
            0.00646572,
            0.356346,
            -0.0118207,
            0.478965,
            0.00880438,
            0.356395,
            -0.0154355,
            0.479001,
            0.0115066,
            0.356484,
            -0.019529,
            0.479075,
            0.0145762,
            0.356609,
            -0.0240991,
            0.47918,
            0.018018,
            0.356766,
            -0.0291413,
            0.479305,
            0.0218379,
            0.357009,
            -0.0346498,
            0.479512,
            0.0260454,
            0.357424,
            -0.0405462,
            0.479909,
            0.0306657,
            0.357899,
            -0.0468825,
            0.480337,
            0.0357054,
            0.358424,
            -0.0536887,
            0.480771,
            0.0411728,
            0.359041,
            -0.0609416,
            0.481242,
            0.0470841,
            0.359903,
            -0.0685239,
            0.481943,
            0.0534831,
            0.360932,
            -0.0764883,
            0.482741,
            0.0603795,
            0.362196,
            -0.0848364,
            0.483688,
            0.0678028,
            0.363847,
            -0.0935002,
            0.484947,
            0.0758086,
            0.365972,
            -0.102471,
            0.486588,
            0.0844173,
            0.368741,
            -0.111751,
            0.488787,
            0.0937199,
            0.372146,
            -0.121334,
            0.491405,
            0.103732,
            0.377114,
            -0.131147,
            0.495604,
            0.114608,
            0.38226,
            -0.141213,
            0.499436,
            0.126345,
            0.389609,
            -0.151632,
            0.505334,
            0.139116,
            0.397925,
            -0.162073,
            0.51168,
            0.152995,
            0.407824,
            -0.172819,
            0.518876,
            0.168071,
            0.420014,
            -0.183929,
            0.527639,
            0.184495,
            0.434266,
            -0.195032,
            0.537588,
            0.20232,
            0.447352,
            -0.205792,
            0.544379,
            0.221189,
            0.463726,
            -0.216704,
            0.553422,
            0.241616,
            0.481406,
            -0.227531,
            0.562074,
            0.263298,
            0.498707,
            -0.238017,
            0.568227,
            0.286116,
            0.518039,
            -0.247936,
            0.574473,
            0.3101,
            0.538277,
            -0.257437,
            0.579191,
            0.335401,
            0.561166,
            -0.266829,
            0.584807,
            0.362246,
            0.583189,
            -0.275329,
            0.586476,
            0.390609,
            0.606024,
            -0.28234,
            0.585578,
            0.420998,
            0.632419,
            -0.287924,
            0.584496,
            0.454357,
            0.656128,
            -0.291972,
            0.577766,
            0.488233,
            0.679953,
            -0.29456,
            0.56875,
            0.523248,
            0.704654,
            -0.295816,
            0.558388,
            0.559168,
            0.729016,
            -0.295157,
            0.544826,
            0.595326,
            0.752062,
            -0.292779,
            0.528273,
            0.631864,
            0.773138,
            -0.288681,
            0.508482,
            0.667793,
            0.794869,
            -0.283358,
            0.487341,
            0.704035,
            0.815101,
            -0.27608,
            0.46354,
            0.739925,
            0.834212,
            -0.26767,
            0.438672,
            0.775539,
            0.852368,
            -0.257397,
            0.411239,
            0.810895,
            0.870207,
            -0.245689,
            0.3829,
            0.846472,
            0.884063,
            -0.231452,
            0.351496,
            0.881788,
            0.898284,
            -0.215561,
            0.31895,
            0.917438,
            0.912964,
            -0.198208,
            0.287367,
            0.952422,
            0.924666,
            -0.180426,
            0.254487,
            0.987551,
            0.934429,
            -0.161525,
            0.222226,
            1.02142,
            0.943485,
            -0.141197,
            0.191143,
            1.05218,
            0.9521,
            -0.120085,
            0.161112,
            1.07937,
            0.957876,
            -0.0975881,
            0.130982,
            1.10403,
            0.966943,
            -0.0726842,
            0.0990553,
            1.12616,
            0.978313,
            -0.0483705,
            0.0662818,
            1.14619,
            0.990048,
            -0.0239072,
            0.0329243,
            1.16413,
            0.999984,
            0.000461885,
            -0.0000772859,
            1.18099,
            0.321287,
            -0.00000935049,
            0.455413,
            0.00000659662,
            0.332595,
            -0.000237513,
            0.471437,
            0.000167562,
            0.332729,
            -0.000949964,
            0.471618,
            0.000670192,
            0.332305,
            -0.00213618,
            0.471028,
            0.00150712,
            0.332326,
            -0.00379765,
            0.471055,
            0.00267959,
            0.332344,
            -0.00593353,
            0.471072,
            0.00418751,
            0.332356,
            -0.00854349,
            0.471077,
            0.00603172,
            0.332403,
            -0.0116268,
            0.471121,
            0.00821362,
            0.332461,
            -0.0151824,
            0.47117,
            0.0107357,
            0.332552,
            -0.0192088,
            0.471251,
            0.0136014,
            0.332657,
            -0.0237024,
            0.47133,
            0.0168152,
            0.332835,
            -0.0286615,
            0.471487,
            0.0203853,
            0.333083,
            -0.0340765,
            0.471708,
            0.0243212,
            0.333547,
            -0.0398563,
            0.47219,
            0.0286518,
            0.333989,
            -0.0460916,
            0.472587,
            0.0333763,
            0.334532,
            -0.0527897,
            0.473054,
            0.0385084,
            0.335167,
            -0.0599284,
            0.473568,
            0.0440638,
            0.33608,
            -0.0673514,
            0.474362,
            0.0500962,
            0.337146,
            -0.0752237,
            0.475231,
            0.0566022,
            0.338462,
            -0.083418,
            0.476282,
            0.0636272,
            0.34014,
            -0.0919382,
            0.477615,
            0.0712153,
            0.342341,
            -0.100741,
            0.479404,
            0.079417,
            0.345088,
            -0.109905,
            0.481618,
            0.0882631,
            0.349049,
            -0.119369,
            0.485081,
            0.0978851,
            0.353939,
            -0.129033,
            0.489317,
            0.108336,
            0.359893,
            -0.139038,
            0.494309,
            0.119698,
            0.366945,
            -0.149411,
            0.499983,
            0.132024,
            0.375814,
            -0.159843,
            0.507185,
            0.145558,
            0.387112,
            -0.170664,
            0.516392,
            0.160433,
            0.40023,
            -0.181897,
            0.526519,
            0.176648,
            0.412555,
            -0.192785,
            0.53423,
            0.193922,
            0.427023,
            -0.203663,
            0.542741,
            0.212662,
            0.443685,
            -0.214695,
            0.552066,
            0.232944,
            0.461499,
            -0.225561,
            0.560762,
            0.254495,
            0.480975,
            -0.236257,
            0.569421,
            0.277531,
            0.501,
            -0.24639,
            0.576101,
            0.301724,
            0.521691,
            -0.256101,
            0.581493,
            0.327112,
            0.543478,
            -0.265289,
            0.585221,
            0.353917,
            0.566094,
            -0.273938,
            0.587614,
            0.381941,
            0.589578,
            -0.281679,
            0.587991,
            0.41172,
            0.614583,
            -0.287655,
            0.585928,
            0.444148,
            0.641813,
            -0.292228,
            0.582092,
            0.478617,
            0.666189,
            -0.295172,
            0.57398,
            0.51397,
            0.690475,
            -0.29648,
            0.561676,
            0.550118,
            0.715543,
            -0.296203,
            0.548758,
            0.586933,
            0.740405,
            -0.293999,
            0.532792,
            0.62384,
            0.762183,
            -0.28998,
            0.512735,
            0.660723,
            0.786069,
            -0.28478,
            0.492402,
            0.69807,
            0.806812,
            -0.277568,
            0.469058,
            0.734422,
            0.826987,
            -0.268951,
            0.443017,
            0.770946,
            0.844588,
            -0.259049,
            0.415501,
            0.80699,
            0.863725,
            -0.2471,
            0.387328,
            0.842107,
            0.879137,
            -0.234157,
            0.356108,
            0.878078,
            0.894634,
            -0.218719,
            0.324315,
            0.914058,
            0.909162,
            -0.201293,
            0.291813,
            0.949922,
            0.92072,
            -0.18267,
            0.258474,
            0.985337,
            0.93158,
            -0.163212,
            0.225593,
            1.0205,
            0.941238,
            -0.142771,
            0.193986,
            1.05273,
            0.949293,
            -0.120956,
            0.163392,
            1.08075,
            0.956226,
            -0.0985743,
            0.132934,
            1.10559,
            0.96546,
            -0.075118,
            0.101255,
            1.12823,
            0.977403,
            -0.0497921,
            0.0675441,
            1.149,
            0.989648,
            -0.0241574,
            0.0334681,
            1.16765,
            1.00001,
            0.0005762,
            -0.000184807,
            1.18519,
            0.303474,
            -0.00000916603,
            0.4542,
            0.0000061243,
            0.308894,
            -0.000232869,
            0.462306,
            0.000155592,
            0.309426,
            -0.000931661,
            0.463093,
            0.000622499,
            0.308643,
            -0.0020949,
            0.461933,
            0.00139979,
            0.308651,
            -0.0037242,
            0.461941,
            0.00248874,
            0.308662,
            -0.00581873,
            0.46195,
            0.00388933,
            0.308687,
            -0.00837818,
            0.461974,
            0.00560247,
            0.308728,
            -0.0114016,
            0.462011,
            0.00762948,
            0.308789,
            -0.0148884,
            0.462067,
            0.00997326,
            0.308882,
            -0.0188369,
            0.462151,
            0.0126375,
            0.309007,
            -0.0232436,
            0.462263,
            0.0156271,
            0.30918,
            -0.0281054,
            0.462417,
            0.0189498,
            0.309442,
            -0.0334065,
            0.462667,
            0.0226167,
            0.309901,
            -0.0390589,
            0.463162,
            0.0266614,
            0.310331,
            -0.0452042,
            0.463555,
            0.0310715,
            0.310858,
            -0.0517735,
            0.464019,
            0.0358698,
            0.311576,
            -0.0587359,
            0.464669,
            0.0410848,
            0.312436,
            -0.0660383,
            0.465406,
            0.0467453,
            0.313526,
            -0.0737266,
            0.466339,
            0.0528718,
            0.314903,
            -0.0817574,
            0.467504,
            0.0595039,
            0.316814,
            -0.090167,
            0.469226,
            0.0666888,
            0.318965,
            -0.0987555,
            0.470981,
            0.0744658,
            0.322077,
            -0.107792,
            0.473814,
            0.082912,
            0.325947,
            -0.117098,
            0.477241,
            0.0920846,
            0.331008,
            -0.126602,
            0.48184,
            0.102137,
            0.337893,
            -0.136619,
            0.488334,
            0.113135,
            0.345106,
            -0.146838,
            0.494415,
            0.12511,
            0.355111,
            -0.157357,
            0.503275,
            0.138356,
            0.365095,
            -0.167955,
            0.510966,
            0.152686,
            0.378344,
            -0.179157,
            0.521508,
            0.16856,
            0.391599,
            -0.190143,
            0.530455,
            0.18561,
            0.407786,
            -0.20123,
            0.541275,
            0.204308,
            0.425294,
            -0.212456,
            0.551784,
            0.224623,
            0.444021,
            -0.223568,
            0.561493,
            0.246172,
            0.463418,
            -0.234154,
            0.569886,
            0.268979,
            0.484077,
            -0.244546,
            0.577116,
            0.293411,
            0.505513,
            -0.254301,
            0.582914,
            0.318936,
            0.527672,
            -0.263564,
            0.587208,
            0.345856,
            0.550565,
            -0.272332,
            0.589277,
            0.374054,
            0.573656,
            -0.280011,
            0.588426,
            0.403276,
            0.59827,
            -0.286924,
            0.587504,
            0.43474,
            0.624731,
            -0.291994,
            0.583401,
            0.468767,
            0.652396,
            -0.295159,
            0.576997,
            0.504411,
            0.67732,
            -0.296954,
            0.565863,
            0.54114,
            0.703147,
            -0.296877,
            0.552316,
            0.57816,
            0.728715,
            -0.295147,
            0.536773,
            0.616124,
            0.752448,
            -0.291275,
            0.51771,
            0.653885,
            0.775169,
            -0.285905,
            0.496087,
            0.691537,
            0.799307,
            -0.279064,
            0.474232,
            0.729251,
            0.819482,
            -0.270294,
            0.447676,
            0.766267,
            0.837659,
            -0.260032,
            0.419656,
            0.802616,
            0.856903,
            -0.248497,
            0.391328,
            0.838583,
            0.873325,
            -0.235252,
            0.360285,
            0.874711,
            0.889788,
            -0.221126,
            0.329215,
            0.91077,
            0.904486,
            -0.204304,
            0.296392,
            0.94653,
            0.917711,
            -0.185562,
            0.262159,
            0.983828,
            0.928969,
            -0.165635,
            0.229142,
            1.01955,
            0.939707,
            -0.14442,
            0.19673,
            1.05317,
            0.948167,
            -0.122147,
            0.165095,
            1.0823,
            0.955222,
            -0.099098,
            0.13451,
            1.10791,
            0.964401,
            -0.0755332,
            0.102476,
            1.1312,
            0.976605,
            -0.0513817,
            0.0689667,
            1.15218,
            0.989085,
            -0.0258499,
            0.034506,
            1.17129,
            0.999908,
            0.000617773,
            -0.000271268,
            1.18961,
            0.285803,
            -0.00000905752,
            0.452348,
            0.00000572272,
            0.284689,
            -0.00022732,
            0.450581,
            0.000143626,
            0.285263,
            -0.000910214,
            0.451482,
            0.000575099,
            0.285302,
            -0.00204784,
            0.451553,
            0.00129395,
            0.285318,
            -0.00364057,
            0.451574,
            0.0023006,
            0.28533,
            -0.00568813,
            0.451585,
            0.00359547,
            0.285361,
            -0.00819001,
            0.451618,
            0.00517934,
            0.285397,
            -0.0111458,
            0.45165,
            0.007054,
            0.285447,
            -0.0145536,
            0.451688,
            0.00922167,
            0.285527,
            -0.0184127,
            0.451758,
            0.0116869,
            0.285688,
            -0.0227207,
            0.451929,
            0.0144555,
            0.28584,
            -0.0274712,
            0.452055,
            0.0175341,
            0.286136,
            -0.0326278,
            0.452369,
            0.0209406,
            0.286574,
            -0.0381792,
            0.452853,
            0.0246965,
            0.287012,
            -0.0441879,
            0.453272,
            0.0287996,
            0.287542,
            -0.0506096,
            0.453752,
            0.033268,
            0.288299,
            -0.0573634,
            0.454488,
            0.0381504,
            0.289186,
            -0.0645458,
            0.455294,
            0.0434447,
            0.290302,
            -0.0720405,
            0.456301,
            0.0491973,
            0.291776,
            -0.0799046,
            0.457648,
            0.0554453,
            0.29372,
            -0.088117,
            0.459483,
            0.0622311,
            0.296052,
            -0.0965328,
            0.461571,
            0.0695992,
            0.299563,
            -0.105409,
            0.465085,
            0.077658,
            0.30335,
            -0.114553,
            0.468506,
            0.0864176,
            0.309167,
            -0.123917,
            0.474423,
            0.0961078,
            0.31529,
            -0.13381,
            0.47995,
            0.106643,
            0.324163,
            -0.144021,
            0.488592,
            0.118322,
            0.333272,
            -0.154382,
            0.496461,
            0.131133,
            0.344224,
            -0.165015,
            0.50562,
            0.145208,
            0.357733,
            -0.176168,
            0.516719,
            0.16073,
            0.373046,
            -0.187468,
            0.528513,
            0.177807,
            0.38788,
            -0.198488,
            0.537713,
            0.196072,
            0.405133,
            -0.209545,
            0.547999,
            0.21605,
            0.423845,
            -0.220724,
            0.55759,
            0.237484,
            0.443777,
            -0.231518,
            0.566246,
            0.26039,
            0.464824,
            -0.242035,
            0.574326,
            0.284835,
            0.486635,
            -0.251898,
            0.58037,
            0.310518,
            0.51012,
            -0.261304,
            0.58568,
            0.337678,
            0.535301,
            -0.270384,
            0.590197,
            0.366242,
            0.559193,
            -0.27841,
            0.590569,
            0.395873,
            0.583544,
            -0.285325,
            0.588161,
            0.426857,
            0.608834,
            -0.291113,
            0.584249,
            0.459477,
            0.635753,
            -0.294882,
            0.57763,
            0.494734,
            0.664367,
            -0.297088,
            0.569479,
            0.532023,
            0.689688,
            -0.297364,
            0.555064,
            0.569629,
            0.715732,
            -0.295949,
            0.539522,
            0.608124,
            0.741307,
            -0.292259,
            0.521613,
            0.646231,
            0.764949,
            -0.287063,
            0.49969,
            0.684938,
            0.788599,
            -0.28012,
            0.476747,
            0.723548,
            0.81048,
            -0.27153,
            0.45116,
            0.761135,
            0.831372,
            -0.261289,
            0.424101,
            0.798916,
            0.850092,
            -0.249559,
            0.39443,
            0.835952,
            0.867777,
            -0.236348,
            0.363849,
            0.871606,
            0.884632,
            -0.221569,
            0.332477,
            0.907843,
            0.90047,
            -0.20618,
            0.300667,
            0.944187,
            0.914524,
            -0.188771,
            0.266552,
            0.981371,
            0.926892,
            -0.168362,
            0.232349,
            1.01841,
            0.937951,
            -0.146761,
            0.199359,
            1.05308,
            0.947236,
            -0.123813,
            0.1675,
            1.0839,
            0.954367,
            -0.099984,
            0.136166,
            1.11047,
            0.963907,
            -0.0759278,
            0.103808,
            1.13414,
            0.976218,
            -0.0511367,
            0.0697061,
            1.15575,
            0.988772,
            -0.0267415,
            0.0352529,
            1.17531,
            0.999888,
            -0.000520778,
            0.000289926,
            1.19389,
            0.263546,
            -0.00000883274,
            0.441896,
            0.00000526783,
            0.262352,
            -0.000221849,
            0.439889,
            0.000132311,
            0.262325,
            -0.000886683,
            0.439848,
            0.000528824,
            0.26228,
            -0.00199476,
            0.439765,
            0.00118975,
            0.262372,
            -0.00354671,
            0.439922,
            0.00211568,
            0.26239,
            -0.00554141,
            0.439941,
            0.00330652,
            0.262412,
            -0.00797888,
            0.439961,
            0.00476346,
            0.262453,
            -0.0108584,
            0.440002,
            0.00648818,
            0.262528,
            -0.0141788,
            0.440085,
            0.0084835,
            0.262615,
            -0.017938,
            0.440166,
            0.0107533,
            0.262744,
            -0.0221346,
            0.440291,
            0.0133044,
            0.262939,
            -0.026762,
            0.440493,
            0.0161445,
            0.263277,
            -0.0317573,
            0.440889,
            0.0192974,
            0.26368,
            -0.0371832,
            0.441338,
            0.0227699,
            0.264106,
            -0.0430371,
            0.441753,
            0.0265698,
            0.264624,
            -0.0493035,
            0.442227,
            0.0307178,
            0.265378,
            -0.0558669,
            0.442985,
            0.0352616,
            0.266253,
            -0.0628718,
            0.443795,
            0.0401968,
            0.267478,
            -0.0701569,
            0.445008,
            0.04559,
            0.269062,
            -0.077845,
            0.446599,
            0.0514539,
            0.270926,
            -0.0857941,
            0.448349,
            0.0578382,
            0.273693,
            -0.0940773,
            0.451221,
            0.0648363,
            0.276746,
            -0.102704,
            0.454097,
            0.0724389,
            0.281693,
            -0.111735,
            0.459517,
            0.0808744,
            0.287335,
            -0.121004,
            0.46531,
            0.0901551,
            0.29448,
            -0.130734,
            0.472605,
            0.100371,
            0.30257,
            -0.140777,
            0.480251,
            0.111644,
            0.312465,
            -0.15111,
            0.489444,
            0.124111,
            0.324856,
            -0.16189,
            0.500919,
            0.137979,
            0.33774,
            -0.172946,
            0.511317,
            0.153163,
            0.35255,
            -0.184152,
            0.522684,
            0.169817,
            0.367786,
            -0.19522,
            0.53248,
            0.187886,
            0.385474,
            -0.20632,
            0.543326,
            0.207634,
            0.404976,
            -0.217744,
            0.554109,
            0.229165,
            0.425203,
            -0.228691,
            0.563395,
            0.252068,
            0.446704,
            -0.239299,
            0.571565,
            0.276471,
            0.468951,
            -0.249348,
            0.577935,
            0.302323,
            0.493487,
            -0.258933,
            0.584309,
            0.329882,
            0.517861,
            -0.268009,
            0.58773,
            0.358525,
            0.543309,
            -0.276238,
            0.589612,
            0.388585,
            0.569704,
            -0.28356,
            0.589294,
            0.419787,
            0.594871,
            -0.289497,
            0.585137,
            0.452114,
            0.622555,
            -0.294452,
            0.580356,
            0.486466,
            0.651167,
            -0.296918,
            0.57185,
            0.523079,
            0.677332,
            -0.297647,
            0.558428,
            0.5611,
            0.703718,
            -0.296321,
            0.542232,
            0.599592,
            0.730262,
            -0.293339,
            0.524541,
            0.639138,
            0.754304,
            -0.288036,
            0.502691,
            0.677978,
            0.778051,
            -0.281018,
            0.479212,
            0.716537,
            0.801557,
            -0.272414,
            0.454071,
            0.75586,
            0.822559,
            -0.262419,
            0.425952,
            0.794477,
            0.843051,
            -0.250702,
            0.397313,
            0.832664,
            0.86232,
            -0.237264,
            0.366534,
            0.869876,
            0.879044,
            -0.222716,
            0.334816,
            0.906973,
            0.896362,
            -0.206827,
            0.303143,
            0.943558,
            0.910342,
            -0.189659,
            0.269699,
            0.979759,
            0.924119,
            -0.171108,
            0.236411,
            1.01718,
            0.935374,
            -0.149579,
            0.202224,
            1.05289,
            0.944295,
            -0.126295,
            0.16989,
            1.08496,
            0.952227,
            -0.101511,
            0.138089,
            1.11256,
            0.962041,
            -0.0766392,
            0.105053,
            1.1375,
            0.97528,
            -0.0511967,
            0.070329,
            1.15983,
            0.988476,
            -0.025463,
            0.0351268,
            1.17987,
            0.999962,
            0.0000286808,
            0.0000145564,
            1.19901,
            0.227089,
            -0.00000841413,
            0.404216,
            0.00000472707,
            0.239725,
            -0.000215083,
            0.426708,
            0.000120833,
            0.239904,
            -0.000860718,
            0.427028,
            0.000483555,
            0.239911,
            -0.00193661,
            0.427039,
            0.00108806,
            0.239914,
            -0.00344276,
            0.42704,
            0.00193457,
            0.239933,
            -0.00537907,
            0.427064,
            0.00302363,
            0.239944,
            -0.00774482,
            0.427065,
            0.00435604,
            0.239993,
            -0.01054,
            0.427122,
            0.00593398,
            0.240052,
            -0.0137626,
            0.427179,
            0.00775987,
            0.240148,
            -0.0174115,
            0.427279,
            0.00983854,
            0.240278,
            -0.021484,
            0.42741,
            0.0121763,
            0.240472,
            -0.0259729,
            0.427618,
            0.0147827,
            0.240839,
            -0.0308131,
            0.428086,
            0.0176837,
            0.241201,
            -0.0360893,
            0.428482,
            0.0208775,
            0.241626,
            -0.0417723,
            0.428907,
            0.0243821,
            0.242207,
            -0.0478337,
            0.42952,
            0.0282228,
            0.24298,
            -0.0542199,
            0.430332,
            0.0324333,
            0.243881,
            -0.0610015,
            0.431222,
            0.0370252,
            0.245123,
            -0.0680874,
            0.432512,
            0.0420535,
            0.24667,
            -0.0755482,
            0.434088,
            0.0475414,
            0.248779,
            -0.0832873,
            0.436323,
            0.0535542,
            0.251665,
            -0.0913546,
            0.439509,
            0.0601716,
            0.255305,
            -0.0998489,
            0.443478,
            0.0674282,
            0.260049,
            -0.108576,
            0.448713,
            0.0754673,
            0.266192,
            -0.117754,
            0.455524,
            0.084339,
            0.273158,
            -0.127294,
            0.4627,
            0.0941683,
            0.282131,
            -0.137311,
            0.472068,
            0.10515,
            0.293332,
            -0.147736,
            0.483565,
            0.117402,
            0.304667,
            -0.158357,
            0.493702,
            0.130824,
            0.317785,
            -0.169274,
            0.504708,
            0.145724,
            0.333245,
            -0.180595,
            0.517107,
            0.16215,
            0.349843,
            -0.191892,
            0.528849,
            0.180149,
            0.367944,
            -0.203168,
            0.540301,
            0.199746,
            0.387579,
            -0.214443,
            0.551514,
            0.221047,
            0.408247,
            -0.225624,
            0.560906,
            0.243981,
            0.43014,
            -0.236422,
            0.56959,
            0.268513,
            0.452669,
            -0.24654,
            0.576098,
            0.294409,
            0.476196,
            -0.256157,
            0.580925,
            0.322002,
            0.501157,
            -0.265289,
            0.584839,
            0.351052,
            0.527632,
            -0.273671,
            0.587614,
            0.3812,
            0.555754,
            -0.281254,
            0.589119,
            0.412994,
            0.581682,
            -0.287448,
            0.585204,
            0.445498,
            0.608196,
            -0.292614,
            0.579006,
            0.479505,
            0.635661,
            -0.296068,
            0.571297,
            0.514643,
            0.664999,
            -0.297395,
            0.560855,
            0.552213,
            0.691039,
            -0.296645,
            0.544525,
            0.591365,
            0.7179,
            -0.293785,
            0.526535,
            0.630883,
            0.744059,
            -0.289089,
            0.50545,
            0.670932,
            0.76863,
            -0.282239,
            0.482514,
            0.710904,
            0.793273,
            -0.273688,
            0.457246,
            0.750259,
            0.814731,
            -0.26328,
            0.428872,
            0.78948,
            0.835603,
            -0.251526,
            0.399384,
            0.828597,
            0.85489,
            -0.238339,
            0.368811,
            0.866892,
            0.872828,
            -0.223607,
            0.336617,
            0.90563,
            0.889462,
            -0.207538,
            0.303997,
            0.943538,
            0.904929,
            -0.190297,
            0.270812,
            0.980591,
            0.919101,
            -0.172034,
            0.237453,
            1.01935,
            0.930536,
            -0.152058,
            0.204431,
            1.05498,
            0.941223,
            -0.129515,
            0.172495,
            1.08717,
            0.94982,
            -0.104263,
            0.140175,
            1.11551,
            0.960592,
            -0.0781944,
            0.106465,
            1.14098,
            0.974629,
            -0.051688,
            0.0711592,
            1.16418,
            0.98811,
            -0.0253929,
            0.0354432,
            1.18465,
            1.00004,
            0.000804378,
            -0.000330876,
            1.20462,
            0.214668,
            -0.00000821282,
            0.406619,
            0.00000433582,
            0.218053,
            -0.000208144,
            0.413025,
            0.000109887,
            0.217987,
            -0.000832212,
            0.412901,
            0.000439362,
            0.217971,
            -0.00187246,
            0.412876,
            0.000988623,
            0.217968,
            -0.00332855,
            0.41286,
            0.00175772,
            0.217985,
            -0.00520055,
            0.412882,
            0.00274729,
            0.218014,
            -0.00748814,
            0.412916,
            0.00395842,
            0.218054,
            -0.0101901,
            0.412957,
            0.00539274,
            0.218106,
            -0.0133057,
            0.413005,
            0.00705348,
            0.218217,
            -0.0168342,
            0.413139,
            0.00894581,
            0.218338,
            -0.0207707,
            0.413258,
            0.0110754,
            0.21855,
            -0.0251001,
            0.413509,
            0.0134551,
            0.218913,
            -0.0297861,
            0.413992,
            0.0161081,
            0.219265,
            -0.0348956,
            0.414383,
            0.0190307,
            0.219696,
            -0.0403909,
            0.414839,
            0.0222458,
            0.220329,
            -0.0462003,
            0.415567,
            0.025792,
            0.220989,
            -0.0524208,
            0.41621,
            0.0296637,
            0.222027,
            -0.058948,
            0.417385,
            0.0339323,
            0.223301,
            -0.0658208,
            0.418779,
            0.0386055,
            0.224988,
            -0.0730347,
            0.420665,
            0.0437355,
            0.227211,
            -0.0805274,
            0.423198,
            0.0493844,
            0.230131,
            -0.088395,
            0.426566,
            0.0556135,
            0.233908,
            -0.0966208,
            0.43091,
            0.0624829,
            0.239092,
            -0.105223,
            0.437148,
            0.0701636,
            0.245315,
            -0.11424,
            0.444302,
            0.0786949,
            0.253166,
            -0.12368,
            0.453262,
            0.0882382,
            0.262374,
            -0.133569,
            0.463211,
            0.0988682,
            0.273145,
            -0.143836,
            0.474271,
            0.110727,
            0.285512,
            -0.154577,
            0.4863,
            0.123945,
            0.299512,
            -0.165501,
            0.498817,
            0.138581,
            0.314287,
            -0.176698,
            0.510341,
            0.154676,
            0.331083,
            -0.188066,
            0.522583,
            0.172459,
            0.349615,
            -0.199597,
            0.534879,
            0.191979,
            0.369318,
            -0.210843,
            0.546083,
            0.21309,
            0.390377,
            -0.222068,
            0.5562,
            0.235998,
            0.412411,
            -0.233059,
            0.564704,
            0.260518,
            0.435715,
            -0.24357,
            0.572314,
            0.286795,
            0.461196,
            -0.253356,
            0.579395,
            0.314559,
            0.485587,
            -0.262362,
            0.581985,
            0.343581,
            0.511908,
            -0.270895,
            0.584347,
            0.374367,
            0.539798,
            -0.278452,
            0.58505,
            0.406015,
            0.567974,
            -0.284877,
            0.583344,
            0.439168,
            0.594303,
            -0.290124,
            0.577348,
            0.473005,
            0.622951,
            -0.294183,
            0.570751,
            0.508534,
            0.652404,
            -0.296389,
            0.561541,
            0.544764,
            0.679291,
            -0.296605,
            0.546426,
            0.582927,
            0.706437,
            -0.294095,
            0.528599,
            0.622681,
            0.734485,
            -0.28978,
            0.508676,
            0.663567,
            0.758841,
            -0.283363,
            0.484768,
            0.704092,
            0.78537,
            -0.275015,
            0.460434,
            0.745101,
            0.807315,
            -0.264689,
            0.432166,
            0.784712,
            0.8271,
            -0.252597,
            0.401807,
            0.824241,
            0.849191,
            -0.239154,
            0.371458,
            0.863803,
            0.867046,
            -0.224451,
            0.338873,
            0.903063,
            0.8852,
            -0.208342,
            0.306175,
            0.942763,
            0.901771,
            -0.190684,
            0.272759,
            0.981559,
            0.915958,
            -0.172105,
            0.239306,
            1.02048,
            0.928046,
            -0.152214,
            0.206071,
            1.05765,
            0.939961,
            -0.130247,
            0.17367,
            1.08999,
            0.948711,
            -0.10672,
            0.142201,
            1.11829,
            0.959305,
            -0.0808688,
            0.108454,
            1.14467,
            0.973009,
            -0.0539145,
            0.0728109,
            1.16839,
            0.987631,
            -0.0262947,
            0.0360625,
            1.19004,
            0.999978,
            0.00132758,
            -0.000559424,
            1.21058,
            0.193925,
            -0.00000793421,
            0.391974,
            0.00000392537,
            0.196746,
            -0.000200315,
            0.397675,
            0.0000991033,
            0.19667,
            -0.000801099,
            0.397521,
            0.000396342,
            0.196633,
            -0.00180246,
            0.397445,
            0.000891829,
            0.196654,
            -0.00320443,
            0.397482,
            0.00158582,
            0.196659,
            -0.00500647,
            0.39748,
            0.00247867,
            0.196683,
            -0.0072086,
            0.397506,
            0.00357167,
            0.196728,
            -0.00981001,
            0.397562,
            0.00486675,
            0.196792,
            -0.0128096,
            0.397633,
            0.00636707,
            0.19689,
            -0.0162055,
            0.397746,
            0.00807752,
            0.197017,
            -0.0199943,
            0.397884,
            0.0100052,
            0.19729,
            -0.024139,
            0.39827,
            0.0121691,
            0.197583,
            -0.0286671,
            0.398639,
            0.0145755,
            0.197927,
            -0.0335858,
            0.399034,
            0.0172355,
            0.198383,
            -0.0388806,
            0.399554,
            0.0201718,
            0.199002,
            -0.0444736,
            0.400289,
            0.0234194,
            0.199739,
            -0.0504583,
            0.401111,
            0.026984,
            0.200784,
            -0.056729,
            0.402349,
            0.0309217,
            0.202075,
            -0.0633643,
            0.403841,
            0.0352496,
            0.203898,
            -0.0703247,
            0.406076,
            0.0400313,
            0.206199,
            -0.0775565,
            0.408841,
            0.0453282,
            0.209252,
            -0.085184,
            0.41259,
            0.0511794,
            0.213638,
            -0.0931994,
            0.418288,
            0.0577459,
            0.21881,
            -0.101617,
            0.424681,
            0.0650508,
            0.225642,
            -0.11052,
            0.433429,
            0.0732759,
            0.233717,
            -0.119772,
            0.442897,
            0.0824683,
            0.242823,
            -0.129505,
            0.452888,
            0.0927484,
            0.254772,
            -0.139906,
            0.466407,
            0.104417,
            0.266603,
            -0.150402,
            0.477413,
            0.117211,
            0.28073,
            -0.161395,
            0.490519,
            0.131598,
            0.295399,
            -0.172465,
            0.50201,
            0.147407,
            0.312705,
            -0.183982,
            0.515311,
            0.165031,
            0.331335,
            -0.195532,
            0.52786,
            0.184336,
            0.351037,
            -0.206971,
            0.5392,
            0.205361,
            0.372175,
            -0.218117,
            0.54941,
            0.228043,
            0.394548,
            -0.229327,
            0.558642,
            0.25267,
            0.419598,
            -0.240052,
            0.567861,
            0.279071,
            0.443922,
            -0.249937,
            0.573332,
            0.306882,
            0.471495,
            -0.259407,
            0.58013,
            0.33661,
            0.496769,
            -0.267749,
            0.580564,
            0.367328,
            0.524951,
            -0.275524,
            0.581696,
            0.399753,
            0.55318,
            -0.282148,
            0.579885,
            0.433134,
            0.581577,
            -0.287533,
            0.575471,
            0.467534,
            0.609231,
            -0.291612,
            0.567445,
            0.502943,
            0.637478,
            -0.293911,
            0.557657,
            0.53871,
            0.667795,
            -0.295096,
            0.546535,
            0.576568,
            0.694272,
            -0.294073,
            0.529561,
            0.614929,
            0.722937,
            -0.290386,
            0.510561,
            0.655909,
            0.749682,
            -0.284481,
            0.487846,
            0.697663,
            0.774754,
            -0.276188,
            0.462487,
            0.738515,
            0.799301,
            -0.266215,
            0.43481,
            0.779802,
            0.820762,
            -0.254116,
            0.404879,
            0.820045,
            0.843231,
            -0.240393,
            0.374559,
            0.860294,
            0.861857,
            -0.225503,
            0.341582,
            0.900965,
            0.880815,
            -0.209382,
            0.308778,
            0.941727,
            0.89766,
            -0.19155,
            0.275232,
            0.980916,
            0.912926,
            -0.172346,
            0.240938,
            1.02162,
            0.926391,
            -0.151799,
            0.207223,
            1.0597,
            0.938429,
            -0.129968,
            0.17484,
            1.09291,
            0.947834,
            -0.10651,
            0.142984,
            1.12248,
            0.958432,
            -0.0824098,
            0.109902,
            1.149,
            0.972402,
            -0.0565242,
            0.0744454,
            1.1733,
            0.987191,
            -0.028427,
            0.0373794,
            1.19538,
            0.999975,
            0.0000385685,
            -0.00004203,
            1.21676,
            0.178114,
            -0.00000766075,
            0.385418,
            0.00000354027,
            0.176074,
            -0.000191966,
            0.381002,
            0.0000887135,
            0.17601,
            -0.000767549,
            0.380861,
            0.000354715,
            0.17598,
            -0.00172696,
            0.380798,
            0.000798168,
            0.175994,
            -0.00307012,
            0.380824,
            0.00141928,
            0.176017,
            -0.00479684,
            0.380858,
            0.00221859,
            0.176019,
            -0.00690648,
            0.380839,
            0.00319714,
            0.176072,
            -0.00939888,
            0.380913,
            0.0043572,
            0.176131,
            -0.0122726,
            0.380979,
            0.005702,
            0.176239,
            -0.0155264,
            0.38112,
            0.00723689,
            0.176371,
            -0.0191551,
            0.381272,
            0.00896907,
            0.176638,
            -0.023117,
            0.381669,
            0.0109194,
            0.176912,
            -0.0274633,
            0.382015,
            0.0130903,
            0.177279,
            -0.032173,
            0.382476,
            0.0154949,
            0.17774,
            -0.0372219,
            0.383041,
            0.0181669,
            0.178344,
            -0.0426132,
            0.38378,
            0.0211209,
            0.179153,
            -0.0483309,
            0.384773,
            0.0243899,
            0.180197,
            -0.0543447,
            0.386076,
            0.0280062,
            0.181581,
            -0.0607122,
            0.387809,
            0.032004,
            0.18344,
            -0.0673855,
            0.390205,
            0.036453,
            0.186139,
            -0.0743989,
            0.393944,
            0.0414162,
            0.189432,
            -0.0817731,
            0.39832,
            0.0469394,
            0.193795,
            -0.0895464,
            0.404188,
            0.0531442,
            0.199641,
            -0.0978264,
            0.4121,
            0.0601374,
            0.206679,
            -0.106499,
            0.421425,
            0.0680078,
            0.214865,
            -0.115654,
            0.431504,
            0.076919,
            0.224406,
            -0.125268,
            0.442526,
            0.0868835,
            0.235876,
            -0.135475,
            0.455465,
            0.0981875,
            0.248335,
            -0.146023,
            0.4681,
            0.110759,
            0.262868,
            -0.157016,
            0.482069,
            0.124885,
            0.278962,
            -0.168245,
            0.496182,
            0.140645,
            0.295082,
            -0.17958,
            0.507401,
            0.157838,
            0.313738,
            -0.191227,
            0.520252,
            0.17695,
            0.333573,
            -0.202718,
            0.531708,
            0.197817,
            0.356433,
            -0.214424,
            0.544509,
            0.220785,
            0.378853,
            -0.225492,
            0.55373,
            0.245306,
            0.402717,
            -0.236236,
            0.561348,
            0.271593,
            0.428375,
            -0.246568,
            0.568538,
            0.299776,
            0.454724,
            -0.255941,
            0.573462,
            0.329433,
            0.482291,
            -0.264511,
            0.576356,
            0.360598,
            0.509706,
            -0.272129,
            0.576446,
            0.393204,
            0.538805,
            -0.278979,
            0.575298,
            0.427227,
            0.568919,
            -0.284528,
            0.572154,
            0.462157,
            0.596804,
            -0.288801,
            0.564691,
            0.497997,
            0.625987,
            -0.291334,
            0.555134,
            0.534467,
            0.656414,
            -0.292722,
            0.545051,
            0.571736,
            0.683916,
            -0.292185,
            0.528813,
            0.610158,
            0.711809,
            -0.290043,
            0.51106,
            0.649061,
            0.739547,
            -0.285246,
            0.490103,
            0.690081,
            0.766914,
            -0.277647,
            0.465523,
            0.732554,
            0.791375,
            -0.267603,
            0.437718,
            0.773982,
            0.814772,
            -0.256109,
            0.40882,
            0.81609,
            0.836691,
            -0.242281,
            0.377823,
            0.856849,
            0.856984,
            -0.227155,
            0.34496,
            0.898363,
            0.876332,
            -0.210395,
            0.311335,
            0.939471,
            0.894988,
            -0.192612,
            0.277703,
            0.980799,
            0.911113,
            -0.173236,
            0.243019,
            1.02215,
            0.924092,
            -0.152258,
            0.209037,
            1.06139,
            0.936828,
            -0.129575,
            0.175909,
            1.09635,
            0.946869,
            -0.10594,
            0.143852,
            1.12707,
            0.958284,
            -0.081318,
            0.110289,
            1.15419,
            0.972325,
            -0.0556133,
            0.0747232,
            1.17909,
            0.986878,
            -0.0297899,
            0.0383149,
            1.20163,
            0.999936,
            -0.00197169,
            0.000912402,
            1.22338,
            0.151174,
            -0.00000720365,
            0.351531,
            0.00000309789,
            0.155594,
            -0.00018279,
            0.361806,
            0.000078608,
            0.156099,
            -0.000731569,
            0.362982,
            0.000314615,
            0.156053,
            -0.00164578,
            0.362869,
            0.000707845,
            0.156093,
            -0.0029261,
            0.362961,
            0.00125884,
            0.156099,
            -0.00457155,
            0.362959,
            0.00196783,
            0.15612,
            -0.00658224,
            0.362982,
            0.00283622,
            0.156168,
            -0.00895774,
            0.363048,
            0.00386625,
            0.156221,
            -0.0116962,
            0.363101,
            0.00506109,
            0.156324,
            -0.0147973,
            0.363241,
            0.00642675,
            0.156476,
            -0.0182503,
            0.363448,
            0.00797175,
            0.156731,
            -0.0220266,
            0.36384,
            0.00971484,
            0.156994,
            -0.026176,
            0.364179,
            0.0116575,
            0.157341,
            -0.0306701,
            0.36462,
            0.0138207,
            0.157867,
            -0.0354591,
            0.365364,
            0.0162356,
            0.15846,
            -0.0406141,
            0.366111,
            0.0189092,
            0.159308,
            -0.0460519,
            0.367248,
            0.021885,
            0.160426,
            -0.0518096,
            0.368767,
            0.0252004,
            0.161877,
            -0.0578906,
            0.370745,
            0.0288825,
            0.163995,
            -0.0642812,
            0.373831,
            0.0330139,
            0.16655,
            -0.0710067,
            0.377366,
            0.0376283,
            0.170237,
            -0.0781522,
            0.382799,
            0.0428493,
            0.175096,
            -0.0857172,
            0.389915,
            0.0487324,
            0.181069,
            -0.0938025,
            0.398487,
            0.0554214,
            0.188487,
            -0.102363,
            0.408799,
            0.0630189,
            0.197029,
            -0.111343,
            0.419991,
            0.071634,
            0.206684,
            -0.120812,
            0.431455,
            0.0812797,
            0.218698,
            -0.131033,
            0.445746,
            0.0923651,
            0.230726,
            -0.141373,
            0.457471,
            0.104545,
            0.245516,
            -0.152387,
            0.472388,
            0.118449,
            0.261551,
            -0.163628,
            0.486671,
            0.133923,
            0.277437,
            -0.174814,
            0.49762,
            0.150849,
            0.296662,
            -0.186713,
            0.51162,
            0.169924,
            0.31795,
            -0.198513,
            0.525435,
            0.190848,
            0.339422,
            -0.210119,
            0.536267,
            0.213504,
            0.362143,
            -0.221354,
            0.545982,
            0.237947,
            0.387198,
            -0.23224,
            0.555364,
            0.264427,
            0.412349,
            -0.24257,
            0.561489,
            0.292519,
            0.439274,
            -0.252284,
            0.566903,
            0.322561,
            0.466779,
            -0.261023,
            0.569614,
            0.353952,
            0.496011,
            -0.26899,
            0.571589,
            0.387278,
            0.524964,
            -0.275498,
            0.570325,
            0.421356,
            0.556518,
            -0.281449,
            0.568792,
            0.457314,
            0.584363,
            -0.285526,
            0.560268,
            0.493199,
            0.614214,
            -0.28844,
            0.55205,
            0.530276,
            0.645684,
            -0.289777,
            0.541906,
            0.56855,
            0.673446,
            -0.289722,
            0.526464,
            0.606927,
            0.701924,
            -0.287792,
            0.509872,
            0.645945,
            0.73037,
            -0.284315,
            0.490649,
            0.685564,
            0.757405,
            -0.278804,
            0.467964,
            0.726511,
            0.784025,
            -0.269543,
            0.441468,
            0.768601,
            0.808255,
            -0.258117,
            0.41216,
            0.811321,
            0.830739,
            -0.244728,
            0.380606,
            0.853496,
            0.851914,
            -0.229428,
            0.348111,
            0.895374,
            0.872586,
            -0.212508,
            0.314732,
            0.937674,
            0.891581,
            -0.194025,
            0.280338,
            0.979869,
            0.907641,
            -0.174711,
            0.245203,
            1.02253,
            0.922233,
            -0.153509,
            0.21077,
            1.06371,
            0.935878,
            -0.130418,
            0.177399,
            1.09972,
            0.946338,
            -0.105558,
            0.144507,
            1.13124,
            0.957265,
            -0.080059,
            0.110508,
            1.15973,
            0.971668,
            -0.0539766,
            0.0742311,
            1.18515,
            0.9866,
            -0.0277101,
            0.0375224,
            1.20858,
            1.00021,
            -0.000515531,
            0.000135226,
            1.23135,
            0.137468,
            -0.00000686011,
            0.345041,
            0.00000273315,
            0.13703,
            -0.000173378,
            0.343936,
            0.0000690761,
            0.136986,
            -0.000693048,
            0.34383,
            0.000276126,
            0.136964,
            -0.00155931,
            0.343761,
            0.000621337,
            0.137003,
            -0.00277211,
            0.343863,
            0.00110494,
            0.137012,
            -0.00433103,
            0.343868,
            0.00172744,
            0.137043,
            -0.00623606,
            0.343916,
            0.00249022,
            0.13709,
            -0.0084868,
            0.343986,
            0.00339559,
            0.137145,
            -0.0110814,
            0.344045,
            0.00444687,
            0.137242,
            -0.0140187,
            0.344177,
            0.00565007,
            0.137431,
            -0.0172713,
            0.344491,
            0.00701868,
            0.137644,
            -0.0208605,
            0.344805,
            0.00856042,
            0.13791,
            -0.024792,
            0.345172,
            0.0102863,
            0.138295,
            -0.0290461,
            0.345734,
            0.0122185,
            0.138764,
            -0.0335957,
            0.346371,
            0.0143771,
            0.139415,
            -0.038467,
            0.347298,
            0.0167894,
            0.140272,
            -0.0436176,
            0.348527,
            0.0194895,
            0.141457,
            -0.0491016,
            0.350276,
            0.0225043,
            0.14303,
            -0.0548764,
            0.352646,
            0.0258962,
            0.145289,
            -0.0610096,
            0.356206,
            0.0297168,
            0.148502,
            -0.0674777,
            0.361488,
            0.0340562,
            0.152188,
            -0.074345,
            0.367103,
            0.0389534,
            0.157359,
            -0.0817442,
            0.375247,
            0.0445541,
            0.16379,
            -0.0896334,
            0.385064,
            0.0509535,
            0.171376,
            -0.098005,
            0.396082,
            0.0582611,
            0.179901,
            -0.106817,
            0.407418,
            0.06654,
            0.189892,
            -0.116239,
            0.420031,
            0.075994,
            0.201838,
            -0.12627,
            0.434321,
            0.0867239,
            0.214311,
            -0.136701,
            0.447631,
            0.0987517,
            0.228902,
            -0.147616,
            0.462046,
            0.112353,
            0.245107,
            -0.158871,
            0.476942,
            0.127605,
            0.262292,
            -0.170261,
            0.490285,
            0.144469,
            0.281215,
            -0.182017,
            0.503783,
            0.163282,
            0.301058,
            -0.193729,
            0.515505,
            0.183873,
            0.322752,
            -0.205512,
            0.52682,
            0.206466,
            0.347547,
            -0.217214,
            0.539473,
            0.231194,
            0.370969,
            -0.227966,
            0.546625,
            0.257288,
            0.397533,
            -0.238555,
            0.55472,
            0.285789,
            0.42398,
            -0.248278,
            0.559468,
            0.315746,
            0.452928,
            -0.257422,
            0.564095,
            0.347724,
            0.482121,
            -0.265306,
            0.565426,
            0.380922,
            0.510438,
            -0.272043,
            0.563205,
            0.415639,
            0.541188,
            -0.277614,
            0.561087,
            0.451702,
            0.571667,
            -0.281927,
            0.554922,
            0.48845,
            0.602432,
            -0.285015,
            0.546838,
            0.526442,
            0.634126,
            -0.286512,
            0.537415,
            0.564896,
            0.662816,
            -0.286388,
            0.522906,
            0.604037,
            0.692411,
            -0.284734,
            0.507003,
            0.643795,
            0.720946,
            -0.281297,
            0.488398,
            0.68298,
            0.748293,
            -0.276262,
            0.466353,
            0.723466,
            0.776931,
            -0.269978,
            0.443573,
            0.764565,
            0.801065,
            -0.260305,
            0.415279,
            0.805838,
            0.825843,
            -0.247426,
            0.384773,
            0.849985,
            0.84807,
            -0.232437,
            0.352555,
            0.893174,
            0.869122,
            -0.215806,
            0.318642,
            0.936564,
            0.888963,
            -0.197307,
            0.28381,
            0.980253,
            0.905547,
            -0.177203,
            0.247888,
            1.02463,
            0.918554,
            -0.155542,
            0.212904,
            1.06714,
            0.931395,
            -0.131948,
            0.1787,
            1.10451,
            0.941749,
            -0.106723,
            0.145902,
            1.13694,
            0.954551,
            -0.0804939,
            0.111193,
            1.1666,
            0.970279,
            -0.0534239,
            0.0744697,
            1.19249,
            0.986117,
            -0.0257452,
            0.0368788,
            1.21665,
            0.999938,
            0.00190634,
            -0.0010291,
            1.23981,
            0.118493,
            -0.00000647439,
            0.32272,
            0.0000023772,
            0.118765,
            -0.000163023,
            0.323456,
            0.0000598573,
            0.118772,
            -0.00065212,
            0.323477,
            0.000239447,
            0.118843,
            -0.00146741,
            0.323657,
            0.000538881,
            0.118804,
            -0.00260846,
            0.323553,
            0.00095826,
            0.118826,
            -0.00407576,
            0.323595,
            0.00149845,
            0.118846,
            -0.00586826,
            0.323617,
            0.00216047,
            0.118886,
            -0.00798578,
            0.32367,
            0.00294679,
            0.118947,
            -0.0104273,
            0.323753,
            0.00386124,
            0.119055,
            -0.0131909,
            0.323922,
            0.00490999,
            0.119241,
            -0.0162444,
            0.324251,
            0.00610804,
            0.11944,
            -0.0196339,
            0.324544,
            0.00745805,
            0.119739,
            -0.0233378,
            0.325026,
            0.00897805,
            0.12011,
            -0.0273179,
            0.325586,
            0.0106895,
            0.120571,
            -0.0316143,
            0.326231,
            0.0126073,
            0.12124,
            -0.0361939,
            0.327264,
            0.0147654,
            0.122162,
            -0.0410511,
            0.328733,
            0.0172001,
            0.123378,
            -0.0462233,
            0.330659,
            0.0199375,
            0.125183,
            -0.0517109,
            0.333754,
            0.0230498,
            0.127832,
            -0.0575652,
            0.338507,
            0.026597,
            0.130909,
            -0.0637441,
            0.343666,
            0.0306345,
            0.135221,
            -0.0704302,
            0.351063,
            0.035273,
            0.14082,
            -0.0776364,
            0.360604,
            0.0406137,
            0.146781,
            -0.0852293,
            0.369638,
            0.0466788,
            0.155121,
            -0.0935351,
            0.3827,
            0.0537628,
            0.16398,
            -0.102234,
            0.39522,
            0.0617985,
            0.173926,
            -0.111465,
            0.40793,
            0.07097,
            0.185137,
            -0.121296,
            0.42105,
            0.0813426,
            0.19826,
            -0.13169,
            0.435735,
            0.0931596,
            0.212938,
            -0.142614,
            0.450932,
            0.106547,
            0.229046,
            -0.153884,
            0.465726,
            0.121575,
            0.246246,
            -0.165382,
            0.479461,
            0.138286,
            0.264637,
            -0.176806,
            0.492106,
            0.15666,
            0.284959,
            -0.188793,
            0.504774,
            0.17728,
            0.308157,
            -0.200763,
            0.518805,
            0.19988,
            0.330951,
            -0.21239,
            0.528231,
            0.224293,
            0.3549,
            -0.223521,
            0.536376,
            0.250541,
            0.381502,
            -0.234169,
            0.544846,
            0.278902,
            0.409529,
            -0.244077,
            0.551717,
            0.309227,
            0.437523,
            -0.253363,
            0.55517,
            0.341426,
            0.467624,
            -0.261659,
            0.557772,
            0.37518,
            0.497268,
            -0.268498,
            0.556442,
            0.41007,
            0.528294,
            -0.274018,
            0.553915,
            0.446445,
            0.559053,
            -0.278169,
            0.549153,
            0.483779,
            0.589329,
            -0.281229,
            0.539878,
            0.522249,
            0.622503,
            -0.282902,
            0.53162,
            0.561754,
            0.652382,
            -0.282815,
            0.518119,
            0.601544,
            0.681847,
            -0.281247,
            0.502187,
            0.641574,
            0.712285,
            -0.277986,
            0.484824,
            0.682633,
            0.740094,
            -0.273017,
            0.463483,
            0.723426,
            0.768478,
            -0.266692,
            0.441299,
            0.763747,
            0.794556,
            -0.258358,
            0.415238,
            0.805565,
            0.819408,
            -0.248807,
            0.386912,
            0.847254,
            0.843411,
            -0.236214,
            0.356165,
            0.891091,
            0.862397,
            -0.219794,
            0.320562,
            0.936174,
            0.883113,
            -0.201768,
            0.285322,
            0.982562,
            0.90023,
            -0.181672,
            0.249713,
            1.02862,
            0.915192,
            -0.159279,
            0.214546,
            1.07163,
            0.928458,
            -0.134725,
            0.180285,
            1.10995,
            0.94069,
            -0.10913,
            0.147119,
            1.14354,
            0.953409,
            -0.0821315,
            0.112492,
            1.17372,
            0.969537,
            -0.0542677,
            0.0752014,
            1.20043,
            0.985612,
            -0.0259096,
            0.0370361,
            1.22528,
            0.999835,
            0.00298198,
            -0.00151801,
            1.24959,
            0.10097,
            -0.00000602574,
            0.300277,
            0.00000202619,
            0.101577,
            -0.000152164,
            0.302077,
            0.0000511662,
            0.101572,
            -0.000608889,
            0.302066,
            0.000204751,
            0.101566,
            -0.00136997,
            0.302047,
            0.000460753,
            0.101592,
            -0.00243557,
            0.302114,
            0.000819497,
            0.101608,
            -0.0038053,
            0.30214,
            0.00128154,
            0.101627,
            -0.00547906,
            0.30216,
            0.0018483,
            0.101669,
            -0.00745647,
            0.302224,
            0.00252223,
            0.101732,
            -0.00973615,
            0.302318,
            0.00330716,
            0.101844,
            -0.0123097,
            0.302513,
            0.00421061,
            0.102025,
            -0.0151681,
            0.30285,
            0.00524481,
            0.102224,
            -0.0183334,
            0.303166,
            0.0064154,
            0.102515,
            -0.0217819,
            0.303654,
            0.00774063,
            0.102886,
            -0.0255067,
            0.304243,
            0.0092398,
            0.103395,
            -0.029514,
            0.305089,
            0.0109339,
            0.104109,
            -0.0337912,
            0.306301,
            0.0128561,
            0.105074,
            -0.0383565,
            0.30798,
            0.0150338,
            0.10654,
            -0.0432132,
            0.310726,
            0.0175228,
            0.108478,
            -0.0484244,
            0.314351,
            0.0203648,
            0.111015,
            -0.0539339,
            0.319032,
            0.0236325,
            0.114682,
            -0.0598885,
            0.32605,
            0.0274188,
            0.11911,
            -0.0663375,
            0.334109,
            0.0317905,
            0.124736,
            -0.0733011,
            0.344013,
            0.0368502,
            0.131479,
            -0.0807744,
            0.355358,
            0.0427104,
            0.139283,
            -0.0888204,
            0.367614,
            0.0494788,
            0.148054,
            -0.0973394,
            0.380072,
            0.0572367,
            0.159037,
            -0.10665,
            0.395678,
            0.0662704,
            0.169794,
            -0.116221,
            0.40795,
            0.0763192,
            0.18314,
            -0.126632,
            0.423546,
            0.087956,
            0.197515,
            -0.137383,
            0.438213,
            0.101042,
            0.213514,
            -0.148641,
            0.453248,
            0.115827,
            0.23065,
            -0.160117,
            0.46688,
            0.132283,
            0.249148,
            -0.171807,
            0.479962,
            0.150644,
            0.270219,
            -0.183695,
            0.494618,
            0.171073,
            0.292338,
            -0.195574,
            0.506937,
            0.193378,
            0.314999,
            -0.207205,
            0.516463,
            0.217585,
            0.340991,
            -0.218955,
            0.528123,
            0.24428,
            0.367982,
            -0.229917,
            0.537025,
            0.272784,
            0.39432,
            -0.239737,
            0.541627,
            0.302742,
            0.423364,
            -0.249048,
            0.546466,
            0.335112,
            0.453751,
            -0.257329,
            0.549466,
            0.369032,
            0.48416,
            -0.264623,
            0.549503,
            0.404577,
            0.515262,
            -0.270411,
            0.547008,
            0.441337,
            0.547036,
            -0.274581,
            0.542249,
            0.479162,
            0.576614,
            -0.277266,
            0.533015,
            0.517904,
            0.611143,
            -0.279144,
            0.525512,
            0.558508,
            0.640989,
            -0.279001,
            0.51154,
            0.598995,
            0.671182,
            -0.277324,
            0.495641,
            0.639935,
            0.700848,
            -0.273908,
            0.477526,
            0.681017,
            0.729862,
            -0.269063,
            0.457955,
            0.722764,
            0.758273,
            -0.262282,
            0.434846,
            0.764349,
            0.784121,
            -0.254281,
            0.409203,
            0.806206,
            0.809798,
            -0.24505,
            0.382694,
            0.848617,
            0.834953,
            -0.233861,
            0.354034,
            0.892445,
            0.856817,
            -0.221308,
            0.321764,
            0.936263,
            0.877609,
            -0.205996,
            0.288118,
            0.982401,
            0.897489,
            -0.186702,
            0.253277,
            1.02975,
            0.913792,
            -0.164618,
            0.217963,
            1.07488,
            0.92785,
            -0.140023,
            0.183221,
            1.11487,
            0.940378,
            -0.11328,
            0.149385,
            1.14947,
            0.95273,
            -0.0853958,
            0.114152,
            1.1807,
            0.969059,
            -0.0568698,
            0.0769845,
            1.20912,
            0.985574,
            -0.0276502,
            0.0381186,
            1.23498,
            0.999943,
            0.00239052,
            -0.00126861,
            1.25987,
            0.0852715,
            -0.00000560067,
            0.279021,
            0.00000171162,
            0.0854143,
            -0.000140871,
            0.279483,
            0.0000430516,
            0.0854191,
            -0.000563385,
            0.2795,
            0.000172184,
            0.0854188,
            -0.00126753,
            0.279493,
            0.000387464,
            0.0854229,
            -0.00225337,
            0.279501,
            0.00068918,
            0.0854443,
            -0.00352086,
            0.279549,
            0.00107803,
            0.0854697,
            -0.00506962,
            0.279591,
            0.00155536,
            0.0855093,
            -0.00689873,
            0.279652,
            0.00212354,
            0.0855724,
            -0.00900821,
            0.279752,
            0.00278703,
            0.0856991,
            -0.0113799,
            0.280011,
            0.0035551,
            0.085855,
            -0.0140314,
            0.280297,
            0.00443449,
            0.0860682,
            -0.016963,
            0.280682,
            0.00543636,
            0.086344,
            -0.0201438,
            0.281159,
            0.0065788,
            0.0867426,
            -0.0235999,
            0.281886,
            0.00787977,
            0.087239,
            -0.0273069,
            0.282745,
            0.0093606,
            0.0879815,
            -0.031269,
            0.284139,
            0.011056,
            0.0891258,
            -0.035531,
            0.28647,
            0.0130065,
            0.0906909,
            -0.0400947,
            0.289708,
            0.0152495,
            0.0927624,
            -0.0449638,
            0.293904,
            0.0178454,
            0.0958376,
            -0.0502427,
            0.300471,
            0.0208915,
            0.0995827,
            -0.0559514,
            0.30806,
            0.0244247,
            0.104526,
            -0.0622152,
            0.317874,
            0.0285721,
            0.110532,
            -0.0690046,
            0.329332,
            0.0334227,
            0.117385,
            -0.0763068,
            0.341217,
            0.0390466,
            0.12522,
            -0.084184,
            0.353968,
            0.0455786,
            0.134037,
            -0.0925248,
            0.366797,
            0.0530773,
            0.144014,
            -0.101487,
            0.380209,
            0.0617424,
            0.156013,
            -0.111273,
            0.395956,
            0.071777,
            0.168872,
            -0.121431,
            0.41053,
            0.0830905,
            0.183089,
            -0.132105,
            0.425073,
            0.0959341,
            0.198763,
            -0.143286,
            0.439833,
            0.110448,
            0.216159,
            -0.154841,
            0.454507,
            0.126769,
            0.234859,
            -0.166588,
            0.468368,
            0.14495,
            0.255879,
            -0.178626,
            0.482846,
            0.165233,
            0.27677,
            -0.190218,
            0.493489,
            0.187217,
            0.301184,
            -0.202227,
            0.506549,
            0.211659,
            0.325852,
            -0.213764,
            0.5158,
            0.237922,
            0.352824,
            -0.22487,
            0.525442,
            0.26632,
            0.380882,
            -0.235246,
            0.532487,
            0.296691,
            0.410137,
            -0.244847,
            0.537703,
            0.329179,
            0.439787,
            -0.253122,
            0.540361,
            0.363135,
            0.472291,
            -0.260517,
            0.542734,
            0.399222,
            0.501856,
            -0.266519,
            0.538826,
            0.436352,
            0.534816,
            -0.270905,
            0.535152,
            0.474505,
            0.565069,
            -0.273826,
            0.525979,
            0.513988,
            0.597154,
            -0.275333,
            0.516394,
            0.554852,
            0.630473,
            -0.275314,
            0.506206,
            0.596592,
            0.660574,
            -0.273323,
            0.489769,
            0.638117,
            0.692015,
            -0.270008,
            0.472578,
            0.680457,
            0.720647,
            -0.265001,
            0.452134,
            0.723008,
            0.750528,
            -0.258311,
            0.430344,
            0.765954,
            0.777568,
            -0.250046,
            0.405624,
            0.809012,
            0.80387,
            -0.240114,
            0.378339,
            0.852425,
            0.828439,
            -0.228737,
            0.349877,
            0.895346,
            0.851472,
            -0.216632,
            0.318968,
            0.940695,
            0.873906,
            -0.202782,
            0.287489,
            0.987235,
            0.89467,
            -0.187059,
            0.254394,
            1.03348,
            0.912281,
            -0.168818,
            0.221294,
            1.07812,
            0.927358,
            -0.146494,
            0.18675,
            1.11928,
            0.940385,
            -0.120009,
            0.152322,
            1.15609,
            0.952672,
            -0.0917183,
            0.117514,
            1.18875,
            0.968496,
            -0.0620321,
            0.0797405,
            1.21821,
            0.985236,
            -0.0314945,
            0.0402383,
            1.24523,
            0.99998,
            -0.000575153,
            0.000110644,
            1.27133,
            0.0702429,
            -0.00000512222,
            0.255273,
            0.00000140947,
            0.0702981,
            -0.000128826,
            0.255469,
            0.0000354488,
            0.0703691,
            -0.000515562,
            0.255727,
            0.000141874,
            0.0703805,
            -0.00116,
            0.255754,
            0.00031929,
            0.0703961,
            -0.00206224,
            0.255813,
            0.000567999,
            0.0704102,
            -0.00322223,
            0.255839,
            0.00088871,
            0.0704298,
            -0.00463928,
            0.255863,
            0.00128272,
            0.0704759,
            -0.00631375,
            0.255953,
            0.00175283,
            0.0705434,
            -0.00824317,
            0.256079,
            0.00230342,
            0.0706693,
            -0.010412,
            0.25636,
            0.0029443,
            0.0708189,
            -0.0128439,
            0.256647,
            0.00368031,
            0.0710364,
            -0.0155177,
            0.257084,
            0.00452614,
            0.0713223,
            -0.0184374,
            0.257637,
            0.00549706,
            0.0717182,
            -0.0216002,
            0.258416,
            0.00661246,
            0.072321,
            -0.0249966,
            0.259699,
            0.00790147,
            0.0731446,
            -0.0286566,
            0.261475,
            0.0093884,
            0.0743352,
            -0.0325888,
            0.264132,
            0.0111186,
            0.0760676,
            -0.036843,
            0.26815,
            0.013145,
            0.078454,
            -0.0414292,
            0.273636,
            0.0155251,
            0.0818618,
            -0.0464634,
            0.281653,
            0.0183525,
            0.0857382,
            -0.0519478,
            0.289992,
            0.0216642,
            0.0908131,
            -0.0579836,
            0.30066,
            0.0255956,
            0.0967512,
            -0.0645124,
            0.312204,
            0.0301954,
            0.103717,
            -0.0716505,
            0.325001,
            0.0356017,
            0.111596,
            -0.0793232,
            0.338129,
            0.041896,
            0.120933,
            -0.087645,
            0.352853,
            0.0492447,
            0.130787,
            -0.096492,
            0.366192,
            0.0576749,
            0.142311,
            -0.105973,
            0.380864,
            0.0673969,
            0.155344,
            -0.116182,
            0.396575,
            0.0785899,
            0.169535,
            -0.126815,
            0.411443,
            0.0912377,
            0.185173,
            -0.138015,
            0.426256,
            0.105607,
            0.201755,
            -0.149325,
            0.439607,
            0.121551,
            0.221334,
            -0.161207,
            0.455467,
            0.139608,
            0.241461,
            -0.173162,
            0.469096,
            0.159591,
            0.26294,
            -0.18504,
            0.481014,
            0.18156,
            0.286776,
            -0.196881,
            0.493291,
            0.205781,
            0.311596,
            -0.208311,
            0.503556,
            0.231819,
            0.338667,
            -0.219671,
            0.513268,
            0.260274,
            0.366021,
            -0.230451,
            0.519414,
            0.290862,
            0.395875,
            -0.240131,
            0.526766,
            0.323196,
            0.425564,
            -0.248566,
            0.52905,
            0.357071,
            0.457094,
            -0.256195,
            0.530796,
            0.393262,
            0.488286,
            -0.262331,
            0.528703,
            0.430797,
            0.522291,
            -0.267141,
            0.52727,
            0.470231,
            0.554172,
            -0.270411,
            0.519848,
            0.510477,
            0.586427,
            -0.271986,
            0.510307,
            0.551594,
            0.619638,
            -0.27192,
            0.499158,
            0.593849,
            0.650656,
            -0.269817,
            0.483852,
            0.636314,
            0.68284,
            -0.266267,
            0.467515,
            0.679679,
            0.714356,
            -0.26113,
            0.44931,
            0.723884,
            0.742717,
            -0.254067,
            0.425789,
            0.767245,
            0.770894,
            -0.245652,
            0.401144,
            0.811819,
            0.797358,
            -0.235554,
            0.374224,
            0.856315,
            0.823377,
            -0.223896,
            0.346167,
            0.901077,
            0.847456,
            -0.210865,
            0.316056,
            0.946502,
            0.870697,
            -0.196574,
            0.284503,
            0.993711,
            0.891068,
            -0.180814,
            0.251628,
            1.04134,
            0.909267,
            -0.163314,
            0.219065,
            1.08609,
            0.925653,
            -0.143304,
            0.186446,
            1.12702,
            0.940017,
            -0.121322,
            0.153416,
            1.16371,
            0.952398,
            -0.0973872,
            0.120334,
            1.19712,
            0.967568,
            -0.0698785,
            0.08352,
            1.22791,
            0.984772,
            -0.0390031,
            0.0439209,
            1.25672,
            1.00026,
            -0.0070087,
            0.00315668,
            1.28428,
            0.0556653,
            -0.00000459654,
            0.227325,
            0.00000112556,
            0.0565238,
            -0.000116382,
            0.230826,
            0.0000284985,
            0.0565717,
            -0.000465666,
            0.231026,
            0.000114036,
            0.0565859,
            -0.00104773,
            0.231079,
            0.000256656,
            0.0565761,
            -0.00186255,
            0.231025,
            0.00045663,
            0.0565913,
            -0.00291002,
            0.231058,
            0.000714664,
            0.0566108,
            -0.00418998,
            0.231085,
            0.00103224,
            0.0566532,
            -0.00570206,
            0.231169,
            0.00141202,
            0.0567473,
            -0.00743666,
            0.231417,
            0.00186018,
            0.0568567,
            -0.00940298,
            0.231661,
            0.00238264,
            0.0569859,
            -0.0115991,
            0.231895,
            0.00298699,
            0.0572221,
            -0.0140096,
            0.232456,
            0.00368957,
            0.057519,
            -0.0166508,
            0.233096,
            0.00450303,
            0.0579534,
            -0.01951,
            0.234094,
            0.00544945,
            0.0585922,
            -0.0225991,
            0.235629,
            0.00655564,
            0.0595647,
            -0.0259416,
            0.238106,
            0.00785724,
            0.0609109,
            -0.0295661,
            0.241557,
            0.00939127,
            0.0628751,
            -0.0335126,
            0.246652,
            0.0112198,
            0.0656908,
            -0.0378604,
            0.254091,
            0.0134168,
            0.0691347,
            -0.0426543,
            0.262666,
            0.0160374,
            0.0732165,
            -0.0478967,
            0.272029,
            0.0191514,
            0.0782863,
            -0.0536716,
            0.283007,
            0.0228597,
            0.0843973,
            -0.0600683,
            0.295732,
            0.0272829,
            0.0913598,
            -0.0670095,
            0.308779,
            0.032484,
            0.0994407,
            -0.0745516,
            0.322886,
            0.0385886,
            0.108189,
            -0.082712,
            0.336408,
            0.0457133,
            0.118574,
            -0.0914927,
            0.351692,
            0.0539832,
            0.129989,
            -0.100854,
            0.366502,
            0.0635162,
            0.142722,
            -0.110837,
            0.381675,
            0.0744386,
            0.156654,
            -0.121353,
            0.3963,
            0.0868483,
            0.172151,
            -0.132414,
            0.411477,
            0.100963,
            0.188712,
            -0.143809,
            0.42508,
            0.116795,
            0.208093,
            -0.155765,
            0.441328,
            0.134715,
            0.227936,
            -0.167608,
            0.454328,
            0.154396,
            0.249495,
            -0.179579,
            0.467235,
            0.176179,
            0.27362,
            -0.191488,
            0.480248,
            0.200193,
            0.296371,
            -0.202618,
            0.487886,
            0.225775,
            0.324234,
            -0.214133,
            0.499632,
            0.25441,
            0.353049,
            -0.225212,
            0.509532,
            0.285077,
            0.381785,
            -0.234875,
            0.514265,
            0.317047,
            0.414038,
            -0.244205,
            0.521282,
            0.351874,
            0.445251,
            -0.252145,
            0.522931,
            0.388279,
            0.476819,
            -0.258433,
            0.520947,
            0.425825,
            0.509209,
            -0.263411,
            0.517669,
            0.465104,
            0.542759,
            -0.266732,
            0.512841,
            0.505741,
            0.574822,
            -0.268263,
            0.503317,
            0.547611,
            0.609324,
            -0.268489,
            0.493035,
            0.590953,
            0.641772,
            -0.266941,
            0.478816,
            0.63488,
            0.674049,
            -0.263297,
            0.462863,
            0.679072,
            0.705071,
            -0.257618,
            0.442931,
            0.723487,
            0.734709,
            -0.250625,
            0.421299,
            0.768708,
            0.763704,
            -0.24179,
            0.397085,
            0.814375,
            0.791818,
            -0.231115,
            0.370577,
            0.859907,
            0.817439,
            -0.21922,
            0.34232,
            0.906715,
            0.843202,
            -0.205658,
            0.312627,
            0.953943,
            0.866639,
            -0.190563,
            0.280933,
            1.00185,
            0.888129,
            -0.173978,
            0.248393,
            1.05105,
            0.907239,
            -0.155485,
            0.216007,
            1.09704,
            0.923893,
            -0.134782,
            0.183233,
            1.13857,
            0.938882,
            -0.11249,
            0.150376,
            1.17539,
            0.952464,
            -0.0890706,
            0.117177,
            1.20924,
            0.968529,
            -0.0646523,
            0.0813095,
            1.24055,
            0.984763,
            -0.038606,
            0.0439378,
            1.27018,
            1.00053,
            -0.01238,
            0.00598668,
            1.29873,
            0.0437928,
            -0.00000409594,
            0.204012,
            0.000000879224,
            0.0440166,
            -0.000103395,
            0.205049,
            0.0000221946,
            0.0440529,
            -0.000413633,
            0.205225,
            0.0000887981,
            0.0440493,
            -0.000930594,
            0.2052,
            0.000199858,
            0.0439884,
            -0.00165352,
            0.204901,
            0.000355495,
            0.0440716,
            -0.0025849,
            0.205255,
            0.000556983,
            0.0440968,
            -0.00372222,
            0.205311,
            0.000805326,
            0.0441359,
            -0.00506478,
            0.205391,
            0.00110333,
            0.0442231,
            -0.00660384,
            0.205638,
            0.00145768,
            0.0443254,
            -0.00835246,
            0.205877,
            0.00187275,
            0.0444832,
            -0.0102992,
            0.20627,
            0.00235938,
            0.0447001,
            -0.0124449,
            0.206796,
            0.0029299,
            0.0450168,
            -0.0147935,
            0.207593,
            0.0036005,
            0.0454816,
            -0.017336,
            0.208819,
            0.00439246,
            0.0462446,
            -0.0201156,
            0.211036,
            0.00533864,
            0.0473694,
            -0.0231568,
            0.214388,
            0.00646984,
            0.0490191,
            -0.0264941,
            0.219357,
            0.00783856,
            0.0512776,
            -0.030184,
            0.226061,
            0.00950182,
            0.0541279,
            -0.0342661,
            0.234094,
            0.0115156,
            0.0578989,
            -0.0388539,
            0.244297,
            0.0139687,
            0.0620835,
            -0.0438735,
            0.254457,
            0.0169015,
            0.0673497,
            -0.04951,
            0.266706,
            0.0204554,
            0.0731759,
            -0.0556263,
            0.278753,
            0.0246606,
            0.0803937,
            -0.0624585,
            0.29309,
            0.0297126,
            0.0879287,
            -0.0697556,
            0.305856,
            0.0355868,
            0.0970669,
            -0.0778795,
            0.321059,
            0.0425768,
            0.106508,
            -0.0863541,
            0.333873,
            0.05056,
            0.11776,
            -0.0955935,
            0.349008,
            0.0598972,
            0.130081,
            -0.105438,
            0.363776,
            0.0706314,
            0.144454,
            -0.115899,
            0.380112,
            0.0828822,
            0.1596,
            -0.126827,
            0.394843,
            0.0967611,
            0.176097,
            -0.138161,
            0.409033,
            0.112381,
            0.194726,
            -0.149904,
            0.424257,
            0.129952,
            0.213944,
            -0.161675,
            0.436945,
            0.149333,
            0.235516,
            -0.173659,
            0.450176,
            0.170892,
            0.260564,
            -0.185963,
            0.466305,
            0.194984,
            0.285183,
            -0.197582,
            0.477328,
            0.220805,
            0.311095,
            -0.208697,
            0.486566,
            0.248694,
            0.338924,
            -0.219519,
            0.494811,
            0.279015,
            0.369757,
            -0.229766,
            0.504065,
            0.311725,
            0.3996,
            -0.238879,
            0.507909,
            0.345844,
            0.430484,
            -0.246802,
            0.509805,
            0.381749,
            0.46413,
            -0.253924,
            0.511436,
            0.420251,
            0.497077,
            -0.259319,
            0.508787,
            0.459957,
            0.530434,
            -0.263297,
            0.50394,
            0.501356,
            0.565725,
            -0.265619,
            0.49804,
            0.544252,
            0.599254,
            -0.265842,
            0.487346,
            0.587856,
            0.631251,
            -0.263978,
            0.472975,
            0.631969,
            0.663972,
            -0.26043,
            0.457135,
            0.677471,
            0.697724,
            -0.255358,
            0.439844,
            0.723744,
            0.727725,
            -0.248308,
            0.417872,
            0.770653,
            0.756417,
            -0.239181,
            0.39273,
            0.817357,
            0.785419,
            -0.22814,
            0.367839,
            0.864221,
            0.81266,
            -0.215681,
            0.339449,
            0.912701,
            0.839391,
            -0.201623,
            0.309279,
            0.962419,
            0.86366,
            -0.185624,
            0.278029,
            1.0122,
            0.885028,
            -0.16797,
            0.245294,
            1.06186,
            0.904639,
            -0.148336,
            0.212689,
            1.10934,
            0.922048,
            -0.12637,
            0.179616,
            1.15063,
            0.936952,
            -0.102928,
            0.146749,
            1.18885,
            0.951895,
            -0.0785268,
            0.112733,
            1.22352,
            0.967198,
            -0.0530153,
            0.0760056,
            1.25681,
            0.984405,
            -0.02649,
            0.0383183,
            1.28762,
            1.00021,
            0.00070019,
            -0.00020039,
            1.31656,
            0.0325964,
            -0.00000355447,
            0.176706,
            0.000000655682,
            0.0329333,
            -0.0000899174,
            0.178527,
            0.0000165869,
            0.0329181,
            -0.000359637,
            0.178453,
            0.0000663498,
            0.0329085,
            -0.000808991,
            0.178383,
            0.000149332,
            0.0329181,
            -0.00143826,
            0.178394,
            0.000265873,
            0.0329425,
            -0.00224678,
            0.178517,
            0.000416597,
            0.0329511,
            -0.00323575,
            0.17849,
            0.000603299,
            0.033011,
            -0.00439875,
            0.178695,
            0.000829422,
            0.0330733,
            -0.00574059,
            0.178843,
            0.00109908,
            0.0331857,
            -0.00725896,
            0.179176,
            0.00141933,
            0.0333445,
            -0.00895289,
            0.179618,
            0.0017999,
            0.0335674,
            -0.0108219,
            0.180238,
            0.00225316,
            0.033939,
            -0.0128687,
            0.181417,
            0.00279765,
            0.0345239,
            -0.015114,
            0.183395,
            0.0034564,
            0.0354458,
            -0.017596,
            0.186616,
            0.00425864,
            0.0368313,
            -0.0203524,
            0.191547,
            0.00524936,
            0.0386115,
            -0.0234105,
            0.197508,
            0.00647033,
            0.0410303,
            -0.0268509,
            0.205395,
            0.00798121,
            0.0442245,
            -0.0307481,
            0.215365,
            0.0098557,
            0.0478659,
            -0.0350863,
            0.225595,
            0.0121417,
            0.0522416,
            -0.0399506,
            0.236946,
            0.0149385,
            0.0574513,
            -0.045357,
            0.249442,
            0.0183189,
            0.0631208,
            -0.0512863,
            0.261222,
            0.0223644,
            0.0701124,
            -0.0579273,
            0.275418,
            0.0272418,
            0.0777331,
            -0.0650652,
            0.288989,
            0.0329458,
            0.0862709,
            -0.0728813,
            0.302546,
            0.0396819,
            0.096103,
            -0.081363,
            0.317164,
            0.04757,
            0.106976,
            -0.0904463,
            0.331733,
            0.0567012,
            0.119175,
            -0.100105,
            0.34661,
            0.067202,
            0.132919,
            -0.110375,
            0.362249,
            0.0792588,
            0.147727,
            -0.121115,
            0.376978,
            0.0928672,
            0.163618,
            -0.132299,
            0.390681,
            0.108228,
            0.182234,
            -0.143887,
            0.406571,
            0.125502,
            0.201809,
            -0.155827,
            0.42042,
            0.144836,
            0.225041,
            -0.168357,
            0.438411,
            0.166706,
            0.247621,
            -0.18004,
            0.450368,
            0.189909,
            0.27097,
            -0.191536,
            0.460083,
            0.215251,
            0.296658,
            -0.203024,
            0.469765,
            0.243164,
            0.325892,
            -0.214056,
            0.481837,
            0.273388,
            0.35406,
            -0.224104,
            0.487474,
            0.305344,
            0.384372,
            -0.233489,
            0.492773,
            0.339741,
            0.41749,
            -0.241874,
            0.498451,
            0.376287,
            0.45013,
            -0.248834,
            0.499632,
            0.414195,
            0.481285,
            -0.254658,
            0.495233,
            0.454077,
            0.519183,
            -0.259367,
            0.496401,
            0.496352,
            0.551544,
            -0.261818,
            0.487686,
            0.538798,
            0.587349,
            -0.262964,
            0.479453,
            0.583626,
            0.621679,
            -0.262128,
            0.467709,
            0.629451,
            0.654991,
            -0.258998,
            0.452123,
            0.67566,
            0.686873,
            -0.254119,
            0.433495,
            0.723248,
            0.719801,
            -0.246946,
            0.413657,
            0.771156,
            0.750355,
            -0.237709,
            0.390366,
            0.81989,
            0.780033,
            -0.226549,
            0.364947,
            0.868601,
            0.809254,
            -0.214186,
            0.337256,
            0.920034,
            0.836576,
            -0.199639,
            0.307395,
            0.971706,
            0.861774,
            -0.183169,
            0.275431,
            1.02479,
            0.885707,
            -0.165111,
            0.243431,
            1.07837,
            0.904742,
            -0.144363,
            0.210921,
            1.12783,
            0.915604,
            -0.121305,
            0.17647,
            1.17254,
            0.930959,
            -0.0962119,
            0.143106,
            1.21012,
            0.948404,
            -0.069969,
            0.108112,
            1.24474,
            0.967012,
            -0.0427586,
            0.0708478,
            1.27718,
            0.984183,
            -0.0147043,
            0.032335,
            1.3083,
            0.999577,
            0.0142165,
            -0.00726867,
            1.3382,
            0.0229227,
            -0.00000299799,
            0.148623,
            0.000000462391,
            0.0232194,
            -0.0000758796,
            0.15054,
            0.0000117033,
            0.0232315,
            -0.000303636,
            0.15063,
            0.0000468397,
            0.0232354,
            -0.000683189,
            0.150624,
            0.000105472,
            0.0232092,
            -0.0012136,
            0.150445,
            0.000187744,
            0.0232523,
            -0.00189765,
            0.150679,
            0.000294847,
            0.0232828,
            -0.00273247,
            0.150789,
            0.000428013,
            0.0233371,
            -0.00371287,
            0.150995,
            0.000591134,
            0.0234015,
            -0.00484794,
            0.15118,
            0.000787642,
            0.023514,
            -0.00612877,
            0.151562,
            0.00102547,
            0.023679,
            -0.00756125,
            0.152116,
            0.00131351,
            0.0239559,
            -0.00914651,
            0.153162,
            0.00166594,
            0.0244334,
            -0.010904,
            0.155133,
            0.00210182,
            0.025139,
            -0.0128615,
            0.158035,
            0.00264406,
            0.0262598,
            -0.0150628,
            0.162751,
            0.00332923,
            0.0277875,
            -0.0175532,
            0.168944,
            0.00419773,
            0.0298472,
            -0.0203981,
            0.176835,
            0.00530034,
            0.0325444,
            -0.023655,
            0.186686,
            0.00669777,
            0.0355581,
            -0.0272982,
            0.196248,
            0.00842661,
            0.0392841,
            -0.0314457,
            0.207352,
            0.0105854,
            0.0436815,
            -0.0361157,
            0.219279,
            0.0132458,
            0.0485272,
            -0.0412932,
            0.230728,
            0.0164736,
            0.0541574,
            -0.0470337,
            0.242994,
            0.0203715,
            0.0609479,
            -0.0535002,
            0.257042,
            0.0250953,
            0.0685228,
            -0.0605409,
            0.27102,
            0.0306856,
            0.0768042,
            -0.0680553,
            0.28406,
            0.037193,
            0.0864844,
            -0.0765011,
            0.299186,
            0.0449795,
            0.0969415,
            -0.0852674,
            0.3132,
            0.0538316,
            0.108478,
            -0.0947333,
            0.327138,
            0.0641149,
            0.121705,
            -0.10481,
            0.342345,
            0.0759185,
            0.136743,
            -0.115474,
            0.358472,
            0.0894116,
            0.152986,
            -0.126536,
            0.374067,
            0.104562,
            0.170397,
            -0.138061,
            0.388267,
            0.121632,
            0.191392,
            -0.150203,
            0.406467,
            0.140996,
            0.211566,
            -0.161751,
            0.418641,
            0.161696,
            0.233567,
            -0.173407,
            0.430418,
            0.184557,
            0.257769,
            -0.185397,
            0.44277,
            0.210092,
            0.28531,
            -0.197048,
            0.457191,
            0.237827,
            0.311726,
            -0.20784,
            0.464712,
            0.267253,
            0.340537,
            -0.218345,
            0.472539,
            0.299332,
            0.372921,
            -0.228306,
            0.482331,
            0.333988,
            0.402924,
            -0.236665,
            0.484378,
            0.369722,
            0.434475,
            -0.244097,
            0.484717,
            0.407836,
            0.469736,
            -0.250547,
            0.487093,
            0.448465,
            0.505045,
            -0.25511,
            0.485575,
            0.490263,
            0.540262,
            -0.258444,
            0.481225,
            0.534495,
            0.576347,
            -0.259903,
            0.473481,
            0.579451,
            0.608656,
            -0.259572,
            0.4603,
            0.625604,
            0.646679,
            -0.257908,
            0.450341,
            0.674511,
            0.679902,
            -0.253663,
            0.431561,
            0.723269,
            0.714159,
            -0.247419,
            0.412684,
            0.773263,
            0.745345,
            -0.239122,
            0.389388,
            0.824182,
            0.778248,
            -0.228837,
            0.365361,
            0.876634,
            0.807208,
            -0.216197,
            0.337667,
            0.92945,
            0.835019,
            -0.201772,
            0.307197,
            0.985261,
            0.860261,
            -0.185291,
            0.274205,
            1.04299,
            0.877601,
            -0.165809,
            0.240178,
            1.09816,
            0.898211,
            -0.143897,
            0.207571,
            1.14694,
            0.915789,
            -0.119513,
            0.174904,
            1.19008,
            0.931831,
            -0.0932919,
            0.141423,
            1.2297,
            0.949244,
            -0.0656528,
            0.105603,
            1.26553,
            0.967527,
            -0.0370262,
            0.0679551,
            1.29986,
            0.984139,
            -0.00730117,
            0.0283133,
            1.33252,
            0.999713,
            0.0234648,
            -0.0121785,
            1.36397,
            0.0152135,
            -0.00000245447,
            0.122795,
            0.000000304092,
            0.0151652,
            -0.0000615778,
            0.122399,
            0.0000076292,
            0.0151181,
            -0.000245948,
            0.122023,
            0.0000304802,
            0.0151203,
            -0.000553394,
            0.12203,
            0.0000686634,
            0.015125,
            -0.000983841,
            0.122037,
            0.000122463,
            0.0151427,
            -0.00153774,
            0.12214,
            0.000192706,
            0.0151708,
            -0.0022103,
            0.122237,
            0.000281219,
            0.0152115,
            -0.00300741,
            0.12238,
            0.000390804,
            0.0152877,
            -0.00392494,
            0.1227,
            0.000526317,
            0.015412,
            -0.00496597,
            0.123244,
            0.00069443,
            0.0156201,
            -0.00613314,
            0.124228,
            0.00090547,
            0.0159658,
            -0.00744113,
            0.125945,
            0.0011732,
            0.0165674,
            -0.00892546,
            0.129098,
            0.00151888,
            0.017487,
            -0.010627,
            0.133865,
            0.00197007,
            0.018839,
            -0.0126043,
            0.140682,
            0.0025637,
            0.020554,
            -0.0148814,
            0.148534,
            0.00333637,
            0.0226727,
            -0.0175123,
            0.157381,
            0.00433738,
            0.0251879,
            -0.0205266,
            0.166685,
            0.00561664,
            0.0283635,
            -0.0240319,
            0.177796,
            0.00725563,
            0.0318694,
            -0.0279432,
            0.188251,
            0.00928811,
            0.0361044,
            -0.0324313,
            0.200038,
            0.011835,
            0.0406656,
            -0.0373527,
            0.210685,
            0.0149146,
            0.0463846,
            -0.0430132,
            0.224182,
            0.0187254,
            0.0525696,
            -0.0491013,
            0.23634,
            0.0232283,
            0.0598083,
            -0.0559175,
            0.250013,
            0.0286521,
            0.0679437,
            -0.0633657,
            0.263981,
            0.0350634,
            0.0771181,
            -0.0714602,
            0.278072,
            0.0425882,
            0.0881273,
            -0.0803502,
            0.29511,
            0.0514487,
            0.0996628,
            -0.0896903,
            0.309976,
            0.0615766,
            0.112702,
            -0.099644,
            0.325611,
            0.0732139,
            0.126488,
            -0.109829,
            0.339321,
            0.0862324,
            0.142625,
            -0.120859,
            0.35574,
            0.101275,
            0.15953,
            -0.131956,
            0.369845,
            0.117892,
            0.176991,
            -0.143145,
            0.38146,
            0.136205,
            0.199715,
            -0.155292,
            0.40052,
            0.157252,
            0.220787,
            -0.167066,
            0.412055,
            0.179966,
            0.243697,
            -0.178396,
            0.423133,
            0.204418,
            0.272106,
            -0.190433,
            0.439524,
            0.232141,
            0.297637,
            -0.201265,
            0.447041,
            0.261109,
            0.325273,
            -0.211834,
            0.454488,
            0.292627,
            0.357219,
            -0.221889,
            0.465004,
            0.326669,
            0.387362,
            -0.230729,
            0.468527,
            0.362426,
            0.423131,
            -0.23924,
            0.475836,
            0.401533,
            0.45543,
            -0.246067,
            0.475017,
            0.441902,
            0.493393,
            -0.251557,
            0.478017,
            0.484239,
            0.526253,
            -0.255571,
            0.4709,
            0.528586,
            0.560554,
            -0.257752,
            0.463167,
            0.574346,
            0.599306,
            -0.258076,
            0.456452,
            0.621655,
            0.634541,
            -0.256471,
            0.443725,
            0.670492,
            0.668907,
            -0.253283,
            0.428719,
            0.721943,
            0.705619,
            -0.247562,
            0.411348,
            0.772477,
            0.739034,
            -0.240626,
            0.388939,
            0.8264,
            0.771408,
            -0.231493,
            0.36425,
            0.881702,
            0.803312,
            -0.220125,
            0.337321,
            0.9385,
            0.828457,
            -0.206645,
            0.305364,
            0.997437,
            0.854819,
            -0.190664,
            0.273715,
            1.05693,
            0.878666,
            -0.171429,
            0.242218,
            1.11251,
            0.898404,
            -0.149235,
            0.209556,
            1.16398,
            0.917416,
            -0.12435,
            0.176863,
            1.21014,
            0.933133,
            -0.0972703,
            0.142775,
            1.25178,
            0.95066,
            -0.0683607,
            0.106735,
            1.29028,
            0.968589,
            -0.0378724,
            0.0681609,
            1.32703,
            0.984776,
            -0.00605712,
            0.0273966,
            1.36158,
            0.99994,
            0.0263276,
            -0.0138124,
            1.3943,
            0.00867437,
            -0.00000186005,
            0.0928979,
            0.000000173682,
            0.00864003,
            -0.0000466389,
            0.0925237,
            0.00000435505,
            0.00864593,
            -0.000186594,
            0.0925806,
            0.0000174322,
            0.00864095,
            -0.000419639,
            0.0924903,
            0.0000392862,
            0.00863851,
            -0.000746272,
            0.0924589,
            0.0000702598,
            0.00868531,
            -0.00116456,
            0.0929,
            0.000111188,
            0.00869667,
            -0.00167711,
            0.0928529,
            0.000163867,
            0.00874332,
            -0.00228051,
            0.0930914,
            0.00023104,
            0.00882709,
            -0.00297864,
            0.0935679,
            0.00031741,
            0.00898874,
            -0.00377557,
            0.0946165,
            0.000430186,
            0.00929346,
            -0.00469247,
            0.0967406,
            0.000580383,
            0.00978271,
            -0.00575491,
            0.100084,
            0.000783529,
            0.0105746,
            -0.00701514,
            0.105447,
            0.00106304,
            0.0116949,
            -0.00851797,
            0.112494,
            0.00144685,
            0.0130419,
            -0.0102757,
            0.119876,
            0.00196439,
            0.0148375,
            -0.012381,
            0.129034,
            0.00266433,
            0.0168725,
            -0.01482,
            0.137812,
            0.00358364,
            0.0193689,
            -0.0176563,
            0.147696,
            0.00478132,
            0.0222691,
            -0.0209211,
            0.157795,
            0.00631721,
            0.0256891,
            -0.0246655,
            0.168431,
            0.00826346,
            0.0294686,
            -0.0288597,
            0.178587,
            0.0106714,
            0.0340412,
            -0.0336441,
            0.190251,
            0.0136629,
            0.0393918,
            -0.039033,
            0.202999,
            0.0173272,
            0.0453947,
            -0.0450087,
            0.215655,
            0.0217448,
            0.0521936,
            -0.0515461,
            0.228686,
            0.0269941,
            0.0600279,
            -0.058817,
            0.242838,
            0.033272,
            0.0692398,
            -0.0667228,
            0.258145,
            0.0406457,
            0.0793832,
            -0.0752401,
            0.273565,
            0.0492239,
            0.0902297,
            -0.0841851,
            0.287735,
            0.0590105,
            0.102014,
            -0.0936479,
            0.301161,
            0.0702021,
            0.116054,
            -0.103967,
            0.317438,
            0.0832001,
            0.13191,
            -0.114622,
            0.334166,
            0.0977951,
            0.148239,
            -0.125452,
            0.348192,
            0.113985,
            0.165809,
            -0.136453,
            0.361094,
            0.131928,
            0.184616,
            -0.147648,
            0.373534,
            0.151811,
            0.207491,
            -0.159607,
            0.39101,
            0.174476,
            0.230106,
            -0.171119,
            0.402504,
            0.198798,
            0.257036,
            -0.182906,
            0.418032,
            0.225796,
            0.281172,
            -0.193605,
            0.425468,
            0.254027,
            0.312034,
            -0.204771,
            0.440379,
            0.285713,
            0.340402,
            -0.214988,
            0.445406,
            0.319196,
            0.370231,
            -0.224711,
            0.44968,
            0.35537,
            0.407105,
            -0.233516,
            0.460747,
            0.393838,
            0.439037,
            -0.240801,
            0.460624,
            0.433747,
            0.47781,
            -0.24762,
            0.465957,
            0.477234,
            0.510655,
            -0.251823,
            0.460054,
            0.52044,
            0.550584,
            -0.255552,
            0.459172,
            0.567853,
            0.585872,
            -0.257036,
            0.450311,
            0.615943,
            0.620466,
            -0.257535,
            0.437763,
            0.667693,
            0.660496,
            -0.255248,
            0.426639,
            0.718988,
            0.695578,
            -0.251141,
            0.409185,
            0.772503,
            0.732176,
            -0.244718,
            0.39015,
            0.827023,
            0.760782,
            -0.236782,
            0.362594,
            0.885651,
            0.79422,
            -0.225923,
            0.33711,
            0.943756,
            0.824521,
            -0.213855,
            0.308272,
            1.00874,
            0.854964,
            -0.197723,
            0.278529,
            1.06764,
            0.878065,
            -0.179209,
            0.246208,
            1.12836,
            0.899834,
            -0.157569,
            0.21329,
            1.18318,
            0.918815,
            -0.133206,
            0.181038,
            1.23161,
            0.934934,
            -0.106545,
            0.146993,
            1.27644,
            0.952115,
            -0.0780574,
            0.111175,
            1.31842,
            0.96906,
            -0.0478279,
            0.0728553,
            1.35839,
            0.985178,
            -0.0160014,
            0.032579,
            1.39697,
            1.00039,
            0.0173126,
            -0.0095256,
            1.43312,
            0.00384146,
            -0.00000124311,
            0.0613583,
            0.0000000778271,
            0.00390023,
            -0.0000314043,
            0.0622919,
            0.00000196626,
            0.00389971,
            -0.000125622,
            0.0622632,
            0.00000787379,
            0.00389491,
            -0.000282352,
            0.0620659,
            0.00001778,
            0.00391618,
            -0.000502512,
            0.0624687,
            0.0000320918,
            0.00392662,
            -0.000784458,
            0.0625113,
            0.0000515573,
            0.00396053,
            -0.00112907,
            0.0628175,
            0.0000778668,
            0.00401911,
            -0.00153821,
            0.0633286,
            0.000113811,
            0.00414994,
            -0.0020208,
            0.0646443,
            0.00016445,
            0.00441223,
            -0.00260007,
            0.0673886,
            0.000237734,
            0.00484427,
            -0.0033097,
            0.0716528,
            0.000345929,
            0.00549109,
            -0.00418966,
            0.0774998,
            0.000505987,
            0.00636293,
            -0.00527331,
            0.0844758,
            0.000739208,
            0.00746566,
            -0.00660428,
            0.0921325,
            0.00107347,
            0.00876625,
            -0.00818826,
            0.0997067,
            0.00153691,
            0.0103125,
            -0.0100811,
            0.107433,
            0.00217153,
            0.0123309,
            -0.0123643,
            0.117088,
            0.00303427,
            0.0146274,
            -0.0150007,
            0.126438,
            0.00416018,
            0.0172295,
            -0.0180531,
            0.135672,
            0.00561513,
            0.0204248,
            -0.0215962,
            0.146244,
            0.007478,
            0.0241597,
            -0.0256234,
            0.157481,
            0.00981046,
            0.0284693,
            -0.0302209,
            0.169125,
            0.0127148,
            0.033445,
            -0.0353333,
            0.181659,
            0.0162453,
            0.0391251,
            -0.0410845,
            0.1944,
            0.0205417,
            0.0454721,
            -0.0473451,
            0.207082,
            0.0256333,
            0.0530983,
            -0.0542858,
            0.221656,
            0.0317036,
            0.0615356,
            -0.0618384,
            0.236036,
            0.0388319,
            0.0703363,
            -0.0697631,
            0.248398,
            0.046974,
            0.0810391,
            -0.0784757,
            0.263611,
            0.0565246,
            0.0920144,
            -0.0873488,
            0.275857,
            0.0671724,
            0.105584,
            -0.0973652,
            0.292555,
            0.0798105,
            0.119506,
            -0.107271,
            0.306333,
            0.0935945,
            0.134434,
            -0.117608,
            0.318888,
            0.109106,
            0.153399,
            -0.128938,
            0.337552,
            0.127074,
            0.171258,
            -0.139944,
            0.349955,
            0.14643,
            0.191059,
            -0.151288,
            0.361545,
            0.168,
            0.215069,
            -0.163018,
            0.378421,
            0.192082,
            0.237838,
            -0.174226,
            0.38879,
            0.217838,
            0.266965,
            -0.186063,
            0.405857,
            0.246931,
            0.292827,
            -0.196909,
            0.414146,
            0.277505,
            0.324352,
            -0.207473,
            0.426955,
            0.310711,
            0.354427,
            -0.217713,
            0.433429,
            0.346794,
            0.389854,
            -0.227183,
            0.443966,
            0.385237,
            0.420749,
            -0.235131,
            0.44471,
            0.424955,
            0.459597,
            -0.242786,
            0.451729,
            0.468446,
            0.495316,
            -0.248767,
            0.45072,
            0.513422,
            0.534903,
            -0.253351,
            0.450924,
            0.560618,
            0.572369,
            -0.256277,
            0.445266,
            0.609677,
            0.612383,
            -0.2576,
            0.438798,
            0.660995,
            0.644037,
            -0.256931,
            0.421693,
            0.713807,
            0.686749,
            -0.254036,
            0.4109,
            0.767616,
            0.719814,
            -0.249785,
            0.390151,
            0.82533,
            0.754719,
            -0.244283,
            0.367847,
            0.888311,
            0.792022,
            -0.235076,
            0.345013,
            0.948177,
            0.822404,
            -0.225061,
            0.316193,
            1.01661,
            0.853084,
            -0.211113,
            0.287013,
            1.08075,
            0.879871,
            -0.19449,
            0.255424,
            1.14501,
            0.901655,
            -0.174023,
            0.222879,
            1.20203,
            0.919957,
            -0.1509,
            0.18989,
            1.25698,
            0.938412,
            -0.124923,
            0.15606,
            1.30588,
            0.953471,
            -0.0968139,
            0.120512,
            1.3529,
            0.970451,
            -0.066734,
            0.0828515,
            1.3986,
            0.985522,
            -0.034734,
            0.0424458,
            1.44148,
            1.00099,
            -0.00102222,
            0.000678929,
            1.48398,
            0.000965494,
            -0.000000627338,
            0.0306409,
            0.0000000197672,
            0.00099168,
            -0.0000158573,
            0.0314638,
            0.000000499803,
            0.000991068,
            -0.0000634012,
            0.031363,
            0.00000200682,
            0.000974567,
            -0.00014144,
            0.03036,
            0.00000457312,
            0.000998079,
            -0.000252812,
            0.031496,
            0.00000860131,
            0.00102243,
            -0.000396506,
            0.0319955,
            0.0000148288,
            0.00107877,
            -0.000577593,
            0.0331376,
            0.0000249141,
            0.00121622,
            -0.000816816,
            0.0359396,
            0.0000423011,
            0.0014455,
            -0.00113761,
            0.0399652,
            0.0000724613,
            0.00178791,
            -0.00156959,
            0.0450556,
            0.000123929,
            0.00225668,
            -0.00214064,
            0.0508025,
            0.000208531,
            0.00285627,
            -0.00287655,
            0.0568443,
            0.000341969,
            0.0035991,
            -0.00380271,
            0.0630892,
            0.000544158,
            0.00455524,
            -0.00496264,
            0.0702204,
            0.000842423,
            0.00569143,
            -0.0063793,
            0.0773426,
            0.00126704,
            0.00716928,
            -0.00813531,
            0.0860839,
            0.00186642,
            0.00885307,
            -0.0101946,
            0.0944079,
            0.00267014,
            0.0109316,
            -0.0126386,
            0.103951,
            0.00374033,
            0.0133704,
            -0.0154876,
            0.113786,
            0.0051304,
            0.0161525,
            -0.0187317,
            0.123477,
            0.00688858,
            0.0194267,
            -0.0224652,
            0.133986,
            0.00910557,
            0.0230967,
            -0.0265976,
            0.143979,
            0.0118074,
            0.0273627,
            -0.0312848,
            0.154645,
            0.0151266,
            0.0323898,
            -0.0365949,
            0.166765,
            0.0191791,
            0.0379225,
            -0.0422914,
            0.177932,
            0.0239236,
            0.0447501,
            -0.0487469,
            0.19167,
            0.0296568,
            0.0519391,
            -0.0556398,
            0.203224,
            0.0362924,
            0.0599464,
            -0.0631646,
            0.215652,
            0.0440585,
            0.0702427,
            -0.0714308,
            0.232089,
            0.0531619,
            0.0806902,
            -0.0800605,
            0.245258,
            0.0634564,
            0.0923194,
            -0.0892815,
            0.258609,
            0.0752481,
            0.106938,
            -0.09931,
            0.276654,
            0.0888914,
            0.121238,
            -0.109575,
            0.289847,
            0.104055,
            0.138817,
            -0.120461,
            0.307566,
            0.121266,
            0.15595,
            -0.131209,
            0.320117,
            0.139944,
            0.178418,
            -0.143049,
            0.339677,
            0.161591,
            0.197875,
            -0.154074,
            0.349886,
            0.184303,
            0.224368,
            -0.166307,
            0.369352,
            0.210669,
            0.252213,
            -0.178051,
            0.386242,
            0.238895,
            0.277321,
            -0.189335,
            0.395294,
            0.269182,
            0.310332,
            -0.200683,
            0.412148,
            0.302508,
            0.338809,
            -0.210856,
            0.418266,
            0.337264,
            0.372678,
            -0.220655,
            0.428723,
            0.374881,
            0.405632,
            -0.230053,
            0.433887,
            0.415656,
            0.442293,
            -0.237993,
            0.439911,
            0.457982,
            0.477256,
            -0.244897,
            0.440175,
            0.502831,
            0.515592,
            -0.250657,
            0.441079,
            0.550277,
            0.550969,
            -0.255459,
            0.435219,
            0.601102,
            0.592883,
            -0.257696,
            0.432882,
            0.651785,
            0.629092,
            -0.259894,
            0.421054,
            0.708961,
            0.672033,
            -0.258592,
            0.41177,
            0.763806,
            0.709147,
            -0.256525,
            0.395267,
            0.824249,
            0.745367,
            -0.254677,
            0.375013,
            0.8951,
            0.784715,
            -0.247892,
            0.353906,
            0.959317,
            0.818107,
            -0.240162,
            0.327801,
            1.03153,
            0.847895,
            -0.229741,
            0.298821,
            1.10601,
            0.879603,
            -0.213084,
            0.269115,
            1.164,
            0.902605,
            -0.195242,
            0.236606,
            1.22854,
            0.922788,
            -0.174505,
            0.203442,
            1.29017,
            0.944831,
            -0.150169,
            0.169594,
            1.34157,
            0.959656,
            -0.124099,
            0.135909,
            1.3956,
            0.972399,
            -0.0960626,
            0.0990563,
            1.45128,
            0.986549,
            -0.0657097,
            0.0602348,
            1.50312,
            1.00013,
            -0.0333558,
            0.0186694,
            1.55364,
            0.00000619747,
            -0.0000001,
            0.00778326,
            0.0000000000796756,
            0.0000000237499,
            -0.0000000999999,
            0.0000282592,
            0.000000000114596,
            0.00000100292,
            -0.00000166369,
            0.000250354,
            0.00000000677492,
            0.00000350752,
            -0.00000637769,
            0.000357289,
            0.0000000631655,
            0.00000826445,
            -0.0000174689,
            0.000516179,
            0.00000031851,
            0.0000242481,
            -0.0000450868,
            0.0010223,
            0.00000130577,
            0.0000455631,
            -0.000089044,
            0.00144302,
            0.00000374587,
            0.0000971222,
            -0.000178311,
            0.00241912,
            0.0000102584,
            0.000171403,
            -0.000313976,
            0.00354938,
            0.0000236481,
            0.000292747,
            -0.000520026,
            0.00513765,
            0.0000496014,
            0.000789827,
            -0.00118187,
            0.0238621,
            0.000139056,
            0.00114093,
            -0.00171827,
            0.0286691,
            0.000244093,
            0.00176119,
            -0.00249667,
            0.0368565,
            0.000420623,
            0.0022233,
            -0.00333742,
            0.0400469,
            0.00065673,
            0.00343382,
            -0.00481976,
            0.0535751,
            0.00109323,
            0.00427602,
            -0.00600755,
            0.057099,
            0.00155268,
            0.00461435,
            -0.00737637,
            0.0551084,
            0.00215031,
            0.00695698,
            -0.00971401,
            0.0715767,
            0.00316529,
            0.00867619,
            -0.0120943,
            0.0793314,
            0.00436995,
            0.0106694,
            -0.0148202,
            0.0869391,
            0.0058959,
            0.0140351,
            -0.0183501,
            0.101572,
            0.00798757,
            0.0168939,
            -0.022006,
            0.11018,
            0.0104233,
            0.020197,
            -0.0261568,
            0.119041,
            0.0134167,
            0.0254702,
            -0.0312778,
            0.135404,
            0.0173009,
            0.0298384,
            -0.0362469,
            0.1437,
            0.0215428,
            0.035159,
            -0.042237,
            0.15512,
            0.0268882,
            0.0427685,
            -0.0488711,
            0.17128,
            0.033235,
            0.0494848,
            -0.0557997,
            0.181813,
            0.0404443,
            0.0592394,
            -0.0635578,
            0.198745,
            0.0490043,
            0.0681463,
            -0.071838,
            0.210497,
            0.0588239,
            0.0804753,
            -0.0809297,
            0.228864,
            0.0702835,
            0.0942205,
            -0.0906488,
            0.247008,
            0.0834012,
            0.106777,
            -0.100216,
            0.258812,
            0.0975952,
            0.124471,
            -0.110827,
            0.278617,
            0.114162,
            0.138389,
            -0.121193,
            0.287049,
            0.131983,
            0.159543,
            -0.13253,
            0.307151,
            0.152541,
            0.176432,
            -0.143611,
            0.31564,
            0.174673,
            0.201723,
            -0.15548,
            0.33538,
            0.199842,
            0.229721,
            -0.167166,
            0.355256,
            0.227097,
            0.250206,
            -0.178238,
            0.360047,
            0.256014,
            0.282118,
            -0.189905,
            0.378761,
            0.28855,
            0.312821,
            -0.201033,
            0.39181,
            0.323348,
            0.341482,
            -0.211584,
            0.397716,
            0.360564,
            0.377368,
            -0.221314,
            0.410141,
            0.400004,
            0.418229,
            -0.230474,
            0.423485,
            0.442371,
            0.444881,
            -0.239443,
            0.418874,
            0.488796,
            0.488899,
            -0.245987,
            0.427545,
            0.535012,
            0.520317,
            -0.253948,
            0.422147,
            0.589678,
            0.568566,
            -0.256616,
            0.42719,
            0.637683,
            0.599607,
            -0.26376,
            0.415114,
            0.703363,
            0.64222,
            -0.268687,
            0.408715,
            0.771363,
            0.685698,
            -0.2694,
            0.399722,
            0.83574,
            0.732327,
            -0.266642,
            0.388651,
            0.897764,
            0.769873,
            -0.267712,
            0.369198,
            0.983312,
            0.806733,
            -0.263479,
            0.346802,
            1.06222,
            0.843466,
            -0.254575,
            0.321368,
            1.13477,
            0.873008,
            -0.242749,
            0.29211,
            1.20712,
            0.908438,
            -0.22725,
            0.262143,
            1.27465,
            0.936321,
            -0.207621,
            0.228876,
            1.33203,
            0.950353,
            -0.187932,
            0.19484,
            1.40439,
            0.96442,
            -0.165154,
            0.163178,
            1.4732,
            0.979856,
            -0.139302,
            0.127531,
            1.53574,
            0.982561,
            -0.11134,
            0.0903457,
            1.59982,
            0.996389,
            -0.0808124,
            0.0489007,
            1.6577
        ];
        const LTC_MAT_2 = [
            1,
            0,
            0,
            0,
            1,
            0.000000000000000000000000000000791421,
            0,
            0,
            1,
            0.00000000000000000000000104392,
            0,
            0,
            1,
            0.00000000000000000000349405,
            0,
            0,
            1,
            0.00000000000000000109923,
            0,
            0,
            1,
            0.0000000000000000947414,
            0,
            0,
            1,
            0.00000000000000359627,
            0,
            0,
            1,
            0.0000000000000772053,
            0,
            0,
            1,
            0.00000000000108799,
            0,
            0,
            1,
            0.0000000000110655,
            0,
            0,
            1,
            0.0000000000865818,
            0,
            0,
            0.999998,
            0.000000000545037,
            0,
            0,
            0.999994,
            0.00000000285095,
            0,
            0,
            0.999989,
            0.0000000126931,
            0,
            0,
            0.999973,
            0.0000000489938,
            0,
            0,
            0.999947,
            0.000000166347,
            0,
            0,
            0.999894,
            0.000000502694,
            0,
            0,
            0.999798,
            0.00000136532,
            0,
            0,
            0.999617,
            0.00000335898,
            0,
            0,
            0.999234,
            0.00000752126,
            0,
            0,
            0.998258,
            0.0000152586,
            0,
            0,
            0.99504,
            0.0000266207,
            0,
            0,
            0.980816,
            0.0000236802,
            0,
            0,
            0.967553,
            0.00000207684,
            0,
            0,
            0.966877,
            0.00000403733,
            0,
            0,
            0.965752,
            0.00000741174,
            0,
            0,
            0.96382,
            0.0000127746,
            0,
            0,
            0.960306,
            0.0000202792,
            0,
            0,
            0.953619,
            0.0000280232,
            0,
            0,
            0.941103,
            0.0000278816,
            0,
            0,
            0.926619,
            0.0000160221,
            0,
            0,
            0.920983,
            0.0000235164,
            0,
            0,
            0.912293,
            0.0000311924,
            0,
            0.0158731,
            0.899277,
            0.0000348118,
            0,
            0.0476191,
            0.880884,
            0.000026041,
            0,
            0.0793651,
            0.870399,
            0.0000338726,
            0,
            0.111111,
            0.856138,
            0.0000392906,
            0,
            0.142857,
            0.837436,
            0.0000372874,
            0,
            0.174603,
            0.820973,
            0.0000392558,
            0,
            0.206349,
            0.803583,
            0.0000434658,
            0,
            0.238095,
            0.782168,
            0.000040256,
            0,
            0.269841,
            0.764107,
            0.0000448159,
            0,
            0.301587,
            0.743092,
            0.0000457627,
            0,
            0.333333,
            0.721626,
            0.0000455314,
            0,
            0.365079,
            0.700375,
            0.0000477335,
            0,
            0.396825,
            0.677334,
            0.0000461072,
            0,
            0.428571,
            0.655702,
            0.0000484393,
            0,
            0.460317,
            0.632059,
            0.0000464583,
            0,
            0.492064,
            0.610125,
            0.0000483923,
            0,
            0.52381,
            0.58653,
            0.0000464342,
            0,
            0.555556,
            0.564508,
            0.0000477033,
            0,
            0.587302,
            0.541405,
            0.0000459263,
            0,
            0.619048,
            0.519556,
            0.000046412,
            0,
            0.650794,
            0.497292,
            0.0000448913,
            0,
            0.68254,
            0.475898,
            0.0000445789,
            0,
            0.714286,
            0.454722,
            0.0000433496,
            0,
            0.746032,
            0.434042,
            0.0000423054,
            0,
            0.777778,
            0.414126,
            0.0000413737,
            0,
            0.809524,
            0.394387,
            0.0000397265,
            0,
            0.84127,
            0.375841,
            0.0000390709,
            0,
            0.873016,
            0.357219,
            0.0000369938,
            0,
            0.904762,
            0.340084,
            0.0000365618,
            0,
            0.936508,
            0.322714,
            0.0000342533,
            0,
            0.968254,
            0.306974,
            0.0000339596,
            0,
            1,
            1,
            0.00000000000000000101524,
            0,
            0,
            1,
            0.0000000000000000010292,
            0,
            0,
            1,
            0.00000000000000000130908,
            0,
            0,
            1,
            0.00000000000000000473331,
            0,
            0,
            1,
            0.0000000000000000625319,
            0,
            0,
            1,
            0.00000000000000107932,
            0,
            0,
            1,
            0.0000000000000163779,
            0,
            0,
            1,
            0.000000000000203198,
            0,
            0,
            1,
            0.00000000000204717,
            0,
            0,
            0.999999,
            0.0000000000168995,
            0,
            0,
            0.999998,
            0.000000000115855,
            0,
            0,
            0.999996,
            0.00000000066947,
            0,
            0,
            0.999991,
            0.00000000330863,
            0,
            0,
            0.999983,
            0.0000000141737,
            0,
            0,
            0.999968,
            0.0000000532626,
            0,
            0,
            0.99994,
            0.000000177431,
            0,
            0,
            0.999891,
            0.000000528835,
            0,
            0,
            0.999797,
            0.00000142169,
            0,
            0,
            0.999617,
            0.00000347057,
            0,
            0,
            0.999227,
            0.0000077231,
            0,
            0,
            0.998239,
            0.0000155753,
            0,
            0,
            0.994937,
            0.0000268495,
            0,
            0,
            0.980225,
            0.0000213742,
            0,
            0,
            0.967549,
            0.0000021631,
            0,
            0,
            0.966865,
            0.00000417989,
            0,
            0,
            0.965739,
            0.00000763341,
            0,
            0,
            0.963794,
            0.0000130892,
            0,
            0,
            0.960244,
            0.0000206456,
            0,
            0,
            0.953495,
            0.0000282016,
            0,
            0.000148105,
            0.940876,
            0.0000271581,
            0,
            0.002454,
            0.926569,
            0.0000164159,
            0,
            0.00867491,
            0.920905,
            0.0000239521,
            0,
            0.01956,
            0.912169,
            0.0000315127,
            0,
            0.035433,
            0.899095,
            0.0000346626,
            0,
            0.056294,
            0.882209,
            0.0000290223,
            0,
            0.0818191,
            0.870272,
            0.0000342992,
            0,
            0.111259,
            0.855977,
            0.0000394164,
            0,
            0.142857,
            0.837431,
            0.0000372343,
            0,
            0.174603,
            0.820826,
            0.0000396691,
            0,
            0.206349,
            0.803408,
            0.0000435395,
            0,
            0.238095,
            0.782838,
            0.0000419579,
            0,
            0.269841,
            0.763941,
            0.0000450953,
            0,
            0.301587,
            0.742904,
            0.0000455847,
            0,
            0.333333,
            0.721463,
            0.0000458833,
            0,
            0.365079,
            0.700197,
            0.0000477159,
            0,
            0.396825,
            0.677501,
            0.0000470641,
            0,
            0.428571,
            0.655527,
            0.0000484732,
            0,
            0.460317,
            0.6324,
            0.0000476834,
            0,
            0.492064,
            0.609964,
            0.0000484213,
            0,
            0.52381,
            0.586839,
            0.0000475541,
            0,
            0.555556,
            0.564353,
            0.0000476951,
            0,
            0.587302,
            0.541589,
            0.0000467611,
            0,
            0.619048,
            0.519413,
            0.0000463493,
            0,
            0.650794,
            0.497337,
            0.0000453994,
            0,
            0.68254,
            0.475797,
            0.0000445308,
            0,
            0.714286,
            0.454659,
            0.0000435787,
            0,
            0.746032,
            0.434065,
            0.0000424839,
            0,
            0.777778,
            0.414018,
            0.000041436,
            0,
            0.809524,
            0.39455,
            0.0000401902,
            0,
            0.84127,
            0.375742,
            0.0000390813,
            0,
            0.873016,
            0.357501,
            0.0000377116,
            0,
            0.904762,
            0.339996,
            0.000036535,
            0,
            0.936508,
            0.323069,
            0.0000351265,
            0,
            0.968254,
            0.306897,
            0.0000339112,
            0,
            1,
            1,
            0.0000000000000010396,
            0,
            0,
            1,
            0.00000000000000104326,
            0,
            0,
            1,
            0.00000000000000110153,
            0,
            0,
            1,
            0.00000000000000144668,
            0,
            0,
            1,
            0.0000000000000034528,
            0,
            0,
            1,
            0.0000000000000175958,
            0,
            0,
            1,
            0.00000000000012627,
            0,
            0,
            1,
            0.000000000000936074,
            0,
            0,
            1,
            0.00000000000645742,
            0,
            0,
            0.999998,
            0.0000000000401228,
            0,
            0,
            0.999997,
            0.000000000222338,
            0,
            0,
            0.999995,
            0.0000000010967,
            0,
            0,
            0.999991,
            0.00000000482132,
            0,
            0,
            0.999981,
            0.0000000189434,
            0,
            0,
            0.999967,
            0.0000000667716,
            0,
            0,
            0.999938,
            0.000000212066,
            0,
            0,
            0.999886,
            0.00000060977,
            0,
            0,
            0.999792,
            0.00000159504,
            0,
            0,
            0.999608,
            0.00000381191,
            0,
            0,
            0.999209,
            0.00000833727,
            0,
            0,
            0.998179,
            0.0000165288,
            0,
            0,
            0.994605,
            0.0000274387,
            0,
            0,
            0.979468,
            0.0000167316,
            0,
            0,
            0.967529,
            0.00000242877,
            0,
            0,
            0.966836,
            0.00000461696,
            0,
            0,
            0.96569,
            0.00000830977,
            0,
            0,
            0.963706,
            0.0000140427,
            0,
            0.00000244659,
            0.960063,
            0.0000217353,
            0,
            0.000760774,
            0.953113,
            0.0000286606,
            0,
            0.00367261,
            0.940192,
            0.0000247691,
            0,
            0.00940263,
            0.927731,
            0.0000195814,
            0,
            0.018333,
            0.920669,
            0.0000252531,
            0,
            0.0306825,
            0.911799,
            0.0000324277,
            0,
            0.0465556,
            0.89857,
            0.0000340982,
            0,
            0.0659521,
            0.883283,
            0.0000319622,
            0,
            0.0887677,
            0.86989,
            0.000035548,
            0,
            0.114784,
            0.855483,
            0.0000397143,
            0,
            0.143618,
            0.837987,
            0.0000391665,
            0,
            0.174606,
            0.820546,
            0.0000411306,
            0,
            0.206349,
            0.802878,
            0.0000436753,
            0,
            0.238095,
            0.783402,
            0.0000444,
            0,
            0.269841,
            0.763439,
            0.0000458726,
            0,
            0.301587,
            0.742925,
            0.0000467097,
            0,
            0.333333,
            0.721633,
            0.0000478887,
            0,
            0.365079,
            0.69985,
            0.0000481251,
            0,
            0.396825,
            0.67783,
            0.0000491811,
            0,
            0.428571,
            0.655126,
            0.0000488199,
            0,
            0.460318,
            0.632697,
            0.0000496025,
            0,
            0.492064,
            0.609613,
            0.000048829,
            0,
            0.52381,
            0.587098,
            0.0000492754,
            0,
            0.555556,
            0.564119,
            0.0000482625,
            0,
            0.587302,
            0.541813,
            0.0000482807,
            0,
            0.619048,
            0.519342,
            0.0000471552,
            0,
            0.650794,
            0.497514,
            0.0000466765,
            0,
            0.68254,
            0.475879,
            0.0000455582,
            0,
            0.714286,
            0.454789,
            0.0000446007,
            0,
            0.746032,
            0.434217,
            0.0000435382,
            0,
            0.777778,
            0.414086,
            0.0000421753,
            0,
            0.809524,
            0.394744,
            0.0000412093,
            0,
            0.84127,
            0.375782,
            0.0000396634,
            0,
            0.873016,
            0.357707,
            0.0000386419,
            0,
            0.904762,
            0.340038,
            0.0000370345,
            0,
            0.936508,
            0.323284,
            0.0000359725,
            0,
            0.968254,
            0.306954,
            0.00003436,
            0,
            1,
            1,
            0.0000000000000599567,
            0,
            0,
            1,
            0.0000000000000600497,
            0,
            0,
            1,
            0.0000000000000614839,
            0,
            0,
            1,
            0.0000000000000686641,
            0,
            0,
            1,
            0.0000000000000972658,
            0,
            0,
            1,
            0.000000000000221271,
            0,
            0,
            1,
            0.000000000000833195,
            0,
            0,
            1,
            0.00000000000403601,
            0,
            0,
            0.999999,
            0.0000000000206001,
            0,
            0,
            0.999998,
            0.000000000101739,
            0,
            0,
            0.999997,
            0.000000000470132,
            0,
            0,
            0.999993,
            0.00000000200436,
            0,
            0,
            0.999988,
            0.00000000783682,
            0,
            0,
            0.999979,
            0.0000000280338,
            0,
            0,
            0.999962,
            0.0000000917033,
            0,
            0,
            0.999933,
            0.000000274514,
            0,
            0,
            0.999881,
            0.000000753201,
            0,
            0,
            0.999783,
            0.00000189826,
            0,
            0,
            0.999594,
            0.00000440279,
            0,
            0,
            0.999178,
            0.0000093898,
            0,
            0,
            0.998073,
            0.0000181265,
            0,
            0,
            0.993993,
            0.0000280487,
            0,
            0,
            0.979982,
            0.0000149422,
            0,
            0,
            0.968145,
            0.00000378481,
            0,
            0,
            0.966786,
            0.0000053771,
            0,
            0,
            0.965611,
            0.00000947508,
            0,
            0.0000388934,
            0.963557,
            0.0000156616,
            0,
            0.0009693,
            0.959752,
            0.0000235144,
            0,
            0.00370329,
            0.952461,
            0.0000291568,
            0,
            0.00868428,
            0.940193,
            0.0000240102,
            0,
            0.0161889,
            0.929042,
            0.0000231235,
            0,
            0.0263948,
            0.920266,
            0.0000273968,
            0,
            0.0394088,
            0.911178,
            0.0000337915,
            0,
            0.0552818,
            0.897873,
            0.0000333629,
            0,
            0.0740138,
            0.884053,
            0.0000351405,
            0,
            0.0955539,
            0.869455,
            0.0000378034,
            0,
            0.119795,
            0.854655,
            0.0000399378,
            0,
            0.14656,
            0.838347,
            0.0000419108,
            0,
            0.175573,
            0.820693,
            0.0000440831,
            0,
            0.206388,
            0.802277,
            0.0000445599,
            0,
            0.238095,
            0.783634,
            0.0000472691,
            0,
            0.269841,
            0.763159,
            0.0000476984,
            0,
            0.301587,
            0.742914,
            0.0000491487,
            0,
            0.333333,
            0.721662,
            0.0000502312,
            0,
            0.365079,
            0.699668,
            0.0000502817,
            0,
            0.396825,
            0.677839,
            0.000051406,
            0,
            0.428571,
            0.655091,
            0.0000511095,
            0,
            0.460317,
            0.632665,
            0.0000516067,
            0,
            0.492064,
            0.609734,
            0.0000512255,
            0,
            0.52381,
            0.587043,
            0.0000510263,
            0,
            0.555556,
            0.564298,
            0.000050565,
            0,
            0.587302,
            0.541769,
            0.0000497951,
            0,
            0.619048,
            0.519529,
            0.0000492698,
            0,
            0.650794,
            0.497574,
            0.0000482066,
            0,
            0.68254,
            0.476028,
            0.0000473689,
            0,
            0.714286,
            0.454961,
            0.0000461941,
            0,
            0.746032,
            0.434341,
            0.0000450618,
            0,
            0.777778,
            0.414364,
            0.0000438355,
            0,
            0.809524,
            0.394832,
            0.0000424196,
            0,
            0.84127,
            0.376109,
            0.0000412563,
            0,
            0.873016,
            0.35779,
            0.0000396226,
            0,
            0.904762,
            0.340379,
            0.0000384886,
            0,
            0.936508,
            0.323385,
            0.0000368214,
            0,
            0.968254,
            0.307295,
            0.0000356636,
            0,
            1,
            1,
            0.00000000000106465,
            0,
            0,
            1,
            0.00000000000106555,
            0,
            0,
            1,
            0.00000000000107966,
            0,
            0,
            1,
            0.00000000000114601,
            0,
            0,
            1,
            0.00000000000137123,
            0,
            0,
            1,
            0.0000000000021243,
            0,
            0,
            0.999999,
            0.00000000000489653,
            0,
            0,
            0.999999,
            0.0000000000160283,
            0,
            0,
            0.999998,
            0.000000000062269,
            0,
            0,
            0.999997,
            0.000000000251859,
            0,
            0,
            0.999996,
            0.000000000996192,
            0,
            0,
            0.999992,
            0.00000000374531,
            0,
            0,
            0.999986,
            0.0000000132022,
            0,
            0,
            0.999975,
            0.0000000433315,
            0,
            0,
            0.999959,
            0.000000131956,
            0,
            0,
            0.999927,
            0.000000372249,
            0,
            0,
            0.999871,
            0.000000972461,
            0,
            0,
            0.999771,
            0.00000235343,
            0,
            0,
            0.999572,
            0.0000052768,
            0,
            0,
            0.999133,
            0.0000109237,
            0,
            0,
            0.997912,
            0.0000203675,
            0,
            0,
            0.993008,
            0.0000279396,
            0,
            0,
            0.980645,
            0.0000139604,
            0,
            0,
            0.970057,
            0.00000646596,
            0,
            0,
            0.966717,
            0.0000065089,
            0,
            0.0000474145,
            0.965497,
            0.0000111863,
            0,
            0.00089544,
            0.96334,
            0.0000179857,
            0,
            0.0032647,
            0.959294,
            0.0000259045,
            0,
            0.0075144,
            0.951519,
            0.0000292327,
            0,
            0.0138734,
            0.940517,
            0.0000249769,
            0,
            0.0224952,
            0.93014,
            0.000026803,
            0,
            0.0334828,
            0.91972,
            0.0000303656,
            0,
            0.0468973,
            0.910294,
            0.0000353323,
            0,
            0.0627703,
            0.897701,
            0.0000351002,
            0,
            0.0811019,
            0.884522,
            0.0000388104,
            0,
            0.10186,
            0.869489,
            0.0000412932,
            0,
            0.124985,
            0.853983,
            0.0000415781,
            0,
            0.150372,
            0.838425,
            0.0000454066,
            0,
            0.177868,
            0.820656,
            0.0000471624,
            0,
            0.207245,
            0.801875,
            0.0000475243,
            0,
            0.238143,
            0.783521,
            0.0000505621,
            0,
            0.269841,
            0.763131,
            0.000050721,
            0,
            0.301587,
            0.74261,
            0.0000523293,
            0,
            0.333333,
            0.72148,
            0.0000528699,
            0,
            0.365079,
            0.699696,
            0.0000538677,
            0,
            0.396825,
            0.677592,
            0.0000539255,
            0,
            0.428571,
            0.65525,
            0.0000546367,
            0,
            0.460317,
            0.632452,
            0.0000541348,
            0,
            0.492064,
            0.609903,
            0.0000544976,
            0,
            0.52381,
            0.586928,
            0.0000536201,
            0,
            0.555556,
            0.564464,
            0.0000535185,
            0,
            0.587302,
            0.541801,
            0.0000524949,
            0,
            0.619048,
            0.519681,
            0.000051812,
            0,
            0.650794,
            0.497685,
            0.0000507687,
            0,
            0.68254,
            0.47622,
            0.0000496243,
            0,
            0.714286,
            0.455135,
            0.0000485714,
            0,
            0.746032,
            0.4346,
            0.0000471847,
            0,
            0.777778,
            0.414564,
            0.0000459294,
            0,
            0.809524,
            0.395165,
            0.0000444705,
            0,
            0.84127,
            0.376333,
            0.0000430772,
            0,
            0.873016,
            0.358197,
            0.0000416229,
            0,
            0.904762,
            0.34064,
            0.0000401019,
            0,
            0.936508,
            0.323816,
            0.0000386623,
            0,
            0.968254,
            0.307581,
            0.0000370933,
            0,
            1,
            1,
            0.00000000000991541,
            0,
            0,
            1,
            0.00000000000992077,
            0,
            0,
            1,
            0.0000000000100041,
            0,
            0,
            1,
            0.000000000010385,
            0,
            0,
            1,
            0.0000000000115777,
            0,
            0,
            1,
            0.0000000000150215,
            0,
            0,
            0.999999,
            0.0000000000254738,
            0,
            0,
            0.999999,
            0.0000000000598822,
            0,
            0,
            0.999998,
            0.000000000179597,
            0,
            0,
            0.999997,
            0.000000000602367,
            0,
            0,
            0.999994,
            0.00000000206835,
            0,
            0,
            0.99999,
            0.00000000694952,
            0,
            0,
            0.999984,
            0.0000000223363,
            0,
            0,
            0.999972,
            0.0000000678578,
            0,
            0,
            0.999952,
            0.000000193571,
            0,
            0,
            0.999919,
            0.000000516594,
            0,
            0,
            0.99986,
            0.00000128739,
            0,
            0,
            0.999753,
            0.00000299298,
            0,
            0,
            0.999546,
            0.00000648258,
            0,
            0,
            0.999074,
            0.0000129985,
            0,
            0,
            0.997671,
            0.0000232176,
            0,
            0,
            0.991504,
            0.0000256701,
            0,
            0,
            0.981148,
            0.0000131141,
            0,
            0,
            0.971965,
            0.00000869048,
            0,
            0.0000280182,
            0.966624,
            0.00000808301,
            0,
            0.000695475,
            0.965344,
            0.0000135235,
            0,
            0.00265522,
            0.963048,
            0.0000210592,
            0,
            0.00622975,
            0.958673,
            0.0000287473,
            0,
            0.0116234,
            0.950262,
            0.0000281379,
            0,
            0.018976,
            0.940836,
            0.0000271089,
            0,
            0.0283844,
            0.930996,
            0.000030926,
            0,
            0.0399151,
            0.919848,
            0.0000348359,
            0,
            0.0536063,
            0.909136,
            0.0000366092,
            0,
            0.0694793,
            0.897554,
            0.0000384162,
            0,
            0.0875342,
            0.884691,
            0.0000430971,
            0,
            0.107749,
            0.869414,
            0.0000447803,
            0,
            0.130087,
            0.853462,
            0.0000452858,
            0,
            0.154481,
            0.838187,
            0.0000495769,
            0,
            0.180833,
            0.820381,
            0.0000502709,
            0,
            0.209005,
            0.801844,
            0.0000522713,
            0,
            0.238791,
            0.783061,
            0.0000541505,
            0,
            0.269869,
            0.763205,
            0.0000553712,
            0,
            0.301587,
            0.742362,
            0.0000564909,
            0,
            0.333333,
            0.721393,
            0.0000572646,
            0,
            0.365079,
            0.699676,
            0.0000581012,
            0,
            0.396825,
            0.677395,
            0.000058096,
            0,
            0.428571,
            0.655208,
            0.0000585766,
            0,
            0.460317,
            0.632451,
            0.0000583602,
            0,
            0.492064,
            0.609839,
            0.0000580234,
            0,
            0.52381,
            0.587093,
            0.0000577161,
            0,
            0.555556,
            0.564467,
            0.0000568447,
            0,
            0.587302,
            0.542043,
            0.0000563166,
            0,
            0.619048,
            0.519826,
            0.000055156,
            0,
            0.650794,
            0.497952,
            0.0000541682,
            0,
            0.68254,
            0.476477,
            0.0000528971,
            0,
            0.714286,
            0.455412,
            0.0000514952,
            0,
            0.746032,
            0.434926,
            0.0000502222,
            0,
            0.777778,
            0.4149,
            0.0000485779,
            0,
            0.809524,
            0.395552,
            0.0000472242,
            0,
            0.84127,
            0.376712,
            0.0000454891,
            0,
            0.873016,
            0.358622,
            0.0000440924,
            0,
            0.904762,
            0.341048,
            0.0000422984,
            0,
            0.936508,
            0.324262,
            0.0000408582,
            0,
            0.968254,
            0.308013,
            0.0000390839,
            0,
            1,
            1,
            0.0000000000613913,
            0,
            0,
            1,
            0.0000000000614145,
            0,
            0,
            1,
            0.0000000000617708,
            0,
            0,
            1,
            0.0000000000633717,
            0,
            0,
            1,
            0.0000000000681648,
            0,
            0,
            1,
            0.0000000000808291,
            0,
            0,
            1,
            0.000000000114608,
            0,
            0,
            0.999998,
            0.000000000210507,
            0,
            0,
            0.999997,
            0.000000000499595,
            0,
            0,
            0.999995,
            0.00000000139897,
            0,
            0,
            0.999994,
            0.00000000419818,
            0,
            0,
            0.999988,
            0.0000000127042,
            0,
            0,
            0.999979,
            0.0000000375153,
            0,
            0,
            0.999965,
            0.000000106206,
            0,
            0,
            0.999945,
            0.000000285381,
            0,
            0,
            0.999908,
            0.000000723611,
            0,
            0,
            0.999846,
            0.0000017255,
            0,
            0,
            0.999733,
            0.00000386104,
            0,
            0,
            0.999511,
            0.00000808493,
            0,
            0,
            0.998993,
            0.0000156884,
            0,
            0,
            0.997326,
            0.0000265538,
            0,
            0,
            0.989706,
            0.0000206466,
            0,
            0,
            0.981713,
            0.0000130756,
            0,
            0.0000070005,
            0.973636,
            0.0000106473,
            0,
            0.000464797,
            0.966509,
            0.000010194,
            0,
            0.00201743,
            0.965149,
            0.0000165881,
            0,
            0.00497549,
            0.962669,
            0.0000249147,
            0,
            0.00953262,
            0.95786,
            0.0000317449,
            0,
            0.0158211,
            0.949334,
            0.0000281045,
            0,
            0.0239343,
            0.941041,
            0.0000303263,
            0,
            0.0339372,
            0.931575,
            0.0000356754,
            0,
            0.0458738,
            0.920102,
            0.0000397075,
            0,
            0.059772,
            0.908002,
            0.0000384886,
            0,
            0.075645,
            0.897269,
            0.000043027,
            0,
            0.0934929,
            0.884559,
            0.0000479925,
            0,
            0.113302,
            0.869161,
            0.000048246,
            0,
            0.135045,
            0.853342,
            0.0000509505,
            0,
            0.158678,
            0.837633,
            0.0000542846,
            0,
            0.184136,
            0.820252,
            0.0000554139,
            0,
            0.211325,
            0.801872,
            0.0000581412,
            0,
            0.240113,
            0.782418,
            0.0000585535,
            0,
            0.270306,
            0.7631,
            0.0000610923,
            0,
            0.301594,
            0.742183,
            0.0000613678,
            0,
            0.333333,
            0.721098,
            0.0000627275,
            0,
            0.365079,
            0.699512,
            0.0000629413,
            0,
            0.396825,
            0.677372,
            0.0000636351,
            0,
            0.428571,
            0.655059,
            0.0000633555,
            0,
            0.460317,
            0.632567,
            0.0000636513,
            0,
            0.492064,
            0.609784,
            0.0000628965,
            0,
            0.52381,
            0.587237,
            0.0000625546,
            0,
            0.555556,
            0.564525,
            0.0000615825,
            0,
            0.587302,
            0.542181,
            0.0000605048,
            0,
            0.619048,
            0.520017,
            0.0000596329,
            0,
            0.650794,
            0.498204,
            0.0000581516,
            0,
            0.68254,
            0.476742,
            0.0000569186,
            0,
            0.714286,
            0.455803,
            0.0000553833,
            0,
            0.746032,
            0.435251,
            0.0000537807,
            0,
            0.777778,
            0.415374,
            0.0000522025,
            0,
            0.809524,
            0.395921,
            0.0000503421,
            0,
            0.84127,
            0.377253,
            0.0000488211,
            0,
            0.873016,
            0.359021,
            0.0000468234,
            0,
            0.904762,
            0.341637,
            0.0000453269,
            0,
            0.936508,
            0.3247,
            0.0000433014,
            0,
            0.968254,
            0.308625,
            0.0000418007,
            0,
            1,
            1,
            0.000000000286798,
            0,
            0,
            1,
            0.000000000286877,
            0,
            0,
            1,
            0.000000000288094,
            0,
            0,
            1,
            0.000000000293506,
            0,
            0,
            1,
            0.000000000309262,
            0,
            0,
            0.999999,
            0.000000000348593,
            0,
            0,
            0.999999,
            0.000000000444582,
            0,
            0,
            0.999998,
            0.000000000688591,
            0,
            0,
            0.999996,
            0.00000000134391,
            0,
            0,
            0.999993,
            0.00000000317438,
            0,
            0,
            0.999989,
            0.00000000835609,
            0,
            0,
            0.999983,
            0.0000000228677,
            0,
            0,
            0.999974,
            0.0000000623361,
            0,
            0,
            0.999959,
            0.000000165225,
            0,
            0,
            0.999936,
            0.000000419983,
            0,
            0,
            0.999896,
            0.00000101546,
            0,
            0,
            0.99983,
            0.00000232376,
            0,
            0,
            0.999709,
            0.0000050156,
            0,
            0,
            0.999469,
            0.000010167,
            0,
            0,
            0.998886,
            0.0000190775,
            0,
            0,
            0.996819,
            0.0000300511,
            0,
            0,
            0.988837,
            0.0000185092,
            0,
            0.000000168222,
            0.982178,
            0.0000134622,
            0,
            0.000259622,
            0.975017,
            0.0000125961,
            0,
            0.00142595,
            0.967101,
            0.000013507,
            0,
            0.00382273,
            0.964905,
            0.0000205003,
            0,
            0.00764164,
            0.96218,
            0.000029546,
            0,
            0.0130121,
            0.956821,
            0.0000343738,
            0,
            0.0200253,
            0.948829,
            0.0000305063,
            0,
            0.0287452,
            0.941092,
            0.0000346487,
            0,
            0.039218,
            0.931883,
            0.0000412061,
            0,
            0.0514748,
            0.920211,
            0.0000444651,
            0,
            0.0655351,
            0.907307,
            0.0000431252,
            0,
            0.0814082,
            0.89684,
            0.0000490382,
            0,
            0.0990939,
            0.884119,
            0.000053334,
            0,
            0.118583,
            0.869148,
            0.000054114,
            0,
            0.139856,
            0.853377,
            0.0000578536,
            0,
            0.162882,
            0.836753,
            0.0000592285,
            0,
            0.187615,
            0.820063,
            0.0000622787,
            0,
            0.213991,
            0.801694,
            0.0000645492,
            0,
            0.241918,
            0.782116,
            0.000065353,
            0,
            0.271267,
            0.762673,
            0.0000674344,
            0,
            0.301847,
            0.742133,
            0.0000682788,
            0,
            0.333333,
            0.720779,
            0.0000691959,
            0,
            0.365079,
            0.699386,
            0.0000696817,
            0,
            0.396826,
            0.67732,
            0.0000699583,
            0,
            0.428572,
            0.654888,
            0.0000698447,
            0,
            0.460318,
            0.632499,
            0.0000694063,
            0,
            0.492064,
            0.609825,
            0.0000691612,
            0,
            0.52381,
            0.587287,
            0.0000681576,
            0,
            0.555556,
            0.564743,
            0.0000674138,
            0,
            0.587302,
            0.542409,
            0.0000661617,
            0,
            0.619048,
            0.520282,
            0.0000647785,
            0,
            0.650794,
            0.498506,
            0.0000633836,
            0,
            0.68254,
            0.477102,
            0.0000615905,
            0,
            0.714286,
            0.456167,
            0.0000601013,
            0,
            0.746032,
            0.435728,
            0.0000581457,
            0,
            0.777778,
            0.415809,
            0.0000564215,
            0,
            0.809524,
            0.396517,
            0.0000544997,
            0,
            0.84127,
            0.377737,
            0.0000525061,
            0,
            0.873016,
            0.359698,
            0.0000506831,
            0,
            0.904762,
            0.342164,
            0.000048568,
            0,
            0.936508,
            0.325417,
            0.0000467826,
            0,
            0.968254,
            0.309186,
            0.0000446736,
            0,
            1,
            1,
            0.00000000109018,
            0,
            0,
            1,
            0.0000000010904,
            0,
            0,
            1,
            0.00000000109393,
            0,
            0,
            1,
            0.0000000011095,
            0,
            0,
            1,
            0.000000001154,
            0,
            0,
            1,
            0.00000000126089,
            0,
            0,
            0.999999,
            0.0000000015059,
            0,
            0,
            0.999997,
            0.00000000207899,
            0,
            0,
            0.999994,
            0.00000000348164,
            0,
            0,
            0.999993,
            0.00000000705728,
            0,
            0,
            0.999987,
            0.0000000163692,
            0,
            0,
            0.999981,
            0.0000000406033,
            0,
            0,
            0.999969,
            0.00000010245,
            0,
            0,
            0.999953,
            0.000000255023,
            0,
            0,
            0.999925,
            0.00000061511,
            0,
            0,
            0.999881,
            0.00000142218,
            0,
            0,
            0.99981,
            0.00000313086,
            0,
            0,
            0.99968,
            0.00000653119,
            0,
            0,
            0.999418,
            0.000012832,
            0,
            0,
            0.998748,
            0.0000232497,
            0,
            0,
            0.996066,
            0.0000329522,
            0,
            0,
            0.988379,
            0.0000179613,
            0,
            0.000108799,
            0.982567,
            0.0000143715,
            0,
            0.000921302,
            0.976097,
            0.0000148096,
            0,
            0.00280738,
            0.968475,
            0.0000178905,
            0,
            0.00596622,
            0.964606,
            0.0000253921,
            0,
            0.0105284,
            0.961564,
            0.0000348623,
            0,
            0.0165848,
            0.955517,
            0.0000357612,
            0,
            0.0242,
            0.948381,
            0.0000343493,
            0,
            0.03342,
            0.941095,
            0.0000405849,
            0,
            0.0442777,
            0.931923,
            0.0000475394,
            0,
            0.0567958,
            0.91996,
            0.0000484328,
            0,
            0.0709879,
            0.907419,
            0.0000502146,
            0,
            0.086861,
            0.89618,
            0.0000561654,
            0,
            0.104415,
            0.88337,
            0.0000587612,
            0,
            0.123643,
            0.869046,
            0.0000618057,
            0,
            0.144531,
            0.853278,
            0.0000657392,
            0,
            0.167057,
            0.836091,
            0.000066303,
            0,
            0.191188,
            0.819644,
            0.0000704445,
            0,
            0.216878,
            0.801246,
            0.0000714071,
            0,
            0.244062,
            0.782031,
            0.0000740093,
            0,
            0.272649,
            0.762066,
            0.000074685,
            0,
            0.302509,
            0.741964,
            0.0000766647,
            0,
            0.333442,
            0.720554,
            0.0000766328,
            0,
            0.365079,
            0.699098,
            0.0000777857,
            0,
            0.396826,
            0.677189,
            0.0000774633,
            0,
            0.428572,
            0.65484,
            0.0000776235,
            0,
            0.460318,
            0.632496,
            0.0000770316,
            0,
            0.492064,
            0.609908,
            0.0000762669,
            0,
            0.52381,
            0.587312,
            0.0000753972,
            0,
            0.555556,
            0.564938,
            0.0000739994,
            0,
            0.587302,
            0.542577,
            0.0000728382,
            0,
            0.619048,
            0.52062,
            0.000071112,
            0,
            0.650794,
            0.498819,
            0.0000694004,
            0,
            0.68254,
            0.477555,
            0.0000675575,
            0,
            0.714286,
            0.456568,
            0.0000653449,
            0,
            0.746032,
            0.436278,
            0.0000636068,
            0,
            0.777778,
            0.41637,
            0.0000613466,
            0,
            0.809524,
            0.397144,
            0.0000594177,
            0,
            0.84127,
            0.378412,
            0.0000570987,
            0,
            0.873016,
            0.360376,
            0.0000550419,
            0,
            0.904762,
            0.342906,
            0.0000527422,
            0,
            0.936508,
            0.326136,
            0.0000506544,
            0,
            0.968254,
            0.30997,
            0.0000484307,
            0,
            1,
            1,
            0.00000000354014,
            0,
            0,
            1,
            0.00000000354073,
            0,
            0,
            1,
            0.00000000354972,
            0,
            0,
            1,
            0.00000000358929,
            0,
            0,
            1,
            0.00000000370093,
            0,
            0,
            0.999999,
            0.00000000396194,
            0,
            0,
            0.999998,
            0.00000000453352,
            0,
            0,
            0.999997,
            0.00000000578828,
            0,
            0,
            0.999994,
            0.00000000863812,
            0,
            0,
            0.999991,
            0.0000000153622,
            0,
            0,
            0.999985,
            0.0000000316356,
            0,
            0,
            0.999977,
            0.0000000712781,
            0,
            0,
            0.999964,
            0.000000166725,
            0,
            0,
            0.999945,
            0.000000390501,
            0,
            0,
            0.999912,
            0.000000895622,
            0,
            0,
            0.999866,
            0.00000198428,
            0,
            0,
            0.999786,
            0.00000421038,
            0,
            0,
            0.999647,
            0.00000850239,
            0,
            0,
            0.999356,
            0.0000162059,
            0,
            0,
            0.998563,
            0.0000282652,
            0,
            0,
            0.994928,
            0.0000336309,
            0,
            0.0000244244,
            0.987999,
            0.0000178458,
            0,
            0.000523891,
            0.982893,
            0.0000159162,
            0,
            0.00194729,
            0.977044,
            0.0000178056,
            0,
            0.00451099,
            0.969972,
            0.0000230624,
            0,
            0.00835132,
            0.964237,
            0.0000313922,
            0,
            0.013561,
            0.960791,
            0.0000406145,
            0,
            0.0202056,
            0.954292,
            0.0000372796,
            0,
            0.0283321,
            0.948052,
            0.0000403199,
            0,
            0.0379739,
            0.940938,
            0.0000479537,
            0,
            0.0491551,
            0.931689,
            0.0000545292,
            0,
            0.0618918,
            0.91987,
            0.000054038,
            0,
            0.0761941,
            0.907665,
            0.0000589909,
            0,
            0.0920672,
            0.895281,
            0.0000642651,
            0,
            0.109511,
            0.882621,
            0.0000659707,
            0,
            0.12852,
            0.86873,
            0.0000709973,
            0,
            0.149085,
            0.853008,
            0.0000742221,
            0,
            0.171189,
            0.835944,
            0.0000761754,
            0,
            0.194809,
            0.818949,
            0.0000797052,
            0,
            0.21991,
            0.800951,
            0.0000812434,
            0,
            0.246447,
            0.781847,
            0.0000838075,
            0,
            0.274352,
            0.761649,
            0.000084501,
            0,
            0.303535,
            0.74152,
            0.0000860258,
            0,
            0.333857,
            0.720495,
            0.0000866233,
            0,
            0.365104,
            0.698742,
            0.0000868326,
            0,
            0.396826,
            0.677096,
            0.000087133,
            0,
            0.428572,
            0.654782,
            0.0000863497,
            0,
            0.460318,
            0.632335,
            0.0000860206,
            0,
            0.492064,
            0.610031,
            0.0000849337,
            0,
            0.52381,
            0.587457,
            0.0000838279,
            0,
            0.555556,
            0.56513,
            0.000082309,
            0,
            0.587302,
            0.542877,
            0.0000803542,
            0,
            0.619048,
            0.5209,
            0.0000786928,
            0,
            0.650794,
            0.499291,
            0.0000765171,
            0,
            0.68254,
            0.477971,
            0.0000744753,
            0,
            0.714286,
            0.457221,
            0.000072209,
            0,
            0.746032,
            0.436803,
            0.0000697448,
            0,
            0.777778,
            0.417083,
            0.0000675333,
            0,
            0.809524,
            0.397749,
            0.0000648058,
            0,
            0.84127,
            0.379177,
            0.0000625759,
            0,
            0.873016,
            0.361061,
            0.0000598584,
            0,
            0.904762,
            0.343713,
            0.0000575797,
            0,
            0.936508,
            0.326894,
            0.0000549999,
            0,
            0.968254,
            0.310816,
            0.0000527482,
            0,
            1,
            1,
            0.000000010153,
            0,
            0,
            1,
            0.0000000101544,
            0,
            0,
            1,
            0.0000000101751,
            0,
            0,
            1,
            0.0000000102662,
            0,
            0,
            1,
            0.000000010521,
            0,
            0,
            0.999999,
            0.0000000111049,
            0,
            0,
            0.999999,
            0.0000000123408,
            0,
            0,
            0.999996,
            0.000000014924,
            0,
            0,
            0.999992,
            0.0000000204471,
            0,
            0,
            0.999989,
            0.0000000326539,
            0,
            0,
            0.99998,
            0.0000000603559,
            0,
            0,
            0.999971,
            0.000000123936,
            0,
            0,
            0.999955,
            0.000000269058,
            0,
            0,
            0.999933,
            0.000000593604,
            0,
            0,
            0.999901,
            0.00000129633,
            0,
            0,
            0.999847,
            0.00000275621,
            0,
            0,
            0.999761,
            0.00000564494,
            0,
            0,
            0.999607,
            0.0000110485,
            0,
            0,
            0.999282,
            0.0000204388,
            0,
            0,
            0.99831,
            0.0000341084,
            0,
            0.00000022038,
            0.993288,
            0.0000294949,
            0,
            0.000242388,
            0.987855,
            0.0000192736,
            0,
            0.0012503,
            0.983167,
            0.0000182383,
            0,
            0.0032745,
            0.977908,
            0.0000218633,
            0,
            0.00646321,
            0.971194,
            0.0000290662,
            0,
            0.0109133,
            0.963867,
            0.0000386401,
            0,
            0.0166927,
            0.95982,
            0.0000462827,
            0,
            0.0238494,
            0.953497,
            0.0000420705,
            0,
            0.0324178,
            0.947621,
            0.0000477743,
            0,
            0.0424225,
            0.940611,
            0.0000568258,
            0,
            0.0538808,
            0.931174,
            0.0000618061,
            0,
            0.0668047,
            0.919919,
            0.0000627098,
            0,
            0.0812014,
            0.907856,
            0.0000694714,
            0,
            0.0970745,
            0.894509,
            0.0000735008,
            0,
            0.114424,
            0.881954,
            0.0000763369,
            0,
            0.133246,
            0.868309,
            0.0000821896,
            0,
            0.153534,
            0.852511,
            0.000083769,
            0,
            0.175275,
            0.835821,
            0.0000881615,
            0,
            0.198453,
            0.817981,
            0.0000896368,
            0,
            0.223042,
            0.800504,
            0.0000930906,
            0,
            0.249009,
            0.78141,
            0.0000945056,
            0,
            0.276304,
            0.761427,
            0.0000963605,
            0,
            0.304862,
            0.74094,
            0.0000968088,
            0,
            0.334584,
            0.720233,
            0.0000981481,
            0,
            0.365322,
            0.698592,
            0.0000979122,
            0,
            0.396826,
            0.676763,
            0.0000981057,
            0,
            0.428571,
            0.654808,
            0.0000973956,
            0,
            0.460318,
            0.632326,
            0.0000962619,
            0,
            0.492064,
            0.610049,
            0.0000952996,
            0,
            0.52381,
            0.58763,
            0.0000933334,
            0,
            0.555556,
            0.565261,
            0.0000917573,
            0,
            0.587302,
            0.543244,
            0.0000896636,
            0,
            0.619048,
            0.521273,
            0.0000873304,
            0,
            0.650794,
            0.499818,
            0.0000852648,
            0,
            0.68254,
            0.478536,
            0.0000823961,
            0,
            0.714286,
            0.457826,
            0.000079939,
            0,
            0.746032,
            0.437549,
            0.000077126,
            0,
            0.777778,
            0.41776,
            0.0000743043,
            0,
            0.809524,
            0.39863,
            0.0000716426,
            0,
            0.84127,
            0.379954,
            0.0000686456,
            0,
            0.873016,
            0.362025,
            0.0000660514,
            0,
            0.904762,
            0.344581,
            0.0000630755,
            0,
            0.936508,
            0.327909,
            0.0000605439,
            0,
            0.968254,
            0.311736,
            0.0000576345,
            0,
            1,
            1,
            0.0000000263344,
            0,
            0,
            1,
            0.0000000263373,
            0,
            0,
            1,
            0.0000000263815,
            0,
            0,
            1,
            0.0000000265753,
            0,
            0,
            1,
            0.0000000271132,
            0,
            0,
            0.999999,
            0.0000000283279,
            0,
            0,
            0.999997,
            0.000000030833,
            0,
            0,
            0.999995,
            0.0000000358711,
            0,
            0,
            0.999992,
            0.0000000461266,
            0,
            0,
            0.999985,
            0.000000067574,
            0,
            0,
            0.999977,
            0.00000011358,
            0,
            0,
            0.999966,
            0.000000213657,
            0,
            0,
            0.999948,
            0.000000431151,
            0,
            0,
            0.999923,
            0.000000896656,
            0,
            0,
            0.999884,
            0.00000186603,
            0,
            0,
            0.999826,
            0.00000381115,
            0,
            0,
            0.999732,
            0.00000754184,
            0,
            0,
            0.999561,
            0.0000143192,
            0,
            0,
            0.999191,
            0.0000257061,
            0,
            0,
            0.997955,
            0.0000405724,
            0,
            0.0000744132,
            0.992228,
            0.0000276537,
            0,
            0.000716477,
            0.987638,
            0.0000208885,
            0,
            0.0022524,
            0.983395,
            0.0000215226,
            0,
            0.00484816,
            0.978614,
            0.0000270795,
            0,
            0.00860962,
            0.972389,
            0.0000365282,
            0,
            0.0136083,
            0.964392,
            0.0000474747,
            0,
            0.0198941,
            0.95861,
            0.0000509141,
            0,
            0.0275023,
            0.952806,
            0.000048963,
            0,
            0.0364584,
            0.94712,
            0.0000571119,
            0,
            0.04678,
            0.940104,
            0.0000671704,
            0,
            0.0584799,
            0.930398,
            0.0000687586,
            0,
            0.0715665,
            0.919866,
            0.0000738161,
            0,
            0.086045,
            0.907853,
            0.0000813235,
            0,
            0.101918,
            0.894078,
            0.0000834582,
            0,
            0.119186,
            0.881177,
            0.0000892093,
            0,
            0.137845,
            0.867575,
            0.0000944548,
            0,
            0.157891,
            0.852107,
            0.0000969607,
            0,
            0.179316,
            0.835502,
            0.000101456,
            0,
            0.202106,
            0.81756,
            0.000103256,
            0,
            0.226243,
            0.79984,
            0.000106954,
            0,
            0.251704,
            0.780998,
            0.000108066,
            0,
            0.278451,
            0.761132,
            0.000110111,
            0,
            0.306436,
            0.740429,
            0.000110459,
            0,
            0.335586,
            0.719836,
            0.000111219,
            0,
            0.365796,
            0.698467,
            0.00011145,
            0,
            0.3969,
            0.676446,
            0.000110393,
            0,
            0.428571,
            0.654635,
            0.000110035,
            0,
            0.460318,
            0.632411,
            0.000108548,
            0,
            0.492064,
            0.609986,
            0.000106963,
            0,
            0.52381,
            0.587872,
            0.000105238,
            0,
            0.555556,
            0.565528,
            0.000102665,
            0,
            0.587302,
            0.543563,
            0.000100543,
            0,
            0.619048,
            0.52176,
            0.0000976182,
            0,
            0.650794,
            0.500188,
            0.0000947099,
            0,
            0.68254,
            0.479204,
            0.0000919929,
            0,
            0.714286,
            0.458413,
            0.0000886139,
            0,
            0.746032,
            0.438314,
            0.0000857839,
            0,
            0.777778,
            0.418573,
            0.000082411,
            0,
            0.809524,
            0.39947,
            0.0000792211,
            0,
            0.84127,
            0.380892,
            0.0000759546,
            0,
            0.873016,
            0.362953,
            0.0000727571,
            0,
            0.904762,
            0.345601,
            0.0000695738,
            0,
            0.936508,
            0.328895,
            0.0000664907,
            0,
            0.968254,
            0.312808,
            0.0000634277,
            0,
            1,
            1,
            0.0000000628647,
            0,
            0,
            1,
            0.0000000628705,
            0,
            0,
            1,
            0.0000000629587,
            0,
            0,
            1,
            0.0000000633441,
            0,
            0,
            0.999999,
            0.0000000644087,
            0,
            0,
            0.999998,
            0.0000000667856,
            0,
            0,
            0.999997,
            0.0000000715889,
            0,
            0,
            0.999995,
            0.0000000809577,
            0,
            0,
            0.999989,
            0.0000000992764,
            0,
            0,
            0.999983,
            0.000000135834,
            0,
            0,
            0.999974,
            0.000000210482,
            0,
            0,
            0.999959,
            0.000000365215,
            0,
            0,
            0.999939,
            0.000000686693,
            0,
            0,
            0.999911,
            0.0000013472,
            0,
            0,
            0.999868,
            0.0000026731,
            0,
            0,
            0.999804,
            0.00000524756,
            0,
            0,
            0.9997,
            0.0000100403,
            0,
            0,
            0.99951,
            0.0000185019,
            0,
            0,
            0.999078,
            0.0000322036,
            0,
            0.00000620676,
            0.997428,
            0.0000470002,
            0,
            0.000341552,
            0.99162,
            0.0000287123,
            0,
            0.00143727,
            0.987479,
            0.0000234706,
            0,
            0.00349201,
            0.983582,
            0.0000260083,
            0,
            0.0066242,
            0.979186,
            0.0000337927,
            0,
            0.0109113,
            0.97325,
            0.0000454689,
            0,
            0.0164064,
            0.965221,
            0.0000573759,
            0,
            0.0231463,
            0.957262,
            0.0000544114,
            0,
            0.0311571,
            0.952211,
            0.0000587006,
            0,
            0.0404572,
            0.946631,
            0.0000692256,
            0,
            0.0510592,
            0.939391,
            0.0000787819,
            0,
            0.0629723,
            0.929795,
            0.0000792368,
            0,
            0.0762025,
            0.91965,
            0.0000875075,
            0,
            0.090753,
            0.907737,
            0.0000950903,
            0,
            0.106626,
            0.893899,
            0.0000972963,
            0,
            0.123822,
            0.880239,
            0.00010459,
            0,
            0.142337,
            0.866562,
            0.000107689,
            0,
            0.16217,
            0.85164,
            0.000113081,
            0,
            0.183314,
            0.835021,
            0.000116636,
            0,
            0.20576,
            0.817311,
            0.000120074,
            0,
            0.229496,
            0.798845,
            0.000121921,
            0,
            0.254502,
            0.780479,
            0.00012475,
            0,
            0.280753,
            0.760694,
            0.000125255,
            0,
            0.308212,
            0.740142,
            0.000126719,
            0,
            0.336825,
            0.719248,
            0.00012636,
            0,
            0.366517,
            0.698209,
            0.000126712,
            0,
            0.397167,
            0.676398,
            0.000125769,
            0,
            0.428578,
            0.654378,
            0.000124432,
            0,
            0.460318,
            0.632484,
            0.000123272,
            0,
            0.492064,
            0.610113,
            0.00012085,
            0,
            0.52381,
            0.587931,
            0.000118411,
            0,
            0.555556,
            0.565872,
            0.00011569,
            0,
            0.587302,
            0.543814,
            0.000112521,
            0,
            0.619048,
            0.522265,
            0.000109737,
            0,
            0.650794,
            0.500835,
            0.000106228,
            0,
            0.68254,
            0.479818,
            0.000102591,
            0,
            0.714286,
            0.459258,
            0.0000991288,
            0,
            0.746032,
            0.439061,
            0.0000952325,
            0,
            0.777778,
            0.419552,
            0.000091895,
            0,
            0.809524,
            0.400399,
            0.0000879051,
            0,
            0.84127,
            0.381976,
            0.0000844775,
            0,
            0.873016,
            0.364009,
            0.0000806316,
            0,
            0.904762,
            0.346761,
            0.0000771848,
            0,
            0.936508,
            0.330049,
            0.0000735429,
            0,
            0.968254,
            0.314018,
            0.0000702103,
            0,
            1,
            1,
            0.000000139968,
            0,
            0,
            1,
            0.000000139979,
            0,
            0,
            1,
            0.000000140145,
            0,
            0,
            1,
            0.00000014087,
            0,
            0,
            0.999999,
            0.000000142865,
            0,
            0,
            0.999998,
            0.000000147279,
            0,
            0,
            0.999997,
            0.000000156057,
            0,
            0,
            0.999992,
            0.00000017276,
            0,
            0,
            0.999989,
            0.000000204352,
            0,
            0,
            0.99998,
            0.00000026494,
            0,
            0,
            0.999969,
            0.000000383435,
            0,
            0,
            0.999953,
            0.000000618641,
            0,
            0,
            0.999929,
            0.00000108755,
            0,
            0,
            0.999898,
            0.00000201497,
            0,
            0,
            0.999849,
            0.00000381346,
            0,
            0,
            0.999778,
            0.00000719815,
            0,
            0,
            0.999661,
            0.0000133215,
            0,
            0,
            0.999451,
            0.0000238313,
            0,
            0,
            0.998936,
            0.0000401343,
            0,
            0.000113724,
            0.99662,
            0.0000517346,
            0,
            0.000820171,
            0.991094,
            0.0000304323,
            0,
            0.00238143,
            0.987487,
            0.0000281757,
            0,
            0.00493527,
            0.983731,
            0.0000320048,
            0,
            0.00856859,
            0.979647,
            0.0000423905,
            0,
            0.0133393,
            0.973837,
            0.0000562935,
            0,
            0.0192863,
            0.96584,
            0.0000677442,
            0,
            0.0264369,
            0.956309,
            0.0000623073,
            0,
            0.03481,
            0.951523,
            0.0000704131,
            0,
            0.0444184,
            0.946003,
            0.0000836594,
            0,
            0.0552713,
            0.938454,
            0.0000911736,
            0,
            0.0673749,
            0.929279,
            0.0000938264,
            0,
            0.0807329,
            0.919239,
            0.000103754,
            0,
            0.0953479,
            0.907293,
            0.000109928,
            0,
            0.111221,
            0.893936,
            0.000115257,
            0,
            0.128352,
            0.879674,
            0.000122265,
            0,
            0.14674,
            0.865668,
            0.000125733,
            0,
            0.166382,
            0.850998,
            0.000132305,
            0,
            0.187276,
            0.834498,
            0.000134844,
            0,
            0.209413,
            0.816903,
            0.000139276,
            0,
            0.232786,
            0.798235,
            0.000140984,
            0,
            0.257382,
            0.779724,
            0.00014378,
            0,
            0.283181,
            0.760251,
            0.000144623,
            0,
            0.310156,
            0.739808,
            0.000145228,
            0,
            0.338269,
            0.718762,
            0.00014539,
            0,
            0.367461,
            0.697815,
            0.000144432,
            0,
            0.397646,
            0.67631,
            0.000143893,
            0,
            0.428685,
            0.654278,
            0.000141846,
            0,
            0.460318,
            0.632347,
            0.00013935,
            0,
            0.492064,
            0.610296,
            0.000137138,
            0,
            0.52381,
            0.588039,
            0.000133806,
            0,
            0.555556,
            0.566218,
            0.000130755,
            0,
            0.587302,
            0.544346,
            0.000127128,
            0,
            0.619048,
            0.522701,
            0.000123002,
            0,
            0.650794,
            0.501542,
            0.000119443,
            0,
            0.68254,
            0.480508,
            0.000115055,
            0,
            0.714286,
            0.460092,
            0.000111032,
            0,
            0.746032,
            0.440021,
            0.000106635,
            0,
            0.777778,
            0.420446,
            0.000102162,
            0,
            0.809524,
            0.401512,
            0.000098184,
            0,
            0.84127,
            0.38299,
            0.0000936497,
            0,
            0.873016,
            0.365232,
            0.000089813,
            0,
            0.904762,
            0.347865,
            0.0000853073,
            0,
            0.936508,
            0.331342,
            0.0000817068,
            0,
            0.968254,
            0.315202,
            0.0000773818,
            0,
            1,
            1,
            0.00000029368,
            0,
            0,
            1,
            0.0000002937,
            0,
            0,
            1,
            0.000000293998,
            0,
            0,
            1,
            0.000000295298,
            0,
            0,
            0.999999,
            0.000000298865,
            0,
            0,
            0.999998,
            0.0000003067,
            0,
            0,
            0.999995,
            0.000000322082,
            0,
            0,
            0.999992,
            0.000000350767,
            0,
            0,
            0.999986,
            0.000000403538,
            0,
            0,
            0.999976,
            0.000000501372,
            0,
            0,
            0.999964,
            0.00000068562,
            0,
            0,
            0.999945,
            0.0000010374,
            0,
            0,
            0.999919,
            0.00000171269,
            0,
            0,
            0.999882,
            0.00000300175,
            0,
            0,
            0.999829,
            0.00000542144,
            0,
            0,
            0.999749,
            0.00000984182,
            0,
            0,
            0.99962,
            0.0000176213,
            0,
            0,
            0.999382,
            0.0000305995,
            0,
            0.0000138418,
            0.998751,
            0.0000496686,
            0,
            0.000389844,
            0.995344,
            0.0000510733,
            0,
            0.00150343,
            0.990768,
            0.0000345829,
            0,
            0.00352451,
            0.987464,
            0.0000342841,
            0,
            0.00655379,
            0.983846,
            0.0000399072,
            0,
            0.0106554,
            0.980007,
            0.0000533219,
            0,
            0.0158723,
            0.974494,
            0.0000696992,
            0,
            0.0222333,
            0.96622,
            0.0000776754,
            0,
            0.029758,
            0.956273,
            0.0000747718,
            0,
            0.0384596,
            0.950952,
            0.0000864611,
            0,
            0.0483473,
            0.945215,
            0.000100464,
            0,
            0.0594266,
            0.937287,
            0.000103729,
            0,
            0.0717019,
            0.928649,
            0.000111665,
            0,
            0.0851752,
            0.918791,
            0.00012353,
            0,
            0.0998479,
            0.906685,
            0.000127115,
            0,
            0.115721,
            0.893706,
            0.00013628,
            0,
            0.132794,
            0.879248,
            0.000142427,
            0,
            0.151067,
            0.864685,
            0.000148091,
            0,
            0.170538,
            0.850032,
            0.000153517,
            0,
            0.191204,
            0.833853,
            0.000157322,
            0,
            0.213063,
            0.816353,
            0.000161086,
            0,
            0.236107,
            0.797834,
            0.000164111,
            0,
            0.260329,
            0.778831,
            0.000165446,
            0,
            0.285714,
            0.759756,
            0.000167492,
            0,
            0.312243,
            0.739419,
            0.000166928,
            0,
            0.339887,
            0.718491,
            0.000167,
            0,
            0.368604,
            0.697392,
            0.000165674,
            0,
            0.398329,
            0.676102,
            0.000163815,
            0,
            0.428961,
            0.654243,
            0.000162003,
            0,
            0.460331,
            0.632176,
            0.000158831,
            0,
            0.492064,
            0.610407,
            0.000155463,
            0,
            0.52381,
            0.588394,
            0.000152062,
            0,
            0.555556,
            0.56645,
            0.000147665,
            0,
            0.587302,
            0.5449,
            0.00014375,
            0,
            0.619048,
            0.523276,
            0.000138905,
            0,
            0.650794,
            0.502179,
            0.000134189,
            0,
            0.68254,
            0.481359,
            0.000129392,
            0,
            0.714286,
            0.46092,
            0.000124556,
            0,
            0.746032,
            0.441084,
            0.00011957,
            0,
            0.777778,
            0.421517,
            0.000114652,
            0,
            0.809524,
            0.402721,
            0.000109688,
            0,
            0.84127,
            0.384222,
            0.000104667,
            0,
            0.873016,
            0.366534,
            0.0000999633,
            0,
            0.904762,
            0.349205,
            0.0000950177,
            0,
            0.936508,
            0.332702,
            0.0000907301,
            0,
            0.968254,
            0.316599,
            0.0000859769,
            0,
            1,
            1,
            0.000000585473,
            0,
            0,
            1,
            0.000000585507,
            0,
            0,
            1,
            0.00000058602,
            0,
            0,
            0.999999,
            0.000000588259,
            0,
            0,
            0.999999,
            0.000000594381,
            0,
            0,
            0.999998,
            0.000000607754,
            0,
            0,
            0.999995,
            0.000000633729,
            0,
            0,
            0.99999,
            0.00000068137,
            0,
            0,
            0.999984,
            0.000000767003,
            0,
            0,
            0.999973,
            0.000000921212,
            0,
            0,
            0.999959,
            0.00000120218,
            0,
            0,
            0.999936,
            0.00000172024,
            0,
            0,
            0.999907,
            0.00000268088,
            0,
            0,
            0.999866,
            0.00000445512,
            0,
            0,
            0.999806,
            0.00000768481,
            0,
            0,
            0.999716,
            0.00001342,
            0,
            0,
            0.999576,
            0.0000232473,
            0,
            0,
            0.9993,
            0.0000391694,
            0,
            0.000129917,
            0.998498,
            0.0000608429,
            0,
            0.000845035,
            0.994132,
            0.0000489743,
            0,
            0.00237616,
            0.99031,
            0.0000384644,
            0,
            0.00484456,
            0.987409,
            0.0000421768,
            0,
            0.00832472,
            0.983981,
            0.0000504854,
            0,
            0.0128643,
            0.980268,
            0.0000671028,
            0,
            0.0184947,
            0.974875,
            0.0000852749,
            0,
            0.025237,
            0.966063,
            0.000085531,
            0,
            0.0331046,
            0.956779,
            0.0000900588,
            0,
            0.0421067,
            0.950259,
            0.00010577,
            0,
            0.0522487,
            0.944239,
            0.000119458,
            0,
            0.0635343,
            0.936341,
            0.000122164,
            0,
            0.0759654,
            0.928047,
            0.000134929,
            0,
            0.0895434,
            0.918065,
            0.000145544,
            0,
            0.104269,
            0.906267,
            0.000150531,
            0,
            0.120142,
            0.893419,
            0.000161652,
            0,
            0.137163,
            0.878758,
            0.00016593,
            0,
            0.15533,
            0.863699,
            0.000174014,
            0,
            0.174645,
            0.848876,
            0.000177877,
            0,
            0.195106,
            0.833032,
            0.000184049,
            0,
            0.21671,
            0.815557,
            0.000186088,
            0,
            0.239454,
            0.797323,
            0.00019054,
            0,
            0.263332,
            0.778124,
            0.000191765,
            0,
            0.288336,
            0.758929,
            0.000192535,
            0,
            0.314451,
            0.738979,
            0.000192688,
            0,
            0.341658,
            0.718213,
            0.000191522,
            0,
            0.369924,
            0.696947,
            0.000190491,
            0,
            0.399202,
            0.675807,
            0.000187913,
            0,
            0.429416,
            0.654147,
            0.000184451,
            0,
            0.460447,
            0.63229,
            0.000181442,
            0,
            0.492064,
            0.610499,
            0.000177139,
            0,
            0.523809,
            0.588747,
            0.000172596,
            0,
            0.555555,
            0.566783,
            0.000167457,
            0,
            0.587301,
            0.545359,
            0.000162518,
            0,
            0.619048,
            0.523984,
            0.000156818,
            0,
            0.650794,
            0.502917,
            0.000151884,
            0,
            0.68254,
            0.482294,
            0.000145514,
            0,
            0.714286,
            0.461945,
            0.000140199,
            0,
            0.746032,
            0.442133,
            0.000134101,
            0,
            0.777778,
            0.422705,
            0.000128374,
            0,
            0.809524,
            0.403916,
            0.000122996,
            0,
            0.84127,
            0.38554,
            0.000116808,
            0,
            0.873016,
            0.367909,
            0.000111973,
            0,
            0.904762,
            0.350651,
            0.000105938,
            0,
            0.936508,
            0.334208,
            0.000101355,
            0,
            0.968254,
            0.318123,
            0.0000957629,
            0,
            1,
            1,
            0.00000111633,
            0,
            0,
            1,
            0.00000111639,
            0,
            0,
            1,
            0.00000111725,
            0,
            0,
            1,
            0.00000112096,
            0,
            0,
            0.999999,
            0.0000011311,
            0,
            0,
            0.999997,
            0.00000115315,
            0,
            0,
            0.999995,
            0.0000011956,
            0,
            0,
            0.999989,
            0.00000127239,
            0,
            0,
            0.999981,
            0.00000140772,
            0,
            0,
            0.999969,
            0.00000164541,
            0,
            0,
            0.999952,
            0.00000206607,
            0,
            0,
            0.999928,
            0.00000281783,
            0,
            0,
            0.999895,
            0.00000416835,
            0,
            0,
            0.999848,
            0.00000658728,
            0,
            0,
            0.999781,
            0.0000108648,
            0,
            0,
            0.999682,
            0.0000182579,
            0,
            0,
            0.999523,
            0.0000306003,
            0,
            0.0000159122,
            0.999205,
            0.0000499862,
            0,
            0.000391184,
            0.998131,
            0.000073306,
            0,
            0.00147534,
            0.993334,
            0.0000513229,
            0,
            0.0034227,
            0.99016,
            0.0000467783,
            0,
            0.00632232,
            0.987321,
            0.0000523413,
            0,
            0.0102295,
            0.984099,
            0.000064267,
            0,
            0.0151794,
            0.980432,
            0.0000843042,
            0,
            0.0211947,
            0.974976,
            0.000102819,
            0,
            0.0282899,
            0.966429,
            0.0000996234,
            0,
            0.0364739,
            0.957633,
            0.000111074,
            0,
            0.0457522,
            0.949422,
            0.000128644,
            0,
            0.0561278,
            0.943045,
            0.000140076,
            0,
            0.0676023,
            0.935448,
            0.000146349,
            0,
            0.0801762,
            0.927225,
            0.000161854,
            0,
            0.0938499,
            0.917033,
            0.000169135,
            0,
            0.108623,
            0.905762,
            0.000179987,
            0,
            0.124496,
            0.892879,
            0.000189832,
            0,
            0.141469,
            0.878435,
            0.000195881,
            0,
            0.159541,
            0.863114,
            0.00020466,
            0,
            0.178713,
            0.84776,
            0.000209473,
            0,
            0.198985,
            0.832084,
            0.000214861,
            0,
            0.220355,
            0.814915,
            0.000217695,
            0,
            0.242823,
            0.796711,
            0.000220313,
            0,
            0.266385,
            0.777603,
            0.00022313,
            0,
            0.291036,
            0.757991,
            0.000222471,
            0,
            0.316767,
            0.738371,
            0.000222869,
            0,
            0.343563,
            0.717872,
            0.000221243,
            0,
            0.371402,
            0.696619,
            0.000218089,
            0,
            0.400248,
            0.675379,
            0.00021562,
            0,
            0.430047,
            0.65411,
            0.00021169,
            0,
            0.460709,
            0.63241,
            0.000206947,
            0,
            0.492079,
            0.61046,
            0.000201709,
            0,
            0.52381,
            0.58903,
            0.000196753,
            0,
            0.555556,
            0.567267,
            0.000189637,
            0,
            0.587302,
            0.545886,
            0.000184735,
            0,
            0.619048,
            0.524714,
            0.000177257,
            0,
            0.650794,
            0.503789,
            0.000171424,
            0,
            0.68254,
            0.483204,
            0.000164688,
            0,
            0.714286,
            0.462976,
            0.000157172,
            0,
            0.746032,
            0.443294,
            0.000151341,
            0,
            0.777778,
            0.423988,
            0.000143737,
            0,
            0.809524,
            0.405325,
            0.000138098,
            0,
            0.84127,
            0.386981,
            0.000130698,
            0,
            0.873016,
            0.369436,
            0.000125276,
            0,
            0.904762,
            0.35219,
            0.000118349,
            0,
            0.936508,
            0.335804,
            0.00011312,
            0,
            0.968254,
            0.319749,
            0.000106687,
            0,
            1,
            1,
            0.00000204685,
            0,
            0,
            1,
            0.00000204694,
            0,
            0,
            1,
            0.00000204831,
            0,
            0,
            0.999999,
            0.00000205428,
            0,
            0,
            0.999999,
            0.00000207056,
            0,
            0,
            0.999997,
            0.00000210581,
            0,
            0,
            0.999993,
            0.0000021732,
            0,
            0,
            0.999987,
            0.00000229365,
            0,
            0,
            0.999979,
            0.00000250243,
            0,
            0,
            0.999965,
            0.00000286127,
            0,
            0,
            0.999947,
            0.00000348028,
            0,
            0,
            0.999918,
            0.00000455588,
            0,
            0,
            0.999881,
            0.00000643303,
            0,
            0,
            0.999828,
            0.00000970064,
            0,
            0,
            0.999753,
            0.0000153233,
            0,
            0,
            0.999642,
            0.000024793,
            0,
            0,
            0.999464,
            0.0000402032,
            0,
            0.000122947,
            0.999089,
            0.0000635852,
            0,
            0.000807414,
            0.997567,
            0.0000857026,
            0,
            0.00227206,
            0.992903,
            0.0000594912,
            0,
            0.00462812,
            0.990011,
            0.0000578515,
            0,
            0.00794162,
            0.987192,
            0.000065399,
            0,
            0.0122534,
            0.98418,
            0.0000819675,
            0,
            0.0175888,
            0.980491,
            0.000105514,
            0,
            0.0239635,
            0.974779,
            0.000121532,
            0,
            0.031387,
            0.96675,
            0.000119144,
            0,
            0.0398644,
            0.958248,
            0.000136125,
            0,
            0.0493982,
            0.948884,
            0.000155408,
            0,
            0.0599896,
            0.941673,
            0.000162281,
            0,
            0.0716382,
            0.934521,
            0.000176754,
            0,
            0.0843437,
            0.926205,
            0.000192873,
            0,
            0.0981056,
            0.916089,
            0.000200038,
            0,
            0.112923,
            0.904963,
            0.000213624,
            0,
            0.128796,
            0.892089,
            0.000221834,
            0,
            0.145725,
            0.878028,
            0.000232619,
            0,
            0.163709,
            0.86249,
            0.000238632,
            0,
            0.182749,
            0.846587,
            0.000247002,
            0,
            0.202847,
            0.830988,
            0.000250702,
            0,
            0.224001,
            0.814165,
            0.000255562,
            0,
            0.246214,
            0.796135,
            0.000257505,
            0,
            0.269482,
            0.777052,
            0.000258625,
            0,
            0.293805,
            0.757201,
            0.000258398,
            0,
            0.319176,
            0.737655,
            0.000256714,
            0,
            0.345587,
            0.717477,
            0.000255187,
            0,
            0.373021,
            0.696433,
            0.000251792,
            0,
            0.401454,
            0.675084,
            0.000247223,
            0,
            0.430844,
            0.653907,
            0.000242213,
            0,
            0.461125,
            0.632561,
            0.000237397,
            0,
            0.492187,
            0.610658,
            0.000229313,
            0,
            0.52381,
            0.589322,
            0.000224402,
            0,
            0.555556,
            0.567857,
            0.000216116,
            0,
            0.587302,
            0.54652,
            0.000209124,
            0,
            0.619048,
            0.525433,
            0.000201601,
            0,
            0.650794,
            0.504679,
            0.000192957,
            0,
            0.68254,
            0.484203,
            0.000186052,
            0,
            0.714286,
            0.464203,
            0.000177672,
            0,
            0.746032,
            0.444549,
            0.000170005,
            0,
            0.777778,
            0.425346,
            0.000162401,
            0,
            0.809524,
            0.406706,
            0.0001544,
            0,
            0.84127,
            0.388576,
            0.000147437,
            0,
            0.873016,
            0.37094,
            0.000139493,
            0,
            0.904762,
            0.353996,
            0.000133219,
            0,
            0.936508,
            0.337391,
            0.000125573,
            0,
            0.968254,
            0.321648,
            0.000119867,
            0,
            1,
            1,
            0.00000362511,
            0,
            0,
            1,
            0.00000362525,
            0,
            0,
            1,
            0.00000362739,
            0,
            0,
            0.999999,
            0.00000363673,
            0,
            0,
            0.999998,
            0.00000366214,
            0,
            0,
            0.999996,
            0.00000371698,
            0,
            0,
            0.999992,
            0.00000382116,
            0,
            0,
            0.999986,
            0.00000400554,
            0,
            0,
            0.999976,
            0.00000432058,
            0,
            0,
            0.999961,
            0.00000485194,
            0,
            0,
            0.999938,
            0.00000574808,
            0,
            0,
            0.999908,
            0.00000726643,
            0,
            0,
            0.999865,
            0.00000984707,
            0,
            0,
            0.999807,
            0.0000142217,
            0,
            0,
            0.999723,
            0.0000215581,
            0,
            0,
            0.999602,
            0.0000336114,
            0,
            0.0000119113,
            0.999398,
            0.0000527353,
            0,
            0.000355813,
            0.998946,
            0.0000805809,
            0,
            0.00137768,
            0.996647,
            0.0000942908,
            0,
            0.00322469,
            0.992298,
            0.0000668733,
            0,
            0.00597897,
            0.989802,
            0.0000716564,
            0,
            0.00968903,
            0.987019,
            0.0000821355,
            0,
            0.0143845,
            0.984219,
            0.000104555,
            0,
            0.0200831,
            0.980425,
            0.000131245,
            0,
            0.0267948,
            0.974241,
            0.000139613,
            0,
            0.034525,
            0.967006,
            0.000145931,
            0,
            0.0432757,
            0.95893,
            0.000167153,
            0,
            0.0530471,
            0.949157,
            0.000188146,
            0,
            0.0638386,
            0.94062,
            0.000194625,
            0,
            0.0756487,
            0.933509,
            0.000213721,
            0,
            0.0884762,
            0.925088,
            0.000229616,
            0,
            0.10232,
            0.915178,
            0.000239638,
            0,
            0.117178,
            0.904093,
            0.000254814,
            0,
            0.133051,
            0.891337,
            0.000263685,
            0,
            0.149939,
            0.877326,
            0.000274789,
            0,
            0.167841,
            0.861794,
            0.000280534,
            0,
            0.18676,
            0.845758,
            0.000289534,
            0,
            0.206696,
            0.829792,
            0.000294446,
            0,
            0.22765,
            0.813037,
            0.000296877,
            0,
            0.249625,
            0.795285,
            0.000300217,
            0,
            0.27262,
            0.776323,
            0.000299826,
            0,
            0.296636,
            0.756673,
            0.000299787,
            0,
            0.321671,
            0.736856,
            0.000297867,
            0,
            0.347718,
            0.716883,
            0.000294052,
            0,
            0.374768,
            0.696089,
            0.000289462,
            0,
            0.402804,
            0.67505,
            0.000285212,
            0,
            0.431796,
            0.653509,
            0.00027653,
            0,
            0.461695,
            0.63258,
            0.000271759,
            0,
            0.49242,
            0.61104,
            0.000262811,
            0,
            0.523822,
            0.589567,
            0.000255151,
            0,
            0.555556,
            0.568322,
            0.000246434,
            0,
            0.587302,
            0.547235,
            0.000237061,
            0,
            0.619048,
            0.52616,
            0.000228343,
            0,
            0.650794,
            0.505716,
            0.000219236,
            0,
            0.68254,
            0.485274,
            0.000209595,
            0,
            0.714286,
            0.465411,
            0.000201011,
            0,
            0.746032,
            0.445854,
            0.00019109,
            0,
            0.777778,
            0.426911,
            0.000182897,
            0,
            0.809524,
            0.408222,
            0.000173569,
            0,
            0.84127,
            0.390307,
            0.000165496,
            0,
            0.873016,
            0.372624,
            0.000156799,
            0,
            0.904762,
            0.355804,
            0.00014917,
            0,
            0.936508,
            0.33924,
            0.000140907,
            0,
            0.968254,
            0.323534,
            0.000134062,
            0,
            1,
            1,
            0.00000622487,
            0,
            0,
            1,
            0.0000062251,
            0,
            0,
            1,
            0.00000622837,
            0,
            0,
            0.999999,
            0.00000624259,
            0,
            0,
            0.999998,
            0.00000628127,
            0,
            0,
            0.999996,
            0.00000636451,
            0,
            0,
            0.999991,
            0.0000065218,
            0,
            0,
            0.999984,
            0.00000679782,
            0,
            0,
            0.999973,
            0.00000726361,
            0,
            0,
            0.999955,
            0.00000803644,
            0,
            0,
            0.999931,
            0.00000931397,
            0,
            0,
            0.999896,
            0.0000114299,
            0,
            0,
            0.999847,
            0.0000149402,
            0,
            0,
            0.999784,
            0.0000207461,
            0,
            0,
            0.999692,
            0.0000302493,
            0,
            0,
            0.999554,
            0.0000454957,
            0,
            0.0000997275,
            0.999326,
            0.0000690762,
            0,
            0.000724813,
            0.998757,
            0.000101605,
            0,
            0.0020972,
            0.995367,
            0.0000958745,
            0,
            0.00432324,
            0.99209,
            0.0000832808,
            0,
            0.00746347,
            0.989517,
            0.0000887601,
            0,
            0.0115534,
            0.987008,
            0.00010564,
            0,
            0.0166134,
            0.98421,
            0.000133179,
            0,
            0.0226552,
            0.98021,
            0.000161746,
            0,
            0.0296838,
            0.973676,
            0.000161821,
            0,
            0.0377016,
            0.967052,
            0.000178635,
            0,
            0.0467079,
            0.959385,
            0.000206765,
            0,
            0.0567013,
            0.949461,
            0.00022476,
            0,
            0.0676796,
            0.939578,
            0.00023574,
            0,
            0.0796403,
            0.932416,
            0.00025893,
            0,
            0.0925812,
            0.923759,
            0.000271228,
            0,
            0.106501,
            0.914223,
            0.000289165,
            0,
            0.121397,
            0.902942,
            0.000301156,
            0,
            0.13727,
            0.890419,
            0.000313852,
            0,
            0.15412,
            0.876639,
            0.000324408,
            0,
            0.171946,
            0.861316,
            0.00033249,
            0,
            0.190751,
            0.84496,
            0.000338497,
            0,
            0.210537,
            0.828427,
            0.000345861,
            0,
            0.231305,
            0.811871,
            0.000347863,
            0,
            0.253057,
            0.794397,
            0.000350225,
            0,
            0.275797,
            0.775726,
            0.000349915,
            0,
            0.299525,
            0.75617,
            0.000347297,
            0,
            0.324242,
            0.736091,
            0.000344232,
            0,
            0.349947,
            0.716213,
            0.000340835,
            0,
            0.376633,
            0.695736,
            0.000332369,
            0,
            0.404289,
            0.674961,
            0.000327943,
            0,
            0.432895,
            0.653518,
            0.000318533,
            0,
            0.462415,
            0.632574,
            0.000310391,
            0,
            0.492788,
            0.61134,
            0.000300755,
            0,
            0.523909,
            0.590017,
            0.000290506,
            0,
            0.555556,
            0.568752,
            0.000280446,
            0,
            0.587302,
            0.548061,
            0.000269902,
            0,
            0.619048,
            0.52711,
            0.000258815,
            0,
            0.650794,
            0.506682,
            0.000248481,
            0,
            0.68254,
            0.486524,
            0.000237141,
            0,
            0.714286,
            0.466812,
            0.000226872,
            0,
            0.746032,
            0.44732,
            0.000216037,
            0,
            0.777778,
            0.428473,
            0.000205629,
            0,
            0.809524,
            0.409921,
            0.000195691,
            0,
            0.84127,
            0.392028,
            0.000185457,
            0,
            0.873016,
            0.374606,
            0.000176436,
            0,
            0.904762,
            0.357601,
            0.000166508,
            0,
            0.936508,
            0.341348,
            0.000158385,
            0,
            0.968254,
            0.32542,
            0.000149203,
            0,
            1,
            1,
            0.0000103967,
            0,
            0,
            1,
            0.000010397,
            0,
            0,
            1,
            0.0000104019,
            0,
            0,
            0.999999,
            0.0000104231,
            0,
            0,
            0.999998,
            0.0000104806,
            0,
            0,
            0.999995,
            0.0000106042,
            0,
            0,
            0.999991,
            0.0000108366,
            0,
            0,
            0.999982,
            0.0000112415,
            0,
            0,
            0.999968,
            0.0000119174,
            0,
            0,
            0.99995,
            0.0000130227,
            0,
            0,
            0.999922,
            0.0000148176,
            0,
            0,
            0.999884,
            0.0000177303,
            0,
            0,
            0.99983,
            0.0000224564,
            0,
            0,
            0.999758,
            0.0000300966,
            0,
            0,
            0.999654,
            0.0000423193,
            0,
            0.00000549083,
            0.999503,
            0.0000614848,
            0,
            0.000296087,
            0.999237,
            0.0000903576,
            0,
            0.00123144,
            0.998491,
            0.0001271,
            0,
            0.00295954,
            0.994594,
            0.000107754,
            0,
            0.00555829,
            0.99178,
            0.000103025,
            0,
            0.00907209,
            0.989265,
            0.00011154,
            0,
            0.0135257,
            0.986998,
            0.000136296,
            0,
            0.0189327,
            0.984137,
            0.000169154,
            0,
            0.0252993,
            0.979798,
            0.000196671,
            0,
            0.0326272,
            0.97337,
            0.000196678,
            0,
            0.0409157,
            0.967239,
            0.000223121,
            0,
            0.0501623,
            0.959543,
            0.000253809,
            0,
            0.0603638,
            0.949466,
            0.000265972,
            0,
            0.0715171,
            0.939074,
            0.000288372,
            0,
            0.0836187,
            0.931118,
            0.000310983,
            0,
            0.0966657,
            0.922525,
            0.000325561,
            0,
            0.110656,
            0.912983,
            0.000345725,
            0,
            0.125588,
            0.901617,
            0.0003556,
            0,
            0.141461,
            0.889487,
            0.000374012,
            0,
            0.158275,
            0.875787,
            0.000383445,
            0,
            0.176031,
            0.860654,
            0.000393972,
            0,
            0.19473,
            0.844417,
            0.000400311,
            0,
            0.214374,
            0.82741,
            0.000405004,
            0,
            0.234967,
            0.810545,
            0.000407378,
            0,
            0.256512,
            0.793312,
            0.000407351,
            0,
            0.279011,
            0.774847,
            0.000406563,
            0,
            0.302468,
            0.755621,
            0.000404903,
            0,
            0.326887,
            0.735511,
            0.000397486,
            0,
            0.352266,
            0.715435,
            0.00039357,
            0,
            0.378605,
            0.695403,
            0.000384739,
            0,
            0.405897,
            0.674681,
            0.000376108,
            0,
            0.43413,
            0.65359,
            0.000365997,
            0,
            0.463277,
            0.632471,
            0.000354957,
            0,
            0.493295,
            0.61151,
            0.000343593,
            0,
            0.524106,
            0.59064,
            0.000331841,
            0,
            0.555561,
            0.569386,
            0.000318891,
            0,
            0.587302,
            0.548785,
            0.0003072,
            0,
            0.619048,
            0.528146,
            0.00029361,
            0,
            0.650794,
            0.507872,
            0.000281709,
            0,
            0.68254,
            0.487805,
            0.000268627,
            0,
            0.714286,
            0.468196,
            0.000255887,
            0,
            0.746032,
            0.448922,
            0.000243997,
            0,
            0.777778,
            0.430093,
            0.000231662,
            0,
            0.809524,
            0.411845,
            0.000220339,
            0,
            0.84127,
            0.393808,
            0.000208694,
            0,
            0.873016,
            0.376615,
            0.000198045,
            0,
            0.904762,
            0.359655,
            0.000187375,
            0,
            0.936508,
            0.343452,
            0.000177371,
            0,
            0.968254,
            0.32765,
            0.000167525,
            0,
            1,
            1,
            0.0000169351,
            0,
            0,
            1,
            0.0000169356,
            0,
            0,
            1,
            0.0000169427,
            0,
            0,
            0.999999,
            0.0000169736,
            0,
            0,
            0.999998,
            0.0000170575,
            0,
            0,
            0.999995,
            0.0000172372,
            0,
            0,
            0.99999,
            0.0000175739,
            0,
            0,
            0.999979,
            0.0000181568,
            0,
            0,
            0.999966,
            0.0000191206,
            0,
            0,
            0.999944,
            0.000020677,
            0,
            0,
            0.999912,
            0.0000231644,
            0,
            0,
            0.999869,
            0.0000271268,
            0,
            0,
            0.999811,
            0.0000334272,
            0,
            0,
            0.99973,
            0.0000433979,
            0,
            0,
            0.999617,
            0.0000590083,
            0,
            0.0000680315,
            0.999445,
            0.0000829497,
            0,
            0.000612796,
            0.999138,
            0.000118019,
            0,
            0.00187408,
            0.998095,
            0.000156712,
            0,
            0.00395791,
            0.993919,
            0.000125054,
            0,
            0.00692144,
            0.991333,
            0.000126091,
            0,
            0.0107962,
            0.989226,
            0.000144912,
            0,
            0.0155986,
            0.986954,
            0.000175737,
            0,
            0.0213364,
            0.983982,
            0.000213883,
            0,
            0.0280114,
            0.979128,
            0.000234526,
            0,
            0.0356226,
            0.973327,
            0.000243725,
            0,
            0.0441668,
            0.967416,
            0.0002773,
            0,
            0.0536399,
            0.959729,
            0.000308799,
            0,
            0.0640376,
            0.949758,
            0.000322447,
            0,
            0.0753554,
            0.939173,
            0.000350021,
            0,
            0.0875893,
            0.9296,
            0.000370089,
            0,
            0.100736,
            0.921181,
            0.000391365,
            0,
            0.114793,
            0.91164,
            0.000413636,
            0,
            0.129759,
            0.900435,
            0.000427068,
            0,
            0.145632,
            0.888183,
            0.000441046,
            0,
            0.162412,
            0.874772,
            0.000454968,
            0,
            0.180101,
            0.859566,
            0.000461882,
            0,
            0.1987,
            0.843579,
            0.000471556,
            0,
            0.218213,
            0.826453,
            0.000474335,
            0,
            0.238641,
            0.809164,
            0.000477078,
            0,
            0.259989,
            0.792179,
            0.00047755,
            0,
            0.282262,
            0.773866,
            0.000472573,
            0,
            0.305464,
            0.754944,
            0.000469765,
            0,
            0.329599,
            0.735133,
            0.000462371,
            0,
            0.35467,
            0.714858,
            0.000453674,
            0,
            0.380678,
            0.694829,
            0.000443888,
            0,
            0.407622,
            0.674453,
            0.000432052,
            0,
            0.435493,
            0.653685,
            0.000420315,
            0,
            0.464275,
            0.632666,
            0.000406829,
            0,
            0.493938,
            0.611676,
            0.000392234,
            0,
            0.524422,
            0.591193,
            0.000379208,
            0,
            0.555624,
            0.570145,
            0.00036319,
            0,
            0.587302,
            0.549566,
            0.000349111,
            0,
            0.619048,
            0.529278,
            0.000334166,
            0,
            0.650794,
            0.509026,
            0.000318456,
            0,
            0.68254,
            0.489186,
            0.00030449,
            0,
            0.714286,
            0.469662,
            0.000289051,
            0,
            0.746032,
            0.450691,
            0.000275494,
            0,
            0.777778,
            0.431841,
            0.000261437,
            0,
            0.809524,
            0.413752,
            0.000247846,
            0,
            0.84127,
            0.395951,
            0.000235085,
            0,
            0.873016,
            0.378633,
            0.000222245,
            0,
            0.904762,
            0.36194,
            0.000210533,
            0,
            0.936508,
            0.345599,
            0.000198494,
            0,
            0.968254,
            0.329999,
            0.000188133,
            0,
            1,
            1,
            0.0000269663,
            0,
            0,
            1,
            0.000026967,
            0,
            0,
            1,
            0.0000269772,
            0,
            0,
            0.999999,
            0.0000270214,
            0,
            0,
            0.999998,
            0.0000271415,
            0,
            0,
            0.999994,
            0.000027398,
            0,
            0,
            0.999988,
            0.0000278771,
            0,
            0,
            0.999977,
            0.0000287019,
            0,
            0,
            0.999961,
            0.0000300544,
            0,
            0,
            0.999937,
            0.0000322138,
            0,
            0,
            0.999904,
            0.0000356163,
            0,
            0,
            0.999854,
            0.0000409465,
            0,
            0,
            0.99979,
            0.0000492651,
            0,
            0,
            0.999699,
            0.0000621722,
            0,
            0.00000088288,
            0.999572,
            0.0000819715,
            0,
            0.000223369,
            0.999381,
            0.000111689,
            0,
            0.00105414,
            0.999016,
            0.000153862,
            0,
            0.0026493,
            0.997437,
            0.000187667,
            0,
            0.00508608,
            0.993545,
            0.000155672,
            0,
            0.00840554,
            0.991135,
            0.000161455,
            0,
            0.012629,
            0.989157,
            0.000188241,
            0,
            0.0177661,
            0.986874,
            0.000226229,
            0,
            0.0238198,
            0.983714,
            0.000268668,
            0,
            0.0307887,
            0.978301,
            0.000277109,
            0,
            0.0386688,
            0.973227,
            0.000303446,
            0,
            0.0474554,
            0.967317,
            0.000341851,
            0,
            0.0571428,
            0.959477,
            0.000370885,
            0,
            0.0677256,
            0.950012,
            0.000392753,
            0,
            0.0791988,
            0.939484,
            0.00042781,
            0,
            0.0915576,
            0.928135,
            0.000443866,
            0,
            0.104798,
            0.919819,
            0.000472959,
            0,
            0.118918,
            0.910049,
            0.000491551,
            0,
            0.133915,
            0.899181,
            0.000512616,
            0,
            0.149788,
            0.886881,
            0.000523563,
            0,
            0.166537,
            0.87359,
            0.000540183,
            0,
            0.184164,
            0.858613,
            0.000547386,
            0,
            0.202669,
            0.842809,
            0.000554809,
            0,
            0.222056,
            0.825727,
            0.000558316,
            0,
            0.242329,
            0.808086,
            0.000557824,
            0,
            0.263492,
            0.790728,
            0.000556346,
            0,
            0.285551,
            0.772987,
            0.000552672,
            0,
            0.30851,
            0.7541,
            0.000543738,
            0,
            0.332376,
            0.734669,
            0.000536107,
            0,
            0.357153,
            0.714411,
            0.000523342,
            0,
            0.382845,
            0.694196,
            0.000512238,
            0,
            0.409454,
            0.674252,
            0.000497465,
            0,
            0.436977,
            0.65357,
            0.000481096,
            0,
            0.465404,
            0.632999,
            0.000467054,
            0,
            0.494713,
            0.611994,
            0.000448771,
            0,
            0.524864,
            0.591604,
            0.000431889,
            0,
            0.555779,
            0.571134,
            0.000415238,
            0,
            0.587302,
            0.550528,
            0.000396369,
            0,
            0.619048,
            0.530292,
            0.000379477,
            0,
            0.650794,
            0.510364,
            0.000361488,
            0,
            0.68254,
            0.490749,
            0.000343787,
            0,
            0.714286,
            0.471266,
            0.000327822,
            0,
            0.746032,
            0.452462,
            0.000310626,
            0,
            0.777778,
            0.433907,
            0.000295352,
            0,
            0.809524,
            0.415659,
            0.000279179,
            0,
            0.84127,
            0.398138,
            0.000264685,
            0,
            0.873016,
            0.380833,
            0.000249905,
            0,
            0.904762,
            0.364247,
            0.000236282,
            0,
            0.936508,
            0.348041,
            0.000222905,
            0,
            0.968254,
            0.332389,
            0.000210522,
            0,
            1,
            1,
            0.0000420604,
            0,
            0,
            1,
            0.0000420614,
            0,
            0,
            1,
            0.0000420757,
            0,
            0,
            0.999999,
            0.000042138,
            0,
            0,
            0.999997,
            0.0000423067,
            0,
            0,
            0.999993,
            0.0000426668,
            0,
            0,
            0.999986,
            0.0000433372,
            0,
            0,
            0.999974,
            0.0000444857,
            0,
            0,
            0.999956,
            0.0000463554,
            0,
            0,
            0.99993,
            0.0000493105,
            0,
            0,
            0.999892,
            0.0000539077,
            0,
            0,
            0.999838,
            0.0000610005,
            0,
            0,
            0.999767,
            0.0000718822,
            0,
            0,
            0.999666,
            0.0000884581,
            0,
            0.0000365471,
            0.999525,
            0.000113398,
            0,
            0.000485623,
            0.999311,
            0.000150043,
            0,
            0.00162096,
            0.998865,
            0.000200063,
            0,
            0.00355319,
            0.996278,
            0.000211014,
            0,
            0.00633818,
            0.992956,
            0.000189672,
            0,
            0.0100043,
            0.991017,
            0.000210262,
            0,
            0.0145648,
            0.989055,
            0.000244292,
            0,
            0.0200237,
            0.986741,
            0.000290481,
            0,
            0.0263798,
            0.983288,
            0.000334303,
            0,
            0.033629,
            0.977784,
            0.000340307,
            0,
            0.0417652,
            0.973037,
            0.000377864,
            0,
            0.0507821,
            0.967181,
            0.0004239,
            0,
            0.060673,
            0.958971,
            0.000443854,
            0,
            0.0714314,
            0.950093,
            0.000483039,
            0,
            0.0830518,
            0.939552,
            0.000517934,
            0,
            0.0955288,
            0.927678,
            0.000539449,
            0,
            0.108859,
            0.918278,
            0.000568604,
            0,
            0.123038,
            0.908449,
            0.000588505,
            0,
            0.138065,
            0.897713,
            0.000612473,
            0,
            0.153938,
            0.885533,
            0.000625575,
            0,
            0.170657,
            0.872131,
            0.00063854,
            0,
            0.188224,
            0.857517,
            0.000647034,
            0,
            0.20664,
            0.841796,
            0.00065209,
            0,
            0.225909,
            0.824726,
            0.0006544,
            0,
            0.246035,
            0.807297,
            0.000655744,
            0,
            0.267022,
            0.789058,
            0.000646716,
            0,
            0.288878,
            0.77189,
            0.000643898,
            0,
            0.311607,
            0.753082,
            0.000629973,
            0,
            0.335216,
            0.7341,
            0.000621564,
            0,
            0.359713,
            0.714094,
            0.000605171,
            0,
            0.385103,
            0.693839,
            0.000588752,
            0,
            0.41139,
            0.673891,
            0.000573294,
            0,
            0.438576,
            0.653565,
            0.000552682,
            0,
            0.466656,
            0.633326,
            0.000533446,
            0,
            0.495617,
            0.612582,
            0.000514635,
            0,
            0.525431,
            0.59205,
            0.00049303,
            0,
            0.556041,
            0.571918,
            0.000471842,
            0,
            0.587338,
            0.551572,
            0.000451713,
            0,
            0.619048,
            0.531553,
            0.000430049,
            0,
            0.650794,
            0.51175,
            0.000410445,
            0,
            0.68254,
            0.49238,
            0.000390098,
            0,
            0.714286,
            0.473143,
            0.000370033,
            0,
            0.746032,
            0.45423,
            0.000351205,
            0,
            0.777778,
            0.435963,
            0.000332049,
            0,
            0.809524,
            0.41787,
            0.000315021,
            0,
            0.84127,
            0.400387,
            0.000297315,
            0,
            0.873016,
            0.383332,
            0.000281385,
            0,
            0.904762,
            0.366665,
            0.000265397,
            0,
            0.936508,
            0.350633,
            0.000250601,
            0,
            0.968254,
            0.334964,
            0.00023589,
            0,
            1,
            1,
            0.0000643736,
            0,
            0,
            1,
            0.000064375,
            0,
            0,
            1,
            0.0000643947,
            0,
            0,
            0.999999,
            0.000064481,
            0,
            0,
            0.999997,
            0.0000647143,
            0,
            0,
            0.999994,
            0.0000652119,
            0,
            0,
            0.999985,
            0.0000661359,
            0,
            0,
            0.999972,
            0.0000677116,
            0,
            0,
            0.999952,
            0.0000702599,
            0,
            0,
            0.999922,
            0.0000742517,
            0,
            0,
            0.99988,
            0.0000803906,
            0,
            0,
            0.99982,
            0.0000897315,
            0,
            0,
            0.999741,
            0.000103838,
            0,
            0,
            0.999629,
            0.00012496,
            0,
            0.000149024,
            0.999474,
            0.000156161,
            0,
            0.000861027,
            0.999229,
            0.000201034,
            0,
            0.00231198,
            0.998662,
            0.000259069,
            0,
            0.00458147,
            0.995299,
            0.000245439,
            0,
            0.00770895,
            0.992732,
            0.00024498,
            0,
            0.0117126,
            0.990847,
            0.000273211,
            0,
            0.0165989,
            0.988911,
            0.000316492,
            0,
            0.0223674,
            0.98654,
            0.00037161,
            0,
            0.0290135,
            0.982636,
            0.000410352,
            0,
            0.0365309,
            0.977346,
            0.000421756,
            0,
            0.0449117,
            0.972909,
            0.000475578,
            0,
            0.0541481,
            0.966821,
            0.000522482,
            0,
            0.0642326,
            0.958686,
            0.000545008,
            0,
            0.075158,
            0.949754,
            0.000589286,
            0,
            0.0869181,
            0.939184,
            0.000619995,
            0,
            0.0995074,
            0.927505,
            0.000654266,
            0,
            0.112922,
            0.916606,
            0.000682362,
            0,
            0.127157,
            0.906707,
            0.000704286,
            0,
            0.142212,
            0.895937,
            0.000725909,
            0,
            0.158085,
            0.883913,
            0.000743939,
            0,
            0.174776,
            0.870642,
            0.000755157,
            0,
            0.192287,
            0.856241,
            0.000764387,
            0,
            0.210619,
            0.84069,
            0.000771032,
            0,
            0.229775,
            0.823728,
            0.000765906,
            0,
            0.249761,
            0.806481,
            0.000767604,
            0,
            0.270582,
            0.787924,
            0.000754385,
            0,
            0.292243,
            0.770588,
            0.000749668,
            0,
            0.314753,
            0.751991,
            0.000731613,
            0,
            0.338118,
            0.733407,
            0.000717655,
            0,
            0.362347,
            0.713688,
            0.000700604,
            0,
            0.387447,
            0.693595,
            0.000678765,
            0,
            0.413424,
            0.673426,
            0.000657042,
            0,
            0.440284,
            0.65359,
            0.000635892,
            0,
            0.468027,
            0.633576,
            0.000611569,
            0,
            0.496645,
            0.613144,
            0.000586011,
            0,
            0.526122,
            0.592711,
            0.000563111,
            0,
            0.556417,
            0.572722,
            0.000537699,
            0,
            0.587451,
            0.552762,
            0.000512556,
            0,
            0.619048,
            0.532985,
            0.000489757,
            0,
            0.650794,
            0.513219,
            0.000464139,
            0,
            0.68254,
            0.493992,
            0.000442193,
            0,
            0.714286,
            0.47509,
            0.000418629,
            0,
            0.746032,
            0.456287,
            0.000397045,
            0,
            0.777778,
            0.438152,
            0.000375504,
            0,
            0.809524,
            0.420294,
            0.00035492,
            0,
            0.84127,
            0.402749,
            0.000335327,
            0,
            0.873016,
            0.385879,
            0.000316422,
            0,
            0.904762,
            0.369352,
            0.000298333,
            0,
            0.936508,
            0.353301,
            0.000281417,
            0,
            0.968254,
            0.337781,
            0.000265203,
            0,
            1,
            1,
            0.0000968267,
            0,
            0,
            1,
            0.0000968284,
            0,
            0,
            1,
            0.0000968556,
            0,
            0,
            0.999999,
            0.0000969733,
            0,
            0,
            0.999997,
            0.0000972913,
            0,
            0,
            0.999993,
            0.0000979688,
            0,
            0,
            0.999984,
            0.0000992239,
            0,
            0,
            0.999969,
            0.000101356,
            0,
            0,
            0.999946,
            0.000104784,
            0,
            0,
            0.999913,
            0.000110111,
            0,
            0,
            0.999868,
            0.000118217,
            0,
            0,
            0.999801,
            0.000130396,
            0,
            0,
            0.999712,
            0.000148523,
            0,
            0.0000124907,
            0.999589,
            0.000175233,
            0,
            0.000355405,
            0.999416,
            0.000213999,
            0,
            0.0013528,
            0.999136,
            0.000268529,
            0,
            0.00312557,
            0.998367,
            0.000333088,
            0,
            0.00573045,
            0.994701,
            0.000304757,
            0,
            0.00919397,
            0.992497,
            0.000318031,
            0,
            0.0135261,
            0.990608,
            0.000353863,
            0,
            0.0187278,
            0.988715,
            0.000409044,
            0,
            0.0247947,
            0.986241,
            0.000472967,
            0,
            0.0317196,
            0.981696,
            0.000495104,
            0,
            0.039494,
            0.977097,
            0.000532873,
            0,
            0.0481087,
            0.972583,
            0.000594447,
            0,
            0.0575549,
            0.966142,
            0.000636867,
            0,
            0.0678242,
            0.95823,
            0.000669899,
            0,
            0.0789089,
            0.949677,
            0.000719499,
            0,
            0.0908023,
            0.939226,
            0.000750584,
            0,
            0.103499,
            0.927501,
            0.000793183,
            0,
            0.116993,
            0.915199,
            0.00081995,
            0,
            0.131282,
            0.90498,
            0.000847654,
            0,
            0.146364,
            0.894243,
            0.000868929,
            0,
            0.162237,
            0.882154,
            0.000884278,
            0,
            0.178902,
            0.869161,
            0.000898108,
            0,
            0.196358,
            0.854751,
            0.000901254,
            0,
            0.21461,
            0.839368,
            0.00090679,
            0,
            0.23366,
            0.822874,
            0.000901541,
            0,
            0.253512,
            0.805514,
            0.000897297,
            0,
            0.274174,
            0.78716,
            0.000881856,
            0,
            0.29565,
            0.769061,
            0.000870032,
            0,
            0.31795,
            0.751,
            0.000851719,
            0,
            0.341081,
            0.732614,
            0.000830671,
            0,
            0.365053,
            0.713171,
            0.000806569,
            0,
            0.389874,
            0.693472,
            0.00078338,
            0,
            0.415553,
            0.673528,
            0.000756404,
            0,
            0.442098,
            0.653397,
            0.000726872,
            0,
            0.469512,
            0.633781,
            0.000700494,
            0,
            0.497794,
            0.613877,
            0.00067105,
            0,
            0.526935,
            0.593506,
            0.000640361,
            0,
            0.556908,
            0.573667,
            0.000613502,
            0,
            0.587657,
            0.553932,
            0.000583177,
            0,
            0.61906,
            0.534345,
            0.000554375,
            0,
            0.650794,
            0.515042,
            0.000527811,
            0,
            0.68254,
            0.495674,
            0.000499367,
            0,
            0.714286,
            0.477132,
            0.00047429,
            0,
            0.746032,
            0.458609,
            0.000447726,
            0,
            0.777778,
            0.440354,
            0.000424205,
            0,
            0.809524,
            0.422765,
            0.000399549,
            0,
            0.84127,
            0.405472,
            0.000378315,
            0,
            0.873016,
            0.388482,
            0.000355327,
            0,
            0.904762,
            0.372191,
            0.000336122,
            0,
            0.936508,
            0.356099,
            0.000315247,
            0,
            0.968254,
            0.340737,
            0.00029794,
            0,
            1,
            1,
            0.000143327,
            0,
            0,
            1,
            0.00014333,
            0,
            0,
            1,
            0.000143366,
            0,
            0,
            0.999999,
            0.000143524,
            0,
            0,
            0.999996,
            0.000143952,
            0,
            0,
            0.999991,
            0.000144862,
            0,
            0,
            0.999981,
            0.000146544,
            0,
            0,
            0.999966,
            0.000149391,
            0,
            0,
            0.999941,
            0.000153946,
            0,
            0,
            0.999905,
            0.000160971,
            0,
            0,
            0.999852,
            0.000171562,
            0,
            0,
            0.99978,
            0.00018729,
            0,
            0,
            0.999681,
            0.000210386,
            0,
            0.0000826239,
            0.999546,
            0.000243906,
            0,
            0.000664807,
            0.999352,
            0.000291739,
            0,
            0.00196192,
            0.999027,
            0.000357419,
            0,
            0.00405941,
            0.997886,
            0.000422349,
            0,
            0.00699664,
            0.99419,
            0.000385008,
            0,
            0.0107896,
            0.99214,
            0.000409775,
            0,
            0.0154415,
            0.990274,
            0.000456418,
            0,
            0.0209488,
            0.988455,
            0.000527008,
            0,
            0.0273037,
            0.985804,
            0.000597685,
            0,
            0.0344969,
            0.98103,
            0.000613124,
            0,
            0.0425183,
            0.976674,
            0.000668321,
            0,
            0.0513575,
            0.972021,
            0.000736985,
            0,
            0.0610046,
            0.965274,
            0.000773789,
            0,
            0.0714508,
            0.958046,
            0.000830852,
            0,
            0.0826877,
            0.949333,
            0.000875766,
            0,
            0.0947085,
            0.939135,
            0.000917088,
            0,
            0.107507,
            0.927119,
            0.000952244,
            0,
            0.121078,
            0.91469,
            0.000990626,
            0,
            0.135419,
            0.903006,
            0.00101304,
            0,
            0.150526,
            0.892368,
            0.00103834,
            0,
            0.166399,
            0.880231,
            0.00105002,
            0,
            0.183038,
            0.867432,
            0.00106331,
            0,
            0.200443,
            0.853208,
            0.00106783,
            0,
            0.218618,
            0.837956,
            0.00106458,
            0,
            0.237566,
            0.821772,
            0.00105945,
            0,
            0.257291,
            0.804328,
            0.00104685,
            0,
            0.2778,
            0.786465,
            0.00103178,
            0,
            0.2991,
            0.768004,
            0.00101077,
            0,
            0.321199,
            0.74972,
            0.000985504,
            0,
            0.344106,
            0.731682,
            0.000962893,
            0,
            0.36783,
            0.712813,
            0.000932146,
            0,
            0.392383,
            0.693139,
            0.00089871,
            0,
            0.417774,
            0.673566,
            0.000869678,
            0,
            0.444013,
            0.653483,
            0.000835525,
            0,
            0.471107,
            0.633891,
            0.000799853,
            0,
            0.49906,
            0.614433,
            0.000766838,
            0,
            0.527869,
            0.594586,
            0.000732227,
            0,
            0.557517,
            0.574769,
            0.000696442,
            0,
            0.587966,
            0.555149,
            0.000663935,
            0,
            0.61913,
            0.535898,
            0.000629826,
            0,
            0.650794,
            0.516753,
            0.000596486,
            0,
            0.68254,
            0.497816,
            0.000567078,
            0,
            0.714286,
            0.479034,
            0.000534399,
            0,
            0.746032,
            0.460975,
            0.000507013,
            0,
            0.777778,
            0.442935,
            0.000477421,
            0,
            0.809524,
            0.425263,
            0.000451101,
            0,
            0.84127,
            0.408248,
            0.000424964,
            0,
            0.873016,
            0.391339,
            0.00039993,
            0,
            0.904762,
            0.37513,
            0.000377619,
            0,
            0.936508,
            0.359172,
            0.000354418,
            0,
            0.968254,
            0.343876,
            0.000334823,
            0,
            1,
            1,
            0.000209042,
            0,
            0,
            1,
            0.000209045,
            0,
            0,
            1,
            0.000209093,
            0,
            0,
            0.999999,
            0.000209304,
            0,
            0,
            0.999996,
            0.000209871,
            0,
            0,
            0.999991,
            0.000211078,
            0,
            0,
            0.999979,
            0.000213304,
            0,
            0,
            0.999963,
            0.000217061,
            0,
            0,
            0.999933,
            0.000223042,
            0,
            0,
            0.999894,
            0.000232206,
            0,
            0,
            0.999837,
            0.000245901,
            0,
            0,
            0.999756,
            0.000266023,
            0,
            0.00000102927,
            0.999648,
            0.000295204,
            0,
            0.000233468,
            0.999499,
            0.000336958,
            0,
            0.00108237,
            0.999283,
            0.000395563,
            0,
            0.00268832,
            0.998896,
            0.000473785,
            0,
            0.00511138,
            0.997006,
            0.000520008,
            0,
            0.00837705,
            0.993819,
            0.000497261,
            0,
            0.0124928,
            0.991632,
            0.000523722,
            0,
            0.0174561,
            0.989875,
            0.000587258,
            0,
            0.0232596,
            0.988109,
            0.000676329,
            0,
            0.0298932,
            0.985155,
            0.000747701,
            0,
            0.0373453,
            0.980479,
            0.000768803,
            0,
            0.0456045,
            0.976271,
            0.000841054,
            0,
            0.0546593,
            0.971347,
            0.000911469,
            0,
            0.0644994,
            0.964528,
            0.000953057,
            0,
            0.0751152,
            0.957632,
            0.00102221,
            0,
            0.0864981,
            0.948681,
            0.00106122,
            0,
            0.0986407,
            0.938716,
            0.00111857,
            0,
            0.111537,
            0.926629,
            0.00114762,
            0,
            0.125182,
            0.914025,
            0.00118995,
            0,
            0.139571,
            0.901026,
            0.00121228,
            0,
            0.154703,
            0.890358,
            0.00123946,
            0,
            0.170576,
            0.878283,
            0.0012527,
            0,
            0.18719,
            0.865459,
            0.00125536,
            0,
            0.204547,
            0.851407,
            0.00126134,
            0,
            0.222648,
            0.836276,
            0.00124759,
            0,
            0.241498,
            0.820436,
            0.00124443,
            0,
            0.261101,
            0.803253,
            0.00122071,
            0,
            0.281465,
            0.785562,
            0.00120107,
            0,
            0.302595,
            0.76718,
            0.00117762,
            0,
            0.324501,
            0.748551,
            0.00114289,
            0,
            0.347192,
            0.730564,
            0.00110872,
            0,
            0.370679,
            0.712253,
            0.00107636,
            0,
            0.394973,
            0.692867,
            0.00103646,
            0,
            0.420085,
            0.673695,
            0.000996793,
            0,
            0.446027,
            0.653912,
            0.00095675,
            0,
            0.47281,
            0.634129,
            0.000916739,
            0,
            0.500441,
            0.615004,
            0.000874401,
            0,
            0.528921,
            0.595587,
            0.000833411,
            0,
            0.558244,
            0.575965,
            0.000794556,
            0,
            0.588384,
            0.5566,
            0.00075196,
            0,
            0.619281,
            0.537428,
            0.000716381,
            0,
            0.650795,
            0.518623,
            0.000676558,
            0,
            0.68254,
            0.499964,
            0.00064074,
            0,
            0.714286,
            0.481356,
            0.000605984,
            0,
            0.746032,
            0.463279,
            0.000570256,
            0,
            0.777778,
            0.445673,
            0.000540138,
            0,
            0.809524,
            0.428032,
            0.000507299,
            0,
            0.84127,
            0.411112,
            0.000479553,
            0,
            0.873016,
            0.394444,
            0.000450737,
            0,
            0.904762,
            0.378247,
            0.000424269,
            0,
            0.936508,
            0.362415,
            0.000399111,
            0,
            0.968254,
            0.347103,
            0.000375274,
            0,
            1,
            1,
            0.000300729,
            0,
            0,
            1,
            0.000300733,
            0,
            0,
            1,
            0.000300797,
            0,
            0,
            0.999998,
            0.000301072,
            0,
            0,
            0.999996,
            0.000301817,
            0,
            0,
            0.999989,
            0.000303398,
            0,
            0,
            0.999977,
            0.000306309,
            0,
            0,
            0.999958,
            0.000311209,
            0,
            0,
            0.999927,
            0.000318975,
            0,
            0,
            0.999884,
            0.000330804,
            0,
            0,
            0.99982,
            0.00034834,
            0,
            0,
            0.999733,
            0.000373854,
            0,
            0.0000326995,
            0.999613,
            0.000410424,
            0,
            0.000477174,
            0.999447,
            0.000462047,
            0,
            0.00161099,
            0.999204,
            0.000533322,
            0,
            0.00353153,
            0.998725,
            0.000624964,
            0,
            0.00627965,
            0.995871,
            0.000631786,
            0,
            0.0098693,
            0.993194,
            0.000632017,
            0,
            0.0143011,
            0.991541,
            0.00068923,
            0,
            0.019568,
            0.989773,
            0.000766892,
            0,
            0.0256593,
            0.987647,
            0.000863668,
            0,
            0.0325625,
            0.984193,
            0.000922089,
            0,
            0.0402647,
            0.980016,
            0.000970749,
            0,
            0.0487532,
            0.975859,
            0.00106027,
            0,
            0.058016,
            0.970514,
            0.00112239,
            0,
            0.0680419,
            0.963625,
            0.00117212,
            0,
            0.0788208,
            0.956959,
            0.00125211,
            0,
            0.0903439,
            0.947956,
            0.00129411,
            0,
            0.102604,
            0.93809,
            0.00135879,
            0,
            0.115594,
            0.92659,
            0.00139309,
            0,
            0.129309,
            0.913829,
            0.00143253,
            0,
            0.143745,
            0.90005,
            0.00145809,
            0,
            0.158901,
            0.888129,
            0.0014748,
            0,
            0.174774,
            0.87607,
            0.00148756,
            0,
            0.191365,
            0.863461,
            0.00148714,
            0,
            0.208674,
            0.849594,
            0.00148892,
            0,
            0.226705,
            0.834531,
            0.00146496,
            0,
            0.245461,
            0.81903,
            0.0014579,
            0,
            0.264947,
            0.802122,
            0.00143039,
            0,
            0.28517,
            0.78445,
            0.00139717,
            0,
            0.306137,
            0.766434,
            0.00136312,
            0,
            0.327857,
            0.747816,
            0.00132597,
            0,
            0.350341,
            0.729519,
            0.00128323,
            0,
            0.373598,
            0.711454,
            0.00123803,
            0,
            0.397642,
            0.692699,
            0.00119097,
            0,
            0.422485,
            0.673723,
            0.00114565,
            0,
            0.448139,
            0.654386,
            0.00109552,
            0,
            0.474619,
            0.634673,
            0.00104553,
            0,
            0.501933,
            0.615554,
            0.00099985,
            0,
            0.530089,
            0.596462,
            0.000948207,
            0,
            0.559087,
            0.577385,
            0.000902299,
            0,
            0.588913,
            0.558257,
            0.000856448,
            0,
            0.619525,
            0.5392,
            0.000810395,
            0,
            0.650826,
            0.520543,
            0.000768558,
            0,
            0.68254,
            0.502206,
            0.0007239,
            0,
            0.714286,
            0.48402,
            0.000685794,
            0,
            0.746032,
            0.465779,
            0.00064471,
            0,
            0.777778,
            0.448455,
            0.000609583,
            0,
            0.809524,
            0.431091,
            0.00057227,
            0,
            0.84127,
            0.414147,
            0.00054042,
            0,
            0.873016,
            0.39765,
            0.000506545,
            0,
            0.904762,
            0.381576,
            0.000477635,
            0,
            0.936508,
            0.365881,
            0.000448446,
            0,
            0.968254,
            0.350582,
            0.000421424,
            0,
            1,
            1,
            0.000427144,
            0,
            0,
            1,
            0.000427151,
            0,
            0,
            1,
            0.000427232,
            0,
            0,
            0.999998,
            0.00042759,
            0,
            0,
            0.999995,
            0.000428555,
            0,
            0,
            0.999988,
            0.000430603,
            0,
            0,
            0.999976,
            0.000434368,
            0,
            0,
            0.999952,
            0.000440688,
            0,
            0,
            0.999919,
            0.000450667,
            0,
            0,
            0.999871,
            0.00046578,
            0,
            0,
            0.999801,
            0.000488024,
            0,
            0,
            0.999704,
            0.000520092,
            0,
            0.000129791,
            0.999572,
            0.000565553,
            0,
            0.000821056,
            0.999389,
            0.000628906,
            0,
            0.00225241,
            0.999114,
            0.000714911,
            0,
            0.00449109,
            0.998488,
            0.000819218,
            0,
            0.00756249,
            0.995234,
            0.00080415,
            0,
            0.0114716,
            0.993021,
            0.000830181,
            0,
            0.0162131,
            0.991407,
            0.000902645,
            0,
            0.021776,
            0.989625,
            0.000996934,
            0,
            0.0281471,
            0.987064,
            0.00109707,
            0,
            0.0353118,
            0.983265,
            0.00114353,
            0,
            0.0432562,
            0.979535,
            0.0012272,
            0,
            0.0519665,
            0.975224,
            0.00132642,
            0,
            0.0614298,
            0.969574,
            0.00138092,
            0,
            0.0716348,
            0.963021,
            0.00145896,
            0,
            0.0825709,
            0.956046,
            0.00152834,
            0,
            0.094229,
            0.947136,
            0.00158217,
            0,
            0.106602,
            0.937313,
            0.0016347,
            0,
            0.119682,
            0.926073,
            0.00168383,
            0,
            0.133465,
            0.913121,
            0.00171627,
            0,
            0.147947,
            0.899165,
            0.00174229,
            0,
            0.163125,
            0.885891,
            0.00176137,
            0,
            0.178998,
            0.873783,
            0.00176406,
            0,
            0.195566,
            0.861331,
            0.00176156,
            0,
            0.21283,
            0.847569,
            0.00175346,
            0,
            0.230793,
            0.832785,
            0.00172753,
            0,
            0.249459,
            0.817442,
            0.00170204,
            0,
            0.268832,
            0.800613,
            0.00166576,
            0,
            0.28892,
            0.783597,
            0.00162909,
            0,
            0.30973,
            0.76571,
            0.0015826,
            0,
            0.331271,
            0.747021,
            0.00153106,
            0,
            0.353554,
            0.728593,
            0.00148036,
            0,
            0.37659,
            0.710661,
            0.00142808,
            0,
            0.400391,
            0.692426,
            0.00136906,
            0,
            0.424973,
            0.673623,
            0.00131066,
            0,
            0.450347,
            0.65494,
            0.00125569,
            0,
            0.476531,
            0.635448,
            0.00119517,
            0,
            0.503535,
            0.616221,
            0.00113828,
            0,
            0.531372,
            0.597531,
            0.0010816,
            0,
            0.560047,
            0.578795,
            0.00102673,
            0,
            0.589554,
            0.559892,
            0.000970985,
            0,
            0.619869,
            0.541307,
            0.000919773,
            0,
            0.650923,
            0.522608,
            0.000868479,
            0,
            0.68254,
            0.504484,
            0.00082137,
            0,
            0.714286,
            0.486603,
            0.000772916,
            0,
            0.746032,
            0.468802,
            0.000730353,
            0,
            0.777778,
            0.451172,
            0.000684955,
            0,
            0.809524,
            0.434348,
            0.000647565,
            0,
            0.84127,
            0.417445,
            0.000605863,
            0,
            0.873016,
            0.401077,
            0.000571885,
            0,
            0.904762,
            0.385039,
            0.000536034,
            0,
            0.936508,
            0.369483,
            0.000504227,
            0,
            0.968254,
            0.354272,
            0.000473165,
            0,
            1,
            1,
            0.000599525,
            0,
            0,
            1,
            0.000599533,
            0,
            0,
            1,
            0.000599639,
            0,
            0,
            0.999998,
            0.000600097,
            0,
            0,
            0.999994,
            0.000601336,
            0,
            0,
            0.999987,
            0.000603958,
            0,
            0,
            0.999972,
            0.000608775,
            0,
            0,
            0.999949,
            0.000616842,
            0,
            0,
            0.999912,
            0.000629534,
            0,
            0,
            0.999857,
            0.000648658,
            0,
            0,
            0.999781,
            0.000676615,
            0,
            0.00000538873,
            0.999674,
            0.000716574,
            0,
            0.000308602,
            0.999528,
            0.000772641,
            0,
            0.00127003,
            0.999326,
            0.000849806,
            0,
            0.00300783,
            0.999009,
            0.000952682,
            0,
            0.00556637,
            0.998112,
            0.00106394,
            0,
            0.00895889,
            0.994496,
            0.00102228,
            0,
            0.0131827,
            0.992806,
            0.00108586,
            0,
            0.0182277,
            0.991211,
            0.0011759,
            0,
            0.0240795,
            0.989415,
            0.00128955,
            0,
            0.030723,
            0.986499,
            0.00139038,
            0,
            0.0381418,
            0.982679,
            0.00144539,
            0,
            0.046321,
            0.978839,
            0.00153954,
            0,
            0.0552459,
            0.974295,
            0.00164417,
            0,
            0.0649034,
            0.968784,
            0.00171517,
            0,
            0.0752814,
            0.962324,
            0.00180282,
            0,
            0.0863693,
            0.954956,
            0.00186387,
            0,
            0.0981578,
            0.94624,
            0.00193817,
            0,
            0.110639,
            0.936517,
            0.00198156,
            0,
            0.123806,
            0.925186,
            0.00203042,
            0,
            0.137655,
            0.91252,
            0.0020664,
            0,
            0.15218,
            0.898441,
            0.00207822,
            0,
            0.16738,
            0.884394,
            0.0020992,
            0,
            0.183253,
            0.871273,
            0.00208748,
            0,
            0.199799,
            0.859057,
            0.00208686,
            0,
            0.21702,
            0.845243,
            0.00205519,
            0,
            0.234918,
            0.830723,
            0.00202868,
            0,
            0.253496,
            0.815801,
            0.00199501,
            0,
            0.272761,
            0.79914,
            0.00194193,
            0,
            0.292719,
            0.782372,
            0.00188824,
            0,
            0.313377,
            0.76482,
            0.00183695,
            0,
            0.334745,
            0.746586,
            0.00177418,
            0,
            0.356833,
            0.7281,
            0.00170628,
            0,
            0.379654,
            0.709842,
            0.00164063,
            0,
            0.403221,
            0.692019,
            0.00157355,
            0,
            0.427548,
            0.67364,
            0.00150262,
            0,
            0.452651,
            0.655277,
            0.00143473,
            0,
            0.478545,
            0.636438,
            0.00136371,
            0,
            0.505246,
            0.617364,
            0.00129911,
            0,
            0.532768,
            0.598603,
            0.00123014,
            0,
            0.561122,
            0.580195,
            0.00116587,
            0,
            0.590309,
            0.561786,
            0.00110398,
            0,
            0.620318,
            0.543377,
            0.00104148,
            0,
            0.651102,
            0.525093,
            0.000983984,
            0,
            0.682545,
            0.506791,
            0.00092667,
            0,
            0.714286,
            0.489291,
            0.000874326,
            0,
            0.746032,
            0.471811,
            0.000821734,
            0,
            0.777778,
            0.454435,
            0.000774698,
            0,
            0.809524,
            0.437493,
            0.000727302,
            0,
            0.84127,
            0.420977,
            0.000684039,
            0,
            0.873016,
            0.404729,
            0.00064373,
            0,
            0.904762,
            0.388756,
            0.00060285,
            0,
            0.936508,
            0.373344,
            0.00056765,
            0,
            0.968254,
            0.358191,
            0.000531929,
            0,
            1,
            1,
            0.000832169,
            0,
            0,
            1,
            0.000832178,
            0,
            0,
            1,
            0.00083231,
            0,
            0,
            0.999998,
            0.000832893,
            0,
            0,
            0.999995,
            0.000834465,
            0,
            0,
            0.999985,
            0.000837791,
            0,
            0,
            0.999969,
            0.000843893,
            0,
            0,
            0.999944,
            0.000854086,
            0,
            0,
            0.999903,
            0.000870071,
            0,
            0,
            0.999843,
            0.000894042,
            0,
            0,
            0.999759,
            0.000928865,
            0,
            0.0000531805,
            0.999643,
            0.000978242,
            0,
            0.000579365,
            0.99948,
            0.00104684,
            0,
            0.00182774,
            0.999255,
            0.00114012,
            0,
            0.00387804,
            0.998885,
            0.00126188,
            0,
            0.00675709,
            0.997405,
            0.00135888,
            0,
            0.010468,
            0.99424,
            0.00133626,
            0,
            0.0150018,
            0.992458,
            0.00140905,
            0,
            0.0203443,
            0.990929,
            0.00152305,
            0,
            0.0264786,
            0.989116,
            0.00165882,
            0,
            0.0333875,
            0.985624,
            0.00174128,
            0,
            0.0410536,
            0.982003,
            0.00182108,
            0,
            0.0494609,
            0.978336,
            0.00194498,
            0,
            0.0585941,
            0.973184,
            0.00202708,
            0,
            0.0684396,
            0.9678,
            0.00212166,
            0,
            0.0789851,
            0.961348,
            0.00221366,
            0,
            0.0902199,
            0.953841,
            0.00228219,
            0,
            0.102134,
            0.94534,
            0.00235662,
            0,
            0.114721,
            0.935552,
            0.00240572,
            0,
            0.127972,
            0.924064,
            0.00244405,
            0,
            0.141884,
            0.911827,
            0.00247557,
            0,
            0.156451,
            0.897731,
            0.00248374,
            0,
            0.171672,
            0.883409,
            0.00249863,
            0,
            0.187545,
            0.868625,
            0.00246688,
            0,
            0.20407,
            0.856529,
            0.00246523,
            0,
            0.221249,
            0.842999,
            0.00242368,
            0,
            0.239083,
            0.828505,
            0.00237354,
            0,
            0.257578,
            0.813825,
            0.00232588,
            0,
            0.276738,
            0.797813,
            0.00226731,
            0,
            0.296569,
            0.781097,
            0.00219704,
            0,
            0.31708,
            0.764038,
            0.00212394,
            0,
            0.338281,
            0.746067,
            0.00204786,
            0,
            0.360181,
            0.727687,
            0.00196728,
            0,
            0.382794,
            0.709571,
            0.00188779,
            0,
            0.406133,
            0.691503,
            0.00180532,
            0,
            0.430213,
            0.673673,
            0.00171849,
            0,
            0.45505,
            0.655732,
            0.00164147,
            0,
            0.480662,
            0.637399,
            0.00155858,
            0,
            0.507065,
            0.618616,
            0.00147641,
            0,
            0.534278,
            0.60005,
            0.00140125,
            0,
            0.562313,
            0.581713,
            0.00132441,
            0,
            0.59118,
            0.563546,
            0.00125014,
            0,
            0.620875,
            0.545605,
            0.00118249,
            0,
            0.651373,
            0.527559,
            0.0011116,
            0,
            0.682593,
            0.509764,
            0.00104979,
            0,
            0.714286,
            0.49193,
            0.000985977,
            0,
            0.746032,
            0.475011,
            0.000928592,
            0,
            0.777778,
            0.457878,
            0.000873466,
            0,
            0.809524,
            0.440979,
            0.000819585,
            0,
            0.84127,
            0.424613,
            0.000772365,
            0,
            0.873016,
            0.408549,
            0.000722195,
            0,
            0.904762,
            0.392771,
            0.000680014,
            0,
            0.936508,
            0.377317,
            0.000636797,
            0,
            0.968254,
            0.362352,
            0.000598318,
            0,
            1,
            1,
            0.00114313,
            0,
            0,
            1,
            0.00114314,
            0,
            0,
            0.999999,
            0.00114331,
            0,
            0,
            0.999998,
            0.00114404,
            0,
            0,
            0.999994,
            0.00114601,
            0,
            0,
            0.999984,
            0.00115019,
            0,
            0,
            0.999967,
            0.00115784,
            0,
            0,
            0.999937,
            0.0011706,
            0,
            0,
            0.999894,
            0.00119054,
            0,
            0,
            0.999828,
            0.00122031,
            0,
            0,
            0.999735,
            0.00126331,
            0,
            0.000169263,
            0.999606,
            0.00132382,
            0,
            0.000949167,
            0.999426,
            0.0014071,
            0,
            0.00249668,
            0.999173,
            0.00151895,
            0,
            0.00486392,
            0.99873,
            0.00166102,
            0,
            0.00806323,
            0.996243,
            0.0017023,
            0,
            0.0120895,
            0.993779,
            0.00172782,
            0,
            0.0169288,
            0.9919,
            0.0018108,
            0,
            0.0225633,
            0.990524,
            0.00196028,
            0,
            0.028974,
            0.98868,
            0.00212014,
            0,
            0.036142,
            0.984663,
            0.00217598,
            0,
            0.044049,
            0.981457,
            0.00230563,
            0,
            0.0526781,
            0.977608,
            0.00243966,
            0,
            0.0620137,
            0.972215,
            0.00251336,
            0,
            0.0720418,
            0.966798,
            0.0026285,
            0,
            0.0827499,
            0.960241,
            0.00271409,
            0,
            0.0941271,
            0.952489,
            0.00278381,
            0,
            0.106164,
            0.944127,
            0.00285399,
            0,
            0.118852,
            0.934282,
            0.00290994,
            0,
            0.132185,
            0.923271,
            0.00294558,
            0,
            0.146157,
            0.910803,
            0.00296269,
            0,
            0.160766,
            0.896705,
            0.00296803,
            0,
            0.176007,
            0.88238,
            0.00296637,
            0,
            0.19188,
            0.867116,
            0.00293163,
            0,
            0.208385,
            0.853636,
            0.00289418,
            0,
            0.225523,
            0.840469,
            0.00284663,
            0,
            0.243296,
            0.82639,
            0.00278594,
            0,
            0.261709,
            0.811759,
            0.00271618,
            0,
            0.280767,
            0.796113,
            0.00263187,
            0,
            0.300476,
            0.779518,
            0.00254589,
            0,
            0.320845,
            0.763142,
            0.00246003,
            0,
            0.341883,
            0.745464,
            0.00236529,
            0,
            0.363601,
            0.727491,
            0.00226536,
            0,
            0.386011,
            0.709414,
            0.00216375,
            0,
            0.409128,
            0.691396,
            0.00207127,
            0,
            0.432967,
            0.67368,
            0.00197106,
            0,
            0.457545,
            0.656049,
            0.00187022,
            0,
            0.482881,
            0.638188,
            0.00177605,
            0,
            0.508992,
            0.620177,
            0.00168482,
            0,
            0.535899,
            0.601506,
            0.00158909,
            0,
            0.563619,
            0.58362,
            0.00150583,
            0,
            0.592165,
            0.565496,
            0.00141791,
            0,
            0.621544,
            0.54789,
            0.00133693,
            0,
            0.651743,
            0.530323,
            0.00126038,
            0,
            0.682709,
            0.512795,
            0.00118556,
            0,
            0.714286,
            0.495199,
            0.00111527,
            0,
            0.746032,
            0.478101,
            0.0010489,
            0,
            0.777778,
            0.461511,
            0.000984264,
            0,
            0.809524,
            0.444879,
            0.00092591,
            0,
            0.84127,
            0.428424,
            0.000866582,
            0,
            0.873016,
            0.412495,
            0.000814463,
            0,
            0.904762,
            0.396975,
            0.000764498,
            0,
            0.936508,
            0.381614,
            0.000715967,
            0,
            0.968254,
            0.366732,
            0.000672483,
            0,
            1,
            1,
            0.00155501,
            0,
            0,
            1,
            0.00155503,
            0,
            0,
            1,
            0.00155524,
            0,
            0,
            0.999998,
            0.00155615,
            0,
            0,
            0.999994,
            0.0015586,
            0,
            0,
            0.999983,
            0.00156379,
            0,
            0,
            0.999963,
            0.0015733,
            0,
            0,
            0.999932,
            0.00158911,
            0,
            0,
            0.999882,
            0.00161376,
            0,
            0,
            0.99981,
            0.00165041,
            0,
            0.0000100875,
            0.999708,
            0.00170304,
            0,
            0.000367658,
            0.999565,
            0.00177658,
            0,
            0.0014234,
            0.999368,
            0.00187688,
            0,
            0.00327939,
            0.999081,
            0.00200989,
            0,
            0.00596629,
            0.99852,
            0.00217177,
            0,
            0.0094852,
            0.99549,
            0.0021745,
            0,
            0.013824,
            0.993252,
            0.00222357,
            0,
            0.0189642,
            0.991727,
            0.00235022,
            0,
            0.0248856,
            0.989951,
            0.00250561,
            0,
            0.0315669,
            0.988029,
            0.00268829,
            0,
            0.0389882,
            0.984029,
            0.0027496,
            0,
            0.0471302,
            0.980683,
            0.00289793,
            0,
            0.0559754,
            0.976554,
            0.00303315,
            0,
            0.0655081,
            0.97139,
            0.00313257,
            0,
            0.0757138,
            0.965544,
            0.00323656,
            0,
            0.08658,
            0.95912,
            0.00333432,
            0,
            0.0980954,
            0.951183,
            0.0034039,
            0,
            0.110251,
            0.942974,
            0.00347515,
            0,
            0.123038,
            0.932642,
            0.00350381,
            0,
            0.13645,
            0.922158,
            0.00354519,
            0,
            0.150482,
            0.909404,
            0.00353851,
            0,
            0.165129,
            0.896071,
            0.0035435,
            0,
            0.18039,
            0.881206,
            0.00349936,
            0,
            0.196263,
            0.866077,
            0.00347256,
            0,
            0.212748,
            0.85093,
            0.003415,
            0,
            0.229847,
            0.837703,
            0.00333367,
            0,
            0.247561,
            0.823878,
            0.003249,
            0,
            0.265895,
            0.809449,
            0.00316347,
            0,
            0.284854,
            0.794379,
            0.00306351,
            0,
            0.304445,
            0.778138,
            0.0029499,
            0,
            0.324675,
            0.761997,
            0.00284099,
            0,
            0.345555,
            0.744938,
            0.00272104,
            0,
            0.367095,
            0.727212,
            0.00260715,
            0,
            0.389309,
            0.709549,
            0.00248855,
            0,
            0.41221,
            0.691704,
            0.00236783,
            0,
            0.435814,
            0.673689,
            0.00225178,
            0,
            0.460138,
            0.656453,
            0.00213765,
            0,
            0.485203,
            0.639128,
            0.00202178,
            0,
            0.511028,
            0.621512,
            0.00191443,
            0,
            0.537634,
            0.603598,
            0.00180977,
            0,
            0.565041,
            0.58559,
            0.00170456,
            0,
            0.593268,
            0.567852,
            0.00160927,
            0,
            0.622327,
            0.5503,
            0.00151395,
            0,
            0.652217,
            0.533033,
            0.00142499,
            0,
            0.682907,
            0.515942,
            0.00133955,
            0,
            0.714296,
            0.498814,
            0.0012602,
            0,
            0.746032,
            0.481595,
            0.00118188,
            0,
            0.777778,
            0.465117,
            0.00111171,
            0,
            0.809524,
            0.448865,
            0.00104091,
            0,
            0.84127,
            0.432711,
            0.000976618,
            0,
            0.873016,
            0.416822,
            0.00091859,
            0,
            0.904762,
            0.401272,
            0.000857704,
            0,
            0.936508,
            0.386226,
            0.000807172,
            0,
            0.968254,
            0.371321,
            0.00075464,
            0,
            1,
            1,
            0.00209596,
            0,
            0,
            1,
            0.00209598,
            0,
            0,
            1,
            0.00209624,
            0,
            0,
            0.999997,
            0.00209736,
            0,
            0,
            0.999991,
            0.00210039,
            0,
            0,
            0.999979,
            0.00210678,
            0,
            0,
            0.999959,
            0.00211847,
            0,
            0,
            0.999925,
            0.0021379,
            0,
            0,
            0.99987,
            0.00216809,
            0,
            0,
            0.999791,
            0.00221281,
            0,
            0.0000681487,
            0.999677,
            0.00227669,
            0,
            0.000658161,
            0.999521,
            0.00236533,
            0,
            0.00200635,
            0.999301,
            0.00248514,
            0,
            0.0041779,
            0.998977,
            0.00264185,
            0,
            0.00718648,
            0.998191,
            0.00281695,
            0,
            0.0110239,
            0.994801,
            0.00278518,
            0,
            0.015672,
            0.993091,
            0.00288774,
            0,
            0.0211091,
            0.991571,
            0.00303931,
            0,
            0.0273123,
            0.9897,
            0.00321643,
            0,
            0.034259,
            0.987023,
            0.00337332,
            0,
            0.0419282,
            0.983289,
            0.00346146,
            0,
            0.0502998,
            0.979892,
            0.00363704,
            0,
            0.0593562,
            0.975111,
            0.00373601,
            0,
            0.069081,
            0.970351,
            0.0038842,
            0,
            0.0794598,
            0.964131,
            0.00397053,
            0,
            0.0904798,
            0.957747,
            0.00408078,
            0,
            0.10213,
            0.949536,
            0.00413533,
            0,
            0.1144,
            0.941372,
            0.00420305,
            0,
            0.127284,
            0.931049,
            0.00422815,
            0,
            0.140772,
            0.920647,
            0.00425048,
            0,
            0.154862,
            0.908033,
            0.0042281,
            0,
            0.169548,
            0.895028,
            0.00422026,
            0,
            0.184828,
            0.879968,
            0.00415042,
            0,
            0.200701,
            0.864875,
            0.00408821,
            0,
            0.217167,
            0.84918,
            0.00400909,
            0,
            0.234227,
            0.834934,
            0.00391178,
            0,
            0.251884,
            0.821397,
            0.00380066,
            0,
            0.270141,
            0.807135,
            0.00367974,
            0,
            0.289004,
            0.792363,
            0.00355172,
            0,
            0.308479,
            0.776661,
            0.003411,
            0,
            0.328575,
            0.760705,
            0.00328123,
            0,
            0.349301,
            0.744408,
            0.00314003,
            0,
            0.370668,
            0.726994,
            0.0029906,
            0,
            0.392689,
            0.709598,
            0.00285034,
            0,
            0.415379,
            0.692112,
            0.00271179,
            0,
            0.438754,
            0.674435,
            0.00257185,
            0,
            0.46283,
            0.65676,
            0.00243425,
            0,
            0.48763,
            0.639982,
            0.00230351,
            0,
            0.513173,
            0.622983,
            0.0021777,
            0,
            0.539482,
            0.605471,
            0.00204991,
            0,
            0.566579,
            0.58796,
            0.00193759,
            0,
            0.594488,
            0.570463,
            0.00181976,
            0,
            0.623226,
            0.553058,
            0.00171497,
            0,
            0.6528,
            0.535894,
            0.00161109,
            0,
            0.683198,
            0.519089,
            0.00151394,
            0,
            0.714354,
            0.502454,
            0.00142122,
            0,
            0.746032,
            0.485681,
            0.00133488,
            0,
            0.777778,
            0.468935,
            0.00124975,
            0,
            0.809524,
            0.452951,
            0.00117309,
            0,
            0.84127,
            0.437139,
            0.00110155,
            0,
            0.873016,
            0.421446,
            0.00103124,
            0,
            0.904762,
            0.405951,
            0.000966387,
            0,
            0.936508,
            0.391003,
            0.000908119,
            0,
            0.968254,
            0.376198,
            0.000848057,
            0,
            1,
            1,
            0.00280076,
            0,
            0,
            1,
            0.00280078,
            0,
            0,
            0.999999,
            0.00280109,
            0,
            0,
            0.999997,
            0.00280246,
            0,
            0,
            0.999992,
            0.00280616,
            0,
            0,
            0.999979,
            0.00281396,
            0,
            0,
            0.999956,
            0.00282822,
            0,
            0,
            0.999916,
            0.00285186,
            0,
            0,
            0.999857,
            0.0028885,
            0,
            0,
            0.999768,
            0.00294259,
            0,
            0.000196026,
            0.999645,
            0.00301946,
            0,
            0.00104842,
            0.99947,
            0.00312541,
            0,
            0.00270199,
            0.999229,
            0.00326733,
            0,
            0.00519449,
            0.998852,
            0.00344992,
            0,
            0.00852602,
            0.997558,
            0.00361052,
            0,
            0.0126804,
            0.994417,
            0.0035898,
            0,
            0.017635,
            0.992824,
            0.00372393,
            0,
            0.023365,
            0.991344,
            0.00390695,
            0,
            0.0298456,
            0.989337,
            0.00410392,
            0,
            0.0370529,
            0.985811,
            0.00420987,
            0,
            0.0449651,
            0.982772,
            0.00437488,
            0,
            0.0535615,
            0.979001,
            0.00455069,
            0,
            0.0628243,
            0.974102,
            0.00464462,
            0,
            0.0727368,
            0.969197,
            0.00480577,
            0,
            0.0832844,
            0.962759,
            0.00487818,
            0,
            0.0944545,
            0.956207,
            0.00498176,
            0,
            0.106236,
            0.947909,
            0.00503392,
            0,
            0.118619,
            0.939596,
            0.00507474,
            0,
            0.131595,
            0.929642,
            0.00509798,
            0,
            0.145159,
            0.918807,
            0.00508476,
            0,
            0.159305,
            0.906921,
            0.00505634,
            0,
            0.174028,
            0.893312,
            0.00498845,
            0,
            0.189327,
            0.878933,
            0.0049133,
            0,
            0.2052,
            0.863986,
            0.0048259,
            0,
            0.221647,
            0.847936,
            0.00470848,
            0,
            0.23867,
            0.832253,
            0.00456889,
            0,
            0.25627,
            0.818619,
            0.00442726,
            0,
            0.274453,
            0.804788,
            0.00427677,
            0,
            0.293222,
            0.790241,
            0.00411906,
            0,
            0.312585,
            0.775162,
            0.00394833,
            0,
            0.33255,
            0.759463,
            0.00377366,
            0,
            0.353126,
            0.743598,
            0.00361026,
            0,
            0.374324,
            0.72697,
            0.00343627,
            0,
            0.396158,
            0.709646,
            0.00326422,
            0,
            0.418641,
            0.69277,
            0.00309717,
            0,
            0.44179,
            0.675371,
            0.0029356,
            0,
            0.465624,
            0.657863,
            0.00277712,
            0,
            0.490163,
            0.640772,
            0.00261738,
            0,
            0.515429,
            0.624441,
            0.0024737,
            0,
            0.541445,
            0.607497,
            0.00233125,
            0,
            0.568236,
            0.590438,
            0.00218994,
            0,
            0.595828,
            0.573224,
            0.0020664,
            0,
            0.624242,
            0.556168,
            0.00193526,
            0,
            0.653496,
            0.539232,
            0.00182463,
            0,
            0.683588,
            0.522352,
            0.00170735,
            0,
            0.714482,
            0.506172,
            0.00160555,
            0,
            0.746032,
            0.489842,
            0.00150451,
            0,
            0.777778,
            0.473463,
            0.00140938,
            0,
            0.809524,
            0.457266,
            0.00132568,
            0,
            0.84127,
            0.441609,
            0.0012376,
            0,
            0.873016,
            0.426348,
            0.00116265,
            0,
            0.904762,
            0.411002,
            0.00108935,
            0,
            0.936508,
            0.396045,
            0.00101946,
            0,
            0.968254,
            0.381448,
            0.000955665,
            0,
            1,
            1,
            0.0037121,
            0,
            0,
            1,
            0.00371213,
            0,
            0,
            1,
            0.00371251,
            0,
            0,
            0.999997,
            0.00371417,
            0,
            0,
            0.99999,
            0.00371863,
            0,
            0,
            0.999977,
            0.00372807,
            0,
            0,
            0.99995,
            0.00374529,
            0,
            0,
            0.999908,
            0.0037738,
            0,
            0,
            0.999843,
            0.00381789,
            0,
            0.0000123596,
            0.999745,
            0.00388273,
            0,
            0.000407442,
            0.999608,
            0.00397443,
            0,
            0.0015447,
            0.999415,
            0.00409998,
            0,
            0.00351385,
            0.999143,
            0.00426662,
            0,
            0.0063316,
            0.9987,
            0.00447625,
            0,
            0.00998679,
            0.996363,
            0.00455323,
            0,
            0.0144569,
            0.994021,
            0.00461052,
            0,
            0.0197151,
            0.992372,
            0.00476359,
            0,
            0.0257344,
            0.991007,
            0.00499101,
            0,
            0.0324882,
            0.988767,
            0.0051972,
            0,
            0.0399517,
            0.984872,
            0.00528407,
            0,
            0.0481022,
            0.982004,
            0.00548926,
            0,
            0.0569191,
            0.977714,
            0.00564385,
            0,
            0.0663839,
            0.973076,
            0.0057693,
            0,
            0.0764801,
            0.967565,
            0.0058924,
            0,
            0.0871928,
            0.961384,
            0.00599629,
            0,
            0.0985095,
            0.954435,
            0.00605998,
            0,
            0.110419,
            0.946303,
            0.0061133,
            0,
            0.122912,
            0.937662,
            0.00612028,
            0,
            0.13598,
            0.927867,
            0.00612209,
            0,
            0.149617,
            0.916475,
            0.00604813,
            0,
            0.163817,
            0.90541,
            0.00603088,
            0,
            0.178577,
            0.891591,
            0.00592218,
            0,
            0.193894,
            0.877573,
            0.00578854,
            0,
            0.209767,
            0.862511,
            0.00566648,
            0,
            0.226196,
            0.846861,
            0.00551481,
            0,
            0.243182,
            0.83068,
            0.00533754,
            0,
            0.260728,
            0.815725,
            0.00515487,
            0,
            0.278837,
            0.802321,
            0.0049655,
            0,
            0.297515,
            0.787826,
            0.00475421,
            0,
            0.316768,
            0.773454,
            0.00456002,
            0,
            0.336605,
            0.758224,
            0.00434727,
            0,
            0.357034,
            0.74265,
            0.00414444,
            0,
            0.378067,
            0.726729,
            0.00393738,
            0,
            0.399717,
            0.710155,
            0.00373575,
            0,
            0.421998,
            0.693312,
            0.00353736,
            0,
            0.444928,
            0.67653,
            0.00334368,
            0,
            0.468523,
            0.659444,
            0.00315981,
            0,
            0.492806,
            0.642051,
            0.00297809,
            0,
            0.517798,
            0.625758,
            0.00280592,
            0,
            0.543525,
            0.609615,
            0.00264254,
            0,
            0.570012,
            0.592919,
            0.00248459,
            0,
            0.597288,
            0.576298,
            0.00233327,
            0,
            0.625379,
            0.559489,
            0.00219519,
            0,
            0.654307,
            0.542891,
            0.00205441,
            0,
            0.684084,
            0.526255,
            0.00193385,
            0,
            0.714693,
            0.509853,
            0.00180745,
            0,
            0.746044,
            0.494131,
            0.00169817,
            0,
            0.777778,
            0.478114,
            0.0015913,
            0,
            0.809524,
            0.462274,
            0.00148981,
            0,
            0.84127,
            0.446412,
            0.00139537,
            0,
            0.873016,
            0.431274,
            0.00130984,
            0,
            0.904762,
            0.41635,
            0.00122403,
            0,
            0.936508,
            0.401476,
            0.00114809,
            0,
            0.968254,
            0.386993,
            0.00107563,
            0,
            1,
            1,
            0.00488216,
            0,
            0,
            1,
            0.0048822,
            0,
            0,
            1,
            0.00488265,
            0,
            0,
            0.999997,
            0.00488463,
            0,
            0,
            0.999988,
            0.00488999,
            0,
            0,
            0.999974,
            0.00490129,
            0,
            0,
            0.999946,
            0.00492191,
            0,
            0,
            0.999897,
            0.00495598,
            0,
            0,
            0.999825,
            0.00500855,
            0,
            0.0000744791,
            0.999718,
            0.00508559,
            0,
            0.000712744,
            0.999565,
            0.005194,
            0,
            0.00215249,
            0.999352,
            0.00534147,
            0,
            0.00444576,
            0.999046,
            0.00553523,
            0,
            0.00759218,
            0.998492,
            0.00577016,
            0,
            0.0115714,
            0.995564,
            0.00578487,
            0,
            0.0163557,
            0.993339,
            0.00586414,
            0,
            0.021915,
            0.991834,
            0.00606002,
            0,
            0.0282201,
            0.990496,
            0.00633312,
            0,
            0.0352433,
            0.987826,
            0.00651941,
            0,
            0.042959,
            0.98383,
            0.00660842,
            0,
            0.0513439,
            0.98109,
            0.00685523,
            0,
            0.0603772,
            0.976131,
            0.00695778,
            0,
            0.0700402,
            0.971922,
            0.00714236,
            0,
            0.0803163,
            0.965901,
            0.00721437,
            0,
            0.0911908,
            0.959606,
            0.00732017,
            0,
            0.102651,
            0.952504,
            0.00735788,
            0,
            0.114686,
            0.944365,
            0.00738493,
            0,
            0.127286,
            0.935652,
            0.00737969,
            0,
            0.140443,
            0.925813,
            0.00733612,
            0,
            0.154151,
            0.914397,
            0.00723094,
            0,
            0.168405,
            0.903257,
            0.00714002,
            0,
            0.183201,
            0.890015,
            0.00700149,
            0,
            0.198536,
            0.876014,
            0.00682813,
            0,
            0.214409,
            0.861436,
            0.00665567,
            0,
            0.23082,
            0.845752,
            0.00644526,
            0,
            0.24777,
            0.829169,
            0.00621635,
            0,
            0.265263,
            0.813435,
            0.00597789,
            0,
            0.283301,
            0.799701,
            0.00575694,
            0,
            0.301889,
            0.785726,
            0.00549866,
            0,
            0.321035,
            0.77152,
            0.0052503,
            0,
            0.340746,
            0.75683,
            0.00499619,
            0,
            0.361032,
            0.741951,
            0.0047543,
            0,
            0.381904,
            0.726367,
            0.0045084,
            0,
            0.403374,
            0.710537,
            0.00426784,
            0,
            0.425457,
            0.693965,
            0.00403487,
            0,
            0.448169,
            0.677724,
            0.0038075,
            0,
            0.47153,
            0.66117,
            0.00359431,
            0,
            0.495561,
            0.644274,
            0.00338354,
            0,
            0.520284,
            0.627449,
            0.00318163,
            0,
            0.545725,
            0.611645,
            0.00299672,
            0,
            0.571911,
            0.595614,
            0.00281016,
            0,
            0.598873,
            0.579426,
            0.00264252,
            0,
            0.62664,
            0.563016,
            0.00247509,
            0,
            0.655239,
            0.546728,
            0.00232647,
            0,
            0.684692,
            0.530539,
            0.00217803,
            0,
            0.714999,
            0.514164,
            0.00204216,
            0,
            0.746106,
            0.498344,
            0.00191403,
            0,
            0.777778,
            0.482957,
            0.00179203,
            0,
            0.809524,
            0.467336,
            0.00167695,
            0,
            0.84127,
            0.451994,
            0.00157567,
            0,
            0.873016,
            0.436514,
            0.00147113,
            0,
            0.904762,
            0.42178,
            0.00138034,
            0,
            0.936508,
            0.407271,
            0.00129219,
            0,
            0.968254,
            0.392822,
            0.0012098,
            0,
            1,
            1,
            0.00637427,
            0,
            0,
            1,
            0.00637431,
            0,
            0,
            0.999999,
            0.00637485,
            0,
            0,
            0.999996,
            0.00637721,
            0,
            0,
            0.999987,
            0.00638357,
            0,
            0,
            0.999971,
            0.006397,
            0,
            0,
            0.999939,
            0.00642142,
            0,
            0,
            0.999888,
            0.00646177,
            0,
            0,
            0.999807,
            0.00652387,
            0,
            0.000207916,
            0.999689,
            0.00661454,
            0,
            0.00112051,
            0.99952,
            0.00674155,
            0,
            0.00287719,
            0.999283,
            0.00691313,
            0,
            0.00550145,
            0.998936,
            0.00713598,
            0,
            0.00897928,
            0.998165,
            0.00738501,
            0,
            0.0132829,
            0.994847,
            0.00734388,
            0,
            0.01838,
            0.993182,
            0.00749991,
            0,
            0.0242381,
            0.991665,
            0.0077246,
            0,
            0.030826,
            0.989708,
            0.00797579,
            0,
            0.0381152,
            0.986663,
            0.00813011,
            0,
            0.0460794,
            0.983288,
            0.00830365,
            0,
            0.0546951,
            0.980104,
            0.00853496,
            0,
            0.0639411,
            0.974855,
            0.00861045,
            0,
            0.0737988,
            0.97045,
            0.00879133,
            0,
            0.0842516,
            0.964509,
            0.00886377,
            0,
            0.0952848,
            0.957594,
            0.00890346,
            0,
            0.106886,
            0.950546,
            0.00893289,
            0,
            0.119044,
            0.942225,
            0.00890074,
            0,
            0.131749,
            0.933365,
            0.00886826,
            0,
            0.144994,
            0.923202,
            0.0087316,
            0,
            0.158772,
            0.912605,
            0.00863082,
            0,
            0.173078,
            0.901099,
            0.00847403,
            0,
            0.187908,
            0.888177,
            0.00825838,
            0,
            0.203261,
            0.873955,
            0.00801834,
            0,
            0.219134,
            0.860091,
            0.00779026,
            0,
            0.235527,
            0.84434,
            0.00752478,
            0,
            0.252443,
            0.828517,
            0.00724074,
            0,
            0.269883,
            0.81239,
            0.00693769,
            0,
            0.287851,
            0.79721,
            0.00664817,
            0,
            0.306352,
            0.783489,
            0.00634763,
            0,
            0.325393,
            0.769514,
            0.00604221,
            0,
            0.344981,
            0.755419,
            0.00573568,
            0,
            0.365126,
            0.741083,
            0.00544359,
            0,
            0.385839,
            0.726059,
            0.00515515,
            0,
            0.407132,
            0.710809,
            0.00487139,
            0,
            0.42902,
            0.695052,
            0.00459846,
            0,
            0.45152,
            0.678886,
            0.00433412,
            0,
            0.474651,
            0.663042,
            0.00407981,
            0,
            0.498433,
            0.646634,
            0.00384264,
            0,
            0.52289,
            0.630117,
            0.00360897,
            0,
            0.548048,
            0.613804,
            0.00338863,
            0,
            0.573936,
            0.598338,
            0.00318486,
            0,
            0.600584,
            0.582687,
            0.00298377,
            0,
            0.628027,
            0.566809,
            0.00280082,
            0,
            0.656295,
            0.550817,
            0.00262255,
            0,
            0.685417,
            0.534937,
            0.00245835,
            0,
            0.715406,
            0.519151,
            0.00230574,
            0,
            0.74624,
            0.503118,
            0.0021549,
            0,
            0.777778,
            0.487723,
            0.00202008,
            0,
            0.809524,
            0.472725,
            0.00189355,
            0,
            0.84127,
            0.457599,
            0.00177108,
            0,
            0.873016,
            0.442558,
            0.00165843,
            0,
            0.904762,
            0.427624,
            0.00155494,
            0,
            0.936508,
            0.413171,
            0.00145273,
            0,
            0.968254,
            0.399122,
            0.00136454,
            0,
            1,
            1,
            0.00826496,
            0,
            0,
            1,
            0.00826499,
            0,
            0,
            1,
            0.00826564,
            0,
            0,
            0.999996,
            0.00826842,
            0,
            0,
            0.999987,
            0.00827589,
            0,
            0,
            0.999967,
            0.00829167,
            0,
            0,
            0.999933,
            0.00832037,
            0,
            0,
            0.999876,
            0.00836768,
            0,
            0.0000109338,
            0.999786,
            0.00844031,
            0,
            0.000427145,
            0.999655,
            0.00854603,
            0,
            0.0016384,
            0.999468,
            0.00869337,
            0,
            0.00372392,
            0.999203,
            0.008891,
            0,
            0.00668513,
            0.998803,
            0.00914387,
            0,
            0.0104968,
            0.99748,
            0.00935838,
            0,
            0.015125,
            0.994446,
            0.00933309,
            0,
            0.0205338,
            0.99292,
            0.00953084,
            0,
            0.0266884,
            0.991414,
            0.0097893,
            0,
            0.0335565,
            0.989049,
            0.0100228,
            0,
            0.0411086,
            0.98582,
            0.0101664,
            0,
            0.0493181,
            0.982441,
            0.0103582,
            0,
            0.0581613,
            0.978595,
            0.0105292,
            0,
            0.0676169,
            0.973495,
            0.0106274,
            0,
            0.0776661,
            0.968405,
            0.0107261,
            0,
            0.0882926,
            0.962717,
            0.0108234,
            0,
            0.0994817,
            0.955478,
            0.0108102,
            0,
            0.111221,
            0.948275,
            0.0107914,
            0,
            0.123499,
            0.940006,
            0.0107161,
            0,
            0.136308,
            0.930831,
            0.0106309,
            0,
            0.149639,
            0.920648,
            0.0104083,
            0,
            0.163485,
            0.910205,
            0.0102312,
            0,
            0.177843,
            0.898445,
            0.0100051,
            0,
            0.192707,
            0.885986,
            0.00971928,
            0,
            0.208077,
            0.872204,
            0.00940747,
            0,
            0.22395,
            0.858436,
            0.0091085,
            0,
            0.240326,
            0.843454,
            0.00876595,
            0,
            0.257208,
            0.827437,
            0.00839794,
            0,
            0.274596,
            0.811488,
            0.00803692,
            0,
            0.292496,
            0.796039,
            0.00767352,
            0,
            0.310911,
            0.781083,
            0.0073097,
            0,
            0.329849,
            0.767642,
            0.00694032,
            0,
            0.349316,
            0.753901,
            0.00657476,
            0,
            0.369323,
            0.740131,
            0.00622699,
            0,
            0.38988,
            0.725845,
            0.0058838,
            0,
            0.410999,
            0.710991,
            0.00555586,
            0,
            0.432696,
            0.696002,
            0.00523089,
            0,
            0.454987,
            0.680461,
            0.00492494,
            0,
            0.47789,
            0.664875,
            0.00463464,
            0,
            0.501426,
            0.649273,
            0.00435422,
            0,
            0.52562,
            0.63302,
            0.0040875,
            0,
            0.550498,
            0.61705,
            0.00384075,
            0,
            0.576089,
            0.601154,
            0.00359557,
            0,
            0.602427,
            0.586008,
            0.00337636,
            0,
            0.629544,
            0.570699,
            0.00316019,
            0,
            0.657479,
            0.555166,
            0.00296033,
            0,
            0.686264,
            0.539645,
            0.00277552,
            0,
            0.715924,
            0.524159,
            0.00259499,
            0,
            0.746459,
            0.508682,
            0.00243257,
            0,
            0.777789,
            0.493163,
            0.00227851,
            0,
            0.809524,
            0.478004,
            0.00213083,
            0,
            0.84127,
            0.46347,
            0.00199502,
            0,
            0.873016,
            0.448778,
            0.00186967,
            0,
            0.904762,
            0.434105,
            0.00174732,
            0,
            0.936508,
            0.419576,
            0.00163861,
            0,
            0.968254,
            0.405541,
            0.00153341,
            0,
            1,
            1,
            0.0106462,
            0,
            0,
            1,
            0.0106462,
            0,
            0,
            0.999999,
            0.010647,
            0,
            0,
            0.999995,
            0.0106502,
            0,
            0,
            0.999985,
            0.0106589,
            0,
            0,
            0.999964,
            0.0106773,
            0,
            0,
            0.999925,
            0.0107106,
            0,
            0,
            0.999861,
            0.0107655,
            0,
            0.0000712986,
            0.999763,
            0.0108497,
            0,
            0.000743959,
            0.999616,
            0.0109716,
            0,
            0.00227361,
            0.999408,
            0.0111408,
            0,
            0.0046983,
            0.999112,
            0.0113659,
            0,
            0.00800158,
            0.998637,
            0.0116475,
            0,
            0.0121493,
            0.996223,
            0.0117231,
            0,
            0.0171023,
            0.994006,
            0.0118064,
            0,
            0.0228218,
            0.992444,
            0.0120254,
            0,
            0.0292711,
            0.991028,
            0.0123314,
            0,
            0.036417,
            0.98803,
            0.0124954,
            0,
            0.0442295,
            0.984816,
            0.0126538,
            0,
            0.0526815,
            0.981399,
            0.0128537,
            0,
            0.0617492,
            0.977085,
            0.0129694,
            0,
            0.0714114,
            0.972154,
            0.013091,
            0,
            0.0816495,
            0.966617,
            0.0131166,
            0,
            0.0924472,
            0.960628,
            0.0131583,
            0,
            0.10379,
            0.953295,
            0.0131094,
            0,
            0.115665,
            0.94575,
            0.0129966,
            0,
            0.128062,
            0.937654,
            0.0128796,
            0,
            0.140972,
            0.927716,
            0.0126477,
            0,
            0.154387,
            0.917932,
            0.0123889,
            0,
            0.168301,
            0.907719,
            0.012131,
            0,
            0.182709,
            0.89584,
            0.0118013,
            0,
            0.197608,
            0.883526,
            0.0114145,
            0,
            0.212994,
            0.870301,
            0.0110075,
            0,
            0.228867,
            0.856272,
            0.0106019,
            0,
            0.245227,
            0.842251,
            0.0101938,
            0,
            0.262074,
            0.826466,
            0.00973254,
            0,
            0.279412,
            0.810859,
            0.0092846,
            0,
            0.297244,
            0.795051,
            0.00883304,
            0,
            0.315575,
            0.780053,
            0.00840272,
            0,
            0.334412,
            0.76575,
            0.00796438,
            0,
            0.35376,
            0.752298,
            0.00752526,
            0,
            0.373631,
            0.739153,
            0.00711486,
            0,
            0.394034,
            0.725514,
            0.00670361,
            0,
            0.414983,
            0.711473,
            0.00632656,
            0,
            0.436491,
            0.696936,
            0.00595206,
            0,
            0.458575,
            0.682126,
            0.00559191,
            0,
            0.481253,
            0.667027,
            0.00525362,
            0,
            0.504547,
            0.651875,
            0.00493805,
            0,
            0.528481,
            0.636463,
            0.00462848,
            0,
            0.553081,
            0.620641,
            0.00433936,
            0,
            0.578377,
            0.604931,
            0.00407,
            0,
            0.604404,
            0.589549,
            0.00380864,
            0,
            0.631197,
            0.574712,
            0.00357049,
            0,
            0.658795,
            0.559775,
            0.00334466,
            0,
            0.687238,
            0.544514,
            0.00312505,
            0,
            0.716559,
            0.529555,
            0.00293199,
            0,
            0.746776,
            0.514402,
            0.00274204,
            0,
            0.777849,
            0.499302,
            0.00256647,
            0,
            0.809524,
            0.484114,
            0.00239901,
            0,
            0.84127,
            0.469308,
            0.00225148,
            0,
            0.873016,
            0.455133,
            0.00210178,
            0,
            0.904762,
            0.440939,
            0.0019727,
            0,
            0.936508,
            0.426627,
            0.00184382,
            0,
            0.968254,
            0.412509,
            0.00172548,
            0,
            1,
            1,
            0.013628,
            0,
            0,
            1,
            0.0136281,
            0,
            0,
            0.999999,
            0.0136289,
            0,
            0,
            0.999995,
            0.0136327,
            0,
            0,
            0.999983,
            0.0136427,
            0,
            0,
            0.99996,
            0.0136638,
            0,
            0,
            0.999917,
            0.0137022,
            0,
            0,
            0.999846,
            0.0137652,
            0,
            0.000204597,
            0.999736,
            0.0138615,
            0,
            0.00116837,
            0.999573,
            0.0140007,
            0,
            0.00303325,
            0.99934,
            0.0141927,
            0,
            0.00580613,
            0.999004,
            0.0144457,
            0,
            0.00945626,
            0.998407,
            0.0147489,
            0,
            0.0139421,
            0.995464,
            0.014731,
            0,
            0.0192202,
            0.993328,
            0.0148283,
            0,
            0.0252495,
            0.991799,
            0.0150797,
            0,
            0.0319921,
            0.990397,
            0.0154316,
            0,
            0.0394138,
            0.986835,
            0.0155005,
            0,
            0.0474843,
            0.983938,
            0.0157308,
            0,
            0.0561763,
            0.980154,
            0.0158753,
            0,
            0.0654661,
            0.975659,
            0.0159581,
            0,
            0.0753326,
            0.970171,
            0.0159832,
            0,
            0.0857571,
            0.964803,
            0.0160084,
            0,
            0.0967236,
            0.958366,
            0.0159484,
            0,
            0.108218,
            0.950613,
            0.0158001,
            0,
            0.120227,
            0.942874,
            0.0155845,
            0,
            0.132741,
            0.935005,
            0.0154292,
            0,
            0.145751,
            0.924991,
            0.0150742,
            0,
            0.159249,
            0.914814,
            0.0146757,
            0,
            0.17323,
            0.904743,
            0.0143097,
            0,
            0.187687,
            0.893216,
            0.0138695,
            0,
            0.202619,
            0.880769,
            0.0133706,
            0,
            0.218021,
            0.868136,
            0.0128606,
            0,
            0.233894,
            0.85469,
            0.0123403,
            0,
            0.250238,
            0.840593,
            0.0118091,
            0,
            0.267052,
            0.825808,
            0.011253,
            0,
            0.284341,
            0.81009,
            0.0107099,
            0,
            0.302106,
            0.79504,
            0.0101636,
            0,
            0.320354,
            0.779757,
            0.00964041,
            0,
            0.33909,
            0.764697,
            0.00911896,
            0,
            0.358322,
            0.750913,
            0.00859533,
            0,
            0.378059,
            0.738175,
            0.00811592,
            0,
            0.398311,
            0.725242,
            0.00764504,
            0,
            0.41909,
            0.711864,
            0.00718885,
            0,
            0.440412,
            0.698009,
            0.00675843,
            0,
            0.462292,
            0.683841,
            0.00634984,
            0,
            0.484748,
            0.669391,
            0.00595502,
            0,
            0.507802,
            0.654731,
            0.00558671,
            0,
            0.531477,
            0.639805,
            0.00523578,
            0,
            0.555802,
            0.624789,
            0.00490834,
            0,
            0.580805,
            0.609325,
            0.00459448,
            0,
            0.606522,
            0.593975,
            0.00430342,
            0,
            0.63299,
            0.578983,
            0.00403019,
            0,
            0.66025,
            0.564442,
            0.0037707,
            0,
            0.688346,
            0.549835,
            0.0035316,
            0,
            0.717319,
            0.535039,
            0.00330255,
            0,
            0.7472,
            0.520403,
            0.00308932,
            0,
            0.777982,
            0.505687,
            0.00289335,
            0,
            0.809524,
            0.490939,
            0.00270818,
            0,
            0.84127,
            0.476233,
            0.0025343,
            0,
            0.873016,
            0.461624,
            0.00237097,
            0,
            0.904762,
            0.447833,
            0.00222065,
            0,
            0.936508,
            0.433992,
            0.00207561,
            0,
            0.968254,
            0.420147,
            0.00194955,
            0,
            1,
            1,
            0.0173415,
            0,
            0,
            1,
            0.0173416,
            0,
            0,
            0.999999,
            0.0173426,
            0,
            0,
            0.999995,
            0.0173468,
            0,
            0,
            0.999983,
            0.0173582,
            0,
            0,
            0.999954,
            0.0173822,
            0,
            0,
            0.999908,
            0.0174258,
            0,
            0.00000669501,
            0.999828,
            0.0174973,
            0,
            0.000427399,
            0.999705,
            0.0176063,
            0,
            0.00171019,
            0.999524,
            0.0177631,
            0,
            0.0039248,
            0.999263,
            0.0179781,
            0,
            0.00705382,
            0.998878,
            0.018258,
            0,
            0.0110552,
            0.998012,
            0.0185551,
            0,
            0.0158812,
            0.994614,
            0.0184264,
            0,
            0.0214852,
            0.993132,
            0.0186385,
            0,
            0.0278239,
            0.991563,
            0.0189067,
            0,
            0.0348585,
            0.989298,
            0.0191577,
            0,
            0.0425544,
            0.986036,
            0.0192522,
            0,
            0.050881,
            0.982558,
            0.0194063,
            0,
            0.059811,
            0.978531,
            0.019486,
            0,
            0.0693209,
            0.974198,
            0.0195847,
            0,
            0.0793895,
            0.968148,
            0.0194749,
            0,
            0.0899984,
            0.962565,
            0.0194277,
            0,
            0.101132,
            0.956041,
            0.0192991,
            0,
            0.112775,
            0.947749,
            0.0189893,
            0,
            0.124917,
            0.94018,
            0.018704,
            0,
            0.137547,
            0.93165,
            0.0183458,
            0,
            0.150655,
            0.921798,
            0.0178775,
            0,
            0.164236,
            0.911573,
            0.0173618,
            0,
            0.178281,
            0.901569,
            0.0168482,
            0,
            0.192788,
            0.890341,
            0.016265,
            0,
            0.207752,
            0.877835,
            0.0156199,
            0,
            0.223171,
            0.865472,
            0.0149516,
            0,
            0.239044,
            0.852905,
            0.0143274,
            0,
            0.255371,
            0.838906,
            0.0136643,
            0,
            0.272153,
            0.824888,
            0.0129903,
            0,
            0.289393,
            0.809977,
            0.0123218,
            0,
            0.307093,
            0.794697,
            0.0116572,
            0,
            0.325259,
            0.780028,
            0.0110307,
            0,
            0.343896,
            0.765124,
            0.0104236,
            0,
            0.363012,
            0.750411,
            0.0098219,
            0,
            0.382617,
            0.737264,
            0.00924397,
            0,
            0.402719,
            0.724799,
            0.00868719,
            0,
            0.423332,
            0.712253,
            0.00816476,
            0,
            0.444469,
            0.699267,
            0.00767262,
            0,
            0.466146,
            0.685618,
            0.00719746,
            0,
            0.488383,
            0.671736,
            0.00673916,
            0,
            0.511199,
            0.657777,
            0.00631937,
            0,
            0.534618,
            0.643497,
            0.00592411,
            0,
            0.558668,
            0.62889,
            0.00553928,
            0,
            0.58338,
            0.614299,
            0.0051934,
            0,
            0.608787,
            0.599197,
            0.00485985,
            0,
            0.634929,
            0.584175,
            0.00454357,
            0,
            0.661849,
            0.569541,
            0.00425787,
            0,
            0.689594,
            0.555193,
            0.00397905,
            0,
            0.718211,
            0.540947,
            0.00372364,
            0,
            0.747742,
            0.526593,
            0.00348599,
            0,
            0.778205,
            0.512335,
            0.00326103,
            0,
            0.80953,
            0.498017,
            0.00305137,
            0,
            0.84127,
            0.483609,
            0.00285485,
            0,
            0.873016,
            0.469368,
            0.00267472,
            0,
            0.904762,
            0.455037,
            0.00249945,
            0,
            0.936508,
            0.441493,
            0.00234792,
            0,
            0.968254,
            0.428147,
            0.00219936,
            0,
            1,
            1,
            0.0219422,
            0,
            0,
            1,
            0.0219423,
            0,
            0,
            0.999998,
            0.0219434,
            0,
            0,
            0.999993,
            0.0219481,
            0,
            0,
            0.999981,
            0.021961,
            0,
            0,
            0.999949,
            0.0219879,
            0,
            0,
            0.999896,
            0.0220367,
            0,
            0.0000593194,
            0.999808,
            0.0221167,
            0,
            0.00075364,
            0.99967,
            0.0222383,
            0,
            0.00237884,
            0.999466,
            0.0224125,
            0,
            0.00495612,
            0.999174,
            0.0226495,
            0,
            0.00844887,
            0.998725,
            0.0229525,
            0,
            0.0128058,
            0.996979,
            0.0231123,
            0,
            0.0179742,
            0.994317,
            0.0230742,
            0,
            0.0239047,
            0.992781,
            0.0232895,
            0,
            0.0305526,
            0.991191,
            0.0235734,
            0,
            0.0378786,
            0.987787,
            0.0236152,
            0,
            0.0458475,
            0.985092,
            0.0237994,
            0,
            0.0544287,
            0.981121,
            0.0238553,
            0,
            0.0635952,
            0.976924,
            0.0238706,
            0,
            0.0733233,
            0.97218,
            0.0238704,
            0,
            0.0835922,
            0.965956,
            0.0236598,
            0,
            0.0943839,
            0.959998,
            0.0234735,
            0,
            0.105682,
            0.953245,
            0.0232277,
            0,
            0.117474,
            0.944445,
            0.0226973,
            0,
            0.129747,
            0.937087,
            0.0223527,
            0,
            0.142491,
            0.928341,
            0.0218144,
            0,
            0.155697,
            0.9184,
            0.0211516,
            0,
            0.169358,
            0.907959,
            0.0204553,
            0,
            0.183469,
            0.89808,
            0.0197673,
            0,
            0.198024,
            0.887047,
            0.0189915,
            0,
            0.21302,
            0.875221,
            0.0182082,
            0,
            0.228455,
            0.86269,
            0.0173584,
            0,
            0.244329,
            0.850735,
            0.0165718,
            0,
            0.260639,
            0.837545,
            0.0157524,
            0,
            0.277389,
            0.823639,
            0.0149482,
            0,
            0.29458,
            0.809699,
            0.0141431,
            0,
            0.312216,
            0.794797,
            0.0133527,
            0,
            0.3303,
            0.780578,
            0.0126193,
            0,
            0.34884,
            0.766019,
            0.0118914,
            0,
            0.367842,
            0.751447,
            0.0111839,
            0,
            0.387315,
            0.737275,
            0.010514,
            0,
            0.40727,
            0.724545,
            0.00987277,
            0,
            0.427717,
            0.712644,
            0.00926569,
            0,
            0.448671,
            0.700432,
            0.00869029,
            0,
            0.470149,
            0.687664,
            0.00814691,
            0,
            0.492167,
            0.674288,
            0.00763012,
            0,
            0.514746,
            0.660966,
            0.00714437,
            0,
            0.537911,
            0.647264,
            0.00668457,
            0,
            0.561688,
            0.633431,
            0.00626581,
            0,
            0.586108,
            0.619133,
            0.00585593,
            0,
            0.611206,
            0.604935,
            0.00548188,
            0,
            0.637022,
            0.590236,
            0.00513288,
            0,
            0.663599,
            0.575473,
            0.0047906,
            0,
            0.690989,
            0.561228,
            0.00448895,
            0,
            0.719242,
            0.547054,
            0.00420233,
            0,
            0.748411,
            0.533175,
            0.00392869,
            0,
            0.778531,
            0.519163,
            0.00367445,
            0,
            0.809583,
            0.505328,
            0.00344097,
            0,
            0.84127,
            0.491446,
            0.00322003,
            0,
            0.873016,
            0.477356,
            0.00301283,
            0,
            0.904762,
            0.46356,
            0.00282592,
            0,
            0.936508,
            0.449623,
            0.00264956,
            0,
            0.968254,
            0.436068,
            0.00246956,
            0,
            1,
            1,
            0.0276135,
            0,
            0,
            1,
            0.0276136,
            0,
            0,
            0.999998,
            0.0276148,
            0,
            0,
            0.999993,
            0.0276201,
            0,
            0,
            0.999976,
            0.0276342,
            0,
            0,
            0.999945,
            0.027664,
            0,
            0,
            0.999884,
            0.0277179,
            0,
            0.00018679,
            0.999784,
            0.027806,
            0,
            0.00119607,
            0.99963,
            0.0279394,
            0,
            0.00318407,
            0.999401,
            0.0281295,
            0,
            0.00613601,
            0.999066,
            0.0283858,
            0,
            0.00999963,
            0.998524,
            0.0287027,
            0,
            0.0147164,
            0.995702,
            0.0286256,
            0,
            0.0202295,
            0.993593,
            0.0286733,
            0,
            0.0264876,
            0.992067,
            0.0288989,
            0,
            0.0334452,
            0.990548,
            0.0292135,
            0,
            0.0410621,
            0.986775,
            0.0291296,
            0,
            0.0493032,
            0.984054,
            0.0293099,
            0,
            0.0581381,
            0.979481,
            0.0291881,
            0,
            0.0675397,
            0.975297,
            0.0291598,
            0,
            0.0774848,
            0.96981,
            0.028954,
            0,
            0.0879528,
            0.963524,
            0.028628,
            0,
            0.0989258,
            0.957398,
            0.0283135,
            0,
            0.110388,
            0.950088,
            0.0278469,
            0,
            0.122327,
            0.941538,
            0.0271798,
            0,
            0.134729,
            0.933332,
            0.0265388,
            0,
            0.147587,
            0.924392,
            0.0257776,
            0,
            0.160889,
            0.914581,
            0.024916,
            0,
            0.174631,
            0.904347,
            0.0240242,
            0,
            0.188806,
            0.894324,
            0.0231229,
            0,
            0.203409,
            0.883724,
            0.022153,
            0,
            0.218437,
            0.872207,
            0.0211355,
            0,
            0.233888,
            0.859927,
            0.0201048,
            0,
            0.249761,
            0.848373,
            0.0191263,
            0,
            0.266056,
            0.836023,
            0.0181306,
            0,
            0.282774,
            0.82289,
            0.0171718,
            0,
            0.299917,
            0.809324,
            0.0162196,
            0,
            0.317488,
            0.795361,
            0.0152622,
            0,
            0.335493,
            0.781253,
            0.01439,
            0,
            0.353936,
            0.767338,
            0.013533,
            0,
            0.372825,
            0.753156,
            0.0127244,
            0,
            0.392168,
            0.739122,
            0.0119454,
            0,
            0.411976,
            0.725358,
            0.0112054,
            0,
            0.432259,
            0.712949,
            0.010487,
            0,
            0.453032,
            0.701621,
            0.00984032,
            0,
            0.47431,
            0.689703,
            0.00921495,
            0,
            0.496111,
            0.677216,
            0.00862492,
            0,
            0.518456,
            0.664217,
            0.00806882,
            0,
            0.541367,
            0.65137,
            0.00755922,
            0,
            0.564872,
            0.638,
            0.00705705,
            0,
            0.589001,
            0.62453,
            0.00661266,
            0,
            0.613789,
            0.610601,
            0.00618432,
            0,
            0.639277,
            0.59676,
            0.00578033,
            0,
            0.66551,
            0.582433,
            0.00540927,
            0,
            0.692539,
            0.568026,
            0.00506104,
            0,
            0.720422,
            0.55414,
            0.0047353,
            0,
            0.749216,
            0.540178,
            0.00442889,
            0,
            0.778974,
            0.526513,
            0.00414363,
            0,
            0.809711,
            0.512954,
            0.00388237,
            0,
            0.84127,
            0.499403,
            0.00362875,
            0,
            0.873016,
            0.486026,
            0.00340827,
            0,
            0.904762,
            0.472345,
            0.00318598,
            0,
            0.936508,
            0.458828,
            0.00297635,
            0,
            0.968254,
            0.445379,
            0.00279447,
            0,
            1,
            1,
            0.0345716,
            0,
            0,
            1,
            0.0345717,
            0,
            0,
            0.999999,
            0.034573,
            0,
            0,
            0.999991,
            0.0345787,
            0,
            0,
            0.999974,
            0.0345941,
            0,
            0,
            0.999937,
            0.0346263,
            0,
            0.00000188589,
            0.999869,
            0.0346847,
            0,
            0.000409238,
            0.999757,
            0.0347798,
            0,
            0.0017674,
            0.999582,
            0.0349233,
            0,
            0.00413658,
            0.999322,
            0.0351265,
            0,
            0.00747408,
            0.998939,
            0.0353967,
            0,
            0.0117157,
            0.998219,
            0.0357018,
            0,
            0.0167966,
            0.994974,
            0.0354726,
            0,
            0.0226572,
            0.993201,
            0.0355621,
            0,
            0.0292445,
            0.991573,
            0.0357641,
            0,
            0.0365123,
            0.989301,
            0.0359252,
            0,
            0.0444203,
            0.985712,
            0.0358017,
            0,
            0.0529334,
            0.982411,
            0.0358353,
            0,
            0.0620214,
            0.977827,
            0.035617,
            0,
            0.0716574,
            0.973278,
            0.0354398,
            0,
            0.0818186,
            0.967397,
            0.0350483,
            0,
            0.0924846,
            0.960696,
            0.0344795,
            0,
            0.103638,
            0.954349,
            0.0339861,
            0,
            0.115263,
            0.946066,
            0.0331323,
            0,
            0.127348,
            0.938012,
            0.032359,
            0,
            0.13988,
            0.929413,
            0.0314413,
            0,
            0.152849,
            0.920355,
            0.0304103,
            0,
            0.166248,
            0.910586,
            0.0292785,
            0,
            0.18007,
            0.900609,
            0.0281391,
            0,
            0.194308,
            0.890093,
            0.0269103,
            0,
            0.208958,
            0.880013,
            0.0257269,
            0,
            0.224018,
            0.869001,
            0.0244671,
            0,
            0.239485,
            0.85751,
            0.0232252,
            0,
            0.255359,
            0.84582,
            0.0220117,
            0,
            0.271638,
            0.834383,
            0.0208274,
            0,
            0.288324,
            0.822158,
            0.0196628,
            0,
            0.305419,
            0.809056,
            0.0185306,
            0,
            0.322927,
            0.795832,
            0.0174174,
            0,
            0.340851,
            0.782547,
            0.0163758,
            0,
            0.359199,
            0.7689,
            0.015391,
            0,
            0.377975,
            0.755526,
            0.0144488,
            0,
            0.397189,
            0.741681,
            0.0135372,
            0,
            0.416851,
            0.728178,
            0.0126957,
            0,
            0.436971,
            0.714642,
            0.0118812,
            0,
            0.457564,
            0.702756,
            0.0111165,
            0,
            0.478644,
            0.69175,
            0.0104145,
            0,
            0.500229,
            0.680159,
            0.00974439,
            0,
            0.522339,
            0.668073,
            0.00911926,
            0,
            0.544997,
            0.655405,
            0.00851393,
            0,
            0.56823,
            0.642921,
            0.00797637,
            0,
            0.592068,
            0.629993,
            0.00745119,
            0,
            0.616546,
            0.616828,
            0.00696972,
            0,
            0.641705,
            0.603305,
            0.00652425,
            0,
            0.66759,
            0.589833,
            0.00610188,
            0,
            0.694255,
            0.575945,
            0.00570834,
            0,
            0.72176,
            0.561745,
            0.00533384,
            0,
            0.750168,
            0.548277,
            0.00500001,
            0,
            0.779545,
            0.534467,
            0.00467582,
            0,
            0.809933,
            0.521032,
            0.00438092,
            0,
            0.841272,
            0.507877,
            0.00410348,
            0,
            0.873016,
            0.494654,
            0.00383618,
            0,
            0.904762,
            0.481592,
            0.00358699,
            0,
            0.936508,
            0.468509,
            0.00337281,
            0,
            0.968254,
            0.455293,
            0.00316196,
            0,
            1,
            1,
            0.0430698,
            0,
            0,
            1,
            0.0430699,
            0,
            0,
            0.999998,
            0.0430713,
            0,
            0,
            0.999991,
            0.0430773,
            0,
            0,
            0.99997,
            0.0430936,
            0,
            0,
            0.999928,
            0.0431277,
            0,
            0.0000406396,
            0.999852,
            0.0431893,
            0,
            0.000744376,
            0.999724,
            0.0432895,
            0,
            0.0024806,
            0.999527,
            0.0434397,
            0,
            0.00524779,
            0.99923,
            0.0436507,
            0,
            0.00898164,
            0.998783,
            0.0439255,
            0,
            0.0136083,
            0.997507,
            0.0441104,
            0,
            0.0190582,
            0.994418,
            0.0438225,
            0,
            0.0252694,
            0.992864,
            0.0439396,
            0,
            0.0321879,
            0.991127,
            0.0440962,
            0,
            0.039767,
            0.987331,
            0.0438408,
            0,
            0.0479667,
            0.984819,
            0.0438991,
            0,
            0.056752,
            0.980384,
            0.0435906,
            0,
            0.0660929,
            0.975846,
            0.0432543,
            0,
            0.075963,
            0.970748,
            0.0428293,
            0,
            0.0863398,
            0.964303,
            0.042153,
            0,
            0.0972035,
            0.95772,
            0.0414111,
            0,
            0.108537,
            0.950747,
            0.0405893,
            0,
            0.120325,
            0.942533,
            0.0394887,
            0,
            0.132554,
            0.934045,
            0.0383544,
            0,
            0.145215,
            0.924942,
            0.037057,
            0,
            0.158296,
            0.915811,
            0.0356993,
            0,
            0.17179,
            0.90612,
            0.0342401,
            0,
            0.185691,
            0.896434,
            0.0328078,
            0,
            0.199993,
            0.886021,
            0.031288,
            0,
            0.214691,
            0.876081,
            0.0297776,
            0,
            0.229782,
            0.865608,
            0.0282334,
            0,
            0.245265,
            0.854924,
            0.026749,
            0,
            0.261138,
            0.843607,
            0.02526,
            0,
            0.277401,
            0.832456,
            0.0238214,
            0,
            0.294056,
            0.821342,
            0.0224682,
            0,
            0.311104,
            0.809303,
            0.0211297,
            0,
            0.328548,
            0.796468,
            0.0198387,
            0,
            0.346394,
            0.784046,
            0.0186227,
            0,
            0.364645,
            0.771262,
            0.0174561,
            0,
            0.38331,
            0.758118,
            0.0163806,
            0,
            0.402396,
            0.745075,
            0.0153287,
            0,
            0.421912,
            0.731926,
            0.0143647,
            0,
            0.44187,
            0.71863,
            0.0134363,
            0,
            0.462283,
            0.705414,
            0.0125603,
            0,
            0.483165,
            0.693792,
            0.0117508,
            0,
            0.504535,
            0.683108,
            0.0110016,
            0,
            0.52641,
            0.67183,
            0.0102757,
            0,
            0.548816,
            0.66015,
            0.00962044,
            0,
            0.571776,
            0.647907,
            0.00898031,
            0,
            0.595323,
            0.635734,
            0.00840811,
            0,
            0.619489,
            0.623208,
            0.00786211,
            0,
            0.644317,
            0.610438,
            0.00734953,
            0,
            0.669852,
            0.597345,
            0.00687688,
            0,
            0.696148,
            0.584138,
            0.00643469,
            0,
            0.723267,
            0.5707,
            0.00602236,
            0,
            0.75128,
            0.556966,
            0.0056324,
            0,
            0.780258,
            0.543607,
            0.00528277,
            0,
            0.810268,
            0.530213,
            0.00493999,
            0,
            0.841311,
            0.516912,
            0.00462265,
            0,
            0.873016,
            0.503916,
            0.0043307,
            0,
            0.904762,
            0.491146,
            0.00406858,
            0,
            0.936508,
            0.478439,
            0.00381436,
            0,
            0.968254,
            0.465834,
            0.00358003,
            0,
            1,
            1,
            0.0534039,
            0,
            0,
            1,
            0.053404,
            0,
            0,
            0.999998,
            0.0534055,
            0,
            0,
            0.999989,
            0.0534116,
            0,
            0,
            0.999968,
            0.0534283,
            0,
            0,
            0.999918,
            0.0534633,
            0,
            0.000155895,
            0.99983,
            0.0535262,
            0,
            0.00120914,
            0.999685,
            0.0536281,
            0,
            0.00334944,
            0.999461,
            0.0537799,
            0,
            0.00653077,
            0.999119,
            0.0539902,
            0,
            0.0106718,
            0.998582,
            0.0542524,
            0,
            0.0156907,
            0.995919,
            0.0540318,
            0,
            0.0215147,
            0.993735,
            0.0538914,
            0,
            0.0280801,
            0.992126,
            0.0539557,
            0,
            0.0353323,
            0.990266,
            0.0540401,
            0,
            0.0432247,
            0.986317,
            0.0536064,
            0,
            0.0517172,
            0.983213,
            0.0534425,
            0,
            0.0607754,
            0.978303,
            0.0528622,
            0,
            0.0703698,
            0.973665,
            0.0523363,
            0,
            0.0804742,
            0.968091,
            0.0516165,
            0,
            0.0910667,
            0.961026,
            0.0505434,
            0,
            0.102128,
            0.954333,
            0.049523,
            0,
            0.113641,
            0.946372,
            0.0481698,
            0,
            0.125591,
            0.938254,
            0.0467674,
            0,
            0.137965,
            0.929516,
            0.0452341,
            0,
            0.150754,
            0.920106,
            0.0435083,
            0,
            0.163947,
            0.910899,
            0.0417399,
            0,
            0.177537,
            0.901532,
            0.0399389,
            0,
            0.191516,
            0.891919,
            0.0380901,
            0,
            0.205881,
            0.882006,
            0.0362341,
            0,
            0.220626,
            0.871965,
            0.0343444,
            0,
            0.235749,
            0.862145,
            0.0324832,
            0,
            0.251248,
            0.852058,
            0.0306681,
            0,
            0.267121,
            0.84161,
            0.0289097,
            0,
            0.283368,
            0.830806,
            0.0272079,
            0,
            0.299992,
            0.820476,
            0.0256089,
            0,
            0.316992,
            0.809514,
            0.0240394,
            0,
            0.334374,
            0.797865,
            0.0225379,
            0,
            0.35214,
            0.785621,
            0.0211235,
            0,
            0.370296,
            0.773765,
            0.0197908,
            0,
            0.388849,
            0.761629,
            0.0185235,
            0,
            0.407807,
            0.748891,
            0.0173358,
            0,
            0.427178,
            0.736437,
            0.0162305,
            0,
            0.446974,
            0.723707,
            0.0151778,
            0,
            0.467207,
            0.710606,
            0.0141791,
            0,
            0.487892,
            0.698019,
            0.0132592,
            0,
            0.509046,
            0.686203,
            0.0123887,
            0,
            0.530687,
            0.675692,
            0.0115976,
            0,
            0.552839,
            0.664826,
            0.0108325,
            0,
            0.575527,
            0.65349,
            0.0101348,
            0,
            0.59878,
            0.641774,
            0.00947756,
            0,
            0.622634,
            0.629794,
            0.00886058,
            0,
            0.647128,
            0.617647,
            0.00828526,
            0,
            0.672308,
            0.60534,
            0.00775312,
            0,
            0.698231,
            0.592718,
            0.00726033,
            0,
            0.724958,
            0.579746,
            0.00679731,
            0,
            0.752563,
            0.566763,
            0.00636111,
            0,
            0.781127,
            0.553515,
            0.00595228,
            0,
            0.810733,
            0.540118,
            0.00556876,
            0,
            0.841426,
            0.527325,
            0.00523051,
            0,
            0.873016,
            0.514265,
            0.00490712,
            0,
            0.904762,
            0.501406,
            0.00460297,
            0,
            0.936508,
            0.488922,
            0.00431247,
            0,
            0.968254,
            0.476541,
            0.0040472,
            0,
            1,
            1,
            0.0659184,
            0,
            0,
            1,
            0.0659185,
            0,
            0,
            0.999998,
            0.06592,
            0,
            0,
            0.999988,
            0.0659259,
            0,
            0,
            0.999963,
            0.0659423,
            0,
            0,
            0.999907,
            0.0659764,
            0,
            0.000374198,
            0.999806,
            0.0660376,
            0,
            0.00182071,
            0.999639,
            0.0661361,
            0,
            0.0043894,
            0.999378,
            0.0662814,
            0,
            0.00800055,
            0.998985,
            0.0664779,
            0,
            0.0125594,
            0.998285,
            0.0666914,
            0,
            0.0179786,
            0.995071,
            0.0661989,
            0,
            0.0241822,
            0.993172,
            0.0660454,
            0,
            0.031106,
            0.991438,
            0.0660105,
            0,
            0.0386952,
            0.988428,
            0.0656875,
            0,
            0.0469032,
            0.985218,
            0.0652913,
            0,
            0.0556905,
            0.981128,
            0.0647107,
            0,
            0.065023,
            0.976015,
            0.0638491,
            0,
            0.0748717,
            0.97097,
            0.062993,
            0,
            0.0852112,
            0.964582,
            0.0617927,
            0,
            0.0960199,
            0.957383,
            0.0603626,
            0,
            0.107279,
            0.949969,
            0.0588128,
            0,
            0.118971,
            0.941843,
            0.0570274,
            0,
            0.131084,
            0.933624,
            0.0551885,
            0,
            0.143604,
            0.924543,
            0.053122,
            0,
            0.156521,
            0.914919,
            0.0508897,
            0,
            0.169825,
            0.905773,
            0.0486418,
            0,
            0.18351,
            0.896434,
            0.0463364,
            0,
            0.197569,
            0.887195,
            0.0440623,
            0,
            0.211997,
            0.877706,
            0.0417799,
            0,
            0.226789,
            0.867719,
            0.03945,
            0,
            0.241944,
            0.858587,
            0.037243,
            0,
            0.257458,
            0.849317,
            0.0350956,
            0,
            0.273331,
            0.839585,
            0.0329852,
            0,
            0.289563,
            0.829856,
            0.0310028,
            0,
            0.306154,
            0.819589,
            0.0290953,
            0,
            0.323108,
            0.809714,
            0.0272738,
            0,
            0.340426,
            0.79934,
            0.0255631,
            0,
            0.358113,
            0.788224,
            0.0239175,
            0,
            0.376175,
            0.776619,
            0.0223831,
            0,
            0.394616,
            0.76521,
            0.0209298,
            0,
            0.413445,
            0.753716,
            0.0195786,
            0,
            0.432671,
            0.741564,
            0.0183001,
            0,
            0.452305,
            0.729413,
            0.0171259,
            0,
            0.472358,
            0.717146,
            0.0159933,
            0,
            0.492845,
            0.70436,
            0.0149495,
            0,
            0.513783,
            0.69219,
            0.0139681,
            0,
            0.535189,
            0.680289,
            0.0130577,
            0,
            0.557087,
            0.669611,
            0.0122198,
            0,
            0.5795,
            0.659113,
            0.0114174,
            0,
            0.602459,
            0.648148,
            0.0106729,
            0,
            0.625997,
            0.636905,
            0.00998997,
            0,
            0.650154,
            0.625154,
            0.00934313,
            0,
            0.674976,
            0.613481,
            0.00874839,
            0,
            0.700518,
            0.60154,
            0.00818265,
            0,
            0.726845,
            0.58943,
            0.00766889,
            0,
            0.754032,
            0.576828,
            0.00717153,
            0,
            0.782167,
            0.564194,
            0.00672696,
            0,
            0.811344,
            0.551501,
            0.00630863,
            0,
            0.841644,
            0.538635,
            0.00592177,
            0,
            0.873016,
            0.525724,
            0.00554888,
            0,
            0.904762,
            0.513209,
            0.00520225,
            0,
            0.936508,
            0.500457,
            0.00488231,
            0,
            0.968254,
            0.48799,
            0.00457153,
            0,
            1,
            1,
            0.0810131,
            0,
            0,
            1,
            0.0810133,
            0,
            0,
            0.999997,
            0.0810145,
            0,
            0,
            0.999985,
            0.08102,
            0,
            0,
            0.999956,
            0.0810347,
            0,
            0.0000195026,
            0.999893,
            0.0810656,
            0,
            0.000719316,
            0.999777,
            0.0811205,
            0,
            0.00259774,
            0.999583,
            0.081208,
            0,
            0.00561807,
            0.999281,
            0.0813343,
            0,
            0.00967472,
            0.998813,
            0.0814969,
            0,
            0.0146627,
            0.997597,
            0.0815217,
            0,
            0.0204902,
            0.994379,
            0.0808502,
            0,
            0.0270802,
            0.992744,
            0.0806792,
            0,
            0.0343674,
            0.990745,
            0.0804589,
            0,
            0.0422974,
            0.986646,
            0.0796107,
            0,
            0.0508242,
            0.983611,
            0.0790913,
            0,
            0.0599087,
            0.978869,
            0.0780746,
            0,
            0.0695175,
            0.973475,
            0.0768218,
            0,
            0.0796223,
            0.967845,
            0.0754926,
            0,
            0.0901983,
            0.960778,
            0.0737063,
            0,
            0.101224,
            0.953333,
            0.0718052,
            0,
            0.112682,
            0.945274,
            0.0695946,
            0,
            0.124555,
            0.936955,
            0.0672492,
            0,
            0.136831,
            0.928319,
            0.0647732,
            0,
            0.149496,
            0.919075,
            0.0620947,
            0,
            0.162542,
            0.909114,
            0.0591816,
            0,
            0.175958,
            0.900137,
            0.0563917,
            0,
            0.189739,
            0.891069,
            0.0535392,
            0,
            0.203877,
            0.882262,
            0.0507642,
            0,
            0.218368,
            0.873232,
            0.0479793,
            0,
            0.233208,
            0.864042,
            0.045226,
            0,
            0.248393,
            0.855002,
            0.0425413,
            0,
            0.263923,
            0.846569,
            0.0400126,
            0,
            0.279796,
            0.837714,
            0.0375269,
            0,
            0.296012,
            0.828918,
            0.0352027,
            0,
            0.312573,
            0.819783,
            0.0330011,
            0,
            0.329479,
            0.810129,
            0.0308908,
            0,
            0.346734,
            0.800866,
            0.0289112,
            0,
            0.364342,
            0.79093,
            0.0270255,
            0,
            0.382307,
            0.780593,
            0.0252758,
            0,
            0.400637,
            0.769511,
            0.0236178,
            0,
            0.419337,
            0.758558,
            0.0220652,
            0,
            0.438418,
            0.747632,
            0.0206289,
            0,
            0.457889,
            0.736146,
            0.0192873,
            0,
            0.477761,
            0.724093,
            0.0180333,
            0,
            0.49805,
            0.71234,
            0.0168264,
            0,
            0.51877,
            0.700201,
            0.015746,
            0,
            0.53994,
            0.687949,
            0.0147027,
            0,
            0.561581,
            0.676163,
            0.0137512,
            0,
            0.583718,
            0.665001,
            0.0128655,
            0,
            0.60638,
            0.65472,
            0.0120366,
            0,
            0.629599,
            0.644213,
            0.0112604,
            0,
            0.653415,
            0.633382,
            0.0105413,
            0,
            0.677874,
            0.62212,
            0.00986498,
            0,
            0.70303,
            0.610631,
            0.00923308,
            0,
            0.728948,
            0.599078,
            0.00864206,
            0,
            0.755706,
            0.587519,
            0.00811784,
            0,
            0.783396,
            0.575505,
            0.00761237,
            0,
            0.812121,
            0.563148,
            0.00713949,
            0,
            0.841989,
            0.550828,
            0.00668379,
            0,
            0.873035,
            0.538458,
            0.00627715,
            0,
            0.904762,
            0.525905,
            0.00588336,
            0,
            0.936508,
            0.513517,
            0.00552687,
            0,
            0.968254,
            0.501395,
            0.00519681,
            0,
            1,
            1,
            0.0991506,
            0,
            0,
            1,
            0.0991504,
            0,
            0,
            0.999996,
            0.0991515,
            0,
            0,
            0.999984,
            0.0991558,
            0,
            0,
            0.999947,
            0.0991672,
            0,
            0.000114389,
            0.999874,
            0.0991912,
            0,
            0.00121503,
            0.999739,
            0.0992331,
            0,
            0.00356108,
            0.999514,
            0.0992983,
            0,
            0.00705578,
            0.999159,
            0.0993877,
            0,
            0.011574,
            0.998586,
            0.0994837,
            0,
            0.017003,
            0.995731,
            0.0988425,
            0,
            0.0232484,
            0.993384,
            0.098276,
            0,
            0.0302318,
            0.991615,
            0.0979269,
            0,
            0.0378884,
            0.989029,
            0.0973432,
            0,
            0.0461641,
            0.985373,
            0.0963539,
            0,
            0.0550136,
            0.981278,
            0.0952306,
            0,
            0.0643988,
            0.975777,
            0.0936233,
            0,
            0.0742868,
            0.970526,
            0.0920219,
            0,
            0.0846501,
            0.963755,
            0.0898912,
            0,
            0.0954644,
            0.956676,
            0.0876064,
            0,
            0.106709,
            0.948099,
            0.0847751,
            0,
            0.118367,
            0.939718,
            0.0818638,
            0,
            0.130423,
            0.931305,
            0.078857,
            0,
            0.142862,
            0.922342,
            0.0756127,
            0,
            0.155674,
            0.912842,
            0.0721473,
            0,
            0.168849,
            0.903304,
            0.0686195,
            0,
            0.182378,
            0.89411,
            0.0650589,
            0,
            0.196255,
            0.885512,
            0.0616022,
            0,
            0.210473,
            0.877193,
            0.0582434,
            0,
            0.225027,
            0.86877,
            0.0548979,
            0,
            0.239915,
            0.860267,
            0.0516095,
            0,
            0.255132,
            0.851915,
            0.048468,
            0,
            0.270678,
            0.843912,
            0.0454447,
            0,
            0.286551,
            0.83604,
            0.0425612,
            0,
            0.302751,
            0.828245,
            0.0398752,
            0,
            0.31928,
            0.820159,
            0.0373198,
            0,
            0.336138,
            0.81167,
            0.034916,
            0,
            0.35333,
            0.802659,
            0.0326402,
            0,
            0.370858,
            0.793921,
            0.0304901,
            0,
            0.388728,
            0.784713,
            0.0284857,
            0,
            0.406944,
            0.774946,
            0.0266186,
            0,
            0.425515,
            0.76448,
            0.0248593,
            0,
            0.444449,
            0.753793,
            0.0232114,
            0,
            0.463756,
            0.743506,
            0.0217039,
            0,
            0.483447,
            0.732555,
            0.0202841,
            0,
            0.503535,
            0.720965,
            0.0189648,
            0,
            0.524036,
            0.709422,
            0.0177189,
            0,
            0.544968,
            0.697756,
            0.0165626,
            0,
            0.56635,
            0.685565,
            0.015483,
            0,
            0.588208,
            0.673987,
            0.0144892,
            0,
            0.610569,
            0.66244,
            0.0135607,
            0,
            0.633466,
            0.651675,
            0.0126956,
            0,
            0.656936,
            0.641598,
            0.0118788,
            0,
            0.681025,
            0.63121,
            0.0111261,
            0,
            0.705788,
            0.620514,
            0.010437,
            0,
            0.731289,
            0.609366,
            0.00978747,
            0,
            0.757606,
            0.598137,
            0.00917257,
            0,
            0.784834,
            0.586966,
            0.00859778,
            0,
            0.813085,
            0.575549,
            0.00806803,
            0,
            0.842485,
            0.563797,
            0.00757294,
            0,
            0.87313,
            0.551758,
            0.00710592,
            0,
            0.904762,
            0.539894,
            0.0066841,
            0,
            0.936508,
            0.527901,
            0.00627901,
            0,
            0.968254,
            0.515819,
            0.00590506,
            0,
            1,
            1,
            0.120864,
            0,
            0,
            1,
            0.120864,
            0,
            0,
            0.999996,
            0.120864,
            0,
            0,
            0.99998,
            0.120867,
            0,
            0,
            0.99994,
            0.120872,
            0,
            0.000323781,
            0.999852,
            0.120884,
            0,
            0.00188693,
            0.999693,
            0.120903,
            0,
            0.00473489,
            0.999426,
            0.120929,
            0,
            0.00872704,
            0.999002,
            0.120955,
            0,
            0.0137237,
            0.998235,
            0.120918,
            0,
            0.0196068,
            0.994608,
            0.119764,
            0,
            0.0262803,
            0.992997,
            0.119265,
            0,
            0.0336657,
            0.990968,
            0.11863,
            0,
            0.0416987,
            0.987002,
            0.117261,
            0,
            0.0503261,
            0.983524,
            0.116009,
            0,
            0.0595035,
            0.97875,
            0.114252,
            0,
            0.0691935,
            0.972652,
            0.11193,
            0,
            0.0793645,
            0.966613,
            0.109555,
            0,
            0.0899894,
            0.959275,
            0.106612,
            0,
            0.101045,
            0.951272,
            0.103375,
            0,
            0.112512,
            0.942323,
            0.0996594,
            0,
            0.124372,
            0.933679,
            0.0958841,
            0,
            0.136611,
            0.924822,
            0.0919265,
            0,
            0.149216,
            0.915742,
            0.0878061,
            0,
            0.162176,
            0.906348,
            0.0834894,
            0,
            0.175482,
            0.896883,
            0.079085,
            0,
            0.189125,
            0.88774,
            0.0746745,
            0,
            0.203098,
            0.87986,
            0.0705773,
            0,
            0.217396,
            0.871998,
            0.0665005,
            0,
            0.232015,
            0.864325,
            0.0625413,
            0,
            0.24695,
            0.856685,
            0.0586781,
            0,
            0.2622,
            0.84925,
            0.0550063,
            0,
            0.277761,
            0.841719,
            0.0514727,
            0,
            0.293634,
            0.834755,
            0.0481398,
            0,
            0.309819,
            0.827853,
            0.0450172,
            0,
            0.326315,
            0.820888,
            0.0420969,
            0,
            0.343126,
            0.813616,
            0.0393702,
            0,
            0.360254,
            0.805767,
            0.0367771,
            0,
            0.377701,
            0.797338,
            0.0343274,
            0,
            0.395474,
            0.789122,
            0.0320529,
            0,
            0.413577,
            0.780601,
            0.0299485,
            0,
            0.432018,
            0.771424,
            0.0279812,
            0,
            0.450804,
            0.761502,
            0.0261054,
            0,
            0.469944,
            0.751166,
            0.0243942,
            0,
            0.489451,
            0.741276,
            0.0228087,
            0,
            0.509337,
            0.730898,
            0.0213265,
            0,
            0.529617,
            0.719878,
            0.0199307,
            0,
            0.550307,
            0.708379,
            0.0186574,
            0,
            0.571428,
            0.697165,
            0.0174446,
            0,
            0.593003,
            0.685554,
            0.0163144,
            0,
            0.615059,
            0.673631,
            0.015276,
            0,
            0.637628,
            0.662385,
            0.0143003,
            0,
            0.660746,
            0.651059,
            0.0134112,
            0,
            0.68446,
            0.640451,
            0.0125794,
            0,
            0.70882,
            0.630536,
            0.011793,
            0,
            0.733893,
            0.620316,
            0.0110547,
            0,
            0.759756,
            0.609722,
            0.0103668,
            0,
            0.786505,
            0.598804,
            0.00973009,
            0,
            0.814259,
            0.587871,
            0.00912812,
            0,
            0.843157,
            0.577121,
            0.00858916,
            0,
            0.87334,
            0.566019,
            0.00807333,
            0,
            0.904762,
            0.554664,
            0.00759687,
            0,
            0.936508,
            0.543101,
            0.00714759,
            0,
            0.968254,
            0.531558,
            0.00673418,
            0,
            1,
            1,
            0.146767,
            0,
            0,
            1,
            0.146767,
            0,
            0,
            0.999997,
            0.146767,
            0,
            0,
            0.999977,
            0.146765,
            0,
            0.00000320658,
            0.999929,
            0.146762,
            0,
            0.000682576,
            0.999823,
            0.146753,
            0,
            0.00276402,
            0.999633,
            0.146735,
            0,
            0.00614771,
            0.999314,
            0.146699,
            0,
            0.0106613,
            0.998796,
            0.14662,
            0,
            0.0161546,
            0.997124,
            0.146107,
            0,
            0.0225063,
            0.994062,
            0.144857,
            0,
            0.0296198,
            0.992154,
            0.144011,
            0,
            0.037417,
            0.989186,
            0.142712,
            0,
            0.0458348,
            0.985279,
            0.140926,
            0,
            0.0548211,
            0.980826,
            0.13885,
            0,
            0.0643326,
            0.975056,
            0.136168,
            0,
            0.074333,
            0.969005,
            0.133217,
            0,
            0.0847917,
            0.961554,
            0.12959,
            0,
            0.0956828,
            0.954206,
            0.125886,
            0,
            0.106984,
            0.945046,
            0.121335,
            0,
            0.118675,
            0.935678,
            0.116492,
            0,
            0.130741,
            0.926748,
            0.111635,
            0,
            0.143166,
            0.917764,
            0.106625,
            0,
            0.155939,
            0.908358,
            0.101325,
            0,
            0.169049,
            0.899219,
            0.0960249,
            0,
            0.182487,
            0.890089,
            0.0906527,
            0,
            0.196245,
            0.881488,
            0.0853905,
            0,
            0.210317,
            0.874031,
            0.0804177,
            0,
            0.224697,
            0.866932,
            0.0756005,
            0,
            0.23938,
            0.859976,
            0.0709019,
            0,
            0.254364,
            0.853375,
            0.0664391,
            0,
            0.269646,
            0.846971,
            0.0622012,
            0,
            0.285223,
            0.840483,
            0.058129,
            0,
            0.301096,
            0.833969,
            0.0542762,
            0,
            0.317265,
            0.82806,
            0.0507042,
            0,
            0.333729,
            0.822128,
            0.047368,
            0,
            0.350491,
            0.815989,
            0.044272,
            0,
            0.367554,
            0.809336,
            0.0413444,
            0,
            0.38492,
            0.802177,
            0.038601,
            0,
            0.402594,
            0.79441,
            0.0360227,
            0,
            0.420582,
            0.786573,
            0.0336383,
            0,
            0.438891,
            0.778619,
            0.0314321,
            0,
            0.457527,
            0.77,
            0.029362,
            0,
            0.476499,
            0.760698,
            0.0274102,
            0,
            0.49582,
            0.750932,
            0.0256146,
            0,
            0.5155,
            0.740993,
            0.023974,
            0,
            0.535555,
            0.731159,
            0.0224182,
            0,
            0.556,
            0.720836,
            0.0209889,
            0,
            0.576855,
            0.709913,
            0.0196411,
            0,
            0.598143,
            0.698415,
            0.0183824,
            0,
            0.619888,
            0.68745,
            0.0172222,
            0,
            0.642123,
            0.676154,
            0.0161509,
            0,
            0.664883,
            0.664383,
            0.0151397,
            0,
            0.688211,
            0.6533,
            0.0141873,
            0,
            0.71216,
            0.642072,
            0.0133105,
            0,
            0.736792,
            0.631412,
            0.0124932,
            0,
            0.762186,
            0.621622,
            0.0117408,
            0,
            0.788439,
            0.611681,
            0.0110358,
            0,
            0.815672,
            0.60142,
            0.0103775,
            0,
            0.844034,
            0.59083,
            0.00975623,
            0,
            0.873699,
            0.580254,
            0.00918084,
            0,
            0.904765,
            0.569841,
            0.00864721,
            0,
            0.936508,
            0.559224,
            0.00815731,
            0,
            0.968254,
            0.548315,
            0.00767924,
            0,
            1,
            1,
            0.177563,
            0,
            0,
            1,
            0.177563,
            0,
            0,
            0.999994,
            0.177562,
            0,
            0,
            0.999972,
            0.177555,
            0,
            0.0000664171,
            0.999914,
            0.177536,
            0,
            0.0012276,
            0.999787,
            0.177496,
            0,
            0.00388025,
            0.999556,
            0.17742,
            0,
            0.00783463,
            0.999165,
            0.177285,
            0,
            0.0128953,
            0.9985,
            0.177037,
            0,
            0.0189053,
            0.995388,
            0.175634,
            0,
            0.025742,
            0.993102,
            0.174375,
            0,
            0.033309,
            0.990992,
            0.173121,
            0,
            0.0415298,
            0.986932,
            0.170896,
            0,
            0.0503425,
            0.982786,
            0.16847,
            0,
            0.0596964,
            0.977592,
            0.165455,
            0,
            0.0695498,
            0.971075,
            0.161676,
            0,
            0.0798676,
            0.963967,
            0.157458,
            0,
            0.0906201,
            0.956397,
            0.152836,
            0,
            0.101783,
            0.947489,
            0.147467,
            0,
            0.113333,
            0.937564,
            0.14145,
            0,
            0.125254,
            0.928182,
            0.135383,
            0,
            0.137529,
            0.919027,
            0.129212,
            0,
            0.150144,
            0.909618,
            0.12276,
            0,
            0.163088,
            0.900492,
            0.116273,
            0,
            0.176351,
            0.891671,
            0.1098,
            0,
            0.189924,
            0.883146,
            0.103362,
            0,
            0.203799,
            0.875151,
            0.0970799,
            0,
            0.21797,
            0.868338,
            0.0911732,
            0,
            0.232433,
            0.862033,
            0.0854966,
            0,
            0.247182,
            0.856107,
            0.0800691,
            0,
            0.262216,
            0.850644,
            0.0749618,
            0,
            0.27753,
            0.845261,
            0.070079,
            0,
            0.293124,
            0.839885,
            0.0654321,
            0,
            0.308997,
            0.834609,
            0.0610975,
            0,
            0.325149,
            0.829083,
            0.0569741,
            0,
            0.341581,
            0.82404,
            0.0531736,
            0,
            0.358294,
            0.818968,
            0.049665,
            0,
            0.37529,
            0.813496,
            0.0463856,
            0,
            0.392573,
            0.807533,
            0.0433217,
            0,
            0.410148,
            0.80099,
            0.0404402,
            0,
            0.428019,
            0.793891,
            0.0377578,
            0,
            0.446192,
            0.786281,
            0.0352616,
            0,
            0.464676,
            0.778773,
            0.0329577,
            0,
            0.483478,
            0.770737,
            0.030808,
            0,
            0.502608,
            0.762094,
            0.0287964,
            0,
            0.522079,
            0.752898,
            0.0269254,
            0,
            0.541905,
            0.743306,
            0.0251926,
            0,
            0.5621,
            0.733416,
            0.023595,
            0,
            0.582684,
            0.723742,
            0.0221155,
            0,
            0.603677,
            0.713542,
            0.0207435,
            0,
            0.625106,
            0.702755,
            0.019434,
            0,
            0.646998,
            0.691484,
            0.0182046,
            0,
            0.66939,
            0.680531,
            0.0170771,
            0,
            0.692324,
            0.66953,
            0.0160339,
            0,
            0.715849,
            0.658126,
            0.0150677,
            0,
            0.740028,
            0.646933,
            0.0141551,
            0,
            0.764937,
            0.636107,
            0.0133179,
            0,
            0.790673,
            0.625271,
            0.0125284,
            0,
            0.817358,
            0.615225,
            0.0117937,
            0,
            0.84515,
            0.605678,
            0.0111181,
            0,
            0.874244,
            0.59583,
            0.0104759,
            0,
            0.904828,
            0.585704,
            0.00986672,
            0,
            0.936508,
            0.575413,
            0.00929712,
            0,
            0.968254,
            0.565373,
            0.00876713,
            0,
            1,
            1,
            0.214058,
            0,
            0,
            0.999999,
            0.214058,
            0,
            0,
            0.999994,
            0.214055,
            0,
            0,
            0.999966,
            0.214039,
            0,
            0.000259642,
            0.999893,
            0.213998,
            0,
            0.00200075,
            0.999737,
            0.21391,
            0,
            0.00527775,
            0.999449,
            0.213745,
            0,
            0.00983959,
            0.99896,
            0.213458,
            0,
            0.0154755,
            0.9979,
            0.212855,
            0,
            0.0220249,
            0.994278,
            0.210779,
            0,
            0.0293654,
            0.992254,
            0.20926,
            0,
            0.0374021,
            0.98881,
            0.206908,
            0,
            0.0460604,
            0.984715,
            0.204009,
            0,
            0.0552802,
            0.979738,
            0.200471,
            0,
            0.0650127,
            0.972884,
            0.195813,
            0,
            0.0752175,
            0.965996,
            0.190856,
            0,
            0.0858612,
            0.957974,
            0.185077,
            0,
            0.0969155,
            0.949155,
            0.17868,
            0,
            0.108356,
            0.939288,
            0.171513,
            0,
            0.120163,
            0.928996,
            0.163838,
            0,
            0.132319,
            0.919563,
            0.156246,
            0,
            0.144808,
            0.910004,
            0.148359,
            0,
            0.157618,
            0.900791,
            0.140417,
            0,
            0.170737,
            0.892135,
            0.132569,
            0,
            0.184155,
            0.883803,
            0.124741,
            0,
            0.197866,
            0.876034,
            0.117091,
            0,
            0.211861,
            0.869219,
            0.109835,
            0,
            0.226134,
            0.863062,
            0.102859,
            0,
            0.240682,
            0.857795,
            0.0962928,
            0,
            0.255499,
            0.853009,
            0.0900725,
            0,
            0.270583,
            0.848603,
            0.0842101,
            0,
            0.285931,
            0.844335,
            0.0786527,
            0,
            0.301542,
            0.840208,
            0.0734397,
            0,
            0.317415,
            0.836035,
            0.0685334,
            0,
            0.33355,
            0.83172,
            0.0639275,
            0,
            0.349948,
            0.827135,
            0.0595909,
            0,
            0.36661,
            0.822797,
            0.0556204,
            0,
            0.383539,
            0.818387,
            0.0519394,
            0,
            0.400738,
            0.813565,
            0.0485317,
            0,
            0.41821,
            0.808142,
            0.0453138,
            0,
            0.435961,
            0.802212,
            0.0423354,
            0,
            0.453997,
            0.79573,
            0.0395553,
            0,
            0.472324,
            0.788741,
            0.036988,
            0,
            0.490951,
            0.781093,
            0.0345688,
            0,
            0.509887,
            0.773597,
            0.0323297,
            0,
            0.529144,
            0.765622,
            0.0302719,
            0,
            0.548735,
            0.757083,
            0.0283477,
            0,
            0.568674,
            0.747992,
            0.0265562,
            0,
            0.588979,
            0.738591,
            0.0248844,
            0,
            0.609671,
            0.728719,
            0.0233342,
            0,
            0.630773,
            0.719146,
            0.0219081,
            0,
            0.652314,
            0.709165,
            0.0205711,
            0,
            0.674328,
            0.69875,
            0.0193248,
            0,
            0.696854,
            0.687884,
            0.0181582,
            0,
            0.719942,
            0.676818,
            0.0170746,
            0,
            0.743651,
            0.666247,
            0.0160718,
            0,
            0.768057,
            0.655284,
            0.0151262,
            0,
            0.793253,
            0.64401,
            0.0142561,
            0,
            0.819363,
            0.633353,
            0.0134327,
            0,
            0.846547,
            0.622674,
            0.012653,
            0,
            0.875017,
            0.612265,
            0.0119354,
            0,
            0.905021,
            0.602455,
            0.0112533,
            0,
            0.936508,
            0.593147,
            0.0106234,
            0,
            0.968254,
            0.583592,
            0.0100213,
            0,
            1,
            1,
            0.25717,
            0,
            0,
            1,
            0.25717,
            0,
            0,
            0.999992,
            0.257164,
            0,
            0,
            0.999958,
            0.257135,
            0,
            0.000641715,
            0.999864,
            0.25706,
            0,
            0.00305314,
            0.999666,
            0.256897,
            0,
            0.00700975,
            0.999302,
            0.256596,
            0,
            0.0122194,
            0.998663,
            0.25607,
            0,
            0.0184622,
            0.995607,
            0.254123,
            0,
            0.0255773,
            0.993094,
            0.252081,
            0,
            0.0334439,
            0.9907,
            0.249867,
            0,
            0.0419696,
            0.98594,
            0.246118,
            0,
            0.0510823,
            0.981214,
            0.242049,
            0,
            0.0607242,
            0.974966,
            0.236869,
            0,
            0.0708486,
            0.967589,
            0.230724,
            0,
            0.081417,
            0.95915,
            0.223635,
            0,
            0.0923974,
            0.950257,
            0.21596,
            0,
            0.103763,
            0.940165,
            0.207296,
            0,
            0.115491,
            0.929396,
            0.197901,
            0,
            0.127562,
            0.919288,
            0.188437,
            0,
            0.13996,
            0.909428,
            0.178762,
            0,
            0.15267,
            0.900105,
            0.169072,
            0,
            0.165679,
            0.891418,
            0.159478,
            0,
            0.178979,
            0.883347,
            0.15002,
            0,
            0.192558,
            0.875992,
            0.140813,
            0,
            0.20641,
            0.869466,
            0.13196,
            0,
            0.220529,
            0.863699,
            0.123501,
            0,
            0.234907,
            0.858553,
            0.115436,
            0,
            0.249542,
            0.854379,
            0.107901,
            0,
            0.264428,
            0.850894,
            0.10088,
            0,
            0.279564,
            0.847632,
            0.0942296,
            0,
            0.294947,
            0.844571,
            0.0879861,
            0,
            0.310575,
            0.84163,
            0.0821534,
            0,
            0.326448,
            0.838542,
            0.0766409,
            0,
            0.342566,
            0.835412,
            0.0715322,
            0,
            0.358929,
            0.831899,
            0.0666883,
            0,
            0.37554,
            0.828177,
            0.0622175,
            0,
            0.392399,
            0.82416,
            0.0580452,
            0,
            0.409511,
            0.820393,
            0.054267,
            0,
            0.426878,
            0.816068,
            0.0507172,
            0,
            0.444506,
            0.811201,
            0.0474041,
            0,
            0.4624,
            0.805785,
            0.0443174,
            0,
            0.480566,
            0.799878,
            0.0414562,
            0,
            0.499013,
            0.793469,
            0.0388147,
            0,
            0.517749,
            0.786473,
            0.0363453,
            0,
            0.536785,
            0.778874,
            0.0340225,
            0,
            0.556134,
            0.771277,
            0.0318599,
            0,
            0.575809,
            0.763426,
            0.0298859,
            0,
            0.595827,
            0.755044,
            0.0280357,
            0,
            0.616207,
            0.746161,
            0.0262979,
            0,
            0.636973,
            0.737124,
            0.0247295,
            0,
            0.65815,
            0.72761,
            0.0232514,
            0,
            0.679772,
            0.717822,
            0.0218755,
            0,
            0.701876,
            0.708279,
            0.0205942,
            0,
            0.724509,
            0.698333,
            0.0193947,
            0,
            0.74773,
            0.68802,
            0.0182717,
            0,
            0.771609,
            0.677321,
            0.0172044,
            0,
            0.79624,
            0.666504,
            0.0162122,
            0,
            0.821743,
            0.656184,
            0.0152924,
            0,
            0.84828,
            0.64556,
            0.0144326,
            0,
            0.876069,
            0.634636,
            0.0136157,
            0,
            0.905404,
            0.624124,
            0.0128612,
            0,
            0.936508,
            0.613914,
            0.0121435,
            0,
            0.968254,
            0.603589,
            0.0114887,
            0,
            1,
            1,
            0.307946,
            0,
            0,
            0.999999,
            0.307945,
            0,
            0,
            0.999988,
            0.307934,
            0,
            0.0000204479,
            0.999944,
            0.307886,
            0,
            0.00127833,
            0.999824,
            0.307756,
            0,
            0.00445047,
            0.999565,
            0.30748,
            0,
            0.00914673,
            0.999085,
            0.306966,
            0,
            0.0150498,
            0.998103,
            0.306004,
            0,
            0.0219367,
            0.994249,
            0.303028,
            0,
            0.0296485,
            0.991807,
            0.300435,
            0,
            0.038068,
            0.987773,
            0.296554,
            0,
            0.0471062,
            0.982673,
            0.2916,
            0,
            0.0566942,
            0.976623,
            0.285641,
            0,
            0.0667768,
            0.968757,
            0.27815,
            0,
            0.0773099,
            0.959849,
            0.269529,
            0,
            0.088257,
            0.950663,
            0.260248,
            0,
            0.0995879,
            0.940129,
            0.249704,
            0,
            0.111277,
            0.92895,
            0.238291,
            0,
            0.123304,
            0.917996,
            0.226501,
            0,
            0.13565,
            0.907813,
            0.214669,
            0,
            0.148299,
            0.898305,
            0.202835,
            0,
            0.161237,
            0.889626,
            0.191158,
            0,
            0.174455,
            0.88175,
            0.179695,
            0,
            0.187941,
            0.874715,
            0.168548,
            0,
            0.201687,
            0.868746,
            0.15792,
            0,
            0.215687,
            0.863703,
            0.147807,
            0,
            0.229933,
            0.859315,
            0.138149,
            0,
            0.24442,
            0.855538,
            0.128993,
            0,
            0.259145,
            0.852428,
            0.120414,
            0,
            0.274103,
            0.850168,
            0.112498,
            0,
            0.289293,
            0.848132,
            0.105054,
            0,
            0.304711,
            0.846291,
            0.0981087,
            0,
            0.320357,
            0.844431,
            0.0915942,
            0,
            0.33623,
            0.842493,
            0.0855056,
            0,
            0.35233,
            0.840368,
            0.0798204,
            0,
            0.368658,
            0.83798,
            0.0745097,
            0,
            0.385214,
            0.83523,
            0.0695424,
            0,
            0.402002,
            0.832091,
            0.0649092,
            0,
            0.419023,
            0.828667,
            0.0606291,
            0,
            0.436282,
            0.824805,
            0.0566523,
            0,
            0.453782,
            0.820988,
            0.0530229,
            0,
            0.471529,
            0.816635,
            0.0496364,
            0,
            0.489528,
            0.811725,
            0.0464658,
            0,
            0.507788,
            0.806316,
            0.0435082,
            0,
            0.526317,
            0.800469,
            0.0407873,
            0,
            0.545124,
            0.794107,
            0.038255,
            0,
            0.564221,
            0.787218,
            0.0358825,
            0,
            0.583621,
            0.779872,
            0.0336785,
            0,
            0.603341,
            0.772097,
            0.0316379,
            0,
            0.623397,
            0.764484,
            0.0297379,
            0,
            0.643812,
            0.756428,
            0.0279581,
            0,
            0.664611,
            0.748022,
            0.0263153,
            0,
            0.685824,
            0.739268,
            0.0247799,
            0,
            0.707488,
            0.73024,
            0.0233385,
            0,
            0.729646,
            0.720893,
            0.0220035,
            0,
            0.752354,
            0.71119,
            0.0207555,
            0,
            0.77568,
            0.701791,
            0.0195843,
            0,
            0.799715,
            0.692184,
            0.0184891,
            0,
            0.824574,
            0.682258,
            0.0174541,
            0,
            0.850417,
            0.67206,
            0.0164873,
            0,
            0.877466,
            0.661717,
            0.0155959,
            0,
            0.90604,
            0.651462,
            0.0147519,
            0,
            0.936528,
            0.641467,
            0.0139727,
            0,
            0.968254,
            0.631229,
            0.0132363,
            0,
            1,
            1,
            0.367573,
            0,
            0,
            0.999999,
            0.367571,
            0,
            0,
            0.999984,
            0.367553,
            0,
            0.000183382,
            0.999925,
            0.367473,
            0,
            0.00225254,
            0.999759,
            0.367259,
            0,
            0.00628165,
            0.99941,
            0.366801,
            0,
            0.0117858,
            0.998739,
            0.365946,
            0,
            0.0184359,
            0.995529,
            0.363191,
            0,
            0.0260114,
            0.992875,
            0.360171,
            0,
            0.0343581,
            0.989135,
            0.355981,
            0,
            0.0433637,
            0.984166,
            0.350401,
            0,
            0.0529438,
            0.977871,
            0.343348,
            0,
            0.0630334,
            0.96951,
            0.334341,
            0,
            0.0735805,
            0.959964,
            0.323862,
            0,
            0.0845437,
            0.950162,
            0.312521,
            0,
            0.095889,
            0.938882,
            0.299577,
            0,
            0.107588,
            0.926992,
            0.285573,
            0,
            0.119617,
            0.915589,
            0.271212,
            0,
            0.131957,
            0.904791,
            0.256611,
            0,
            0.144591,
            0.895177,
            0.242224,
            0,
            0.157503,
            0.886403,
            0.227952,
            0,
            0.170682,
            0.878957,
            0.214192,
            0,
            0.184117,
            0.872418,
            0.200795,
            0,
            0.197799,
            0.867029,
            0.188015,
            0,
            0.21172,
            0.862835,
            0.175975,
            0,
            0.225873,
            0.859411,
            0.164526,
            0,
            0.240253,
            0.856655,
            0.153693,
            0,
            0.254854,
            0.854519,
            0.14352,
            0,
            0.269673,
            0.852828,
            0.13397,
            0,
            0.284707,
            0.851412,
            0.124984,
            0,
            0.299953,
            0.850609,
            0.116748,
            0,
            0.315408,
            0.849855,
            0.10905,
            0,
            0.331073,
            0.849017,
            0.101839,
            0,
            0.346946,
            0.848079,
            0.0951359,
            0,
            0.363028,
            0.846911,
            0.0888774,
            0,
            0.379318,
            0.845445,
            0.0830375,
            0,
            0.395818,
            0.84362,
            0.0775844,
            0,
            0.41253,
            0.841411,
            0.0725054,
            0,
            0.429457,
            0.838768,
            0.0677691,
            0,
            0.446602,
            0.835801,
            0.0634016,
            0,
            0.463968,
            0.832341,
            0.0593095,
            0,
            0.481561,
            0.828424,
            0.0555121,
            0,
            0.499386,
            0.824312,
            0.052024,
            0,
            0.51745,
            0.819918,
            0.0487865,
            0,
            0.535761,
            0.815072,
            0.0457801,
            0,
            0.554328,
            0.809863,
            0.0430184,
            0,
            0.573162,
            0.804164,
            0.0404245,
            0,
            0.592275,
            0.798034,
            0.0380146,
            0,
            0.611681,
            0.791436,
            0.0357436,
            0,
            0.631398,
            0.784498,
            0.0336475,
            0,
            0.651445,
            0.777125,
            0.0316666,
            0,
            0.671845,
            0.769365,
            0.0298122,
            0,
            0.692628,
            0.761579,
            0.0281001,
            0,
            0.713827,
            0.753746,
            0.0265049,
            0,
            0.735484,
            0.745573,
            0.0250067,
            0,
            0.75765,
            0.737083,
            0.0236026,
            0,
            0.78039,
            0.728545,
            0.0223302,
            0,
            0.803789,
            0.719691,
            0.0211243,
            0,
            0.82796,
            0.710569,
            0.0199983,
            0,
            0.853056,
            0.701216,
            0.0189569,
            0,
            0.879298,
            0.692094,
            0.0179702,
            0,
            0.907014,
            0.682909,
            0.0170418,
            0,
            0.936691,
            0.673509,
            0.0161732,
            0,
            0.968254,
            0.663863,
            0.0153406,
            0,
            1,
            1,
            0.437395,
            0,
            0,
            0.999998,
            0.437394,
            0,
            0,
            0.99998,
            0.437363,
            0,
            0.000616704,
            0.999891,
            0.437232,
            0,
            0.00367925,
            0.999656,
            0.436877,
            0,
            0.00867446,
            0.999148,
            0.436121,
            0,
            0.0150679,
            0.997959,
            0.434564,
            0,
            0.022531,
            0.993464,
            0.430134,
            0,
            0.0308507,
            0.990606,
            0.426077,
            0,
            0.0398805,
            0.985027,
            0.419397,
            0,
            0.0495148,
            0.978491,
            0.41118,
            0,
            0.0596749,
            0.969643,
            0.40048,
            0,
            0.0703001,
            0.959189,
            0.38769,
            0,
            0.0813427,
            0.948223,
            0.373575,
            0,
            0.0927641,
            0.935955,
            0.357622,
            0,
            0.104533,
            0.923237,
            0.34043,
            0,
            0.116624,
            0.911074,
            0.322735,
            0,
            0.129015,
            0.899724,
            0.30479,
            0,
            0.141687,
            0.890189,
            0.287392,
            0,
            0.154626,
            0.881796,
            0.270248,
            0,
            0.167818,
            0.874781,
            0.253659,
            0,
            0.181252,
            0.869166,
            0.237786,
            0,
            0.194918,
            0.864725,
            0.222618,
            0,
            0.208807,
            0.861565,
            0.208356,
            0,
            0.222913,
            0.859284,
            0.194867,
            0,
            0.237229,
            0.857677,
            0.18212,
            0,
            0.25175,
            0.856714,
            0.17018,
            0,
            0.266473,
            0.856155,
            0.158969,
            0,
            0.281392,
            0.8558,
            0.148413,
            0,
            0.296505,
            0.855672,
            0.138578,
            0,
            0.311811,
            0.855538,
            0.129345,
            0,
            0.327306,
            0.855689,
            0.120861,
            0,
            0.342991,
            0.855767,
            0.112969,
            0,
            0.358864,
            0.855618,
            0.105593,
            0,
            0.374925,
            0.85525,
            0.0987451,
            0,
            0.391176,
            0.854583,
            0.0923727,
            0,
            0.407616,
            0.853534,
            0.0864143,
            0,
            0.424249,
            0.852061,
            0.0808338,
            0,
            0.441076,
            0.850253,
            0.0756771,
            0,
            0.4581,
            0.848004,
            0.0708612,
            0,
            0.475324,
            0.845333,
            0.0663784,
            0,
            0.492754,
            0.842376,
            0.0622631,
            0,
            0.510394,
            0.838956,
            0.0584112,
            0,
            0.528251,
            0.835121,
            0.0548328,
            0,
            0.546331,
            0.830842,
            0.0514838,
            0,
            0.564644,
            0.826212,
            0.048355,
            0,
            0.583198,
            0.821522,
            0.0454714,
            0,
            0.602005,
            0.816551,
            0.0428263,
            0,
            0.621078,
            0.811211,
            0.0403612,
            0,
            0.640434,
            0.805479,
            0.038039,
            0,
            0.660089,
            0.799409,
            0.0358739,
            0,
            0.680066,
            0.79306,
            0.0338727,
            0,
            0.70039,
            0.786395,
            0.0319985,
            0,
            0.721094,
            0.779416,
            0.030241,
            0,
            0.742215,
            0.77214,
            0.0285951,
            0,
            0.7638,
            0.764636,
            0.0270747,
            0,
            0.785912,
            0.756836,
            0.0256354,
            0,
            0.808628,
            0.749315,
            0.0243027,
            0,
            0.832055,
            0.741561,
            0.0230497,
            0,
            0.856338,
            0.733589,
            0.0218801,
            0,
            0.88169,
            0.725479,
            0.020784,
            0,
            0.908441,
            0.717255,
            0.0197702,
            0,
            0.937125,
            0.708829,
            0.0188168,
            0,
            0.968254,
            0.700191,
            0.0179113,
            0,
            1,
            1,
            0.518937,
            0,
            0,
            0.999998,
            0.518933,
            0,
            0,
            0.999967,
            0.518883,
            0,
            0.00147741,
            0.999832,
            0.51866,
            0,
            0.00573221,
            0.999466,
            0.518057,
            0,
            0.011826,
            0.998644,
            0.516752,
            0,
            0.0192116,
            0.994458,
            0.512347,
            0,
            0.027573,
            0.991223,
            0.507675,
            0,
            0.0367099,
            0.985515,
            0.500188,
            0,
            0.046487,
            0.978308,
            0.490408,
            0,
            0.0568071,
            0.968359,
            0.477357,
            0,
            0.0675984,
            0.95682,
            0.461752,
            0,
            0.0788059,
            0.943929,
            0.443796,
            0,
            0.090386,
            0.930224,
            0.423893,
            0,
            0.102304,
            0.916514,
            0.402682,
            0,
            0.114532,
            0.903653,
            0.380914,
            0,
            0.127047,
            0.892315,
            0.359212,
            0,
            0.139828,
            0.882942,
            0.338102,
            0,
            0.152861,
            0.875438,
            0.31773,
            0,
            0.16613,
            0.869642,
            0.298186,
            0,
            0.179624,
            0.865304,
            0.279491,
            0,
            0.193332,
            0.862382,
            0.261804,
            0,
            0.207247,
            0.860666,
            0.245146,
            0,
            0.22136,
            0.859788,
            0.229406,
            0,
            0.235666,
            0.859608,
            0.214605,
            0,
            0.250158,
            0.859912,
            0.200691,
            0,
            0.264832,
            0.86053,
            0.187623,
            0,
            0.279684,
            0.861368,
            0.17539,
            0,
            0.294711,
            0.862237,
            0.163901,
            0,
            0.309911,
            0.863127,
            0.153175,
            0,
            0.32528,
            0.863923,
            0.143147,
            0,
            0.340819,
            0.864567,
            0.133781,
            0,
            0.356524,
            0.865013,
            0.125042,
            0,
            0.372397,
            0.86539,
            0.116952,
            0,
            0.388438,
            0.865591,
            0.109476,
            0,
            0.404645,
            0.865517,
            0.102542,
            0,
            0.421022,
            0.865084,
            0.0960688,
            0,
            0.437569,
            0.864309,
            0.0900499,
            0,
            0.454287,
            0.863151,
            0.0844328,
            0,
            0.471181,
            0.861649,
            0.0792218,
            0,
            0.488253,
            0.859742,
            0.0743482,
            0,
            0.505507,
            0.857446,
            0.0697963,
            0,
            0.522947,
            0.854757,
            0.0655364,
            0,
            0.54058,
            0.851783,
            0.061608,
            0,
            0.558412,
            0.848516,
            0.0579701,
            0,
            0.576449,
            0.844897,
            0.0545742,
            0,
            0.594701,
            0.840956,
            0.0514167,
            0,
            0.613178,
            0.836676,
            0.0484598,
            0,
            0.631892,
            0.832075,
            0.0456934,
            0,
            0.650856,
            0.827191,
            0.0431178,
            0,
            0.670088,
            0.822295,
            0.0407718,
            0,
            0.689606,
            0.817294,
            0.0386032,
            0,
            0.709434,
            0.812013,
            0.0365675,
            0,
            0.7296,
            0.806465,
            0.0346547,
            0,
            0.750138,
            0.800691,
            0.0328717,
            0,
            0.771093,
            0.794709,
            0.031211,
            0,
            0.792519,
            0.788493,
            0.0296504,
            0,
            0.814488,
            0.782049,
            0.0281782,
            0,
            0.837097,
            0.775403,
            0.0267965,
            0,
            0.860481,
            0.76857,
            0.0255002,
            0,
            0.884842,
            0.761536,
            0.0242759,
            0,
            0.910494,
            0.754303,
            0.0231142,
            0,
            0.937985,
            0.74692,
            0.0220305,
            0,
            0.968254,
            0.739745,
            0.0210192,
            0,
            1,
            1,
            0.613914,
            0,
            0,
            0.999996,
            0.613907,
            0,
            0.0000963597,
            0.999942,
            0.613814,
            0,
            0.00301247,
            0.999704,
            0.613407,
            0,
            0.00870385,
            0.999046,
            0.612302,
            0,
            0.0160714,
            0.995516,
            0.608266,
            0,
            0.0245899,
            0.991726,
            0.602863,
            0,
            0.0339681,
            0.985157,
            0.593956,
            0,
            0.0440254,
            0.97642,
            0.581748,
            0,
            0.0546409,
            0.964404,
            0.565183,
            0,
            0.0657284,
            0.950601,
            0.545273,
            0,
            0.0772246,
            0.935158,
            0.522129,
            0,
            0.0890812,
            0.919364,
            0.496782,
            0,
            0.10126,
            0.904754,
            0.470571,
            0,
            0.113731,
            0.89176,
            0.444037,
            0,
            0.126469,
            0.881492,
            0.418322,
            0,
            0.139454,
            0.873656,
            0.393522,
            0,
            0.15267,
            0.868053,
            0.369795,
            0,
            0.166101,
            0.864336,
            0.347171,
            0,
            0.179736,
            0.862259,
            0.325737,
            0,
            0.193565,
            0.861556,
            0.305532,
            0,
            0.207578,
            0.861776,
            0.286416,
            0,
            0.221769,
            0.862661,
            0.268355,
            0,
            0.23613,
            0.864015,
            0.251334,
            0,
            0.250656,
            0.865711,
            0.235352,
            0,
            0.265343,
            0.867519,
            0.220302,
            0,
            0.280187,
            0.869351,
            0.206161,
            0,
            0.295183,
            0.871144,
            0.192908,
            0,
            0.31033,
            0.872839,
            0.180505,
            0,
            0.325624,
            0.874307,
            0.168848,
            0,
            0.341065,
            0.875667,
            0.158021,
            0,
            0.35665,
            0.876758,
            0.147877,
            0,
            0.37238,
            0.87764,
            0.138441,
            0,
            0.388253,
            0.878237,
            0.129627,
            0,
            0.404269,
            0.878563,
            0.121415,
            0,
            0.42043,
            0.878572,
            0.113741,
            0,
            0.436735,
            0.87842,
            0.106652,
            0,
            0.453187,
            0.878057,
            0.100097,
            0,
            0.469786,
            0.877413,
            0.0940128,
            0,
            0.486536,
            0.87646,
            0.0883462,
            0,
            0.503439,
            0.875233,
            0.0830924,
            0,
            0.520498,
            0.8737,
            0.0781975,
            0,
            0.537717,
            0.871873,
            0.07364,
            0,
            0.555102,
            0.86978,
            0.0694103,
            0,
            0.572657,
            0.867405,
            0.0654696,
            0,
            0.59039,
            0.864751,
            0.0617914,
            0,
            0.608307,
            0.861818,
            0.0583491,
            0,
            0.626419,
            0.858645,
            0.0551443,
            0,
            0.644733,
            0.855307,
            0.0521894,
            0,
            0.663264,
            0.851736,
            0.0494334,
            0,
            0.682025,
            0.847927,
            0.0468504,
            0,
            0.701032,
            0.843888,
            0.0444261,
            0,
            0.720308,
            0.839629,
            0.0421497,
            0,
            0.739875,
            0.835158,
            0.0400082,
            0,
            0.759764,
            0.830509,
            0.0380076,
            0,
            0.780014,
            0.825714,
            0.0361488,
            0,
            0.800673,
            0.820729,
            0.0343956,
            0,
            0.821803,
            0.815751,
            0.0327781,
            0,
            0.843492,
            0.810752,
            0.031275,
            0,
            0.86586,
            0.805587,
            0.0298542,
            0,
            0.889087,
            0.800317,
            0.0285397,
            0,
            0.913466,
            0.79489,
            0.0272948,
            0,
            0.93952,
            0.789314,
            0.0261139,
            0,
            0.96835,
            0.783593,
            0.0249938,
            0,
            1,
            1,
            0.724258,
            0,
            0,
            0.999992,
            0.724243,
            0,
            0.000726889,
            0.99987,
            0.724044,
            0,
            0.00569574,
            0.999336,
            0.72317,
            0,
            0.0131702,
            0.996271,
            0.719432,
            0,
            0.0220738,
            0.991159,
            0.712576,
            0,
            0.0319405,
            0.982465,
            0.700927,
            0,
            0.0425202,
            0.97049,
            0.684297,
            0,
            0.0536599,
            0.953973,
            0.661244,
            0,
            0.065258,
            0.935546,
            0.633804,
            0,
            0.0772427,
            0.916596,
            0.603071,
            0,
            0.0895616,
            0.899353,
            0.57105,
            0,
            0.102175,
            0.885216,
            0.539206,
            0,
            0.11505,
            0.875076,
            0.508714,
            0,
            0.128164,
            0.868334,
            0.479571,
            0,
            0.141495,
            0.864414,
            0.451796,
            0,
            0.155026,
            0.862678,
            0.425328,
            0,
            0.168745,
            0.862835,
            0.400352,
            0,
            0.182639,
            0.864067,
            0.376532,
            0,
            0.196699,
            0.866086,
            0.35391,
            0,
            0.210915,
            0.868557,
            0.332424,
            0,
            0.225282,
            0.871271,
            0.312053,
            0,
            0.239792,
            0.874058,
            0.292764,
            0,
            0.25444,
            0.8768,
            0.27453,
            0,
            0.269223,
            0.87939,
            0.257297,
            0,
            0.284135,
            0.8819,
            0.24114,
            0,
            0.299174,
            0.884187,
            0.225934,
            0,
            0.314337,
            0.886262,
            0.211669,
            0,
            0.329622,
            0.888119,
            0.198311,
            0,
            0.345026,
            0.889709,
            0.185783,
            0,
            0.360549,
            0.891054,
            0.174063,
            0,
            0.376189,
            0.892196,
            0.163143,
            0,
            0.391946,
            0.893101,
            0.152952,
            0,
            0.407819,
            0.893803,
            0.143475,
            0,
            0.423808,
            0.894277,
            0.134647,
            0,
            0.439914,
            0.894532,
            0.126434,
            0,
            0.456137,
            0.894576,
            0.1188,
            0,
            0.472479,
            0.894393,
            0.111694,
            0,
            0.48894,
            0.893976,
            0.105069,
            0,
            0.505523,
            0.893346,
            0.0989077,
            0,
            0.52223,
            0.892502,
            0.0931724,
            0,
            0.539064,
            0.891441,
            0.0878276,
            0,
            0.556028,
            0.890276,
            0.082903,
            0,
            0.573125,
            0.888972,
            0.0783505,
            0,
            0.590361,
            0.887469,
            0.0741083,
            0,
            0.607741,
            0.885785,
            0.0701633,
            0,
            0.62527,
            0.883914,
            0.0664835,
            0,
            0.642957,
            0.881872,
            0.0630567,
            0,
            0.660809,
            0.879651,
            0.0598527,
            0,
            0.678836,
            0.877267,
            0.0568615,
            0,
            0.69705,
            0.874717,
            0.05406,
            0,
            0.715465,
            0.872012,
            0.0514378,
            0,
            0.734098,
            0.869157,
            0.0489805,
            0,
            0.752968,
            0.866155,
            0.0466727,
            0,
            0.772101,
            0.863014,
            0.0445056,
            0,
            0.791529,
            0.859748,
            0.0424733,
            0,
            0.81129,
            0.856416,
            0.0405957,
            0,
            0.831438,
            0.852958,
            0.0388273,
            0,
            0.852044,
            0.849382,
            0.0371619,
            0,
            0.87321,
            0.845694,
            0.0355959,
            0,
            0.89509,
            0.841893,
            0.0341155,
            0,
            0.917932,
            0.837981,
            0.0327141,
            0,
            0.942204,
            0.833963,
            0.0313856,
            0,
            0.968981,
            0.829847,
            0.0301275,
            0,
            1,
            1,
            0.85214,
            0,
            0,
            0.999969,
            0.852095,
            0,
            0.00279627,
            0.999483,
            0.851408,
            0,
            0.0107635,
            0.994545,
            0.84579,
            0,
            0.0206454,
            0.986188,
            0.835231,
            0,
            0.0315756,
            0.969847,
            0.814687,
            0,
            0.0432021,
            0.945951,
            0.783735,
            0,
            0.0553396,
            0.91917,
            0.746074,
            0,
            0.0678766,
            0.895488,
            0.706938,
            0,
            0.0807395,
            0.878232,
            0.669534,
            0,
            0.0938767,
            0.868252,
            0.635168,
            0,
            0.10725,
            0.863873,
            0.603069,
            0,
            0.120832,
            0.863369,
            0.572514,
            0,
            0.134598,
            0.86545,
            0.543169,
            0,
            0.148533,
            0.868803,
            0.514578,
            0,
            0.16262,
            0.872794,
            0.486762,
            0,
            0.176849,
            0.87702,
            0.459811,
            0,
            0.19121,
            0.881054,
            0.433654,
            0,
            0.205694,
            0.884974,
            0.408574,
            0,
            0.220294,
            0.888587,
            0.384525,
            0,
            0.235005,
            0.891877,
            0.36156,
            0,
            0.24982,
            0.894793,
            0.339661,
            0,
            0.264737,
            0.89743,
            0.318913,
            0,
            0.279751,
            0.899796,
            0.299302,
            0,
            0.294859,
            0.901943,
            0.280843,
            0,
            0.310058,
            0.903858,
            0.263481,
            0,
            0.325346,
            0.905574,
            0.247197,
            0,
            0.340721,
            0.907069,
            0.231915,
            0,
            0.356181,
            0.908379,
            0.217614,
            0,
            0.371725,
            0.90952,
            0.20425,
            0,
            0.387353,
            0.910483,
            0.191758,
            0,
            0.403063,
            0.91128,
            0.180092,
            0,
            0.418854,
            0.911936,
            0.169222,
            0,
            0.434727,
            0.912454,
            0.159098,
            0,
            0.450682,
            0.912835,
            0.149668,
            0,
            0.466718,
            0.913078,
            0.140884,
            0,
            0.482837,
            0.913192,
            0.132709,
            0,
            0.499038,
            0.913175,
            0.125095,
            0,
            0.515324,
            0.91304,
            0.118012,
            0,
            0.531695,
            0.912781,
            0.111417,
            0,
            0.548153,
            0.91241,
            0.105281,
            0,
            0.5647,
            0.911924,
            0.0995691,
            0,
            0.581338,
            0.911331,
            0.0942531,
            0,
            0.59807,
            0.910637,
            0.0893076,
            0,
            0.6149,
            0.90984,
            0.0846998,
            0,
            0.63183,
            0.908941,
            0.0804044,
            0,
            0.648865,
            0.907944,
            0.0763984,
            0,
            0.666011,
            0.906857,
            0.0726638,
            0,
            0.683273,
            0.90568,
            0.0691783,
            0,
            0.700659,
            0.904416,
            0.0659222,
            0,
            0.718176,
            0.903067,
            0.0628782,
            0,
            0.735834,
            0.901637,
            0.0600307,
            0,
            0.753646,
            0.900128,
            0.0573647,
            0,
            0.771625,
            0.898544,
            0.0548668,
            0,
            0.78979,
            0.89689,
            0.052527,
            0,
            0.808162,
            0.895165,
            0.0503306,
            0,
            0.826771,
            0.893371,
            0.0482668,
            0,
            0.845654,
            0.891572,
            0.0463605,
            0,
            0.864863,
            0.889763,
            0.0445998,
            0,
            0.884472,
            0.887894,
            0.0429451,
            0,
            0.904592,
            0.885967,
            0.0413884,
            0,
            0.925407,
            0.883984,
            0.0399225,
            0,
            0.947271,
            0.881945,
            0.0385405,
            0,
            0.97105,
            0.879854,
            0.0372362,
            0,
            1,
            0.999804,
            0.995833,
            0,
            0,
            0.938155,
            0.933611,
            0,
            0.0158731,
            0.864755,
            0.854311,
            0,
            0.0317461,
            0.888594,
            0.865264,
            0,
            0.0476191,
            0.905575,
            0.863922,
            0,
            0.0634921,
            0.915125,
            0.850558,
            0,
            0.0793651,
            0.920665,
            0.829254,
            0,
            0.0952381,
            0.924073,
            0.802578,
            0,
            0.111111,
            0.926304,
            0.772211,
            0,
            0.126984,
            0.927829,
            0.739366,
            0,
            0.142857,
            0.928924,
            0.705033,
            0,
            0.15873,
            0.92973,
            0.670019,
            0,
            0.174603,
            0.930339,
            0.634993,
            0,
            0.190476,
            0.930811,
            0.600485,
            0,
            0.206349,
            0.931191,
            0.566897,
            0,
            0.222222,
            0.93149,
            0.534485,
            0,
            0.238095,
            0.931737,
            0.503429,
            0,
            0.253968,
            0.931939,
            0.473811,
            0,
            0.269841,
            0.932108,
            0.445668,
            0,
            0.285714,
            0.93225,
            0.418993,
            0,
            0.301587,
            0.932371,
            0.393762,
            0,
            0.31746,
            0.932474,
            0.369939,
            0,
            0.333333,
            0.932562,
            0.347479,
            0,
            0.349206,
            0.932638,
            0.326336,
            0,
            0.365079,
            0.932703,
            0.306462,
            0,
            0.380952,
            0.93276,
            0.287805,
            0,
            0.396825,
            0.932809,
            0.270313,
            0,
            0.412698,
            0.932851,
            0.253933,
            0,
            0.428571,
            0.932887,
            0.23861,
            0,
            0.444444,
            0.932917,
            0.224289,
            0,
            0.460317,
            0.932943,
            0.210917,
            0,
            0.47619,
            0.932965,
            0.19844,
            0,
            0.492063,
            0.932982,
            0.186807,
            0,
            0.507937,
            0.932995,
            0.175966,
            0,
            0.52381,
            0.933005,
            0.165869,
            0,
            0.539683,
            0.933011,
            0.156468,
            0,
            0.555556,
            0.933013,
            0.147719,
            0,
            0.571429,
            0.933013,
            0.139579,
            0,
            0.587302,
            0.93301,
            0.132007,
            0,
            0.603175,
            0.933004,
            0.124965,
            0,
            0.619048,
            0.932994,
            0.118416,
            0,
            0.634921,
            0.932982,
            0.112326,
            0,
            0.650794,
            0.932968,
            0.106663,
            0,
            0.666667,
            0.93295,
            0.101397,
            0,
            0.68254,
            0.932931,
            0.0964993,
            0,
            0.698413,
            0.932908,
            0.0919438,
            0,
            0.714286,
            0.932883,
            0.0877057,
            0,
            0.730159,
            0.932856,
            0.0837623,
            0,
            0.746032,
            0.932827,
            0.0800921,
            0,
            0.761905,
            0.932796,
            0.0766754,
            0,
            0.777778,
            0.932762,
            0.0734936,
            0,
            0.793651,
            0.932727,
            0.0705296,
            0,
            0.809524,
            0.932689,
            0.0677676,
            0,
            0.825397,
            0.93265,
            0.0651929,
            0,
            0.84127,
            0.932609,
            0.0627917,
            0,
            0.857143,
            0.932565,
            0.0605515,
            0,
            0.873016,
            0.932521,
            0.0584606,
            0,
            0.888889,
            0.932474,
            0.0565082,
            0,
            0.904762,
            0.932427,
            0.0546841,
            0,
            0.920635,
            0.932377,
            0.0529793,
            0,
            0.936508,
            0.932326,
            0.0513851,
            0,
            0.952381,
            0.932274,
            0.0498936,
            0,
            0.968254,
            0.93222,
            0.0484975,
            0,
            0.984127,
            0.932164,
            0.0471899,
            0,
            1
        ];
        // data textures
        const ltc_float_1 = new Float32Array(LTC_MAT_1);
        const ltc_float_2 = new Float32Array(LTC_MAT_2);
        _three.UniformsLib.LTC_FLOAT_1 = new _three.DataTexture(ltc_float_1, 64, 64, _three.RGBAFormat, _three.FloatType, _three.UVMapping, _three.ClampToEdgeWrapping, _three.ClampToEdgeWrapping, _three.LinearFilter, _three.NearestFilter, 1);
        _three.UniformsLib.LTC_FLOAT_2 = new _three.DataTexture(ltc_float_2, 64, 64, _three.RGBAFormat, _three.FloatType, _three.UVMapping, _three.ClampToEdgeWrapping, _three.ClampToEdgeWrapping, _three.LinearFilter, _three.NearestFilter, 1);
        const ltc_half_1 = new Uint16Array(LTC_MAT_1.length);
        LTC_MAT_1.forEach(function(x, index) {
            ltc_half_1[index] = _three.DataUtils.toHalfFloat(x);
        });
        const ltc_half_2 = new Uint16Array(LTC_MAT_2.length);
        LTC_MAT_2.forEach(function(x, index) {
            ltc_half_2[index] = _three.DataUtils.toHalfFloat(x);
        });
        _three.UniformsLib.LTC_HALF_1 = new _three.DataTexture(ltc_half_1, 64, 64, _three.RGBAFormat, _three.HalfFloatType, _three.UVMapping, _three.ClampToEdgeWrapping, _three.ClampToEdgeWrapping, _three.LinearFilter, _three.NearestFilter, 1);
        _three.UniformsLib.LTC_HALF_2 = new _three.DataTexture(ltc_half_2, 64, 64, _three.RGBAFormat, _three.HalfFloatType, _three.UVMapping, _three.ClampToEdgeWrapping, _three.ClampToEdgeWrapping, _three.LinearFilter, _three.NearestFilter, 1);
    }
}

},{"three":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3iDYE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnrealBloomPass", ()=>UnrealBloomPass
);
var _three = require("three");
var _passJs = require("../postprocessing/Pass.js");
var _copyShaderJs = require("../shaders/CopyShader.js");
var _luminosityHighPassShaderJs = require("../shaders/LuminosityHighPassShader.js");
/**
 * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a
 * mip map chain of bloom textures and blurs them with different radii. Because
 * of the weighted combination of mips, and because larger blurs are done on
 * higher mips, this effect provides good quality and performance.
 *
 * Reference:
 * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/
 */ class UnrealBloomPass extends _passJs.Pass {
    constructor(resolution, strength, radius, threshold){
        super();
        this.strength = strength !== undefined ? strength : 1;
        this.radius = radius;
        this.threshold = threshold;
        this.resolution = resolution !== undefined ? new _three.Vector2(resolution.x, resolution.y) : new _three.Vector2(256, 256);
        // create color only once here, reuse it later inside the render function
        this.clearColor = new _three.Color(0, 0, 0);
        // render targets
        const pars = {
            minFilter: _three.LinearFilter,
            magFilter: _three.LinearFilter,
            format: _three.RGBAFormat
        };
        this.renderTargetsHorizontal = [];
        this.renderTargetsVertical = [];
        this.nMips = 5;
        let resx = Math.round(this.resolution.x / 2);
        let resy = Math.round(this.resolution.y / 2);
        this.renderTargetBright = new _three.WebGLRenderTarget(resx, resy, pars);
        this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';
        this.renderTargetBright.texture.generateMipmaps = false;
        for(let i = 0; i < this.nMips; i++){
            const renderTargetHorizonal = new _three.WebGLRenderTarget(resx, resy, pars);
            renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;
            renderTargetHorizonal.texture.generateMipmaps = false;
            this.renderTargetsHorizontal.push(renderTargetHorizonal);
            const renderTargetVertical = new _three.WebGLRenderTarget(resx, resy, pars);
            renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;
            renderTargetVertical.texture.generateMipmaps = false;
            this.renderTargetsVertical.push(renderTargetVertical);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
        // luminosity high pass material
        if (_luminosityHighPassShaderJs.LuminosityHighPassShader === undefined) console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader');
        const highPassShader = _luminosityHighPassShaderJs.LuminosityHighPassShader;
        this.highPassUniforms = _three.UniformsUtils.clone(highPassShader.uniforms);
        this.highPassUniforms['luminosityThreshold'].value = threshold;
        this.highPassUniforms['smoothWidth'].value = 0.01;
        this.materialHighPassFilter = new _three.ShaderMaterial({
            uniforms: this.highPassUniforms,
            vertexShader: highPassShader.vertexShader,
            fragmentShader: highPassShader.fragmentShader,
            defines: {}
        });
        // Gaussian Blur Materials
        this.separableBlurMaterials = [];
        const kernelSizeArray = [
            3,
            5,
            7,
            9,
            11
        ];
        resx = Math.round(this.resolution.x / 2);
        resy = Math.round(this.resolution.y / 2);
        for(let i1 = 0; i1 < this.nMips; i1++){
            this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i1]));
            this.separableBlurMaterials[i1].uniforms['texSize'].value = new _three.Vector2(resx, resy);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
        // Composite material
        this.compositeMaterial = this.getCompositeMaterial(this.nMips);
        this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;
        this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;
        this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;
        this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;
        this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;
        this.compositeMaterial.uniforms['bloomStrength'].value = strength;
        this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;
        this.compositeMaterial.needsUpdate = true;
        const bloomFactors = [
            1,
            0.8,
            0.6,
            0.4,
            0.2
        ];
        this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;
        this.bloomTintColors = [
            new _three.Vector3(1, 1, 1),
            new _three.Vector3(1, 1, 1),
            new _three.Vector3(1, 1, 1),
            new _three.Vector3(1, 1, 1),
            new _three.Vector3(1, 1, 1)
        ];
        this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;
        // copy material
        if (_copyShaderJs.CopyShader === undefined) console.error('THREE.UnrealBloomPass relies on CopyShader');
        const copyShader = _copyShaderJs.CopyShader;
        this.copyUniforms = _three.UniformsUtils.clone(copyShader.uniforms);
        this.copyUniforms['opacity'].value = 1;
        this.materialCopy = new _three.ShaderMaterial({
            uniforms: this.copyUniforms,
            vertexShader: copyShader.vertexShader,
            fragmentShader: copyShader.fragmentShader,
            blending: _three.AdditiveBlending,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
        this.enabled = true;
        this.needsSwap = false;
        this._oldClearColor = new _three.Color();
        this.oldClearAlpha = 1;
        this.basic = new _three.MeshBasicMaterial();
        this.fsQuad = new _passJs.FullScreenQuad(null);
    }
    dispose() {
        for(let i = 0; i < this.renderTargetsHorizontal.length; i++)this.renderTargetsHorizontal[i].dispose();
        for(let i2 = 0; i2 < this.renderTargetsVertical.length; i2++)this.renderTargetsVertical[i2].dispose();
        this.renderTargetBright.dispose();
    }
    setSize(width, height) {
        let resx = Math.round(width / 2);
        let resy = Math.round(height / 2);
        this.renderTargetBright.setSize(resx, resy);
        for(let i = 0; i < this.nMips; i++){
            this.renderTargetsHorizontal[i].setSize(resx, resy);
            this.renderTargetsVertical[i].setSize(resx, resy);
            this.separableBlurMaterials[i].uniforms['texSize'].value = new _three.Vector2(resx, resy);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
    }
    render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
        renderer.getClearColor(this._oldClearColor);
        this.oldClearAlpha = renderer.getClearAlpha();
        const oldAutoClear = renderer.autoClear;
        renderer.autoClear = false;
        renderer.setClearColor(this.clearColor, 0);
        if (maskActive) renderer.state.buffers.stencil.setTest(false);
        // Render input to screen
        if (this.renderToScreen) {
            this.fsQuad.material = this.basic;
            this.basic.map = readBuffer.texture;
            renderer.setRenderTarget(null);
            renderer.clear();
            this.fsQuad.render(renderer);
        }
        // 1. Extract Bright Areas
        this.highPassUniforms['tDiffuse'].value = readBuffer.texture;
        this.highPassUniforms['luminosityThreshold'].value = this.threshold;
        this.fsQuad.material = this.materialHighPassFilter;
        renderer.setRenderTarget(this.renderTargetBright);
        renderer.clear();
        this.fsQuad.render(renderer);
        // 2. Blur All the mips progressively
        let inputRenderTarget = this.renderTargetBright;
        for(let i = 0; i < this.nMips; i++){
            this.fsQuad.material = this.separableBlurMaterials[i];
            this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;
            this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;
            renderer.setRenderTarget(this.renderTargetsHorizontal[i]);
            renderer.clear();
            this.fsQuad.render(renderer);
            this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;
            this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;
            renderer.setRenderTarget(this.renderTargetsVertical[i]);
            renderer.clear();
            this.fsQuad.render(renderer);
            inputRenderTarget = this.renderTargetsVertical[i];
        }
        // Composite All the mips
        this.fsQuad.material = this.compositeMaterial;
        this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;
        this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;
        this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;
        renderer.setRenderTarget(this.renderTargetsHorizontal[0]);
        renderer.clear();
        this.fsQuad.render(renderer);
        // Blend it additively over the input texture
        this.fsQuad.material = this.materialCopy;
        this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;
        if (maskActive) renderer.state.buffers.stencil.setTest(true);
        if (this.renderToScreen) {
            renderer.setRenderTarget(null);
            this.fsQuad.render(renderer);
        } else {
            renderer.setRenderTarget(readBuffer);
            this.fsQuad.render(renderer);
        }
        // Restore renderer settings
        renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
        renderer.autoClear = oldAutoClear;
    }
    getSeperableBlurMaterial(kernelRadius) {
        return new _three.ShaderMaterial({
            defines: {
                'KERNEL_RADIUS': kernelRadius,
                'SIGMA': kernelRadius
            },
            uniforms: {
                'colorTexture': {
                    value: null
                },
                'texSize': {
                    value: new _three.Vector2(0.5, 0.5)
                },
                'direction': {
                    value: new _three.Vector2(0.5, 0.5)
                }
            },
            vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
            fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
        });
    }
    getCompositeMaterial(nMips) {
        return new _three.ShaderMaterial({
            defines: {
                'NUM_MIPS': nMips
            },
            uniforms: {
                'blurTexture1': {
                    value: null
                },
                'blurTexture2': {
                    value: null
                },
                'blurTexture3': {
                    value: null
                },
                'blurTexture4': {
                    value: null
                },
                'blurTexture5': {
                    value: null
                },
                'dirtTexture': {
                    value: null
                },
                'bloomStrength': {
                    value: 1
                },
                'bloomFactors': {
                    value: null
                },
                'bloomTintColors': {
                    value: null
                },
                'bloomRadius': {
                    value: 0
                }
            },
            vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
            fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform sampler2D dirtTexture;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
        });
    }
}
UnrealBloomPass.BlurDirectionX = new _three.Vector2(1, 0);
UnrealBloomPass.BlurDirectionY = new _three.Vector2(0, 1);

},{"three":"ktPTu","../postprocessing/Pass.js":"i2IfB","../shaders/CopyShader.js":"d0PyX","../shaders/LuminosityHighPassShader.js":"j8C2Y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j8C2Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LuminosityHighPassShader", ()=>LuminosityHighPassShader
);
var _three = require("three");
/**
 * Luminosity
 * http://en.wikipedia.org/wiki/Luminosity
 */ const LuminosityHighPassShader = {
    shaderID: 'luminosityHighPass',
    uniforms: {
        'tDiffuse': {
            value: null
        },
        'luminosityThreshold': {
            value: 1
        },
        'smoothWidth': {
            value: 1
        },
        'defaultColor': {
            value: new _three.Color(0)
        },
        'defaultOpacity': {
            value: 0
        }
    },
    vertexShader: /* glsl */ `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: /* glsl */ `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
};

},{"three":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"31sSt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FilmPass", ()=>FilmPass
);
var _three = require("three");
var _passJs = require("../postprocessing/Pass.js");
var _filmShaderJs = require("../shaders/FilmShader.js");
class FilmPass extends _passJs.Pass {
    constructor(noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale){
        super();
        if (_filmShaderJs.FilmShader === undefined) console.error('THREE.FilmPass relies on FilmShader');
        const shader = _filmShaderJs.FilmShader;
        this.uniforms = _three.UniformsUtils.clone(shader.uniforms);
        this.material = new _three.ShaderMaterial({
            uniforms: this.uniforms,
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader
        });
        if (grayscale !== undefined) this.uniforms.grayscale.value = grayscale;
        if (noiseIntensity !== undefined) this.uniforms.nIntensity.value = noiseIntensity;
        if (scanlinesIntensity !== undefined) this.uniforms.sIntensity.value = scanlinesIntensity;
        if (scanlinesCount !== undefined) this.uniforms.sCount.value = scanlinesCount;
        this.fsQuad = new _passJs.FullScreenQuad(this.material);
    }
    render(renderer, writeBuffer, readBuffer, deltaTime /*, maskActive */ ) {
        this.uniforms['tDiffuse'].value = readBuffer.texture;
        this.uniforms['time'].value += deltaTime;
        if (this.renderToScreen) {
            renderer.setRenderTarget(null);
            this.fsQuad.render(renderer);
        } else {
            renderer.setRenderTarget(writeBuffer);
            if (this.clear) renderer.clear();
            this.fsQuad.render(renderer);
        }
    }
}

},{"three":"ktPTu","../postprocessing/Pass.js":"i2IfB","../shaders/FilmShader.js":"fQttT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fQttT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FilmShader", ()=>FilmShader
);
/**
 * Film grain & scanlines shader
 *
 * - ported from HLSL to WebGL / GLSL
 * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html
 *
 * Screen Space Static Postprocessor
 *
 * Produces an analogue noise overlay similar to a film grain / TV static
 *
 * Original implementation and noise algorithm
 * Pat 'Hawthorne' Shearon
 *
 * Optimized scanlines + noise version with intensity scaling
 * Georg 'Leviathan' Steinrohder
 *
 * This version is provided under a Creative Commons Attribution 3.0 License
 * http://creativecommons.org/licenses/by/3.0/
 */ const FilmShader = {
    uniforms: {
        'tDiffuse': {
            value: null
        },
        'time': {
            value: 0
        },
        'nIntensity': {
            value: 0.5
        },
        'sIntensity': {
            value: 0.05
        },
        'sCount': {
            value: 4096
        },
        'grayscale': {
            value: 1
        }
    },
    vertexShader: /* glsl */ `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: /* glsl */ `

		#include <common>

		// control parameter
		uniform float time;

		uniform bool grayscale;

		// noise effect intensity value (0 = no effect, 1 = full effect)
		uniform float nIntensity;

		// scanlines effect intensity value (0 = no effect, 1 = full effect)
		uniform float sIntensity;

		// scanlines effect count value (0 = no effect, 4096 = full effect)
		uniform float sCount;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

		// sample the source
			vec4 cTextureScreen = texture2D( tDiffuse, vUv );

		// make some noise
			float dx = rand( vUv + time );

		// add noise
			vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );

		// get us a sine and cosine
			vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );

		// add scanlines
			cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;

		// interpolate between source and result by intensity
			cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );

		// convert to grayscale if desired
			if( grayscale ) {

				cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );

			}

			gl_FragColor =  vec4( cResult, cTextureScreen.a );

		}`
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["70Ywo","a6i2s"], "a6i2s", "parcelRequire1287")

//# sourceMappingURL=reflection-fun.634ad707.js.map
