{"mappings":"A,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,Q,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,K,E,Q,E,E,S,E,O,C,I,E,A,M,uB,E,I,O,E,K,mB,C,C,E,S,S,C,C,C,E,C,C,E,C,C,E,E,kB,G,I,E,E,S,E,E,S,E,E,QEeA,OAAM,UAAkB,EAAA,OAEvB,YAAa,CAAO,CAAG,CAEtB,KAAK,CAAE,GAGP,IAAI,CAAC,WAAa,GAGlB,IAAI,CAAC,YAAc,IAEpB,CAEA,KAAM,CAAG,CAAE,CAAM,CAAE,CAAU,CAAE,CAAO,CAAG,CAExC,IAAM,EAAQ,IAAI,CAEZ,EAAS,IAAI,EAAA,WAAY,EAAM,SACrC,EAAO,QAAS,EAAM,MACtB,EAAO,iBAAkB,EAAM,eAC/B,EAAO,mBAAoB,EAAM,iBACjC,EAAO,KAAM,EAAK,SAAW,CAAI,EAEhC,GAAI,CAEH,EAAQ,EAAM,MAAO,GAEtB,CAAE,MAAQ,EAAI,CAER,EAEJ,EAAS,GAIT,QAAQ,MAAO,GAIhB,EAAM,QAAQ,UAAW,EAE1B,CAED,EAAG,EAAY,EAEhB,CAEA,MAAO,CAAI,CAAG,CAEb,IAAM,EAAQ,IAAI,CAwmBlB,SAAS,EAAiB,CAAI,CAAE,CAAE,CAAE,CAAE,CAAE,CAAe,CAAE,CAAc,CAAE,CAAU,CAAE,CAAK,CAAE,CAAG,EAE9F,GAAK,AAAM,GAAN,GAAW,AAAM,GAAN,EAAU,CAGzB,EAAK,OAAQ,EAAI,EAAG,EAAI,GACxB,MAED,CAEA,EAAkB,EAAkB,KAAK,GAAK,IAG9C,EAAK,KAAK,IAAK,GACf,EAAK,KAAK,IAAK,GAGf,IAAM,EAAM,AAAE,CAAA,EAAM,EAAI,EAAI,CAAA,EAAM,EAC5B,EAAM,AAAE,CAAA,EAAM,EAAI,EAAI,CAAA,EAAM,EAC5B,EAAM,KAAK,IAAK,GAAoB,EAAM,KAAK,IAAK,GAAoB,EACxE,EAAM,CAAE,KAAK,IAAK,GAAoB,EAAM,KAAK,IAAK,GAAoB,EAG5E,EAAM,EAAK,EACX,EAAM,EAAK,EACT,EAAO,EAAM,EACb,EAAO,EAAM,EAGb,EAAK,EAAO,EAAM,EAAO,EAE/B,GAAK,EAAK,EAAI,CAGb,IAAM,EAAI,KAAK,KAAM,GACrB,GAAK,EACL,GAAK,EACL,EAAM,EAAK,EACX,EAAM,EAAK,CAEZ,CAEA,IAAM,EAAO,EAAM,EAAO,EAAM,EAC1B,EAAK,AAAE,CAAA,EAAM,EAAM,CAAA,EAAO,EAC5B,EAAI,KAAK,KAAM,KAAK,IAAK,EAAG,IAC3B,IAAmB,GAAa,CAAA,EAAI,CAAE,CAAA,EAC3C,IAAM,EAAM,EAAI,EAAK,EAAM,EACrB,EAAM,CAAE,EAAI,EAAK,EAAM,EAGvB,EAAK,KAAK,IAAK,GAAoB,EAAM,KAAK,IAAK,GAAoB,EAAQ,AAAA,CAAA,EAAM,EAAI,EAAI,CAAA,EAAM,EACnG,EAAK,KAAK,IAAK,GAAoB,EAAM,KAAK,IAAK,GAAoB,EAAQ,AAAA,CAAA,EAAM,EAAI,EAAI,CAAA,EAAM,EAGnG,EAAQ,EAAU,EAAG,EAAK,AAAA,CAAA,EAAM,CAAA,EAAQ,EAAI,AAAE,CAAA,EAAM,CAAA,EAAQ,GAC5D,EAAQ,EAAY,AAAA,CAAA,EAAM,CAAA,EAAQ,EAAM,AAAA,CAAA,EAAM,CAAA,EAAQ,EAAI,AAAE,CAAA,CAAE,EAAM,CAAA,EAAQ,EAAI,AAAE,CAAA,CAAE,EAAM,CAAA,EAAQ,GAAS,CAAA,AAAU,EAAV,KAAK,EAAK,EAE3H,EAAK,YAAY,WAAY,EAAI,EAAI,EAAI,EAAI,EAAO,EAAQ,EAAO,AAAe,IAAf,EAAkB,EAEtF,CAEA,SAAS,EAAU,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAIhC,IAAI,EAAM,KAAK,KAAM,KAAK,IAAK,GAAK,KAAK,IAAK,EAAG,AAFrC,CAAA,EAAK,EAAK,EAAK,CAA3B,EACY,CAAA,KAAK,KAAM,EAAK,EAAK,EAAK,GAAO,KAAK,KAAM,EAAK,EAAK,EAAK,EAAvE,KAGA,OADO,EAAK,EAAK,EAAK,EAAO,GAAI,CAAA,EAAM,CAAE,CAAzC,EACO,CAER,CA0MA,SAAS,EAAY,CAAI,CAAE,CAAK,EAE/B,EAAQ,OAAO,OAAQ,CAAC,EAAG,GAE3B,IAAI,EAAmB,CAAC,EAExB,GAAK,EAAK,aAAc,SAAY,CAEnC,IAAM,EAAiB,EAAK,aAAc,SACxC,MAAO,MACP,OAAQ,SACR,IAAK,AAAA,GAAK,EAAE,QAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAe,OAAQ,IAE3C,EAAmB,OAAO,OAAQ,EAAkB,CAAW,CAAE,IAAM,CAAc,CAAE,EAAG,CAAE,CAI9F,CAQA,SAAS,EAAU,CAAO,CAAE,CAAM,CAAE,CAAc,EAEzB,KAAA,IAAnB,GAA+B,CAAA,EAAiB,SAAe,CAAC,EAIpE,OAFK,EAAE,WAAY,QAAU,QAAQ,KAAM,2DAEpC,CAER,CAAA,EAEK,EAAK,aAAc,IAAY,CAAA,CAAK,CAAE,EAAQ,CAAG,EAAgB,EAAK,aAAc,GAAzF,EACK,CAAgB,CAAE,EAAS,EAAG,CAAA,CAAK,CAAE,EAAQ,CAAG,EAAgB,CAAgB,CAAE,EAAS,CAAA,EAC3F,EAAK,OAAS,AAA0B,KAA1B,EAAK,KAAK,CAAE,EAAS,EAAU,CAAA,CAAK,CAAE,EAAQ,CAAG,EAAgB,EAAK,KAAK,CAAE,EAAS,CAAA,CAE1G,CAEA,SAAS,EAAO,CAAC,EAEhB,OAAO,KAAK,IAAK,EAAG,KAAK,IAAK,EAAG,EAAqB,IAEvD,CAEA,SAAS,EAAU,CAAC,EAEnB,OAAO,KAAK,IAAK,EAAG,EAAqB,GAE1C,CAaA,OA7CK,EAAK,aAAc,OAEvB,CAAA,EAAmB,OAAO,OAAQ,EAAkB,CAAW,CAAE,IAAM,EAAK,aAAc,MAAQ,CAAA,EAgCnG,EAAU,OAAQ,QAClB,EAAU,eAAgB,cAAe,GACzC,EAAU,UAAW,UAAW,GAChC,EAAU,SAAU,UACpB,EAAU,iBAAkB,gBAAiB,GAC7C,EAAU,eAAgB,cAAe,GACzC,EAAU,kBAAmB,kBAC7B,EAAU,iBAAkB,iBAC5B,EAAU,oBAAqB,mBAAoB,GACnD,EAAU,aAAc,cAEjB,CAER,CAYA,SAAS,EAAa,CAAK,CAAE,CAAK,CAAE,CAAM,MAqDrC,EAnDJ,GAAK,AAAiB,UAAjB,OAAO,EAEX,MAAM,AAAI,UAAW,kBAAoB,OAAO,GAKjD,IAAM,EAAK,CACV,UAAW,kBACX,WAAY,YACZ,MAAO,OACP,KAAM,OACN,MAAO,KACP,MAAO,IACP,IAAK,KACL,MAAO,MACR,EAQI,EALQ,EAMR,EAAY,CAAA,EACZ,EAAS,GAAI,EAAW,GACtB,EAAS,EAAE,CAEjB,SAAS,EAAkB,CAAO,CAAE,CAAC,CAAE,CAAO,EAE7C,IAAM,EAAQ,AAAI,YAAa,yBAA2B,EAAU,cAAgB,EAAI,IAExF,OADA,EAAM,QAAU,EACV,CAEP,CAEA,SAAS,IAEQ,KAAX,IAEC,AAAa,KAAb,EAAkB,EAAO,KAAM,OAAQ,IACvC,EAAO,KAAM,OAAQ,GAAW,KAAK,IAAK,GAAI,OAAQ,MAI5D,EAAS,GACT,EAAW,EAEZ,CAGA,IAAM,EAAS,EAAM,OAErB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAQ,IAAO,CAKnC,GAHA,EAAU,CAAK,CAAE,EAAG,CAGf,MAAM,QAAS,IAAW,EAAM,SAAU,EAAO,OAAS,IAAY,EAAG,MAAM,KAAM,GAAY,CAErG,EAzCU,EA0CV,EAAS,EACT,IACA,QAED,CAGA,GAAK,AAlDM,IAkDN,EAAgB,CAGpB,GAAK,EAAG,WAAW,KAAM,GAExB,SAKD,GAAK,EAAG,MAAM,KAAM,IAAa,EAAG,KAAK,KAAM,GAAY,CAE1D,EA7DS,EA8DT,EAAS,EACT,QAED,CAEA,GAAK,EAAG,MAAM,KAAM,GAAY,CAE/B,EApEW,EAqEX,EAAS,EACT,QAED,CAGK,EAAG,MAAM,KAAM,KAEd,GAEJ,EAAkB,EAAS,EAAG,GAI/B,EAAY,CAAA,EAId,CAGA,GAAK,AA3FM,IA2FN,EAAgB,CAEpB,GAAK,EAAG,MAAM,KAAM,GAAY,CAE/B,GAAU,EACV,QAED,CAEA,GAAK,EAAG,MAAM,KAAM,GAAY,CAE/B,GAAU,EACV,EAtGW,EAuGX,QAED,CAEA,GAAK,EAAG,IAAI,KAAM,GAAY,CAE7B,EA5GS,EA6GT,QAED,CAGK,EAAG,KAAK,KAAM,IACd,AAAkB,IAAlB,EAAO,QACP,EAAG,KAAK,KAAM,CAAM,CAAE,EAAG,GAE7B,EAAkB,EAAS,EAAG,EAIhC,CAGA,GAAK,AA9HQ,IA8HR,EAAkB,CAEtB,GAAK,EAAG,MAAM,KAAM,GAAY,CAE/B,GAAU,EACV,QAED,CAEA,GAAK,EAAG,IAAI,KAAM,GAAY,CAE7B,EAxIS,EAyIT,QAED,CAGK,EAAG,MAAM,KAAM,IAAa,AAAgC,MAAhC,CAAM,CAAE,EAAO,OAAS,EAAG,EAE3D,EAAkB,EAAS,EAAG,EAIhC,CAGA,GAAK,AAvJM,IAuJN,EAAgB,CAEpB,GAAK,EAAG,MAAM,KAAM,GAAY,CAE/B,GAAY,EACZ,QAED,CAEA,GAAK,EAAG,KAAK,KAAM,GAAY,CAE9B,GAAK,AAAa,KAAb,EAAkB,CAEtB,GAAY,EACZ,QAED,CAEyB,IAApB,EAAS,QAAgB,EAAG,KAAK,KAAM,IAE3C,EAAkB,EAAS,EAAG,EAIhC,CAED,CAIK,EAAG,WAAW,KAAM,IAExB,IACA,EA3LU,EA4LV,EAAY,CAAA,GAED,EAAG,MAAM,KAAM,IAE1B,IACA,EAjMU,EAkMV,EAAY,CAAA,GAED,EAAG,KAAK,KAAM,IAEzB,IACA,EAtMU,EAuMV,EAAS,GAEE,EAAG,MAAM,KAAM,IAE1B,IACA,EA3MY,EA4MZ,EAAS,GAIT,EAAkB,EAAS,EAAG,EAIhC,CAKA,OAFA,IAEO,CAER,CAIA,IAAM,EAAQ,CAAE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,CAG9C,EAAiB,CAEtB,GAAM,CACL,GAAM,EACN,GAAM,GACN,GAAM,EAAI,KACV,GAAM,GAAK,KACX,GAAM,EAAI,KACV,GAAM,EACP,EACA,GAAM,CACL,GAAM,GACN,GAAM,EACN,GAAM,EAAI,KACV,GAAM,GAAK,KACX,GAAM,EAAI,KACV,GAAM,EACP,EACA,GAAM,CACL,GAAM,KACN,GAAM,KACN,GAAM,EACN,GAAM,GACN,GAAM,EACN,GAAM,EACP,EACA,GAAM,CACL,GAAM,KAAO,GACb,GAAM,KAAO,GACb,GAAM,EAAI,GACV,GAAM,EACN,GAAM,EAAI,GACV,GAAM,EACP,EACA,GAAM,CACL,GAAM,KAAO,EACb,GAAM,KAAO,EACb,GAAM,EAAI,EACV,GAAM,GACN,GAAM,EACN,GAAM,EACP,EACA,GAAM,CACL,GAAM,CACP,CAED,EAEA,SAAS,EAAqB,CAAM,EAEnC,IAoBI,EApBA,EAAU,KAEd,GAAK,AAAkB,UAAlB,OAAO,GAAuB,aAAkB,OAEpD,IAAM,IAAI,EAAI,EAAG,EAAI,EAAM,OAAQ,EAAI,EAAG,IAAO,CAEhD,IAAM,EAAI,CAAK,CAAE,EAAG,CAEpB,GAAK,EAAO,SAAU,GAAM,CAE3B,EAAU,EACV,EAAS,EAAO,UAAW,EAAG,EAAO,OAAS,EAAE,QAChD,KAED,CAED,CA0BD,MApBK,AAAY,OAAZ,GAAoB,AAAsB,OAAtB,EAAM,YAI9B,EAAQ,EAAgB,EAAM,CAAE,EAAM,YAAa,CAAG,EAAM,WAI5D,CAAA,EAAQ,CAAc,CAAE,EAAS,CAAE,EAAM,YAAa,AAAb,EAE5B,GAIZ,CAAA,EAAQ,CAAc,CAAE,EAAS,CAAE,GAAS,EAAM,UAAlD,EAMK,EAAQ,WAAY,EAE5B,CAmRA,IAAM,EAAQ,EAAE,CACV,EAAc,CAAC,EAEf,EAAiB,EAAE,CAEnB,EAAiB,IAAI,EAAA,QACrB,EAAiB,IAAI,EAAA,QACrB,EAAiB,IAAI,EAAA,QACrB,EAAiB,IAAI,EAAA,QACrB,EAAS,IAAI,EAAA,QACb,EAAS,IAAI,EAAA,QAEb,EAAmB,IAAI,EAAA,QAEvB,EAAM,IAAI,YAAY,gBAAiB,EAAM,kBAEnD,AA/jDA,SAAS,EAAW,CAAI,CAAE,CAAK,EAE9B,GAAK,AAAkB,IAAlB,EAAK,SAAiB,OAE3B,IAAM,EAAY,AA4xCnB,SAA2B,CAAI,EAE9B,GAAK,CAAI,CAAA,EAAK,aAAc,cAAmB,AAAkB,QAAlB,EAAK,UAAwB,CAAA,EAAK,aAAc,MAAS,EAAK,aAAc,IAAA,CAAI,EAE9H,OAAO,KAIR,IAAM,EAAY,AAenB,SAA6B,CAAI,EAEhC,IAAM,EAAY,IAAI,EAAA,QAGtB,GAAK,AAAkB,QAAlB,EAAK,UAAwB,CAAA,EAAK,aAAc,MAAS,EAAK,aAAc,IAAA,EAAU,CAE1F,IAAM,EAAK,EAAqB,EAAK,aAAc,MAC7C,EAAK,EAAqB,EAAK,aAAc,MAEnD,EAAU,UAAW,EAAI,EAE1B,CAEA,GAAK,EAAK,aAAc,aAAgB,CAEvC,IAAM,EAAkB,EAAK,aAAc,aAAc,MAAO,KAEhE,IAAM,IAAI,EAAS,EAAgB,OAAS,EAAG,GAAU,EAAG,IAAY,CAEvE,IAAM,EAAgB,CAAe,CAAE,EAAQ,CAAC,OAEhD,GAAK,AAAkB,KAAlB,EAAuB,SAE5B,IAAM,EAAa,EAAc,QAAS,KACpC,EAAc,EAAc,OAElC,GAAK,EAAa,GAAK,EAAa,EAAc,CAEjD,IAAM,EAAgB,EAAc,OAAQ,EAAG,GAEzC,EAAQ,EAAa,EAAc,OAAQ,EAAa,EAAG,EAAc,EAAa,IAI5F,OAFA,AA9BsB,EA8BL,WAER,GAER,IAAK,YAEJ,GAAK,EAAM,QAAU,EAAI,CAExB,IAAM,EAAK,CAAK,CAAE,EAAG,CACjB,EAAK,CAEJ,CAAA,EAAM,QAAU,GAEpB,CAAA,EAAK,CAAK,CAAE,EAAG,AAAH,EAIb,AA/CmB,EA+CF,UAAW,EAAI,EAEjC,CAEA,KAED,KAAK,SAEJ,GAAK,EAAM,QAAU,EAAI,CAExB,IAAI,EAAQ,EACR,EAAK,EACL,EAAK,EAGT,EAAQ,CAAE,CAAK,CAAE,EAAG,CAAG,KAAK,GAAK,IAE5B,EAAM,QAAU,IAGpB,EAAK,CAAK,CAAE,EAAG,CACf,EAAK,CAAK,CAAE,EAAG,EAKhB,EAAe,WAAW,UAAW,CAAE,EAAI,CAAE,GAC7C,EAAe,WAAW,OAAQ,GAClC,EAAe,iBAAkB,EAAgB,GACjD,EAAe,WAAW,UAAW,EAAI,GACzC,AA7EmB,EA6EF,iBAAkB,EAAgB,EAEpD,CAEA,KAED,KAAK,QAEJ,GAAK,EAAM,QAAU,EAAI,CAExB,IAAM,EAAS,CAAK,CAAE,EAAG,CACrB,EAAS,CAER,CAAA,EAAM,QAAU,GAEpB,CAAA,EAAS,CAAK,CAAE,EAAG,AAAH,EAIjB,AAhGmB,EAgGF,MAAO,EAAQ,EAEjC,CAEA,KAED,KAAK,QAEkB,IAAjB,EAAM,QAEV,AA1GmB,EA0GF,IAChB,EAAG,KAAK,IAAK,CAAK,CAAE,EAAG,CAAG,KAAK,GAAK,KAAO,EAC3C,EAAG,EAAG,EACN,EAAG,EAAG,GAKR,KAED,KAAK,QAEkB,IAAjB,EAAM,QAEV,AAxHmB,EAwHF,IAChB,EAAG,EAAG,EACN,KAAK,IAAK,CAAK,CAAE,EAAG,CAAG,KAAK,GAAK,KAAO,EAAG,EAC3C,EAAG,EAAG,GAKR,KAED,KAAK,SAEkB,IAAjB,EAAM,QAEV,AAtImB,EAsIF,IAChB,CAAK,CAAE,EAAG,CAAE,CAAK,CAAE,EAAG,CAAE,CAAK,CAAE,EAAG,CAClC,CAAK,CAAE,EAAG,CAAE,CAAK,CAAE,EAAG,CAAE,CAAK,CAAE,EAAG,CAClC,EAAG,EAAG,EAOV,CAED,CAEA,EAAU,YApJa,EAsJxB,CAED,CAEA,OAAO,CAER,EA9KuC,GAWtC,OATK,EAAe,OAAS,GAE5B,EAAU,YAAa,CAAc,CAAE,EAAe,OAAS,EAAG,EAInE,EAAiB,KAAM,GACvB,EAAe,KAAM,GAEd,CAER,EAjzCqC,GAEhC,EAAqB,CAAA,EAErB,EAAO,KAEX,OAAS,EAAK,UAEb,IAAK,MACJ,KAED,KAAK,SACJ,AAijBH,SAA6B,CAAI,EAEhC,GAAK,AAAE,EAAK,OAAW,EAAK,MAAM,UAAc,EAAK,MAAM,SAAS,OAEpE,IAAM,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,SAAS,OAAQ,IAAO,CAEvD,IAAM,EAAa,EAAK,MAAM,QAAQ,CAAE,EAAG,CAE3C,GAAK,AAAoB,IAApB,EAAW,KAAa,SAE7B,IAAM,EAAe,EAAW,aAC9B,MAAO,OACP,OAAQ,SACR,IAAK,AAAA,GAAK,EAAE,QAEd,IAAM,IAAI,EAAI,EAAG,EAAI,EAAa,OAAQ,IAEzC,CAAW,CAAE,CAAY,CAAE,EAAG,CAAE,CAAG,OAAO,OACzC,CAAW,CAAE,CAAY,CAAE,EAAG,CAAE,EAAI,CAAC,EACrC,EAAW,MAKd,CAED,EA3kBuB,GACpB,KAED,KAAK,IACJ,EAAQ,EAAY,EAAM,GAC1B,KAED,KAAK,OACJ,EAAQ,EAAY,EAAM,GACrB,EAAK,aAAc,MAAQ,CAAA,EAAO,AAwG1C,SAAwB,CAAI,EAE3B,IAAM,EAAO,IAAI,EAAA,UAEX,EAAQ,IAAI,EAAA,QACZ,EAAU,IAAI,EAAA,QAEd,EAAa,IAAI,EAAA,QACnB,EAAe,CAAA,EACf,EAAkB,CAAA,EAEhB,EAAI,EAAK,aAAc,KAIvB,EAAW,EAAE,MAAO,wBAE1B,IAAM,IAAI,EAAI,EAAG,EAAI,EAAS,OAAQ,EAAI,EAAG,IAAO,KA2yB7B,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,MA7xBlB,EAZJ,IAAM,EAAU,CAAQ,CAAE,EAAG,CAEvB,EAAO,EAAQ,OAAQ,GACvB,EAAO,EAAQ,OAAQ,GAAI,OAWjC,OATsB,CAAA,IAAjB,IAEJ,EAAkB,CAAA,EAClB,EAAe,CAAA,GAMP,GAER,IAAK,IACJ,EAAU,EAAa,GACvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,GAAK,EAElD,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAQ,EAAI,EAAM,EAClB,EAAQ,EAAI,EAAM,EAEb,AAAM,IAAN,EAEJ,EAAK,OAAQ,EAAM,EAAG,EAAM,GAI5B,EAAK,OAAQ,EAAM,EAAG,EAAM,GAIlB,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,GAI7D,KAED,KAAK,IACJ,EAAU,EAAa,GAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,IAE7C,EAAM,EAAI,CAAO,CAAE,EAAG,CACtB,EAAQ,EAAI,EAAM,EAClB,EAAQ,EAAI,EAAM,EAClB,EAAK,OAAQ,EAAM,EAAG,EAAM,GAEjB,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,GAI7D,KAED,KAAK,IACJ,EAAU,EAAa,GAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,IAE7C,EAAM,EAAI,CAAO,CAAE,EAAG,CACtB,EAAQ,EAAI,EAAM,EAClB,EAAQ,EAAI,EAAM,EAClB,EAAK,OAAQ,EAAM,EAAG,EAAM,GAEjB,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,GAI7D,KAED,KAAK,IACJ,EAAU,EAAa,GAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,GAAK,EAElD,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAQ,EAAI,EAAM,EAClB,EAAQ,EAAI,EAAM,EAClB,EAAK,OAAQ,EAAM,EAAG,EAAM,GAEjB,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,GAI7D,KAED,KAAK,IACJ,EAAU,EAAa,GAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,GAAK,EAElD,EAAK,cACJ,CAAO,CAAE,EAAI,EAAG,CAChB,CAAO,CAAE,EAAI,EAAG,CAChB,CAAO,CAAE,EAAI,EAAG,CAChB,CAAO,CAAE,EAAI,EAAG,CAChB,CAAO,CAAE,EAAI,EAAG,CAChB,CAAO,CAAE,EAAI,EAAG,EAEjB,EAAQ,EAAI,CAAO,CAAE,EAAI,EAAG,CAC5B,EAAQ,EAAI,CAAO,CAAE,EAAI,EAAG,CAC5B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAEf,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,GAI7D,KAED,KAAK,IACJ,EAAU,EAAa,GAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,GAAK,EAElD,EAAK,cAorBF,CAFgB,EAjrBH,EAAM,GAmrBb,CAAA,AAnrBgB,EAAQ,EAmrBpB,CAAA,EAAV,CAFgB,EAhrBH,EAAM,GAkrBb,CAAA,AAlrBgB,EAAQ,EAkrBpB,CAAA,EAjrBZ,CAAO,CAAE,EAAI,EAAG,CAChB,CAAO,CAAE,EAAI,EAAG,CAChB,CAAO,CAAE,EAAI,EAAG,CAChB,CAAO,CAAE,EAAI,EAAG,EAEjB,EAAQ,EAAI,CAAO,CAAE,EAAI,EAAG,CAC5B,EAAQ,EAAI,CAAO,CAAE,EAAI,EAAG,CAC5B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAEf,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,GAI7D,KAED,KAAK,IACJ,EAAU,EAAa,GAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,GAAK,EAElD,EAAK,iBACJ,CAAO,CAAE,EAAI,EAAG,CAChB,CAAO,CAAE,EAAI,EAAG,CAChB,CAAO,CAAE,EAAI,EAAG,CAChB,CAAO,CAAE,EAAI,EAAG,EAEjB,EAAQ,EAAI,CAAO,CAAE,EAAI,EAAG,CAC5B,EAAQ,EAAI,CAAO,CAAE,EAAI,EAAG,CAC5B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAEf,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,GAI7D,KAED,KAAK,IACJ,EAAU,EAAa,GAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,GAAK,EAAI,CAEtD,IAAM,EAsoBH,CAFgB,EApoBO,EAAM,GAsoBvB,CAAA,AAtoB0B,EAAQ,EAsoB9B,CAAA,EAroBP,EAqoBH,CAFgB,EAnoBO,EAAM,GAqoBvB,CAAA,AAroB0B,EAAQ,EAqoB9B,CAAA,EApoBb,EAAK,iBACJ,EACA,EACA,CAAO,CAAE,EAAI,EAAG,CAChB,CAAO,CAAE,EAAI,EAAG,EAEjB,EAAQ,EAAI,EACZ,EAAQ,EAAI,EACZ,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAEf,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,EAE7D,CAEA,KAED,KAAK,IACJ,EAAU,EAAa,EAAM,CAAE,EAAG,EAAG,CAAE,GAEvC,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,GAAK,EAAI,CAGtD,GAAK,CAAO,CAAE,EAAI,EAAG,EAAI,EAAM,GAAK,CAAO,CAAE,EAAI,EAAG,EAAI,EAAM,EAAI,SAElE,IAAM,EAAQ,EAAM,OACpB,CAAA,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAQ,EAAI,EAAM,EAClB,EAAQ,EAAI,EAAM,EAClB,EACC,EAAM,CAAO,CAAE,EAAG,CAAE,CAAO,CAAE,EAAI,EAAG,CAAE,CAAO,CAAE,EAAI,EAAG,CAAE,CAAO,CAAE,EAAI,EAAG,CAAE,CAAO,CAAE,EAAI,EAAG,CAAE,EAAO,GAGzF,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,EAE7D,CAEA,KAED,KAAK,IACJ,EAAU,EAAa,GAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,GAAK,EAElD,EAAM,GAAK,CAAO,CAAE,EAAI,EAAG,CAC3B,EAAM,GAAK,CAAO,CAAE,EAAI,EAAG,CAC3B,EAAQ,EAAI,EAAM,EAClB,EAAQ,EAAI,EAAM,EAEb,AAAM,IAAN,EAEJ,EAAK,OAAQ,EAAM,EAAG,EAAM,GAI5B,EAAK,OAAQ,EAAM,EAAG,EAAM,GAIlB,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,GAI7D,KAED,KAAK,IACJ,EAAU,EAAa,GAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,IAE7C,EAAM,GAAK,CAAO,CAAE,EAAG,CACvB,EAAQ,EAAI,EAAM,EAClB,EAAQ,EAAI,EAAM,EAClB,EAAK,OAAQ,EAAM,EAAG,EAAM,GAEjB,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,GAI7D,KAED,KAAK,IACJ,EAAU,EAAa,GAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,IAE7C,EAAM,GAAK,CAAO,CAAE,EAAG,CACvB,EAAQ,EAAI,EAAM,EAClB,EAAQ,EAAI,EAAM,EAClB,EAAK,OAAQ,EAAM,EAAG,EAAM,GAEjB,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,GAI7D,KAED,KAAK,IACJ,EAAU,EAAa,GAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,GAAK,EAElD,EAAM,GAAK,CAAO,CAAE,EAAI,EAAG,CAC3B,EAAM,GAAK,CAAO,CAAE,EAAI,EAAG,CAC3B,EAAQ,EAAI,EAAM,EAClB,EAAQ,EAAI,EAAM,EAClB,EAAK,OAAQ,EAAM,EAAG,EAAM,GAEjB,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,GAI7D,KAED,KAAK,IACJ,EAAU,EAAa,GAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,GAAK,EAElD,EAAK,cACJ,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,EAE3B,EAAQ,EAAI,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CACtC,EAAQ,EAAI,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CACtC,EAAM,GAAK,CAAO,CAAE,EAAI,EAAG,CAC3B,EAAM,GAAK,CAAO,CAAE,EAAI,EAAG,CAEhB,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,GAI7D,KAED,KAAK,IACJ,EAAU,EAAa,GAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,GAAK,EAElD,EAAK,cAofF,CAFgB,EAjfH,EAAM,GAmfb,CAAA,AAnfgB,EAAQ,EAmfpB,CAAA,EAAV,CAFgB,EAhfH,EAAM,GAkfb,CAAA,AAlfgB,EAAQ,EAkfpB,CAAA,EAjfZ,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,EAE3B,EAAQ,EAAI,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CACtC,EAAQ,EAAI,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CACtC,EAAM,GAAK,CAAO,CAAE,EAAI,EAAG,CAC3B,EAAM,GAAK,CAAO,CAAE,EAAI,EAAG,CAEhB,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,GAI7D,KAED,KAAK,IACJ,EAAU,EAAa,GAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,GAAK,EAElD,EAAK,iBACJ,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,EAE3B,EAAQ,EAAI,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CACtC,EAAQ,EAAI,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CACtC,EAAM,GAAK,CAAO,CAAE,EAAI,EAAG,CAC3B,EAAM,GAAK,CAAO,CAAE,EAAI,EAAG,CAEhB,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,GAI7D,KAED,KAAK,IACJ,EAAU,EAAa,GAEvB,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,GAAK,EAAI,CAEtD,IAAM,EAscH,CAFgB,EApcO,EAAM,GAscvB,CAAA,AAtc0B,EAAQ,EAsc9B,CAAA,EArcP,EAqcH,CAFgB,EAncO,EAAM,GAqcvB,CAAA,AArc0B,EAAQ,EAqc9B,CAAA,EApcb,EAAK,iBACJ,EACA,EACA,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAC1B,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,EAE3B,EAAQ,EAAI,EACZ,EAAQ,EAAI,EACZ,EAAM,EAAI,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CACpC,EAAM,EAAI,EAAM,EAAI,CAAO,CAAE,EAAI,EAAG,CAEzB,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,EAE7D,CAEA,KAED,KAAK,IACJ,EAAU,EAAa,EAAM,CAAE,EAAG,EAAG,CAAE,GAEvC,IAAM,IAAI,EAAI,EAAG,EAAK,EAAQ,OAAQ,EAAI,EAAI,GAAK,EAAI,CAGtD,GAAK,AAAoB,GAApB,CAAO,CAAE,EAAI,EAAG,EAAS,AAAoB,GAApB,CAAO,CAAE,EAAI,EAAG,CAAQ,SAEtD,IAAM,EAAQ,EAAM,OACpB,CAAA,EAAM,GAAK,CAAO,CAAE,EAAI,EAAG,CAC3B,EAAM,GAAK,CAAO,CAAE,EAAI,EAAG,CAC3B,EAAQ,EAAI,EAAM,EAClB,EAAQ,EAAI,EAAM,EAClB,EACC,EAAM,CAAO,CAAE,EAAG,CAAE,CAAO,CAAE,EAAI,EAAG,CAAE,CAAO,CAAE,EAAI,EAAG,CAAE,CAAO,CAAE,EAAI,EAAG,CAAE,CAAO,CAAE,EAAI,EAAG,CAAE,EAAO,GAGzF,IAAN,GAAW,AAAoB,CAAA,IAApB,GAA2B,EAAW,KAAM,EAE7D,CAEA,KAED,KAAK,IACL,IAAK,IACJ,EAAK,YAAY,UAAY,CAAA,EAExB,EAAK,YAAY,OAAO,OAAS,IAGrC,EAAM,KAAM,GACZ,EAAK,YAAY,aAAa,KAAM,GACpC,EAAe,CAAA,GAIhB,KAED,SACC,QAAQ,KAAM,EAEhB,CAIA,EAAkB,CAAA,CAEnB,CAEA,OAAO,CAER,EAtiByD,EAAtD,EACA,KAED,KAAK,OACJ,EAAQ,EAAY,EAAM,GAC1B,EAAO,AAmpBV,SAAwB,CAAI,EAE3B,IAAM,EAAI,EAAqB,EAAK,aAAc,MAAS,GACrD,EAAI,EAAqB,EAAK,aAAc,MAAS,GACrD,EAAK,EAAqB,EAAK,aAAc,OAAU,EAAK,aAAc,OAAU,GACpF,EAAK,EAAqB,EAAK,aAAc,OAAU,EAAK,aAAc,OAAU,GACpF,EAAI,EAAqB,EAAK,aAAc,UAC5C,EAAI,EAAqB,EAAK,aAAc,WAM5C,EAAO,IAAI,EAAA,UA0DjB,OAvDA,EAAK,OAAQ,EAAI,EAAI,GAGrB,EAAK,OAAQ,EAAI,EAAI,EAAI,GACpB,CAAA,AAAO,IAAP,GAAY,AAAO,IAAP,CAAO,GAEvB,EAAK,cACJ,EAAI,EAAI,AAZE,cAYF,EACR,EACA,EAAI,EACJ,EAAI,AAfM,cAeN,EACJ,EAAI,EACJ,EAAI,GAMN,EAAK,OAAQ,EAAI,EAAG,EAAI,EAAI,GACvB,CAAA,AAAO,IAAP,GAAY,AAAO,IAAP,CAAO,GAEvB,EAAK,cACJ,EAAI,EACJ,EAAI,EAAI,AA5BE,cA4BF,EACR,EAAI,EAAI,AA7BE,cA6BF,EACR,EAAI,EACJ,EAAI,EAAI,EACR,EAAI,GAMN,EAAK,OAAQ,EAAI,EAAI,EAAI,GACpB,CAAA,AAAO,IAAP,GAAY,AAAO,IAAP,CAAO,GAEvB,EAAK,cACJ,EAAI,AA1CM,cA0CN,EACJ,EAAI,EACJ,EACA,EAAI,EAAI,AA7CE,cA6CF,EACR,EACA,EAAI,EAAI,GAMV,EAAK,OAAQ,EAAG,EAAI,GACf,CAAA,AAAO,IAAP,GAAY,AAAO,IAAP,CAAO,GAEvB,EAAK,cAAe,EAAG,EAAI,AAxDhB,cAwDgB,EAAU,EAAI,AAxD9B,cAwD8B,EAAU,EAAG,EAAI,EAAI,GAIxD,CAER,EA5tByB,GACtB,KAED,KAAK,UACJ,EAAQ,EAAY,EAAM,GAC1B,EAAO,AAytBV,SAA2B,CAAI,EAuB9B,IAAM,EAAO,IAAI,EAAA,UAEb,EAAQ,EAMZ,OAJA,EAAK,aAAc,UAAW,QANhB,kCAnBd,SAAmB,CAAK,CAAE,CAAC,CAAE,CAAC,EAE7B,IAAM,EAAI,EAAqB,GACzB,EAAI,EAAqB,EAE1B,AAAU,CAAA,IAAV,EAEJ,EAAK,OAAQ,EAAG,GAIhB,EAAK,OAAQ,EAAG,GAIjB,GAED,GAUA,EAAK,YAAY,UAAY,CAAA,EAEtB,CAER,EA1vB4B,GACzB,KAED,KAAK,WACJ,EAAQ,EAAY,EAAM,GAC1B,EAAO,AAuvBV,SAA4B,CAAI,EAuB/B,IAAM,EAAO,IAAI,EAAA,UAEb,EAAQ,EAMZ,OAJA,EAAK,aAAc,UAAW,QANhB,kCAnBd,SAAmB,CAAK,CAAE,CAAC,CAAE,CAAC,EAE7B,IAAM,EAAI,EAAqB,GACzB,EAAI,EAAqB,EAE1B,AAAU,CAAA,IAAV,EAEJ,EAAK,OAAQ,EAAG,GAIhB,EAAK,OAAQ,EAAG,GAIjB,GAED,GAUA,EAAK,YAAY,UAAY,CAAA,EAEtB,CAER,EAxxB6B,GAC1B,KAED,KAAK,SACJ,EAAQ,EAAY,EAAM,GAC1B,EAAO,AAqxBV,SAA0B,CAAI,EAE7B,IAAM,EAAI,EAAqB,EAAK,aAAc,OAAU,GACtD,EAAI,EAAqB,EAAK,aAAc,OAAU,GACtD,EAAI,EAAqB,EAAK,aAAc,MAAS,GAErD,EAAU,IAAI,EAAA,KACpB,EAAQ,OAAQ,EAAG,EAAG,EAAG,EAAG,AAAU,EAAV,KAAK,IAEjC,IAAM,EAAO,IAAI,EAAA,UAGjB,OAFA,EAAK,SAAS,KAAM,GAEb,CAER,EAnyB2B,GACxB,KAED,KAAK,UACJ,EAAQ,EAAY,EAAM,GAC1B,EAAO,AAgyBV,SAA2B,CAAI,EAE9B,IAAM,EAAI,EAAqB,EAAK,aAAc,OAAU,GACtD,EAAI,EAAqB,EAAK,aAAc,OAAU,GACtD,EAAK,EAAqB,EAAK,aAAc,OAAU,GACvD,EAAK,EAAqB,EAAK,aAAc,OAAU,GAEvD,EAAU,IAAI,EAAA,KACpB,EAAQ,WAAY,EAAG,EAAG,EAAI,EAAI,EAAG,AAAU,EAAV,KAAK,IAE1C,IAAM,EAAO,IAAI,EAAA,UAGjB,OAFA,EAAK,SAAS,KAAM,GAEb,CAER,EA/yB4B,GACzB,KAED,KAAK,OACJ,EAAQ,EAAY,EAAM,GAC1B,EAAO,AA4yBV,SAAwB,CAAI,EAE3B,IAAM,EAAK,EAAqB,EAAK,aAAc,OAAU,GACvD,EAAK,EAAqB,EAAK,aAAc,OAAU,GACvD,EAAK,EAAqB,EAAK,aAAc,OAAU,GACvD,EAAK,EAAqB,EAAK,aAAc,OAAU,GAEvD,EAAO,IAAI,EAAA,UAKjB,OAJA,EAAK,OAAQ,EAAI,GACjB,EAAK,OAAQ,EAAI,GACjB,EAAK,YAAY,UAAY,CAAA,EAEtB,CAER,EA1zByB,GACtB,KAED,KAAK,OACJ,EAAqB,CAAA,EACrB,KAED,KAAK,MACJ,EAAQ,EAAY,EAAM,GAC1B,IAAM,EAAa,EAAK,KAAK,QAAQ,UAAW,GAC1C,EAAW,EAAK,gBAAgB,eAAgB,GACjD,EAEJ,EAAW,EAAU,GAIrB,QAAQ,KAAM,0DAA8D,EAS/E,CAkBA,GAhBK,IAEgB,KAAA,IAAf,EAAM,MAAsB,AAAe,SAAf,EAAM,MAEtC,EAAK,MAAM,SAAU,EAAM,MAI5B,AA63CF,SAAwB,CAAI,CAAE,CAAC,EAE9B,SAAS,EAAY,CAAE,EAEtB,EAAO,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,aAAc,GAE1C,EAAG,IAAK,EAAO,EAAG,EAAO,EAE1B,CAEA,IAAM,EAyDC,AAAoB,IAApB,AAzD+B,EAyD7B,QAAQ,CAAE,EAAG,EAAU,AAAoB,IAApB,AAzDM,EAyDJ,QAAQ,CAAE,EAAG,CAvDzC,EAAW,EAAK,SAEtB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAS,OAAQ,EAAI,EAAG,IAAO,CAEnD,IAAM,EAAU,CAAQ,CAAE,EAAG,CACvB,EAAS,EAAQ,OAEvB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAO,OAAQ,IAAO,CAE1C,IAAM,EAAQ,CAAM,CAAE,EAAG,AAEpB,CAAA,EAAM,aAEV,EAAY,EAAM,IAClB,EAAY,EAAM,KAEP,EAAM,oBAEjB,EAAY,EAAM,IAClB,EAAY,EAAM,IAClB,EAAY,EAAM,IAClB,EAAY,EAAM,KAEP,EAAM,wBAEjB,EAAY,EAAM,IAClB,EAAY,EAAM,IAClB,EAAY,EAAM,KAEP,EAAM,iBAEZ,GAEJ,QAAQ,KAAM,8EAIf,EAAO,IAAK,EAAM,GAAI,EAAM,IAC5B,EAAY,GACZ,EAAM,GAAK,EAAO,EAClB,EAAM,GAAK,EAAO,EAElB,EAAM,SAAW,AAiBrB,SAA6B,CAAC,EAE7B,IAAM,EAAK,EAAE,SACb,OAAO,KAAK,KAAM,CAAE,CAAE,EAAG,CAAG,CAAE,CAAE,EAAG,CAAG,CAAE,CAAE,EAAG,CAAG,CAAE,CAAE,EAAG,CAExD,EAtByC,GACrC,EAAM,SAAW,AAuBrB,SAA6B,CAAC,EAE7B,IAAM,EAAK,EAAE,SACb,OAAO,KAAK,KAAM,CAAE,CAAE,EAAG,CAAG,CAAE,CAAE,EAAG,CAAG,CAAE,CAAE,EAAG,CAAG,CAAE,CAAE,EAAG,CAExD,EA5ByC,GAIvC,CAED,CAED,EA57CiB,EAAM,GAErB,EAAM,KAAM,GAEZ,EAAK,SAAW,CAAE,KAAM,EAAM,MAAO,CAAM,GAIvC,EAAqB,CAEzB,IAAM,EAAQ,EAAK,WAEnB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAM,OAAQ,IAElC,EAAW,CAAK,CAAE,EAAG,CAAE,EAIzB,CAEK,IAEJ,EAAe,MAEV,EAAe,OAAS,EAE5B,EAAiB,KAAM,CAAc,CAAE,EAAe,OAAS,EAAG,EAIlE,EAAiB,WAMpB,EAg8CW,EAAI,gBAAiB,CAC/B,KAAM,OACN,YAAa,EACb,cAAe,EACf,YAAa,EACb,eAAgB,QAChB,cAAe,OACf,iBAAkB,CACnB,GAEA,IAAM,EAAO,CAAE,MAAO,EAAO,IAAK,EAAI,eAAgB,EAGtD,OAAO,CAER,CAEA,OAAO,aAAc,CAAS,CAAG,CAOhC,IAAM,EAA2B,CAChC,OAAQ,EACR,YAAa,EACb,QAAS,EACT,KAAM,EACN,MAAO,EACP,OAAQ,EACR,OAAQ,CACT,EAEM,EAAiB,CACtB,IAAK,EAAyB,OAC9B,EAAG,CACJ,EA2EA,SAAS,EAAe,CAAC,CAAE,CAAS,CAAE,CAAO,EAE5C,IAAM,EAAK,EAAQ,EAAI,EAAU,EAC3B,EAAK,EAAQ,EAAI,EAAU,EAC3B,EAAK,EAAE,EAAI,EAAU,EACrB,EAAK,EAAE,EAAI,EAAU,EACrB,EAAK,EAAK,EAAK,EAAK,EAE1B,GAAO,EAAE,IAAM,EAAU,GAAS,EAAE,IAAM,EAAU,EAAM,CAEzD,EAAe,IAAM,EAAyB,OAC9C,EAAe,EAAI,EACnB,MAED,CAEA,GAAO,EAAE,IAAM,EAAQ,GAAS,EAAE,IAAM,EAAQ,EAAM,CAErD,EAAe,IAAM,EAAyB,YAC9C,EAAe,EAAI,EACnB,MAED,CAEA,GAAK,EAAK,CAAE,OAAO,QAAU,CAE5B,EAAe,IAAM,EAAyB,KAC9C,MAED,CAEA,GAAK,EAAK,OAAO,QAAU,CAE1B,EAAe,IAAM,EAAyB,MAC9C,MAGD,CAEA,GAAS,EAAK,EAAO,GAAS,EAAO,EAAO,EAAM,CAEjD,EAAe,IAAM,EAAyB,OAC9C,MAED,CAEA,GAAK,KAAO,KAAM,EAAK,EAAK,EAAK,GAAW,KAAK,KAAM,EAAK,EAAK,EAAK,GAAS,CAE9E,EAAe,IAAM,EAAyB,OAC9C,MAED,CAcA,EAAe,IAAM,EAAyB,QAC9C,EAAe,EAXV,AAAO,IAAP,EAEA,EAAK,EAIL,EAAK,CAOX,CAqLA,IAAI,EAAa,EAEb,EArVc,UAsVd,EAAe,WAEf,EAAc,EAAU,SAAS,IAAK,AAAA,IAEzC,IAAM,EAAS,EAAE,YACb,EAAO,WACP,EA5Va,UA6Vb,EAAO,WACP,EA9Va,UAkWjB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAO,OAAQ,IAAO,CAE1C,IAAM,EAAI,CAAM,CAAE,EAAG,AAEhB,CAAA,EAAE,EAAI,GAEV,CAAA,EAAO,EAAE,CAAA,EAIL,EAAE,EAAI,GAEV,CAAA,EAAO,EAAE,CAAA,EAIL,EAAE,EAAI,GAEV,CAAA,EAAO,EAAE,CAAA,EAIL,EAAE,EAAI,GAEV,CAAA,EAAO,EAAE,CAAA,CAIX,CAeA,OAZK,GAAgB,GAEpB,CAAA,EAAe,EAAO,CAAA,EAIlB,GAAgB,GAEpB,CAAA,EAAe,EAAO,CAAA,EAIhB,CAAE,OAAQ,EAAQ,KAAM,AAAA,CAAA,EAAA,EAAA,UAAA,EAAW,YAAa,GAAU,WAAY,IAAe,YAAa,IAAI,EAAA,KAAM,IAAI,EAAA,QAAS,EAAM,GAAQ,IAAI,EAAA,QAAS,EAAM,GAAS,CAE3K,GAEA,EAAc,EAAY,OAAQ,AAAA,GAAM,EAAG,OAAO,OAAS,GAG3D,IAAM,EAAU,EAAY,IAAK,AAAA,GAAK,AAhLtC,CAAA,SAAmB,CAAU,CAAE,CAAQ,CAAE,CAAY,CAAE,CAAY,CAAE,CAAS,EAExE,CAAA,MAAA,GAAiD,AAAc,KAAd,CAAc,GAEnE,CAAA,EAAY,SAFb,EAMA,IAAM,EAAoB,IAAI,EAAA,QAC9B,EAAW,YAAY,UAAW,GAElC,IAAM,EAAW,CAAE,IAAI,EAAA,QAAS,EAAc,EAAkB,GAAK,IAAI,EAAA,QAAS,EAAc,EAAkB,GAAK,CAEjH,EAAwB,AAjD/B,SAAmC,CAAQ,CAAE,CAAW,CAAE,CAAK,EAE9D,IAAM,EAAS,IAAI,EAAA,QACnB,EAAY,UAAW,GAEvB,IAAM,EAAmB,EAAE,CA2B3B,OAzBA,EAAM,QAAS,AAAA,IAKd,GAAK,EAAK,YAAY,cAAe,GAAW,CAE/C,IAAM,EAAgB,AA9CzB,SAA2B,CAAK,CAAE,CAAK,EAEtC,IAAM,EAAmB,EAAE,CACrB,EAAgB,EAAE,CAExB,IAAM,IAAI,EAAQ,EAAG,EAAQ,EAAM,OAAQ,IAAW,CAErD,IAAM,EAAiB,CAAK,CAAE,EAAQ,EAAG,CACnC,EAAe,CAAK,CAAE,EAAO,CAEnC,IAAM,IAAI,EAAS,EAAG,EAAS,EAAM,OAAQ,IAAY,CAExD,IAAM,EAAiB,CAAK,CAAE,EAAS,EAAG,CACpC,EAAe,CAAK,CAAE,EAAQ,CAE9B,EAAe,AA9JxB,SAA+B,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAE5C,IAAM,EAAK,EAAG,EACR,EAAK,EAAG,EACR,EAAK,EAAG,EACR,EAAK,EAAG,EACR,EAAK,EAAG,EACR,EAAK,EAAG,EACR,EAAK,EAAG,EACR,EAAK,EAAG,EACR,EAAO,AAAE,CAAA,EAAK,CAAA,EAAS,CAAA,EAAK,CAAA,EAAS,AAAA,CAAA,EAAK,CAAA,EAAS,CAAA,EAAK,CAAA,EAExD,EAAQ,AAAE,CAAA,EAAK,CAAA,EAAS,CAAA,EAAK,CAAA,EAAS,AAAA,CAAA,EAAK,CAAA,EAAS,CAAA,EAAK,CAAA,EACzD,EAAK,EAAO,EACZ,EAAK,AAHE,CAAA,AAAE,CAAA,EAAK,CAAA,EAAS,CAAA,EAAK,CAAA,EAAS,AAAA,CAAA,EAAK,CAAA,EAAS,CAAA,EAAK,CAAA,CAAC,EAG7C,EAElB,GAAS,AAAU,IAAV,GAAmB,AAAS,IAAT,GAAoB,GAAM,GAAS,GAAM,GAAS,EAAK,GAAS,EAAK,EAIhG,OAAO,KAED,GAAK,AAAW,IAAX,GAAoB,AAAU,IAAV,EAAgB,CAK/C,IAAM,IAAI,EAAI,EAAG,EAAI,EAAG,IAAO,CAI9B,GAFA,EAAe,AAAM,IAAN,EAAU,EAAK,EAAI,EAAI,GAEjC,EAAe,KAAO,EAAyB,OAAS,CAE5D,IAAM,EAAU,AAAM,IAAN,EAAU,EAAK,EAC/B,MAAO,CAAE,EAAG,EAAM,EAAG,EAAG,EAAM,EAAG,EAAG,EAAe,CAAE,CAEtD,CAAO,GAAK,EAAe,KAAO,EAAyB,QAAU,CAEpE,IAAM,EAAI,CAAI,AAAE,CAAA,EAAK,EAAe,EAAM,CAAA,EAAK,CAAA,CAAC,EAAM,YAAa,IAC7D,EAAI,CAAI,AAAE,CAAA,EAAK,EAAe,EAAM,CAAA,EAAK,CAAA,CAAC,EAAM,YAAa,IACnE,MAAO,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAe,CAAG,CAE3C,CAED,CAEA,OAAO,IAER,CAAO,CAIN,IAAM,IAAI,EAAI,EAAG,EAAI,EAAG,IAIvB,GAFA,EAAe,AAAM,IAAN,EAAU,EAAK,EAAI,EAAI,GAEjC,EAAe,KAAO,EAAyB,OAAS,CAE5D,IAAM,EAAU,AAAM,IAAN,EAAU,EAAK,EAC/B,MAAO,CAAE,EAAG,EAAM,EAAG,EAAG,EAAM,EAAG,EAAG,EAAe,CAAE,CAEtD,CAID,IAAM,EAAI,CAAI,AAAE,CAAA,EAAK,EAAO,CAAA,EAAK,CAAA,CAAC,EAAM,YAAa,IAC/C,EAAI,CAAI,AAAE,CAAA,EAAK,EAAO,CAAA,EAAK,CAAA,CAAC,EAAM,YAAa,IACrD,MAAO,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,CAAG,CAE5B,CAED,EAuF8C,EAAgB,EAAc,EAAgB,EAEnE,QAAjB,GAAyB,AAAmH,KAAA,IAAnH,EAAiB,KAAM,AAAA,GAAK,EAAE,GAAK,EAAa,EAAI,OAAO,SAAW,EAAE,GAAK,EAAa,EAAI,OAAO,WAElI,EAAiB,KAAM,GACvB,EAAc,KAAM,IAAI,EAAA,QAAS,EAAa,EAAG,EAAa,IAIhE,CAED,CAEA,OAAO,CAER,EAgB2C,EAAU,EAAK,QAEvD,EAAc,QAAS,AAAA,IAEtB,EAAiB,KAAM,CAAE,WAAY,EAAK,WAAY,KAAM,EAAK,KAAM,MAAO,CAAE,EAEjF,EAED,CAED,GAEA,EAAiB,KAAM,CAAE,EAAI,IAErB,EAAG,MAAM,EAAI,EAAG,MAAM,GAIvB,CAER,EAeyD,EAAU,EAAW,YAAa,GAE1F,EAAsB,KAAM,CAAE,EAAI,IAE1B,EAAG,MAAM,EAAI,EAAG,MAAM,GAI9B,IAAM,EAAoB,EAAE,CACtB,EAAqB,EAAE,CAE7B,EAAsB,QAAS,AAAA,IAEzB,EAAE,aAAe,EAAW,WAEhC,EAAkB,KAAM,GAIxB,EAAmB,KAAM,EAI3B,GAEA,IAAM,EAAe,CAAiB,CAAE,EAAG,CAAC,MAAM,EAG5C,EAAQ,EAAE,CACZ,EAAI,EAER,KAAQ,EAAI,EAAmB,QAAU,CAAkB,CAAE,EAAG,CAAC,MAAM,EAAI,GAErE,EAAM,OAAS,GAAK,CAAK,CAAE,EAAM,OAAS,EAAG,GAAK,CAAkB,CAAE,EAAG,CAAC,WAE9E,EAAM,MAIN,EAAM,KAAM,CAAkB,CAAE,EAAG,CAAC,YAIrC,IAMD,GAFA,EAAM,KAAM,EAAW,YAElB,AAAc,YAAd,EAA0B,CAE9B,IAAM,EAAS,EAAM,OAAS,GAAM,EAC9B,EAAY,CAAK,CAAE,EAAM,OAAS,EAAG,CAE3C,MAAO,CAAE,WAAY,EAAW,WAAY,OAAQ,EAAQ,IAAK,CAAU,CAE5E,CAAO,GAAK,AAAc,YAAd,EAA0B,CAGrC,IAAI,EAAS,CAAA,EACT,EAAY,KACZ,EAAc,KAElB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAM,OAAQ,IAAO,CAEzC,IAAM,EAAa,CAAK,CAAE,EAAG,CACxB,GAEJ,EAAc,CAAQ,CAAE,EAAY,CAAC,KACrC,EAAS,CAAA,EACT,EAAY,GAED,IAAgB,CAAQ,CAAE,EAAY,CAAC,OAElD,EAAc,CAAQ,CAAE,EAAY,CAAC,KACrC,EAAS,CAAA,EAIX,CAEA,MAAO,CAAE,WAAY,EAAW,WAAY,OAAQ,EAAQ,IAAK,CAAU,CAE5E,CAEC,QAAQ,KAAM,eAAiB,EAAY,kCAI7C,CAAA,EA0EgD,EAAG,EAAa,EAAc,EAAc,EAAU,SAAS,MAAM,WAG/G,EAAiB,EAAE,CAqBzB,OApBA,EAAY,QAAS,AAAA,IAEpB,IAAM,EAAW,CAAO,CAAE,EAAE,WAAY,CAExC,GAAK,CAAE,EAAS,OAAS,CAExB,IAAM,EAAQ,IAAI,EAAA,MAAO,EAAE,QACrB,EAAQ,EAAQ,OAAQ,AAAA,GAAK,EAAE,QAAU,EAAE,MAAQ,EAAE,YAC3D,EAAM,QAAS,AAAA,IAEd,IAAM,EAAO,CAAW,CAAE,EAAE,WAAY,CACxC,EAAM,MAAM,KAAM,IAAI,EAAA,KAAM,EAAK,QAElC,GACA,EAAe,KAAM,EAEtB,CAED,GAEO,CAER,CAEA,OAAO,eAAgB,CAAK,CAAE,CAAK,CAAE,CAAQ,CAAE,CAAO,CAAE,CAAU,CAAG,CAepE,MAAO,CACN,YAND,EAAQ,AAAU,KAAA,IAAV,EAAsB,EAAQ,OAOrC,YARD,EAAQ,AAAU,KAAA,IAAV,EAAsB,EAAQ,EASrC,eAPD,EAAW,AAAa,KAAA,IAAb,EAAyB,EAAW,QAQ9C,cAPD,EAAU,AAAY,KAAA,IAAZ,EAAwB,EAAU,OAQ3C,iBAPD,EAAa,AAAe,KAAA,IAAf,EAA2B,EAAa,CAQrD,CAED,CAEA,OAAO,eAAgB,CAAM,CAAE,CAAK,CAAE,CAAY,CAAE,CAAW,CAAG,CAUjE,IAAM,EAAW,EAAE,CACb,EAAU,EAAE,CACZ,EAAM,EAAE,CAEd,GAAK,AAA4G,IAA5G,EAAU,0BAA2B,EAAQ,EAAO,EAAc,EAAa,EAAU,EAAS,GAEtG,OAAO,KAIR,IAAM,EAAW,IAAI,EAAA,eAKrB,OAJA,EAAS,aAAc,WAAY,IAAI,EAAA,uBAAwB,EAAU,IACzE,EAAS,aAAc,SAAU,IAAI,EAAA,uBAAwB,EAAS,IACtE,EAAS,aAAc,KAAM,IAAI,EAAA,uBAAwB,EAAK,IAEvD,CAER,CAEA,OAAO,0BAA2B,CAAM,CAAE,CAAK,CAAE,CAAY,CAAE,CAAW,CAAE,CAAQ,CAAE,CAAO,CAAE,CAAG,CAAE,CAAY,CAAG,KAwC9G,EAEA,EAOA,EACA,EACA,EA1CJ,IAAM,EAAW,IAAI,EAAA,QACf,EAAW,IAAI,EAAA,QACf,EAAW,IAAI,EAAA,QACf,EAAW,IAAI,EAAA,QACf,EAAW,IAAI,EAAA,QACf,EAAW,IAAI,EAAA,QACf,EAAW,IAAI,EAAA,QACf,EAAa,IAAI,EAAA,QACjB,EAAa,IAAI,EAAA,QACjB,EAAU,IAAI,EAAA,QACd,EAAU,IAAI,EAAA,QACd,EAAgB,IAAI,EAAA,QACpB,EAAgB,IAAI,EAAA,QACpB,EAAa,IAAI,EAAA,QACjB,EAAa,IAAI,EAAA,QACjB,EAAa,IAAI,EAAA,QACjB,EAAa,IAAI,EAAA,QAEvB,EAAe,AAAiB,KAAA,IAAjB,EAA6B,EAAe,GAC3D,EAAc,AAAgB,KAAA,IAAhB,EAA4B,EAAc,KACxD,EAAe,AAAiB,KAAA,IAAjB,EAA6B,EAAe,EAG3D,EAAS,AAwqBT,SAAiC,CAAM,EAKtC,IAAI,EAAY,CAAA,EAChB,IAAM,IAAI,EAAI,EAAG,EAAI,EAAO,OAAS,EAAG,EAAI,EAAG,IAE9C,GAAK,CAAM,CAAE,EAAG,CAAC,WAAY,CAAM,CAAE,EAAI,EAAG,EAAK,EAAc,CAE9D,EAAY,CAAA,EACZ,KAED,CAID,GAAK,CAAE,EAAY,OAAO,EAE1B,IAAM,EAAY,EAAE,CACpB,EAAU,KAAM,CAAM,CAAE,EAAG,EAE3B,IAAM,IAAI,EAAI,EAAG,EAAI,EAAO,OAAS,EAAG,EAAI,EAAG,IAEzC,CAAM,CAAE,EAAG,CAAC,WAAY,CAAM,CAAE,EAAI,EAAG,GAAM,GAEjD,EAAU,KAAM,CAAM,CAAE,EAAG,EAQ7B,OAFA,EAAU,KAAM,CAAM,CAAE,EAAO,OAAS,EAAG,EAEpC,CAER,EA5sBiC,GAEjC,IAAM,EAAY,EAAO,OAEzB,GAAK,EAAY,EAAI,OAAO,EAE5B,IAAM,EAAW,CAAM,CAAE,EAAG,CAAC,OAAQ,CAAM,CAAE,EAAY,EAAG,EAGxD,EAAgB,CAAM,CAAE,EAAG,CAGzB,EAAe,EAAM,YAAc,EAEnC,EAAS,EAAM,CAAA,EAAY,CAAA,EAC7B,EAAK,EAAG,EAKR,EAA0B,CAAA,EAE1B,EAAc,EACd,EAAoB,AAAe,EAAf,EACpB,EAAsB,AAAe,EAAf,EAG1B,EAAW,CAAM,CAAE,EAAG,CAAE,CAAM,CAAE,EAAG,CAAE,GAAW,eAAgB,GAChE,EAAW,KAAM,CAAM,CAAE,EAAG,EAAG,IAAK,GACpC,EAAW,KAAM,CAAM,CAAE,EAAG,EAAG,IAAK,GACpC,EAAQ,KAAM,GACd,EAAQ,KAAM,GAEd,IAAM,IAAI,EAAS,EAAG,EAAS,EAAW,IAAY,CAgCrD,GA9BA,EAAe,CAAM,CAAE,EAAQ,CAQ7B,EALG,IAAW,EAAY,EAEtB,EAGQ,CAAM,CAAE,EAAG,CAEL,KAAA,EAIP,CAAM,CAAE,EAAS,EAAG,CAMjC,EAAW,EAAe,EADV,GAGhB,EAAS,KAHO,GAGS,eAAgB,GACzC,EAAc,KAAM,GAAe,IAAK,GACxC,EAAc,KAAM,GAAe,IAAK,GAExC,EAAK,EAAK,EAEV,EAAoB,CAAA,EAEf,AAAc,KAAA,IAAd,EAA0B,CAG9B,EAAW,EAAc,EAAW,GAEpC,EAAS,KAAM,GAAW,eAAgB,GAC1C,EAAW,KAAM,GAAe,IAAK,GACrC,EAAW,KAAM,GAAe,IAAK,GAErC,EAAmB,CAAA,EACnB,EAAS,WAAY,EAAW,GACD,EAA1B,AAtBU,EAsBF,IAAK,IAEjB,CAAA,EAAmB,CAAA,CAFpB,EAMgB,IAAX,GAAe,CAAA,EAA0B,CAA9C,EAEA,EAAS,WAAY,EAAW,GAChC,EAAS,YACT,IAAM,EAAM,KAAK,IAAK,AAhCP,EAgCe,IAAK,IAGnC,GAAK,AAAQ,IAAR,EAAY,CAGhB,IAAM,EAAY,EAAe,EACjC,EAAS,eAAgB,CAAE,GAC3B,EAAS,WAAY,EAAc,GACnC,EAAS,KAAM,GAAW,UAAW,GAAY,IAAK,GACtD,EAAW,KAAM,GAAW,SAC5B,IAAM,EAAe,EAAS,SACxB,EAAoB,EAAS,SACnC,EAAS,aAAc,GACvB,EAAS,WAAY,EAAW,GAChC,IAAM,EAAoB,EAAS,SAoCnC,OAnCA,EAAS,aAAc,GAElB,EAAS,IAAK,GAAe,GAAqB,EAAS,IAAK,GAAe,GAEnF,CAAA,EAAoB,CAAA,CAFrB,EAMA,EAAW,KAAM,GAAW,IAAK,GACjC,EAAW,IAAK,GAEhB,EAAU,CAAA,EAEL,EAEC,GAEJ,EAAW,KAAM,GACjB,EAAc,KAAM,KAIpB,EAAW,KAAM,GACjB,EAAc,KAAM,IAQrB,IAIQ,EAAM,gBAEd,IAAK,QAEJ,EAA0B,EAAkB,EAAmB,GAE/D,KAED,KAAK,QAIJ,EAAyC,EAAkB,GAItD,EAEJ,EAAoB,EAAc,EAAe,EAAY,EAAI,GAIjE,EAAoB,EAAc,EAAY,EAAe,EAAI,GAIlE,KAED,SAIC,IAAM,EAAkB,EAAe,EAAM,iBAAqB,CAE7D,CAAA,EAAgB,EAIf,AAAyB,eAAzB,EAAM,eAEV,EAA0B,EAAkB,EAAmB,IAO/D,EAAyC,EAAkB,GAItD,GAEJ,EAAS,WAAY,EAAY,GAAgB,eAAgB,GAAgB,IAAK,GACtF,EAAS,WAAY,EAAY,GAAa,eAAgB,GAAgB,IAAK,GAEnF,EAAW,EAAe,EAAI,GAC9B,EAAW,EAAU,EAAI,GACzB,EAAW,EAAc,EAAI,IAE7B,EAAW,EAAc,EAAI,IAC7B,EAAW,EAAU,EAAI,GACzB,EAAW,EAAU,EAAI,GAEzB,EAAW,EAAc,EAAI,IAC7B,EAAW,EAAU,EAAI,GACzB,EAAW,EAAY,EAAI,KAI3B,EAAS,WAAY,EAAY,GAAgB,eAAgB,GAAgB,IAAK,GACtF,EAAS,WAAY,EAAY,GAAa,eAAgB,GAAgB,IAAK,GAEnF,EAAW,EAAe,EAAI,GAC9B,EAAW,EAAU,EAAI,GACzB,EAAW,EAAc,EAAI,IAE7B,EAAW,EAAc,EAAI,IAC7B,EAAW,EAAU,EAAI,GACzB,EAAW,EAAU,EAAI,GAEzB,EAAW,EAAc,EAAI,IAC7B,EAAW,EAAU,EAAI,GACzB,EAAW,EAAY,EAAI,MAUxB,GAIC,GAEJ,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,GAE3B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,KAI3B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,GAE3B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,IAKvB,EAEJ,EAAW,KAAM,GAIjB,EAAW,KAAM,IASb,GAEJ,EAAW,EAAe,EAAI,GAC9B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAc,EAAI,IAE7B,EAAW,EAAc,EAAI,IAC7B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,KAI3B,EAAW,EAAe,EAAI,GAC9B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAc,EAAI,IAE7B,EAAW,EAAc,EAAI,IAC7B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,IAM7B,EAAU,CAAA,EAMb,CAED,MAIC,GAIF,MAIC,IAIM,GAAY,IAAW,EAAY,GAGzC,EAAgB,CAAM,CAAE,EAAG,CAAE,EAAS,EAAS,EAAkB,CAAA,EAAM,GAMxE,EAAK,EAEL,EAAgB,EAEhB,EAAW,KAAM,GACjB,EAAW,KAAM,EAElB,CAEA,GAAO,EAKA,CAAA,GAAK,GAAqB,EAAW,CAI3C,IAAI,EAAY,EACZ,EAAY,EAEX,IAA4B,IAEhC,EAAY,EACZ,EAAY,GAIR,EAEC,CAAA,GAAW,CAAA,IAEf,EAAU,QAAS,EAAU,GAC7B,EAAU,QAAS,EAAU,GAExB,GAEJ,EAAU,QAAS,EAAU,IAQ1B,CAAA,GAAW,CAAE,CAAA,IAEjB,EAAU,QAAS,EAAU,GAC7B,EAAU,QAAS,EAAU,GAExB,GAEJ,EAAU,QAAS,EAAU,GAQjC,CAAA,MAhDC,EAAgB,EAAc,EAAe,EAAe,EAAkB,CAAA,EAAO,GAkDtF,OAAO,EAMP,SAAS,EAAW,CAAE,CAAE,CAAE,CAAE,CAAM,EAGjC,OADA,EAAO,WAAY,EAAI,GAChB,EAAO,IAAK,CAAE,EAAO,EAAG,EAAO,GAAI,WAE3C,CAEA,SAAS,EAAW,CAAQ,CAAE,CAAC,CAAE,CAAC,EAE5B,IAEJ,CAAQ,CAAE,EAAmB,CAAG,EAAS,EACzC,CAAQ,CAAE,EAAoB,EAAG,CAAG,EAAS,EAC7C,CAAQ,CAAE,EAAoB,EAAG,CAAG,EAE/B,IAEJ,CAAO,CAAE,EAAmB,CAAG,EAC/B,CAAO,CAAE,EAAoB,EAAG,CAAG,EACnC,CAAO,CAAE,EAAoB,EAAG,CAAG,GAIpC,GAAqB,EAEhB,IAEJ,CAAG,CAAE,EAAqB,CAAG,EAC7B,CAAG,CAAE,EAAsB,EAAG,CAAG,EAEjC,GAAuB,IAMzB,GAAe,CAEhB,CAEA,SAAS,EAAoB,CAAM,CAAE,CAAE,CAAE,CAAE,CAAE,CAAC,CAAE,CAAC,EAKhD,EAAS,KAAM,GAAK,IAAK,GAAS,YAClC,EAAS,KAAM,GAAK,IAAK,GAAS,YAElC,IAAI,EAAQ,KAAK,GACX,EAAM,EAAS,IAAK,EACH,CAAA,EAAlB,KAAK,IAAK,IAAY,CAAA,EAAQ,KAAK,IAAK,KAAK,KAAM,GAAxD,EAEA,GAAS,EAET,EAAS,KAAM,GAEf,IAAM,IAAI,EAAI,EAAG,EAAK,EAAe,EAAG,EAAI,EAAI,IAE/C,EAAS,KAAM,GAAW,aAAc,EAAQ,GAEhD,EAAW,EAAU,EAAG,GACxB,EAAW,EAAU,EAAG,GACxB,EAAW,EAAQ,EAAG,IAEtB,EAAS,KAAM,GAIhB,EAAW,EAAU,EAAG,GACxB,EAAW,EAAI,EAAG,GAClB,EAAW,EAAQ,EAAG,GAEvB,CAEA,SAAS,IAER,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAe,EAAI,GAE9B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAe,EAAI,GAC9B,EAAW,EAAe,EAAI,EAE/B,CAEA,SAAS,EAA0B,CAAgB,CAAE,CAAiB,CAAE,CAAC,EAEnE,EAIC,GAIJ,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAe,EAAI,GAE9B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAe,EAAI,GAC9B,EAAW,EAAY,EAAI,GAI3B,EAAW,EAAe,EAAG,GAC7B,EAAW,EAAY,EAAG,GAC1B,EAAW,EAAY,EAAG,MAM1B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAe,EAAI,GAE9B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAe,EAAI,GAI9B,EAAW,EAAe,EAAG,GAC7B,EAAW,EAAY,EAAG,GAC1B,EAAW,EAAY,EAAG,KAQtB,GAEJ,EAAW,EAAe,EAAG,GAC7B,EAAW,EAAY,EAAG,GAC1B,EAAW,EAAc,EAAG,MAI5B,EAAW,EAAe,EAAG,GAC7B,EAAW,EAAY,EAAG,GAC1B,EAAW,EAAc,EAAG,IAM/B,CAEA,SAAS,EAAyC,CAAgB,CAAE,CAAiB,EAE/E,IAEC,GAEJ,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAe,EAAI,GAE9B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAe,EAAI,GAC9B,EAAW,EAAY,EAAI,GAE3B,EAAW,EAAe,EAAI,GAC9B,EAAW,EAAc,EAAI,IAC7B,EAAW,EAAY,EAAI,GAE3B,EAAW,EAAc,EAAI,IAC7B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,KAI3B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAe,EAAI,GAE9B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAe,EAAI,GAE9B,EAAW,EAAe,EAAI,GAC9B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAc,EAAI,IAE7B,EAAW,EAAc,EAAI,IAC7B,EAAW,EAAY,EAAI,GAC3B,EAAW,EAAY,EAAI,IAM9B,CAEA,SAAS,EAAgB,CAAM,CAAE,CAAE,CAAE,CAAE,CAAE,CAAgB,CAAE,CAAK,CAAE,CAAC,EAKlE,OAAS,EAAM,eAEd,IAAK,QAEC,EAEJ,EAAoB,EAAQ,EAAI,EAAI,EAAG,IAIvC,EAAoB,EAAQ,EAAI,EAAI,EAAG,IAIxC,KAED,KAAK,SAEJ,GAAK,EAEJ,EAAS,WAAY,EAAI,GACzB,EAAS,IAAK,EAAS,EAAG,CAAE,EAAS,GAErC,EAAS,WAAY,EAAU,GAAW,IAAK,GAC/C,EAAS,WAAY,EAAU,GAAW,IAAK,GAG1C,GAEJ,EAAS,QAAS,EAAU,GAC5B,EAAS,QAAS,EAAU,GAC5B,EAAS,QAAS,EAAU,KAI5B,EAAS,QAAS,EAAU,GAC5B,EAAS,QAAS,EAAU,GAC5B,EAAS,QAAS,EAAU,QAIvB,CAEN,EAAS,WAAY,EAAI,GACzB,EAAS,IAAK,EAAS,EAAG,CAAE,EAAS,GAErC,EAAS,WAAY,EAAU,GAAW,IAAK,GAC/C,EAAS,WAAY,EAAU,GAAW,IAAK,GAE/C,IAAM,EAAK,EAAS,OAGf,GAEJ,EAAS,QAAS,EAAU,EAAK,GACjC,EAAS,QAAS,EAAU,EAAK,GACjC,EAAS,QAAS,EAAU,EAAK,MAIjC,EAAS,QAAS,EAAU,EAAK,GACjC,EAAS,QAAS,EAAU,EAAK,GACjC,EAAS,QAAS,EAAU,EAAK,IAInC,CAUF,CAED,CAwCD,CAGD,C,I,E,C,EE/2FoE,EAAe,AAAsE,WAAW,aAAa,IAAI,EAAE,WAAW,IAAI,EAAE,EAAE,EAAE,SAAS,cAAc,OAAO,SAAS,EAAE,CAAC,EAAE,OAAO,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC,SAAS,EAAE,CAAC,EAAE,IAAI,IAAI,EAAE,EAAE,EAAE,EAAE,SAAS,OAAO,IAAI,EAAE,QAAQ,CAAC,EAAE,CAAC,MAAM,QAAQ,IAAI,EAAE,QAAQ,OAAO,EAAE,CAAC,CAAC,EAAE,MAAM,QAAQ,uEAAuE,EAAE,iBAAiB,QAAQ,SAAS,CAAC,EAAE,EAAE,iBAAiB,EAAE,EAAE,EAAE,EAAE,SAAS,OAAO,EAAE,CAAC,GAAG,IAAI,EAAG,AAAA,CAAA,aAAa,IAAA,EAAM,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,MAAM,MAAM,OAAO,SAAS,EAAE,EAAE,IAAI,EAAE,MAAM,KAAK,OAAO,SAAS,GAAG,KAAK,aAAa,KAAK,YAAY,OAAO,IAAI,EAAE,EAAE,IAAI,EAAE,MAAM,KAAK,OAAO,SAAS,OAAO,EAAE,GAAG,CAAC,SAAS,GAAG,IAAI,EAAE,SAAS,EAAE,UAAU,EAAE,MAAM,WAAW,EAAE,AAAC,CAAA,aAAa,IAAA,EAAM,KAAK,EAAE,IAAI,WAAW,IAAI,IAAI,EAAE,AAAC,CAAA,aAAa,IAAA,EAAM,MAAM,GAAG,EAAE,OAAO,EAAE,EAAE,KAAK,EAAE,KAAK,GAAI,CAAA,EAAE,OAAO,IAAI,EAAG,CAAA,EAAE,CAAA,EAAG,KAAK,EAAE,EAAE,EAAE,EAAE,CAAA,EAAG,CAAC,IAAI,EAAE,YAAY,OAAO,EAAE,OAAO,EAAE,eAAe,QAAQ,EAAE,gBAAgB,QAAQ,CAAC,OAAO,CAAC,EAAE,OAAO,WAAW,EAAE,IAAI,CAAC,KAAK,EAAE,WAAW,EAAE,QAAQ,CAAC,CAAC,EAAE,OAAO,EAAE,MAAM,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,MAAM,EAAE,EAAE,OAAO,kBAAkB,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,SAAS,cAAc,SAAU,CAAA,EAAE,MAAM,EAAE,EAAE,OAAO,EAAE,EAAE,MAAM,QAAQ,yBAAyB,IAAI,EAAE,EAAE,WAAW,MAAM,OAAO,EAAE,KAAK,QAAQ,EAAE,EAAE,gCAAgC,EAAE,aAAa,MAAM,EAAE,UAAU,EAAE,EAAE,SAAS,EAAE,EAAE,EAAE,GAAG,EAAE,UAAU,EAAE,EAAE,SAAS,EAAE,EAAE,GAAG,EAAE,SAAS,EAAE,EAAE,EAAE,GAAG,EAAE,UAAU,EAAE,EAAE,YAAY,GAAG,EAAE,SAAS,EAAE,EAAE,EAAE,GAAG,CAAC,IAAI,EAAE,OAAO,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,KAAK,IAAI,EAAE,GAAG,EAAE,KAAK,IAAI,EAAE,GAAG,EAAE,UAAU,EAAE,EAAE,YAAY,EAAE,EAAE,SAAS,EAAE,EAAE,EAAE,GAAG,EAAE,UAAU,EAAE,EAAE,SAAS,EAAE,GAAG,IAAI,EAAE,KAAK,EAAE,GAAG,IAAI,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,UAAU,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,SAAS,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,UAAU,EAAE,EAAE,YAAY,GAAG,EAAE,SAAS,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,AAAC,CAAA,EAAE,EAAE,CAAA,EAAG,GAAG,CAAC,CAAC,EAAE,CAAC,IDE73D,MAAM,EAAQ,GAAI,CAAA,A,S,C,E,O,G,E,W,E,Q,C,EAAA,EAAA,EAClB,EAAM,UAAU,GAMhB,IAAI,EAAY,CAAA,EFQhB,MAAM,EAAW,IAAI,EAAA,cAAc,CAAE,UAAW,CAAA,EAAM,MAAO,CAAA,CAAK,GAClE,EAAS,cAAc,EAAU,GACjC,EAAS,QAAQ,OAAO,WAAY,OAAO,aAC3C,SAAS,KAAK,YAAY,EAAS,YAGnC,MAAM,EAAQ,IAAI,EAAA,MAGZ,EAAS,IAAI,EAAA,kBAAkB,GAAI,OAAO,WAAa,OAAO,YAAa,EAAG,IACpF,CAAA,EAAO,SAAS,EAAI,KACpB,IAAI,EAAA,cAAc,EAAQ,EAAS,YAEnC,MAAM,EAAS,IAAI,EACnB,EAAO,KACN,2CACA,SAAU,CAAA,MAAE,CAAA,CAAO,EAClB,IAAM,EAAQ,IAAI,EAAA,MAClB,IAAK,IAAM,KAAQ,EAAO,CACzB,IAAM,EAAkB,IAAI,EAAA,qBAAqB,CAChD,MAAO,EAAK,KACb,GAEM,EAAoB,IAAI,EAAA,kBAAkB,CAC/C,MAAO,EAAK,MACZ,KAAM,EAAA,SACN,UAAW,CAAA,CACZ,GAEM,EAAS,EAAK,SAAS,CAAA,GAEvB,CAAA,KAAE,CAAA,CAAM,CAAG,EAAK,SAAS,MAC/B,GAAI,GAAQ,AAAS,SAAT,EACX,IAAK,IAAM,KAAS,EAAQ,CAC3B,IAAM,EAAkB,IAAI,EAAA,gBAAgB,EAAO,CAClD,MAAO,EACP,aAAc,CAAA,CACf,GACM,EAAc,IAAI,EAAA,KAAK,EAAiB,GAC9C,EAAM,IAAI,GAEV,IAAM,EAAW,IAAI,EAAA,oBAAoB,GACnC,EAAO,IAAI,EAAA,KAAK,EAAU,GAChC,EAAM,IAAI,EACX,CAEF,CAEA,EAAM,QAAQ,KAAK,IACnB,EAAM,SAAS,EAAI,IACnB,EAAM,SAAS,EAAI,IACnB,EAAM,IAAI,EACX,EACA,SAAU,CAAG,EAEb,EACA,SAAU,CAAK,EACd,QAAQ,MAAM,EACf,GAGD,MAAM,EAAQ,IAAI,EAAA,gBAAgB,SAAU,SAAU,GACtD,EAAM,IAAI,GEpET,CAAA,EAAY,CAAC,CAAb,EAEC,SAAS,KAAK,YAAY,EAAM,KAEhC,EAAM,IAAI,SF2EZ,AALA,SAAS,IACR,sBAAsB,GACtB,EAAS,OAAO,EAAO,GEjFvB,EAAM,QFmFP","sources":["<anon>","src/svg-demo.js","node_modules/three/examples/jsm/loaders/SVGLoader.js","src/debug-stats.js","node_modules/stats-js/build/stats.min.js"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire1287\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire1287\"] = parcelRequire;\n}\n\nvar $eq1Fs = parcelRequire(\"eq1Fs\");\n\nvar $eOHOW = parcelRequire(\"eOHOW\");\n\nvar $eq1Fs = parcelRequire(\"eq1Fs\");\nclass $df9b5faaec02a911$export$959ae9097e74a233 extends (0, $eq1Fs.Loader) {\n    constructor(manager){\n        super(manager);\n        // Default dots per inch\n        this.defaultDPI = 90;\n        // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n        this.defaultUnit = \"px\";\n    }\n    load(url, onLoad, onProgress, onError) {\n        const scope = this;\n        const loader = new (0, $eq1Fs.FileLoader)(scope.manager);\n        loader.setPath(scope.path);\n        loader.setRequestHeader(scope.requestHeader);\n        loader.setWithCredentials(scope.withCredentials);\n        loader.load(url, function(text) {\n            try {\n                onLoad(scope.parse(text));\n            } catch (e) {\n                if (onError) onError(e);\n                else console.error(e);\n                scope.manager.itemError(url);\n            }\n        }, onProgress, onError);\n    }\n    parse(text) {\n        const scope = this;\n        function parseNode(node, style) {\n            if (node.nodeType !== 1) return;\n            const transform = getNodeTransform(node);\n            let traverseChildNodes = true;\n            let path = null;\n            switch(node.nodeName){\n                case \"svg\":\n                    break;\n                case \"style\":\n                    parseCSSStylesheet(node);\n                    break;\n                case \"g\":\n                    style = parseStyle(node, style);\n                    break;\n                case \"path\":\n                    style = parseStyle(node, style);\n                    if (node.hasAttribute(\"d\")) path = parsePathNode(node);\n                    break;\n                case \"rect\":\n                    style = parseStyle(node, style);\n                    path = parseRectNode(node);\n                    break;\n                case \"polygon\":\n                    style = parseStyle(node, style);\n                    path = parsePolygonNode(node);\n                    break;\n                case \"polyline\":\n                    style = parseStyle(node, style);\n                    path = parsePolylineNode(node);\n                    break;\n                case \"circle\":\n                    style = parseStyle(node, style);\n                    path = parseCircleNode(node);\n                    break;\n                case \"ellipse\":\n                    style = parseStyle(node, style);\n                    path = parseEllipseNode(node);\n                    break;\n                case \"line\":\n                    style = parseStyle(node, style);\n                    path = parseLineNode(node);\n                    break;\n                case \"defs\":\n                    traverseChildNodes = false;\n                    break;\n                case \"use\":\n                    style = parseStyle(node, style);\n                    const usedNodeId = node.href.baseVal.substring(1);\n                    const usedNode = node.viewportElement.getElementById(usedNodeId);\n                    if (usedNode) parseNode(usedNode, style);\n                    else console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n                    break;\n                default:\n            }\n            if (path) {\n                if (style.fill !== undefined && style.fill !== \"none\") path.color.setStyle(style.fill);\n                transformPath(path, currentTransform);\n                paths.push(path);\n                path.userData = {\n                    node: node,\n                    style: style\n                };\n            }\n            if (traverseChildNodes) {\n                const nodes = node.childNodes;\n                for(let i = 0; i < nodes.length; i++)parseNode(nodes[i], style);\n            }\n            if (transform) {\n                transformStack.pop();\n                if (transformStack.length > 0) currentTransform.copy(transformStack[transformStack.length - 1]);\n                else currentTransform.identity();\n            }\n        }\n        function parsePathNode(node) {\n            const path = new (0, $eq1Fs.ShapePath)();\n            const point = new (0, $eq1Fs.Vector2)();\n            const control = new (0, $eq1Fs.Vector2)();\n            const firstPoint = new (0, $eq1Fs.Vector2)();\n            let isFirstPoint = true;\n            let doSetFirstPoint = false;\n            const d = node.getAttribute(\"d\");\n            // console.log( d );\n            const commands = d.match(/[a-df-z][^a-df-z]*/ig);\n            for(let i = 0, l = commands.length; i < l; i++){\n                const command = commands[i];\n                const type = command.charAt(0);\n                const data = command.substr(1).trim();\n                if (isFirstPoint === true) {\n                    doSetFirstPoint = true;\n                    isFirstPoint = false;\n                }\n                let numbers;\n                switch(type){\n                    case \"M\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j += 2){\n                            point.x = numbers[j + 0];\n                            point.y = numbers[j + 1];\n                            control.x = point.x;\n                            control.y = point.y;\n                            if (j === 0) path.moveTo(point.x, point.y);\n                            else path.lineTo(point.x, point.y);\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"H\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j++){\n                            point.x = numbers[j];\n                            control.x = point.x;\n                            control.y = point.y;\n                            path.lineTo(point.x, point.y);\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"V\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j++){\n                            point.y = numbers[j];\n                            control.x = point.x;\n                            control.y = point.y;\n                            path.lineTo(point.x, point.y);\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"L\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j += 2){\n                            point.x = numbers[j + 0];\n                            point.y = numbers[j + 1];\n                            control.x = point.x;\n                            control.y = point.y;\n                            path.lineTo(point.x, point.y);\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"C\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j += 6){\n                            path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);\n                            control.x = numbers[j + 2];\n                            control.y = numbers[j + 3];\n                            point.x = numbers[j + 4];\n                            point.y = numbers[j + 5];\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"S\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j += 4){\n                            path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n                            control.x = numbers[j + 0];\n                            control.y = numbers[j + 1];\n                            point.x = numbers[j + 2];\n                            point.y = numbers[j + 3];\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"Q\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j += 4){\n                            path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n                            control.x = numbers[j + 0];\n                            control.y = numbers[j + 1];\n                            point.x = numbers[j + 2];\n                            point.y = numbers[j + 3];\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"T\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j += 2){\n                            const rx = getReflection(point.x, control.x);\n                            const ry = getReflection(point.y, control.y);\n                            path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n                            control.x = rx;\n                            control.y = ry;\n                            point.x = numbers[j + 0];\n                            point.y = numbers[j + 1];\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"A\":\n                        numbers = parseFloats(data, [\n                            3,\n                            4\n                        ], 7);\n                        for(let j = 0, jl = numbers.length; j < jl; j += 7){\n                            // skip command if start point == end point\n                            if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue;\n                            const start = point.clone();\n                            point.x = numbers[j + 5];\n                            point.y = numbers[j + 6];\n                            control.x = point.x;\n                            control.y = point.y;\n                            parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"m\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j += 2){\n                            point.x += numbers[j + 0];\n                            point.y += numbers[j + 1];\n                            control.x = point.x;\n                            control.y = point.y;\n                            if (j === 0) path.moveTo(point.x, point.y);\n                            else path.lineTo(point.x, point.y);\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"h\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j++){\n                            point.x += numbers[j];\n                            control.x = point.x;\n                            control.y = point.y;\n                            path.lineTo(point.x, point.y);\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"v\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j++){\n                            point.y += numbers[j];\n                            control.x = point.x;\n                            control.y = point.y;\n                            path.lineTo(point.x, point.y);\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"l\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j += 2){\n                            point.x += numbers[j + 0];\n                            point.y += numbers[j + 1];\n                            control.x = point.x;\n                            control.y = point.y;\n                            path.lineTo(point.x, point.y);\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"c\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j += 6){\n                            path.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);\n                            control.x = point.x + numbers[j + 2];\n                            control.y = point.y + numbers[j + 3];\n                            point.x += numbers[j + 4];\n                            point.y += numbers[j + 5];\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"s\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j += 4){\n                            path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n                            control.x = point.x + numbers[j + 0];\n                            control.y = point.y + numbers[j + 1];\n                            point.x += numbers[j + 2];\n                            point.y += numbers[j + 3];\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"q\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j += 4){\n                            path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n                            control.x = point.x + numbers[j + 0];\n                            control.y = point.y + numbers[j + 1];\n                            point.x += numbers[j + 2];\n                            point.y += numbers[j + 3];\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"t\":\n                        numbers = parseFloats(data);\n                        for(let j = 0, jl = numbers.length; j < jl; j += 2){\n                            const rx = getReflection(point.x, control.x);\n                            const ry = getReflection(point.y, control.y);\n                            path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n                            control.x = rx;\n                            control.y = ry;\n                            point.x = point.x + numbers[j + 0];\n                            point.y = point.y + numbers[j + 1];\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"a\":\n                        numbers = parseFloats(data, [\n                            3,\n                            4\n                        ], 7);\n                        for(let j = 0, jl = numbers.length; j < jl; j += 7){\n                            // skip command if no displacement\n                            if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue;\n                            const start = point.clone();\n                            point.x += numbers[j + 5];\n                            point.y += numbers[j + 6];\n                            control.x = point.x;\n                            control.y = point.y;\n                            parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n                            if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n                        }\n                        break;\n                    case \"Z\":\n                    case \"z\":\n                        path.currentPath.autoClose = true;\n                        if (path.currentPath.curves.length > 0) {\n                            // Reset point to beginning of Path\n                            point.copy(firstPoint);\n                            path.currentPath.currentPoint.copy(point);\n                            isFirstPoint = true;\n                        }\n                        break;\n                    default:\n                        console.warn(command);\n                }\n                // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n                doSetFirstPoint = false;\n            }\n            return path;\n        }\n        function parseCSSStylesheet(node) {\n            if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n            for(let i = 0; i < node.sheet.cssRules.length; i++){\n                const stylesheet = node.sheet.cssRules[i];\n                if (stylesheet.type !== 1) continue;\n                const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i)=>i.trim());\n                for(let j = 0; j < selectorList.length; j++)stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);\n            }\n        }\n        /**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */ function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n            if (rx == 0 || ry == 0) {\n                // draw a line if either of the radii == 0\n                path.lineTo(end.x, end.y);\n                return;\n            }\n            x_axis_rotation = x_axis_rotation * Math.PI / 180;\n            // Ensure radii are positive\n            rx = Math.abs(rx);\n            ry = Math.abs(ry);\n            // Compute (x1', y1')\n            const dx2 = (start.x - end.x) / 2.0;\n            const dy2 = (start.y - end.y) / 2.0;\n            const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n            const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n            // Compute (cx', cy')\n            let rxs = rx * rx;\n            let rys = ry * ry;\n            const x1ps = x1p * x1p;\n            const y1ps = y1p * y1p;\n            // Ensure radii are large enough\n            const cr = x1ps / rxs + y1ps / rys;\n            if (cr > 1) {\n                // scale up rx,ry equally so cr == 1\n                const s = Math.sqrt(cr);\n                rx = s * rx;\n                ry = s * ry;\n                rxs = rx * rx;\n                rys = ry * ry;\n            }\n            const dq = rxs * y1ps + rys * x1ps;\n            const pq = (rxs * rys - dq) / dq;\n            let q = Math.sqrt(Math.max(0, pq));\n            if (large_arc_flag === sweep_flag) q = -q;\n            const cxp = q * rx * y1p / ry;\n            const cyp = -q * ry * x1p / rx;\n            // Step 3: Compute (cx, cy) from (cx', cy')\n            const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n            const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n            // Step 4: Compute θ1 and Δθ\n            const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n            const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n            path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n        }\n        function svgAngle(ux, uy, vx, vy) {\n            const dot = ux * vx + uy * vy;\n            const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n            let ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear\n            if (ux * vy - uy * vx < 0) ang = -ang;\n            return ang;\n        }\n        /*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/ function parseRectNode(node) {\n            const x = parseFloatWithUnits(node.getAttribute(\"x\") || 0);\n            const y = parseFloatWithUnits(node.getAttribute(\"y\") || 0);\n            const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || node.getAttribute(\"ry\") || 0);\n            const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || node.getAttribute(\"rx\") || 0);\n            const w = parseFloatWithUnits(node.getAttribute(\"width\"));\n            const h = parseFloatWithUnits(node.getAttribute(\"height\"));\n            // Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n            // https://spencermortensen.com/articles/bezier-circle/\n            const bci = 0.448084975506;\n            const path = new (0, $eq1Fs.ShapePath)();\n            // top left\n            path.moveTo(x + rx, y);\n            // top right\n            path.lineTo(x + w - rx, y);\n            if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);\n            // bottom right\n            path.lineTo(x + w, y + h - ry);\n            if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);\n            // bottom left\n            path.lineTo(x + rx, y + h);\n            if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);\n            // back to top left\n            path.lineTo(x, y + ry);\n            if (rx !== 0 || ry !== 0) path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);\n            return path;\n        }\n        function parsePolygonNode(node) {\n            function iterator(match, a, b) {\n                const x = parseFloatWithUnits(a);\n                const y = parseFloatWithUnits(b);\n                if (index === 0) path.moveTo(x, y);\n                else path.lineTo(x, y);\n                index++;\n            }\n            const regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n            const path = new (0, $eq1Fs.ShapePath)();\n            let index = 0;\n            node.getAttribute(\"points\").replace(regex, iterator);\n            path.currentPath.autoClose = true;\n            return path;\n        }\n        function parsePolylineNode(node) {\n            function iterator(match, a, b) {\n                const x = parseFloatWithUnits(a);\n                const y = parseFloatWithUnits(b);\n                if (index === 0) path.moveTo(x, y);\n                else path.lineTo(x, y);\n                index++;\n            }\n            const regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n            const path = new (0, $eq1Fs.ShapePath)();\n            let index = 0;\n            node.getAttribute(\"points\").replace(regex, iterator);\n            path.currentPath.autoClose = false;\n            return path;\n        }\n        function parseCircleNode(node) {\n            const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n            const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n            const r = parseFloatWithUnits(node.getAttribute(\"r\") || 0);\n            const subpath = new (0, $eq1Fs.Path)();\n            subpath.absarc(x, y, r, 0, Math.PI * 2);\n            const path = new (0, $eq1Fs.ShapePath)();\n            path.subPaths.push(subpath);\n            return path;\n        }\n        function parseEllipseNode(node) {\n            const x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n            const y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n            const rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n            const ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n            const subpath = new (0, $eq1Fs.Path)();\n            subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n            const path = new (0, $eq1Fs.ShapePath)();\n            path.subPaths.push(subpath);\n            return path;\n        }\n        function parseLineNode(node) {\n            const x1 = parseFloatWithUnits(node.getAttribute(\"x1\") || 0);\n            const y1 = parseFloatWithUnits(node.getAttribute(\"y1\") || 0);\n            const x2 = parseFloatWithUnits(node.getAttribute(\"x2\") || 0);\n            const y2 = parseFloatWithUnits(node.getAttribute(\"y2\") || 0);\n            const path = new (0, $eq1Fs.ShapePath)();\n            path.moveTo(x1, y1);\n            path.lineTo(x2, y2);\n            path.currentPath.autoClose = false;\n            return path;\n        }\n        //\n        function parseStyle(node, style) {\n            style = Object.assign({}, style); // clone style\n            let stylesheetStyles = {};\n            if (node.hasAttribute(\"class\")) {\n                const classSelectors = node.getAttribute(\"class\").split(/\\s/).filter(Boolean).map((i)=>i.trim());\n                for(let i = 0; i < classSelectors.length; i++)stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\".\" + classSelectors[i]]);\n            }\n            if (node.hasAttribute(\"id\")) stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\"#\" + node.getAttribute(\"id\")]);\n            function addStyle(svgName, jsName, adjustFunction) {\n                if (adjustFunction === undefined) adjustFunction = function copy(v) {\n                    if (v.startsWith(\"url\")) console.warn(\"SVGLoader: url access in attributes is not implemented.\");\n                    return v;\n                };\n                if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n                if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n                if (node.style && node.style[svgName] !== \"\") style[jsName] = adjustFunction(node.style[svgName]);\n            }\n            function clamp(v) {\n                return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n            }\n            function positive(v) {\n                return Math.max(0, parseFloatWithUnits(v));\n            }\n            addStyle(\"fill\", \"fill\");\n            addStyle(\"fill-opacity\", \"fillOpacity\", clamp);\n            addStyle(\"opacity\", \"opacity\", clamp);\n            addStyle(\"stroke\", \"stroke\");\n            addStyle(\"stroke-opacity\", \"strokeOpacity\", clamp);\n            addStyle(\"stroke-width\", \"strokeWidth\", positive);\n            addStyle(\"stroke-linejoin\", \"strokeLineJoin\");\n            addStyle(\"stroke-linecap\", \"strokeLineCap\");\n            addStyle(\"stroke-miterlimit\", \"strokeMiterLimit\", positive);\n            addStyle(\"visibility\", \"visibility\");\n            return style;\n        }\n        // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n        function getReflection(a, b) {\n            return a - (b - a);\n        }\n        // from https://github.com/ppvg/svg-numbers (MIT License)\n        function parseFloats(input, flags, stride) {\n            if (typeof input !== \"string\") throw new TypeError(\"Invalid input: \" + typeof input);\n            // Character groups\n            const RE = {\n                SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n                WHITESPACE: /[ \\t\\r\\n]/,\n                DIGIT: /[\\d]/,\n                SIGN: /[-+]/,\n                POINT: /\\./,\n                COMMA: /,/,\n                EXP: /e/i,\n                FLAGS: /[01]/\n            };\n            // States\n            const SEP = 0;\n            const INT = 1;\n            const FLOAT = 2;\n            const EXP = 3;\n            let state = SEP;\n            let seenComma = true;\n            let number = \"\", exponent = \"\";\n            const result = [];\n            function throwSyntaxError(current, i, partial) {\n                const error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + \".\");\n                error.partial = partial;\n                throw error;\n            }\n            function newNumber() {\n                if (number !== \"\") {\n                    if (exponent === \"\") result.push(Number(number));\n                    else result.push(Number(number) * Math.pow(10, Number(exponent)));\n                }\n                number = \"\";\n                exponent = \"\";\n            }\n            let current;\n            const length = input.length;\n            for(let i = 0; i < length; i++){\n                current = input[i];\n                // check for flags\n                if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n                    state = INT;\n                    number = current;\n                    newNumber();\n                    continue;\n                }\n                // parse until next number\n                if (state === SEP) {\n                    // eat whitespace\n                    if (RE.WHITESPACE.test(current)) continue;\n                    // start new number\n                    if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n                        state = INT;\n                        number = current;\n                        continue;\n                    }\n                    if (RE.POINT.test(current)) {\n                        state = FLOAT;\n                        number = current;\n                        continue;\n                    }\n                    // throw on double commas (e.g. \"1, , 2\")\n                    if (RE.COMMA.test(current)) {\n                        if (seenComma) throwSyntaxError(current, i, result);\n                        seenComma = true;\n                    }\n                }\n                // parse integer part\n                if (state === INT) {\n                    if (RE.DIGIT.test(current)) {\n                        number += current;\n                        continue;\n                    }\n                    if (RE.POINT.test(current)) {\n                        number += current;\n                        state = FLOAT;\n                        continue;\n                    }\n                    if (RE.EXP.test(current)) {\n                        state = EXP;\n                        continue;\n                    }\n                    // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n                    if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) throwSyntaxError(current, i, result);\n                }\n                // parse decimal part\n                if (state === FLOAT) {\n                    if (RE.DIGIT.test(current)) {\n                        number += current;\n                        continue;\n                    }\n                    if (RE.EXP.test(current)) {\n                        state = EXP;\n                        continue;\n                    }\n                    // throw on double decimal points (e.g. \"1..2\")\n                    if (RE.POINT.test(current) && number[number.length - 1] === \".\") throwSyntaxError(current, i, result);\n                }\n                // parse exponent part\n                if (state === EXP) {\n                    if (RE.DIGIT.test(current)) {\n                        exponent += current;\n                        continue;\n                    }\n                    if (RE.SIGN.test(current)) {\n                        if (exponent === \"\") {\n                            exponent += current;\n                            continue;\n                        }\n                        if (exponent.length === 1 && RE.SIGN.test(exponent)) throwSyntaxError(current, i, result);\n                    }\n                }\n                // end of number\n                if (RE.WHITESPACE.test(current)) {\n                    newNumber();\n                    state = SEP;\n                    seenComma = false;\n                } else if (RE.COMMA.test(current)) {\n                    newNumber();\n                    state = SEP;\n                    seenComma = true;\n                } else if (RE.SIGN.test(current)) {\n                    newNumber();\n                    state = INT;\n                    number = current;\n                } else if (RE.POINT.test(current)) {\n                    newNumber();\n                    state = FLOAT;\n                    number = current;\n                } else throwSyntaxError(current, i, result);\n            }\n            // add the last number found (if any)\n            newNumber();\n            return result;\n        }\n        // Units\n        const units = [\n            \"mm\",\n            \"cm\",\n            \"in\",\n            \"pt\",\n            \"pc\",\n            \"px\"\n        ];\n        // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n        const unitConversion = {\n            \"mm\": {\n                \"mm\": 1,\n                \"cm\": 0.1,\n                \"in\": 1 / 25.4,\n                \"pt\": 72 / 25.4,\n                \"pc\": 6 / 25.4,\n                \"px\": -1\n            },\n            \"cm\": {\n                \"mm\": 10,\n                \"cm\": 1,\n                \"in\": 1 / 2.54,\n                \"pt\": 72 / 2.54,\n                \"pc\": 6 / 2.54,\n                \"px\": -1\n            },\n            \"in\": {\n                \"mm\": 25.4,\n                \"cm\": 2.54,\n                \"in\": 1,\n                \"pt\": 72,\n                \"pc\": 6,\n                \"px\": -1\n            },\n            \"pt\": {\n                \"mm\": 25.4 / 72,\n                \"cm\": 2.54 / 72,\n                \"in\": 1 / 72,\n                \"pt\": 1,\n                \"pc\": 6 / 72,\n                \"px\": -1\n            },\n            \"pc\": {\n                \"mm\": 25.4 / 6,\n                \"cm\": 2.54 / 6,\n                \"in\": 1 / 6,\n                \"pt\": 12,\n                \"pc\": 1,\n                \"px\": -1\n            },\n            \"px\": {\n                \"px\": 1\n            }\n        };\n        function parseFloatWithUnits(string) {\n            let theUnit = \"px\";\n            if (typeof string === \"string\" || string instanceof String) for(let i = 0, n = units.length; i < n; i++){\n                const u = units[i];\n                if (string.endsWith(u)) {\n                    theUnit = u;\n                    string = string.substring(0, string.length - u.length);\n                    break;\n                }\n            }\n            let scale = undefined;\n            if (theUnit === \"px\" && scope.defaultUnit !== \"px\") // Conversion scale from  pixels to inches, then to default units\n            scale = unitConversion[\"in\"][scope.defaultUnit] / scope.defaultDPI;\n            else {\n                scale = unitConversion[theUnit][scope.defaultUnit];\n                if (scale < 0) // Conversion scale to pixels\n                scale = unitConversion[theUnit][\"in\"] * scope.defaultDPI;\n            }\n            return scale * parseFloat(string);\n        }\n        // Transforms\n        function getNodeTransform(node) {\n            if (!(node.hasAttribute(\"transform\") || node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\")))) return null;\n            const transform = parseNodeTransform(node);\n            if (transformStack.length > 0) transform.premultiply(transformStack[transformStack.length - 1]);\n            currentTransform.copy(transform);\n            transformStack.push(transform);\n            return transform;\n        }\n        function parseNodeTransform(node) {\n            const transform = new (0, $eq1Fs.Matrix3)();\n            const currentTransform = tempTransform0;\n            if (node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\"))) {\n                const tx = parseFloatWithUnits(node.getAttribute(\"x\"));\n                const ty = parseFloatWithUnits(node.getAttribute(\"y\"));\n                transform.translate(tx, ty);\n            }\n            if (node.hasAttribute(\"transform\")) {\n                const transformsTexts = node.getAttribute(\"transform\").split(\")\");\n                for(let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--){\n                    const transformText = transformsTexts[tIndex].trim();\n                    if (transformText === \"\") continue;\n                    const openParPos = transformText.indexOf(\"(\");\n                    const closeParPos = transformText.length;\n                    if (openParPos > 0 && openParPos < closeParPos) {\n                        const transformType = transformText.substr(0, openParPos);\n                        const array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));\n                        currentTransform.identity();\n                        switch(transformType){\n                            case \"translate\":\n                                if (array.length >= 1) {\n                                    const tx = array[0];\n                                    let ty = tx;\n                                    if (array.length >= 2) ty = array[1];\n                                    currentTransform.translate(tx, ty);\n                                }\n                                break;\n                            case \"rotate\":\n                                if (array.length >= 1) {\n                                    let angle = 0;\n                                    let cx = 0;\n                                    let cy = 0;\n                                    // Angle\n                                    angle = -array[0] * Math.PI / 180;\n                                    if (array.length >= 3) {\n                                        // Center x, y\n                                        cx = array[1];\n                                        cy = array[2];\n                                    }\n                                    // Rotate around center (cx, cy)\n                                    tempTransform1.identity().translate(-cx, -cy);\n                                    tempTransform2.identity().rotate(angle);\n                                    tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                                    tempTransform1.identity().translate(cx, cy);\n                                    currentTransform.multiplyMatrices(tempTransform1, tempTransform3);\n                                }\n                                break;\n                            case \"scale\":\n                                if (array.length >= 1) {\n                                    const scaleX = array[0];\n                                    let scaleY = scaleX;\n                                    if (array.length >= 2) scaleY = array[1];\n                                    currentTransform.scale(scaleX, scaleY);\n                                }\n                                break;\n                            case \"skewX\":\n                                if (array.length === 1) currentTransform.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                                break;\n                            case \"skewY\":\n                                if (array.length === 1) currentTransform.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                                break;\n                            case \"matrix\":\n                                if (array.length === 6) currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                                break;\n                        }\n                    }\n                    transform.premultiply(currentTransform);\n                }\n            }\n            return transform;\n        }\n        function transformPath(path, m) {\n            function transfVec2(v2) {\n                tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n                v2.set(tempV3.x, tempV3.y);\n            }\n            const isRotated = isTransformRotated(m);\n            const subPaths = path.subPaths;\n            for(let i = 0, n = subPaths.length; i < n; i++){\n                const subPath = subPaths[i];\n                const curves = subPath.curves;\n                for(let j = 0; j < curves.length; j++){\n                    const curve = curves[j];\n                    if (curve.isLineCurve) {\n                        transfVec2(curve.v1);\n                        transfVec2(curve.v2);\n                    } else if (curve.isCubicBezierCurve) {\n                        transfVec2(curve.v0);\n                        transfVec2(curve.v1);\n                        transfVec2(curve.v2);\n                        transfVec2(curve.v3);\n                    } else if (curve.isQuadraticBezierCurve) {\n                        transfVec2(curve.v0);\n                        transfVec2(curve.v1);\n                        transfVec2(curve.v2);\n                    } else if (curve.isEllipseCurve) {\n                        if (isRotated) console.warn(\"SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.\");\n                        tempV2.set(curve.aX, curve.aY);\n                        transfVec2(tempV2);\n                        curve.aX = tempV2.x;\n                        curve.aY = tempV2.y;\n                        curve.xRadius *= getTransformScaleX(m);\n                        curve.yRadius *= getTransformScaleY(m);\n                    }\n                }\n            }\n        }\n        function isTransformRotated(m) {\n            return m.elements[1] !== 0 || m.elements[3] !== 0;\n        }\n        function getTransformScaleX(m) {\n            const te = m.elements;\n            return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n        }\n        function getTransformScaleY(m) {\n            const te = m.elements;\n            return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n        }\n        //\n        const paths = [];\n        const stylesheets = {};\n        const transformStack = [];\n        const tempTransform0 = new (0, $eq1Fs.Matrix3)();\n        const tempTransform1 = new (0, $eq1Fs.Matrix3)();\n        const tempTransform2 = new (0, $eq1Fs.Matrix3)();\n        const tempTransform3 = new (0, $eq1Fs.Matrix3)();\n        const tempV2 = new (0, $eq1Fs.Vector2)();\n        const tempV3 = new (0, $eq1Fs.Vector3)();\n        const currentTransform = new (0, $eq1Fs.Matrix3)();\n        const xml = new DOMParser().parseFromString(text, \"image/svg+xml\"); // application/xml\n        parseNode(xml.documentElement, {\n            fill: \"#000\",\n            fillOpacity: 1,\n            strokeOpacity: 1,\n            strokeWidth: 1,\n            strokeLineJoin: \"miter\",\n            strokeLineCap: \"butt\",\n            strokeMiterLimit: 4\n        });\n        const data = {\n            paths: paths,\n            xml: xml.documentElement\n        };\n        // console.log( paths );\n        return data;\n    }\n    static createShapes(shapePath) {\n        // Param shapePath: a shapepath as returned by the parse function of this class\n        // Returns Shape object\n        const BIGNUMBER = 999999999;\n        const IntersectionLocationType = {\n            ORIGIN: 0,\n            DESTINATION: 1,\n            BETWEEN: 2,\n            LEFT: 3,\n            RIGHT: 4,\n            BEHIND: 5,\n            BEYOND: 6\n        };\n        const classifyResult = {\n            loc: IntersectionLocationType.ORIGIN,\n            t: 0\n        };\n        function findEdgeIntersection(a0, a1, b0, b1) {\n            const x1 = a0.x;\n            const x2 = a1.x;\n            const x3 = b0.x;\n            const x4 = b1.x;\n            const y1 = a0.y;\n            const y2 = a1.y;\n            const y3 = b0.y;\n            const y4 = b1.y;\n            const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n            const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n            const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n            const t1 = nom1 / denom;\n            const t2 = nom2 / denom;\n            if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) //1. lines are parallel or edges don't intersect\n            return null;\n            else if (nom1 === 0 && denom === 0) {\n                //2. lines are colinear\n                //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n                for(let i = 0; i < 2; i++){\n                    classifyPoint(i === 0 ? b0 : b1, a0, a1);\n                    //find position of this endpoints relatively to edge1\n                    if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n                        const point = i === 0 ? b0 : b1;\n                        return {\n                            x: point.x,\n                            y: point.y,\n                            t: classifyResult.t\n                        };\n                    } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n                        const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n                        const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n                        return {\n                            x: x,\n                            y: y,\n                            t: classifyResult.t\n                        };\n                    }\n                }\n                return null;\n            } else {\n                //3. edges intersect\n                for(let i = 0; i < 2; i++){\n                    classifyPoint(i === 0 ? b0 : b1, a0, a1);\n                    if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n                        const point = i === 0 ? b0 : b1;\n                        return {\n                            x: point.x,\n                            y: point.y,\n                            t: classifyResult.t\n                        };\n                    }\n                }\n                const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n                const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n                return {\n                    x: x,\n                    y: y,\n                    t: t1\n                };\n            }\n        }\n        function classifyPoint(p, edgeStart, edgeEnd) {\n            const ax = edgeEnd.x - edgeStart.x;\n            const ay = edgeEnd.y - edgeStart.y;\n            const bx = p.x - edgeStart.x;\n            const by = p.y - edgeStart.y;\n            const sa = ax * by - bx * ay;\n            if (p.x === edgeStart.x && p.y === edgeStart.y) {\n                classifyResult.loc = IntersectionLocationType.ORIGIN;\n                classifyResult.t = 0;\n                return;\n            }\n            if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n                classifyResult.loc = IntersectionLocationType.DESTINATION;\n                classifyResult.t = 1;\n                return;\n            }\n            if (sa < -Number.EPSILON) {\n                classifyResult.loc = IntersectionLocationType.LEFT;\n                return;\n            }\n            if (sa > Number.EPSILON) {\n                classifyResult.loc = IntersectionLocationType.RIGHT;\n                return;\n            }\n            if (ax * bx < 0 || ay * by < 0) {\n                classifyResult.loc = IntersectionLocationType.BEHIND;\n                return;\n            }\n            if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n                classifyResult.loc = IntersectionLocationType.BEYOND;\n                return;\n            }\n            let t;\n            if (ax !== 0) t = bx / ax;\n            else t = by / ay;\n            classifyResult.loc = IntersectionLocationType.BETWEEN;\n            classifyResult.t = t;\n        }\n        function getIntersections(path1, path2) {\n            const intersectionsRaw = [];\n            const intersections = [];\n            for(let index = 1; index < path1.length; index++){\n                const path1EdgeStart = path1[index - 1];\n                const path1EdgeEnd = path1[index];\n                for(let index2 = 1; index2 < path2.length; index2++){\n                    const path2EdgeStart = path2[index2 - 1];\n                    const path2EdgeEnd = path2[index2];\n                    const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n                    if (intersection !== null && intersectionsRaw.find((i)=>i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON) === undefined) {\n                        intersectionsRaw.push(intersection);\n                        intersections.push(new (0, $eq1Fs.Vector2)(intersection.x, intersection.y));\n                    }\n                }\n            }\n            return intersections;\n        }\n        function getScanlineIntersections(scanline, boundingBox, paths) {\n            const center = new (0, $eq1Fs.Vector2)();\n            boundingBox.getCenter(center);\n            const allIntersections = [];\n            paths.forEach((path)=>{\n                // check if the center of the bounding box is in the bounding box of the paths.\n                // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n                // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n                if (path.boundingBox.containsPoint(center)) {\n                    const intersections = getIntersections(scanline, path.points);\n                    intersections.forEach((p)=>{\n                        allIntersections.push({\n                            identifier: path.identifier,\n                            isCW: path.isCW,\n                            point: p\n                        });\n                    });\n                }\n            });\n            allIntersections.sort((i1, i2)=>{\n                return i1.point.x - i2.point.x;\n            });\n            return allIntersections;\n        }\n        function isHoleTo(simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule) {\n            if (_fillRule === null || _fillRule === undefined || _fillRule === \"\") _fillRule = \"nonzero\";\n            const centerBoundingBox = new (0, $eq1Fs.Vector2)();\n            simplePath.boundingBox.getCenter(centerBoundingBox);\n            const scanline = [\n                new (0, $eq1Fs.Vector2)(scanlineMinX, centerBoundingBox.y),\n                new (0, $eq1Fs.Vector2)(scanlineMaxX, centerBoundingBox.y)\n            ];\n            const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n            scanlineIntersections.sort((i1, i2)=>{\n                return i1.point.x - i2.point.x;\n            });\n            const baseIntersections = [];\n            const otherIntersections = [];\n            scanlineIntersections.forEach((i)=>{\n                if (i.identifier === simplePath.identifier) baseIntersections.push(i);\n                else otherIntersections.push(i);\n            });\n            const firstXOfPath = baseIntersections[0].point.x;\n            // build up the path hierarchy\n            const stack = [];\n            let i = 0;\n            while(i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath){\n                if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) stack.pop();\n                else stack.push(otherIntersections[i].identifier);\n                i++;\n            }\n            stack.push(simplePath.identifier);\n            if (_fillRule === \"evenodd\") {\n                const isHole = stack.length % 2 === 0 ? true : false;\n                const isHoleFor = stack[stack.length - 2];\n                return {\n                    identifier: simplePath.identifier,\n                    isHole: isHole,\n                    for: isHoleFor\n                };\n            } else if (_fillRule === \"nonzero\") {\n                // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n                let isHole = true;\n                let isHoleFor = null;\n                let lastCWValue = null;\n                for(let i = 0; i < stack.length; i++){\n                    const identifier = stack[i];\n                    if (isHole) {\n                        lastCWValue = allPaths[identifier].isCW;\n                        isHole = false;\n                        isHoleFor = identifier;\n                    } else if (lastCWValue !== allPaths[identifier].isCW) {\n                        lastCWValue = allPaths[identifier].isCW;\n                        isHole = true;\n                    }\n                }\n                return {\n                    identifier: simplePath.identifier,\n                    isHole: isHole,\n                    for: isHoleFor\n                };\n            } else console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n        }\n        // check for self intersecting paths\n        // TODO\n        // check intersecting paths\n        // TODO\n        // prepare paths for hole detection\n        let identifier = 0;\n        let scanlineMinX = BIGNUMBER;\n        let scanlineMaxX = -BIGNUMBER;\n        let simplePaths = shapePath.subPaths.map((p)=>{\n            const points = p.getPoints();\n            let maxY = -BIGNUMBER;\n            let minY = BIGNUMBER;\n            let maxX = -BIGNUMBER;\n            let minX = BIGNUMBER;\n            //points.forEach(p => p.y *= -1);\n            for(let i = 0; i < points.length; i++){\n                const p = points[i];\n                if (p.y > maxY) maxY = p.y;\n                if (p.y < minY) minY = p.y;\n                if (p.x > maxX) maxX = p.x;\n                if (p.x < minX) minX = p.x;\n            }\n            //\n            if (scanlineMaxX <= maxX) scanlineMaxX = maxX + 1;\n            if (scanlineMinX >= minX) scanlineMinX = minX - 1;\n            return {\n                points: points,\n                isCW: (0, $eq1Fs.ShapeUtils).isClockWise(points),\n                identifier: identifier++,\n                boundingBox: new (0, $eq1Fs.Box2)(new (0, $eq1Fs.Vector2)(minX, minY), new (0, $eq1Fs.Vector2)(maxX, maxY))\n            };\n        });\n        simplePaths = simplePaths.filter((sp)=>sp.points.length > 1);\n        // check if path is solid or a hole\n        const isAHole = simplePaths.map((p)=>isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule));\n        const shapesToReturn = [];\n        simplePaths.forEach((p)=>{\n            const amIAHole = isAHole[p.identifier];\n            if (!amIAHole.isHole) {\n                const shape = new (0, $eq1Fs.Shape)(p.points);\n                const holes = isAHole.filter((h)=>h.isHole && h.for === p.identifier);\n                holes.forEach((h)=>{\n                    const path = simplePaths[h.identifier];\n                    shape.holes.push(new (0, $eq1Fs.Path)(path.points));\n                });\n                shapesToReturn.push(shape);\n            }\n        });\n        return shapesToReturn;\n    }\n    static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n        // Param width: Stroke width\n        // Param color: As returned by THREE.Color.getStyle()\n        // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n        // Param lineCap: One of \"round\", \"square\" or \"butt\"\n        // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n        // Returns style object\n        width = width !== undefined ? width : 1;\n        color = color !== undefined ? color : \"#000\";\n        lineJoin = lineJoin !== undefined ? lineJoin : \"miter\";\n        lineCap = lineCap !== undefined ? lineCap : \"butt\";\n        miterLimit = miterLimit !== undefined ? miterLimit : 4;\n        return {\n            strokeColor: color,\n            strokeWidth: width,\n            strokeLineJoin: lineJoin,\n            strokeLineCap: lineCap,\n            strokeMiterLimit: miterLimit\n        };\n    }\n    static pointsToStroke(points, style, arcDivisions, minDistance) {\n        // Generates a stroke with some witdh around the given path.\n        // The path can be open or closed (last point equals to first point)\n        // Param points: Array of Vector2D (the path). Minimum 2 points.\n        // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n        // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n        // Param minDistance: Points closer to this distance will be merged. (Optional)\n        // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n        const vertices = [];\n        const normals = [];\n        const uvs = [];\n        if ($df9b5faaec02a911$export$959ae9097e74a233.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) return null;\n        const geometry = new (0, $eq1Fs.BufferGeometry)();\n        geometry.setAttribute(\"position\", new (0, $eq1Fs.Float32BufferAttribute)(vertices, 3));\n        geometry.setAttribute(\"normal\", new (0, $eq1Fs.Float32BufferAttribute)(normals, 3));\n        geometry.setAttribute(\"uv\", new (0, $eq1Fs.Float32BufferAttribute)(uvs, 2));\n        return geometry;\n    }\n    static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n        // This function can be called to update existing arrays or buffers.\n        // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n        // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n        // Returns number of written vertices / normals / uvs pairs\n        // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n        // 'normals' and 'uvs' buffers are optional\n        const tempV2_1 = new (0, $eq1Fs.Vector2)();\n        const tempV2_2 = new (0, $eq1Fs.Vector2)();\n        const tempV2_3 = new (0, $eq1Fs.Vector2)();\n        const tempV2_4 = new (0, $eq1Fs.Vector2)();\n        const tempV2_5 = new (0, $eq1Fs.Vector2)();\n        const tempV2_6 = new (0, $eq1Fs.Vector2)();\n        const tempV2_7 = new (0, $eq1Fs.Vector2)();\n        const lastPointL = new (0, $eq1Fs.Vector2)();\n        const lastPointR = new (0, $eq1Fs.Vector2)();\n        const point0L = new (0, $eq1Fs.Vector2)();\n        const point0R = new (0, $eq1Fs.Vector2)();\n        const currentPointL = new (0, $eq1Fs.Vector2)();\n        const currentPointR = new (0, $eq1Fs.Vector2)();\n        const nextPointL = new (0, $eq1Fs.Vector2)();\n        const nextPointR = new (0, $eq1Fs.Vector2)();\n        const innerPoint = new (0, $eq1Fs.Vector2)();\n        const outerPoint = new (0, $eq1Fs.Vector2)();\n        arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n        minDistance = minDistance !== undefined ? minDistance : 0.001;\n        vertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n        // First ensure there are no duplicated points\n        points = removeDuplicatedPoints(points);\n        const numPoints = points.length;\n        if (numPoints < 2) return 0;\n        const isClosed = points[0].equals(points[numPoints - 1]);\n        let currentPoint;\n        let previousPoint = points[0];\n        let nextPoint;\n        const strokeWidth2 = style.strokeWidth / 2;\n        const deltaU = 1 / (numPoints - 1);\n        let u0 = 0, u1;\n        let innerSideModified;\n        let joinIsOnLeftSide;\n        let isMiter;\n        let initialJoinIsOnLeftSide = false;\n        let numVertices = 0;\n        let currentCoordinate = vertexOffset * 3;\n        let currentCoordinateUV = vertexOffset * 2;\n        // Get initial left and right stroke points\n        getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n        lastPointL.copy(points[0]).sub(tempV2_1);\n        lastPointR.copy(points[0]).add(tempV2_1);\n        point0L.copy(lastPointL);\n        point0R.copy(lastPointR);\n        for(let iPoint = 1; iPoint < numPoints; iPoint++){\n            currentPoint = points[iPoint];\n            // Get next point\n            if (iPoint === numPoints - 1) {\n                if (isClosed) // Skip duplicated initial point\n                nextPoint = points[1];\n                else nextPoint = undefined;\n            } else nextPoint = points[iPoint + 1];\n            // Normal of previous segment in tempV2_1\n            const normal1 = tempV2_1;\n            getNormal(previousPoint, currentPoint, normal1);\n            tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n            currentPointL.copy(currentPoint).sub(tempV2_3);\n            currentPointR.copy(currentPoint).add(tempV2_3);\n            u1 = u0 + deltaU;\n            innerSideModified = false;\n            if (nextPoint !== undefined) {\n                // Normal of next segment in tempV2_2\n                getNormal(currentPoint, nextPoint, tempV2_2);\n                tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n                nextPointL.copy(currentPoint).sub(tempV2_3);\n                nextPointR.copy(currentPoint).add(tempV2_3);\n                joinIsOnLeftSide = true;\n                tempV2_3.subVectors(nextPoint, previousPoint);\n                if (normal1.dot(tempV2_3) < 0) joinIsOnLeftSide = false;\n                if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n                tempV2_3.subVectors(nextPoint, currentPoint);\n                tempV2_3.normalize();\n                const dot = Math.abs(normal1.dot(tempV2_3));\n                // If path is straight, don't create join\n                if (dot !== 0) {\n                    // Compute inner and outer segment intersections\n                    const miterSide = strokeWidth2 / dot;\n                    tempV2_3.multiplyScalar(-miterSide);\n                    tempV2_4.subVectors(currentPoint, previousPoint);\n                    tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n                    innerPoint.copy(tempV2_5).negate();\n                    const miterLength2 = tempV2_5.length();\n                    const segmentLengthPrev = tempV2_4.length();\n                    tempV2_4.divideScalar(segmentLengthPrev);\n                    tempV2_6.subVectors(nextPoint, currentPoint);\n                    const segmentLengthNext = tempV2_6.length();\n                    tempV2_6.divideScalar(segmentLengthNext);\n                    // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n                    if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) innerSideModified = true;\n                    outerPoint.copy(tempV2_5).add(currentPoint);\n                    innerPoint.add(currentPoint);\n                    isMiter = false;\n                    if (innerSideModified) {\n                        if (joinIsOnLeftSide) {\n                            nextPointR.copy(innerPoint);\n                            currentPointR.copy(innerPoint);\n                        } else {\n                            nextPointL.copy(innerPoint);\n                            currentPointL.copy(innerPoint);\n                        }\n                    } else // The segment triangles are generated here if there was overlapping\n                    makeSegmentTriangles();\n                    switch(style.strokeLineJoin){\n                        case \"bevel\":\n                            makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                            break;\n                        case \"round\":\n                            // Segment triangles\n                            createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                            // Join triangles\n                            if (joinIsOnLeftSide) makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n                            else makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n                            break;\n                        case \"miter\":\n                        case \"miter-clip\":\n                        default:\n                            const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n                            if (miterFraction < 1) {\n                                // The join miter length exceeds the miter limit\n                                if (style.strokeLineJoin !== \"miter-clip\") {\n                                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                                    break;\n                                } else {\n                                    // Segment triangles\n                                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                                    // Miter-clip join triangles\n                                    if (joinIsOnLeftSide) {\n                                        tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                                        tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                                        addVertex(currentPointL, u1, 0);\n                                        addVertex(tempV2_6, u1, 0);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(tempV2_6, u1, 0);\n                                        addVertex(tempV2_7, u1, 0);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(tempV2_7, u1, 0);\n                                        addVertex(nextPointL, u1, 0);\n                                    } else {\n                                        tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                                        tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                                        addVertex(currentPointR, u1, 1);\n                                        addVertex(tempV2_6, u1, 1);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(tempV2_6, u1, 1);\n                                        addVertex(tempV2_7, u1, 1);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(tempV2_7, u1, 1);\n                                        addVertex(nextPointR, u1, 1);\n                                    }\n                                }\n                            } else {\n                                // Miter join segment triangles\n                                if (innerSideModified) {\n                                    // Optimized segment + join triangles\n                                    if (joinIsOnLeftSide) {\n                                        addVertex(lastPointR, u0, 1);\n                                        addVertex(lastPointL, u0, 0);\n                                        addVertex(outerPoint, u1, 0);\n                                        addVertex(lastPointR, u0, 1);\n                                        addVertex(outerPoint, u1, 0);\n                                        addVertex(innerPoint, u1, 1);\n                                    } else {\n                                        addVertex(lastPointR, u0, 1);\n                                        addVertex(lastPointL, u0, 0);\n                                        addVertex(outerPoint, u1, 1);\n                                        addVertex(lastPointL, u0, 0);\n                                        addVertex(innerPoint, u1, 0);\n                                        addVertex(outerPoint, u1, 1);\n                                    }\n                                    if (joinIsOnLeftSide) nextPointL.copy(outerPoint);\n                                    else nextPointR.copy(outerPoint);\n                                } else // Add extra miter join triangles\n                                if (joinIsOnLeftSide) {\n                                    addVertex(currentPointL, u1, 0);\n                                    addVertex(outerPoint, u1, 0);\n                                    addVertex(currentPoint, u1, 0.5);\n                                    addVertex(currentPoint, u1, 0.5);\n                                    addVertex(outerPoint, u1, 0);\n                                    addVertex(nextPointL, u1, 0);\n                                } else {\n                                    addVertex(currentPointR, u1, 1);\n                                    addVertex(outerPoint, u1, 1);\n                                    addVertex(currentPoint, u1, 0.5);\n                                    addVertex(currentPoint, u1, 0.5);\n                                    addVertex(outerPoint, u1, 1);\n                                    addVertex(nextPointR, u1, 1);\n                                }\n                                isMiter = true;\n                            }\n                            break;\n                    }\n                } else // The segment triangles are generated here when two consecutive points are collinear\n                makeSegmentTriangles();\n            } else // The segment triangles are generated here if it is the ending segment\n            makeSegmentTriangles();\n            if (!isClosed && iPoint === numPoints - 1) // Start line endcap\n            addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n            // Increment loop variables\n            u0 = u1;\n            previousPoint = currentPoint;\n            lastPointL.copy(nextPointL);\n            lastPointR.copy(nextPointR);\n        }\n        if (!isClosed) // Ending line endcap\n        addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n        else if (innerSideModified && vertices) {\n            // Modify path first segment vertices to adjust to the segments inner and outer intersections\n            let lastOuter = outerPoint;\n            let lastInner = innerPoint;\n            if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n                lastOuter = innerPoint;\n                lastInner = outerPoint;\n            }\n            if (joinIsOnLeftSide) {\n                if (isMiter || initialJoinIsOnLeftSide) {\n                    lastInner.toArray(vertices, 0);\n                    lastInner.toArray(vertices, 9);\n                    if (isMiter) lastOuter.toArray(vertices, 3);\n                }\n            } else if (isMiter || !initialJoinIsOnLeftSide) {\n                lastInner.toArray(vertices, 3);\n                lastInner.toArray(vertices, 9);\n                if (isMiter) lastOuter.toArray(vertices, 0);\n            }\n        }\n        return numVertices;\n        // -- End of algorithm\n        // -- Functions\n        function getNormal(p1, p2, result) {\n            result.subVectors(p2, p1);\n            return result.set(-result.y, result.x).normalize();\n        }\n        function addVertex(position, u, v) {\n            if (vertices) {\n                vertices[currentCoordinate] = position.x;\n                vertices[currentCoordinate + 1] = position.y;\n                vertices[currentCoordinate + 2] = 0;\n                if (normals) {\n                    normals[currentCoordinate] = 0;\n                    normals[currentCoordinate + 1] = 0;\n                    normals[currentCoordinate + 2] = 1;\n                }\n                currentCoordinate += 3;\n                if (uvs) {\n                    uvs[currentCoordinateUV] = u;\n                    uvs[currentCoordinateUV + 1] = v;\n                    currentCoordinateUV += 2;\n                }\n            }\n            numVertices += 3;\n        }\n        function makeCircularSector(center, p1, p2, u, v) {\n            // param p1, p2: Points in the circle arc.\n            // p1 and p2 are in clockwise direction.\n            tempV2_1.copy(p1).sub(center).normalize();\n            tempV2_2.copy(p2).sub(center).normalize();\n            let angle = Math.PI;\n            const dot = tempV2_1.dot(tempV2_2);\n            if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n            angle /= arcDivisions;\n            tempV2_3.copy(p1);\n            for(let i = 0, il = arcDivisions - 1; i < il; i++){\n                tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n                addVertex(tempV2_3, u, v);\n                addVertex(tempV2_4, u, v);\n                addVertex(center, u, 0.5);\n                tempV2_3.copy(tempV2_4);\n            }\n            addVertex(tempV2_4, u, v);\n            addVertex(p2, u, v);\n            addVertex(center, u, 0.5);\n        }\n        function makeSegmentTriangles() {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 1);\n            addVertex(currentPointR, u1, 0);\n        }\n        function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n            if (innerSideModified) {\n                // Optimized segment + bevel triangles\n                if (joinIsOnLeftSide) {\n                    // Path segments triangles\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                    // Bevel join triangle\n                    addVertex(currentPointL, u, 0);\n                    addVertex(nextPointL, u, 0);\n                    addVertex(innerPoint, u, 0.5);\n                } else {\n                    // Path segments triangles\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(currentPointR, u1, 1);\n                    // Bevel join triangle\n                    addVertex(currentPointR, u, 1);\n                    addVertex(nextPointR, u, 0);\n                    addVertex(innerPoint, u, 0.5);\n                }\n            } else // Bevel join triangle. The segment triangles are done in the main loop\n            if (joinIsOnLeftSide) {\n                addVertex(currentPointL, u, 0);\n                addVertex(nextPointL, u, 0);\n                addVertex(currentPoint, u, 0.5);\n            } else {\n                addVertex(currentPointR, u, 1);\n                addVertex(nextPointR, u, 0);\n                addVertex(currentPoint, u, 0.5);\n            }\n        }\n        function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n            if (innerSideModified) {\n                if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                    addVertex(currentPointL, u0, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(innerPoint, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(nextPointL, u0, 0);\n                    addVertex(innerPoint, u1, 1);\n                } else {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(currentPointR, u0, 1);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(nextPointR, u0, 1);\n                }\n            }\n        }\n        function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n            // param center: End point of the path\n            // param p1, p2: Left and right cap points\n            switch(style.strokeLineCap){\n                case \"round\":\n                    if (start) makeCircularSector(center, p2, p1, u, 0.5);\n                    else makeCircularSector(center, p1, p2, u, 0.5);\n                    break;\n                case \"square\":\n                    if (start) {\n                        tempV2_1.subVectors(p1, center);\n                        tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n                        tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n                        tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n                        // Modify already existing vertices\n                        if (joinIsOnLeftSide) {\n                            tempV2_3.toArray(vertices, 3);\n                            tempV2_4.toArray(vertices, 0);\n                            tempV2_4.toArray(vertices, 9);\n                        } else {\n                            tempV2_3.toArray(vertices, 3);\n                            tempV2_3.toArray(vertices, 9);\n                            tempV2_4.toArray(vertices, 0);\n                        }\n                    } else {\n                        tempV2_1.subVectors(p2, center);\n                        tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n                        tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n                        tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n                        const vl = vertices.length;\n                        // Modify already existing vertices\n                        if (joinIsOnLeftSide) {\n                            tempV2_3.toArray(vertices, vl - 3);\n                            tempV2_4.toArray(vertices, vl - 6);\n                            tempV2_4.toArray(vertices, vl - 12);\n                        } else {\n                            tempV2_3.toArray(vertices, vl - 6);\n                            tempV2_4.toArray(vertices, vl - 3);\n                            tempV2_4.toArray(vertices, vl - 12);\n                        }\n                    }\n                    break;\n                case \"butt\":\n                default:\n                    break;\n            }\n        }\n        function removeDuplicatedPoints(points) {\n            // Creates a new array if necessary with duplicated points removed.\n            // This does not remove duplicated initial and ending points of a closed path.\n            let dupPoints = false;\n            for(let i = 1, n = points.length - 1; i < n; i++)if (points[i].distanceTo(points[i + 1]) < minDistance) {\n                dupPoints = true;\n                break;\n            }\n            if (!dupPoints) return points;\n            const newPoints = [];\n            newPoints.push(points[0]);\n            for(let i = 1, n = points.length - 1; i < n; i++)if (points[i].distanceTo(points[i + 1]) >= minDistance) newPoints.push(points[i]);\n            newPoints.push(points[points.length - 1]);\n            return newPoints;\n        }\n    }\n}\n\n\nvar $a07f7f9dd384c0a2$exports = {};\n!function(e, t) {\n    $a07f7f9dd384c0a2$exports = t();\n}($a07f7f9dd384c0a2$exports, function() {\n    \"use strict\";\n    var c = function() {\n        var n = 0, l = document.createElement(\"div\");\n        function e(e) {\n            return l.appendChild(e.dom), e;\n        }\n        function t(e) {\n            for(var t = 0; t < l.children.length; t++)l.children[t].style.display = t === e ? \"block\" : \"none\";\n            n = e;\n        }\n        l.style.cssText = \"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\", l.addEventListener(\"click\", function(e) {\n            e.preventDefault(), t(++n % l.children.length);\n        }, !1);\n        var i = (performance || Date).now(), a = i, o = 0, f = e(new c.Panel(\"FPS\", \"#0ff\", \"#002\")), r = e(new c.Panel(\"MS\", \"#0f0\", \"#020\"));\n        if (self.performance && self.performance.memory) var d = e(new c.Panel(\"MB\", \"#f08\", \"#201\"));\n        return t(0), {\n            REVISION: 16,\n            dom: l,\n            addPanel: e,\n            showPanel: t,\n            begin: function() {\n                i = (performance || Date).now();\n            },\n            end: function() {\n                o++;\n                var e = (performance || Date).now();\n                if (r.update(e - i, 200), a + 1e3 <= e && (f.update(1e3 * o / (e - a), 100), a = e, o = 0, d)) {\n                    var t = performance.memory;\n                    d.update(t.usedJSHeapSize / 1048576, t.jsHeapSizeLimit / 1048576);\n                }\n                return e;\n            },\n            update: function() {\n                i = this.end();\n            },\n            domElement: l,\n            setMode: t\n        };\n    };\n    return c.Panel = function(n, l, i) {\n        var a = 1 / 0, o = 0, f = Math.round, r = f(window.devicePixelRatio || 1), d = 80 * r, e = 48 * r, c = 3 * r, p = 2 * r, u = 3 * r, s = 15 * r, m = 74 * r, h = 30 * r, y = document.createElement(\"canvas\");\n        y.width = d, y.height = e, y.style.cssText = \"width:80px;height:48px\";\n        var v = y.getContext(\"2d\");\n        return v.font = \"bold \" + 9 * r + \"px Helvetica,Arial,sans-serif\", v.textBaseline = \"top\", v.fillStyle = i, v.fillRect(0, 0, d, e), v.fillStyle = l, v.fillText(n, c, p), v.fillRect(u, s, m, h), v.fillStyle = i, v.globalAlpha = .9, v.fillRect(u, s, m, h), {\n            dom: y,\n            update: function(e, t) {\n                a = Math.min(a, e), o = Math.max(o, e), v.fillStyle = i, v.globalAlpha = 1, v.fillRect(0, 0, d, s), v.fillStyle = l, v.fillText(f(e) + \" \" + n + \" (\" + f(a) + \"-\" + f(o) + \")\", c, p), v.drawImage(y, u + r, s, m - r, h, u, s, m - r, h), v.fillRect(u + m - r, s, r, h), v.fillStyle = i, v.globalAlpha = .9, v.fillRect(u + m - r, s, r, f((1 - e / t) * h));\n            }\n        };\n    }, c;\n});\n\n\nconst $a8fffecac97013f4$var$stats = new (0, (/*@__PURE__*/$parcel$interopDefault($a07f7f9dd384c0a2$exports)))();\n$a8fffecac97013f4$var$stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom\nfunction $a8fffecac97013f4$export$f4fa5dfc8595aab7() {\n    $a8fffecac97013f4$var$stats.update();\n}\nlet $a8fffecac97013f4$var$showStats = false;\nfunction $a8fffecac97013f4$export$83c65e7868c10750() {\n    $a8fffecac97013f4$var$showStats = !$a8fffecac97013f4$var$showStats;\n    if ($a8fffecac97013f4$var$showStats) document.body.appendChild($a8fffecac97013f4$var$stats.dom);\n    else $a8fffecac97013f4$var$stats.dom.remove();\n}\n\n\nconst $b67b0d3037fbc2ca$var$renderer = new (0, $eq1Fs.WebGLRenderer)({\n    antialias: true,\n    alpha: true\n});\n$b67b0d3037fbc2ca$var$renderer.setClearColor(0x000000, 0);\n$b67b0d3037fbc2ca$var$renderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild($b67b0d3037fbc2ca$var$renderer.domElement);\n// In the beginning ...\nconst $b67b0d3037fbc2ca$var$scene = new (0, $eq1Fs.Scene)();\n// Camera\nconst $b67b0d3037fbc2ca$var$camera = new (0, $eq1Fs.PerspectiveCamera)(60, window.innerWidth / window.innerHeight, 1, 1000);\n$b67b0d3037fbc2ca$var$camera.position.z = -160;\nnew (0, $eOHOW.OrbitControls)($b67b0d3037fbc2ca$var$camera, $b67b0d3037fbc2ca$var$renderer.domElement);\nconst $b67b0d3037fbc2ca$var$loader = new (0, $df9b5faaec02a911$export$959ae9097e74a233)();\n$b67b0d3037fbc2ca$var$loader.load(\"./assets/shine-like-stars-outlined-3.svg\", function({ paths: paths  }) {\n    const group = new (0, $eq1Fs.Group)();\n    for (const path of paths){\n        const extrudeMaterial = new (0, $eq1Fs.MeshStandardMaterial)({\n            color: path.color\n        });\n        const frontGlowMaterial = new (0, $eq1Fs.MeshBasicMaterial)({\n            color: path.color,\n            side: (0, $eq1Fs.BackSide),\n            depthTest: false\n        });\n        const shapes = path.toShapes(true);\n        const { fill: fill  } = path.userData.style;\n        if (fill && fill !== \"none\") for (const shape of shapes){\n            const extrudeGeometry = new (0, $eq1Fs.ExtrudeGeometry)(shape, {\n                depth: 4,\n                bevelEnabled: false\n            });\n            const extrudeMesh = new (0, $eq1Fs.Mesh)(extrudeGeometry, extrudeMaterial);\n            group.add(extrudeMesh);\n            const geometry = new (0, $eq1Fs.ShapeBufferGeometry)(shape);\n            const mesh = new (0, $eq1Fs.Mesh)(geometry, frontGlowMaterial);\n            group.add(mesh);\n        }\n    }\n    group.rotateZ(Math.PI); // Not sure why SVG comes out flipped around.\n    group.position.x = 200;\n    group.position.y = 160;\n    $b67b0d3037fbc2ca$var$scene.add(group);\n}, function(xhr) {\n// called when loading is in progresses\n}, function(error) {\n    console.error(error);\n});\nconst $b67b0d3037fbc2ca$var$light = new (0, $eq1Fs.HemisphereLight)(0xaaaaff, 0xffaaaa, 1);\n$b67b0d3037fbc2ca$var$scene.add($b67b0d3037fbc2ca$var$light);\n// Show stats\n(0, $a8fffecac97013f4$export$83c65e7868c10750)();\n// Main loop\nfunction $b67b0d3037fbc2ca$var$animate() {\n    requestAnimationFrame($b67b0d3037fbc2ca$var$animate);\n    $b67b0d3037fbc2ca$var$renderer.render($b67b0d3037fbc2ca$var$scene, $b67b0d3037fbc2ca$var$camera);\n    (0, $a8fffecac97013f4$export$f4fa5dfc8595aab7)();\n}\n$b67b0d3037fbc2ca$var$animate();\n\n\n//# sourceMappingURL=svg.685dea4d.js.map\n","import {\n\tScene,\n\tPerspectiveCamera,\n\tWebGLRenderer,\n\tMeshStandardMaterial,\n\tHemisphereLight,\n\tMesh,\n\tGroup,\n\tMeshBasicMaterial,\n\tShapeBufferGeometry,\n\tExtrudeGeometry,\n\tBackSide,\n} from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls.js\";\nimport { SVGLoader } from \"three/examples/jsm/loaders/SVGLoader\";\nimport { updateStats, toggleStats } from \"./debug-stats\";\n\nconst renderer = new WebGLRenderer({ antialias: true, alpha: true });\nrenderer.setClearColor(0x000000, 0);\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n\n// In the beginning ...\nconst scene = new Scene();\n\n// Camera\nconst camera = new PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);\ncamera.position.z = -160;\nnew OrbitControls(camera, renderer.domElement);\n\nconst loader = new SVGLoader();\nloader.load(\n\t\"./assets/shine-like-stars-outlined-3.svg\",\n\tfunction ({ paths }) {\n\t\tconst group = new Group();\n\t\tfor (const path of paths) {\n\t\t\tconst extrudeMaterial = new MeshStandardMaterial({\n\t\t\t\tcolor: path.color,\n\t\t\t});\n\n\t\t\tconst frontGlowMaterial = new MeshBasicMaterial({\n\t\t\t\tcolor: path.color,\n\t\t\t\tside: BackSide, // Not sure why it comes out backward by default, but it does.\n\t\t\t\tdepthTest: false, // Hack: Since we're rendering the ShapeBufferGeometry directly on top of the ExtrudeGeometry, always render on top.\n\t\t\t});\n\n\t\t\tconst shapes = path.toShapes(true);\n\n\t\t\tconst { fill } = path.userData.style;\n\t\t\tif (fill && fill !== \"none\") {\n\t\t\t\tfor (const shape of shapes) {\n\t\t\t\t\tconst extrudeGeometry = new ExtrudeGeometry(shape, {\n\t\t\t\t\t\tdepth: 4,\n\t\t\t\t\t\tbevelEnabled: false,\n\t\t\t\t\t});\n\t\t\t\t\tconst extrudeMesh = new Mesh(extrudeGeometry, extrudeMaterial);\n\t\t\t\t\tgroup.add(extrudeMesh);\n\n\t\t\t\t\tconst geometry = new ShapeBufferGeometry(shape);\n\t\t\t\t\tconst mesh = new Mesh(geometry, frontGlowMaterial);\n\t\t\t\t\tgroup.add(mesh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgroup.rotateZ(Math.PI); // Not sure why SVG comes out flipped around.\n\t\tgroup.position.x = 200;\n\t\tgroup.position.y = 160;\n\t\tscene.add(group);\n\t},\n\tfunction (xhr) {\n\t\t// called when loading is in progresses\n\t},\n\tfunction (error) {\n\t\tconsole.error(error);\n\t}\n);\n\nconst light = new HemisphereLight(0xaaaaff, 0xffaaaa, 1);\nscene.add(light);\n\n// Show stats\ntoggleStats();\n\n// Main loop\nfunction animate() {\n\trequestAnimationFrame(animate);\n\trenderer.render(scene, camera);\n\tupdateStats();\n}\nanimate();\n","import {\n\tBox2,\n\tBufferGeometry,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tMatrix3,\n\tPath,\n\tShape,\n\tShapePath,\n\tShapeUtils,\n\tVector2,\n\tVector3\n} from 'three';\n\nclass SVGLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Default dots per inch\n\t\tthis.defaultDPI = 90;\n\n\t\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\t\tthis.defaultUnit = 'px';\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text ) {\n\n\t\tconst scope = this;\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tconst transform = getNodeTransform( node );\n\n\t\t\tlet traverseChildNodes = true;\n\n\t\t\tlet path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'style':\n\t\t\t\t\tparseCSSStylesheet( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'defs':\n\t\t\t\t\ttraverseChildNodes = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'use':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tconst usedNodeId = node.href.baseVal.substring( 1 );\n\t\t\t\t\tconst usedNode = node.viewportElement.getElementById( usedNodeId );\n\t\t\t\t\tif ( usedNode ) {\n\n\t\t\t\t\t\tparseNode( usedNode, style );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// console.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tif ( traverseChildNodes ) {\n\n\t\t\t\tconst nodes = node.childNodes;\n\n\t\t\t\tfor ( let i = 0; i < nodes.length; i ++ ) {\n\n\t\t\t\t\tparseNode( nodes[ i ], style );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tconst point = new Vector2();\n\t\t\tconst control = new Vector2();\n\n\t\t\tconst firstPoint = new Vector2();\n\t\t\tlet isFirstPoint = true;\n\t\t\tlet doSetFirstPoint = false;\n\n\t\t\tconst d = node.getAttribute( 'd' );\n\n\t\t\t// console.log( d );\n\n\t\t\tconst commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( let i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tconst command = commands[ i ];\n\n\t\t\t\tconst type = command.charAt( 0 );\n\t\t\t\tconst data = command.substr( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tlet numbers;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if start point == end point\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if no displacement\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCSSStylesheet( node ) {\n\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\n\n\t\t\tfor ( let i = 0; i < node.sheet.cssRules.length; i ++ ) {\n\n\t\t\t\tconst stylesheet = node.sheet.cssRules[ i ];\n\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\n\n\t\t\t\tconst selectorList = stylesheet.selectorText\n\t\t\t\t\t.split( /,/gm )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let j = 0; j < selectorList.length; j ++ ) {\n\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\n\t\t\t\t\t\tstylesheet.style\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tif ( rx == 0 || ry == 0 ) {\n\n\t\t\t\t// draw a line if either of the radii == 0\n\t\t\t\tpath.lineTo( end.x, end.y );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1', y1')\n\t\t\tconst dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tconst dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tconst x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tconst y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx', cy')\n\t\t\tlet rxs = rx * rx;\n\t\t\tlet rys = ry * ry;\n\t\t\tconst x1ps = x1p * x1p;\n\t\t\tconst y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tconst cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tconst s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tconst dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tconst pq = ( rxs * rys - dq ) / dq;\n\t\t\tlet q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tconst cxp = q * rx * y1p / ry;\n\t\t\tconst cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\n\t\t\tconst cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tconst cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute θ1 and Δθ\n\t\t\tconst theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tconst delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tconst dot = ux * vx + uy * vy;\n\t\t\tconst len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tlet ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || node.getAttribute( 'ry' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\tconst h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\t// Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n\t\t\t// https://spencermortensen.com/articles/bezier-circle/\n\t\t\tconst bci = 1 - 0.551915024494;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\t// top left\n\t\t\tpath.moveTo( x + rx, y );\n\n\t\t\t// top right\n\t\t\tpath.lineTo( x + w - rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry * bci,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom right\n\t\t\tpath.lineTo( x + w, y + h - ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx + w - rx,\n\t\t\t\t\ty + h\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom left\n\t\t\tpath.lineTo( x + rx, y + h );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// back to top left\n\t\t\tpath.lineTo( x, y + ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + ry * bci, x + rx * bci, y, x + rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tconst x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );\n\t\t\tconst y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );\n\t\t\tconst x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );\n\t\t\tconst y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tlet stylesheetStyles = {};\n\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\n\n\t\t\t\tconst classSelectors = node.getAttribute( 'class' )\n\t\t\t\t\t.split( /\\s/ )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let i = 0; i < classSelectors.length; i ++ ) {\n\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\n\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\n\n\t\t\t}\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\t\t\taddStyle( 'visibility', 'visibility' );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\t// from https://github.com/ppvg/svg-numbers (MIT License)\n\n\t\tfunction parseFloats( input, flags, stride ) {\n\n\t\t\tif ( typeof input !== 'string' ) {\n\n\t\t\t\tthrow new TypeError( 'Invalid input: ' + typeof input );\n\n\t\t\t}\n\n\t\t\t// Character groups\n\t\t\tconst RE = {\n\t\t\t\tSEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n\t\t\t\tWHITESPACE: /[ \\t\\r\\n]/,\n\t\t\t\tDIGIT: /[\\d]/,\n\t\t\t\tSIGN: /[-+]/,\n\t\t\t\tPOINT: /\\./,\n\t\t\t\tCOMMA: /,/,\n\t\t\t\tEXP: /e/i,\n\t\t\t\tFLAGS: /[01]/\n\t\t\t};\n\n\t\t\t// States\n\t\t\tconst SEP = 0;\n\t\t\tconst INT = 1;\n\t\t\tconst FLOAT = 2;\n\t\t\tconst EXP = 3;\n\n\t\t\tlet state = SEP;\n\t\t\tlet seenComma = true;\n\t\t\tlet number = '', exponent = '';\n\t\t\tconst result = [];\n\n\t\t\tfunction throwSyntaxError( current, i, partial ) {\n\n\t\t\t\tconst error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' );\n\t\t\t\terror.partial = partial;\n\t\t\t\tthrow error;\n\n\t\t\t}\n\n\t\t\tfunction newNumber() {\n\n\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\tif ( exponent === '' ) result.push( Number( number ) );\n\t\t\t\t\telse result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tnumber = '';\n\t\t\t\texponent = '';\n\n\t\t\t}\n\n\t\t\tlet current;\n\t\t\tconst length = input.length;\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tcurrent = input[ i ];\n\n\t\t\t\t// check for flags\n\t\t\t\tif ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {\n\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// parse until next number\n\t\t\t\tif ( state === SEP ) {\n\n\t\t\t\t\t// eat whitespace\n\t\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// start new number\n\t\t\t\t\tif ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tstate = INT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double commas (e.g. \"1, , 2\")\n\t\t\t\t\tif ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\t\tif ( seenComma ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tseenComma = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse integer part\n\t\t\t\tif ( state === INT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\t\t\t\t\tif ( RE.SIGN.test( current )\n\t\t\t\t\t\t\t&& number.length === 1\n\t\t\t\t\t\t\t&& RE.SIGN.test( number[ 0 ] ) ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse decimal part\n\t\t\t\tif ( state === FLOAT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double decimal points (e.g. \"1..2\")\n\t\t\t\t\tif ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse exponent part\n\t\t\t\tif ( state === EXP ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tif ( exponent === '' ) {\n\n\t\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// end of number\n\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = false;\n\n\t\t\t\t} else if ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = true;\n\n\t\t\t\t} else if ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else if ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add the last number found (if any)\n\t\t\tnewNumber();\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// Units\n\n\t\tconst units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\tconst unitConversion = {\n\n\t\t\t'mm': {\n\t\t\t\t'mm': 1,\n\t\t\t\t'cm': 0.1,\n\t\t\t\t'in': 1 / 25.4,\n\t\t\t\t'pt': 72 / 25.4,\n\t\t\t\t'pc': 6 / 25.4,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'cm': {\n\t\t\t\t'mm': 10,\n\t\t\t\t'cm': 1,\n\t\t\t\t'in': 1 / 2.54,\n\t\t\t\t'pt': 72 / 2.54,\n\t\t\t\t'pc': 6 / 2.54,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'in': {\n\t\t\t\t'mm': 25.4,\n\t\t\t\t'cm': 2.54,\n\t\t\t\t'in': 1,\n\t\t\t\t'pt': 72,\n\t\t\t\t'pc': 6,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pt': {\n\t\t\t\t'mm': 25.4 / 72,\n\t\t\t\t'cm': 2.54 / 72,\n\t\t\t\t'in': 1 / 72,\n\t\t\t\t'pt': 1,\n\t\t\t\t'pc': 6 / 72,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pc': {\n\t\t\t\t'mm': 25.4 / 6,\n\t\t\t\t'cm': 2.54 / 6,\n\t\t\t\t'in': 1 / 6,\n\t\t\t\t'pt': 72 / 6,\n\t\t\t\t'pc': 1,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'px': {\n\t\t\t\t'px': 1\n\t\t\t}\n\n\t\t};\n\n\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\tlet theUnit = 'px';\n\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\tfor ( let i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\tconst u = units[ i ];\n\n\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet scale = undefined;\n\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\n\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t} else {\n\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn scale * parseFloat( string );\n\n\t\t}\n\n\t\t// Transforms\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tconst transform = new Matrix3();\n\t\t\tconst currentTransform = tempTransform0;\n\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\n\n\t\t\t\tconst tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\n\t\t\t\tconst ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\n\n\t\t\t\ttransform.translate( tx, ty );\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\tconst transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tconst transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tconst openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tconst closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tconst transformType = transformText.substr( 0, openParPos );\n\n\t\t\t\t\t\tconst array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase 'translate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet ty = tx;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'rotate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tlet angle = 0;\n\t\t\t\t\t\t\t\t\tlet cx = 0;\n\t\t\t\t\t\t\t\t\tlet cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'scale':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewX':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewY':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'matrix':\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tconst isRotated = isTransformRotated( m );\n\n\t\t\tconst subPaths = path.subPaths;\n\n\t\t\tfor ( let i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tconst subPath = subPaths[ i ];\n\t\t\t\tconst curves = subPath.curves;\n\n\t\t\t\tfor ( let j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tconst curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformRotated( m ) {\n\n\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t//\n\n\t\tconst paths = [];\n\t\tconst stylesheets = {};\n\n\t\tconst transformStack = [];\n\n\t\tconst tempTransform0 = new Matrix3();\n\t\tconst tempTransform1 = new Matrix3();\n\t\tconst tempTransform2 = new Matrix3();\n\t\tconst tempTransform3 = new Matrix3();\n\t\tconst tempV2 = new Vector2();\n\t\tconst tempV3 = new Vector3();\n\n\t\tconst currentTransform = new Matrix3();\n\n\t\tconst xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tconst data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\t\treturn data;\n\n\t}\n\n\tstatic createShapes( shapePath ) {\n\n\t\t// Param shapePath: a shapepath as returned by the parse function of this class\n\t\t// Returns Shape object\n\n\t\tconst BIGNUMBER = 999999999;\n\n\t\tconst IntersectionLocationType = {\n\t\t\tORIGIN: 0,\n\t\t\tDESTINATION: 1,\n\t\t\tBETWEEN: 2,\n\t\t\tLEFT: 3,\n\t\t\tRIGHT: 4,\n\t\t\tBEHIND: 5,\n\t\t\tBEYOND: 6\n\t\t};\n\n\t\tconst classifyResult = {\n\t\t\tloc: IntersectionLocationType.ORIGIN,\n\t\t\tt: 0\n\t\t};\n\n\t\tfunction findEdgeIntersection( a0, a1, b0, b1 ) {\n\n\t\t\tconst x1 = a0.x;\n\t\t\tconst x2 = a1.x;\n\t\t\tconst x3 = b0.x;\n\t\t\tconst x4 = b1.x;\n\t\t\tconst y1 = a0.y;\n\t\t\tconst y2 = a1.y;\n\t\t\tconst y3 = b0.y;\n\t\t\tconst y4 = b1.y;\n\t\t\tconst nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );\n\t\t\tconst nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );\n\t\t\tconst denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );\n\t\t\tconst t1 = nom1 / denom;\n\t\t\tconst t2 = nom2 / denom;\n\n\t\t\tif ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {\n\n\t\t\t\t//1. lines are parallel or edges don't intersect\n\n\t\t\t\treturn null;\n\n\t\t\t} else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {\n\n\t\t\t\t//2. lines are colinear\n\n\t\t\t\t//check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\t\t\t\t\t//find position of this endpoints relatively to edge1\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t} else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {\n\n\t\t\t\t\t\tconst x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\tconst y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\treturn { x: x, y: y, t: classifyResult.t, };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t} else {\n\n\t\t\t\t//3. edges intersect\n\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\tconst y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\treturn { x: x, y: y, t: t1 };\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction classifyPoint( p, edgeStart, edgeEnd ) {\n\n\t\t\tconst ax = edgeEnd.x - edgeStart.x;\n\t\t\tconst ay = edgeEnd.y - edgeStart.y;\n\t\t\tconst bx = p.x - edgeStart.x;\n\t\t\tconst by = p.y - edgeStart.y;\n\t\t\tconst sa = ax * by - bx * ay;\n\n\t\t\tif ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.ORIGIN;\n\t\t\t\tclassifyResult.t = 0;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.DESTINATION;\n\t\t\t\tclassifyResult.t = 1;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa < - Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.LEFT;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa > Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.RIGHT;\n\t\t\t\treturn;\n\n\n\t\t\t}\n\n\t\t\tif ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEHIND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEYOND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet t;\n\n\t\t\tif ( ax !== 0 ) {\n\n\t\t\t\tt = bx / ax;\n\n\t\t\t} else {\n\n\t\t\t\tt = by / ay;\n\n\t\t\t}\n\n\t\t\tclassifyResult.loc = IntersectionLocationType.BETWEEN;\n\t\t\tclassifyResult.t = t;\n\n\t\t}\n\n\t\tfunction getIntersections( path1, path2 ) {\n\n\t\t\tconst intersectionsRaw = [];\n\t\t\tconst intersections = [];\n\n\t\t\tfor ( let index = 1; index < path1.length; index ++ ) {\n\n\t\t\t\tconst path1EdgeStart = path1[ index - 1 ];\n\t\t\t\tconst path1EdgeEnd = path1[ index ];\n\n\t\t\t\tfor ( let index2 = 1; index2 < path2.length; index2 ++ ) {\n\n\t\t\t\t\tconst path2EdgeStart = path2[ index2 - 1 ];\n\t\t\t\t\tconst path2EdgeEnd = path2[ index2 ];\n\n\t\t\t\t\tconst intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );\n\n\t\t\t\t\tif ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {\n\n\t\t\t\t\t\tintersectionsRaw.push( intersection );\n\t\t\t\t\t\tintersections.push( new Vector2( intersection.x, intersection.y ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn intersections;\n\n\t\t}\n\n\t\tfunction getScanlineIntersections( scanline, boundingBox, paths ) {\n\n\t\t\tconst center = new Vector2();\n\t\t\tboundingBox.getCenter( center );\n\n\t\t\tconst allIntersections = [];\n\n\t\t\tpaths.forEach( path => {\n\n\t\t\t\t// check if the center of the bounding box is in the bounding box of the paths.\n\t\t\t\t// this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n\t\t\t\t// if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n\t\t\t\tif ( path.boundingBox.containsPoint( center ) ) {\n\n\t\t\t\t\tconst intersections = getIntersections( scanline, path.points );\n\n\t\t\t\t\tintersections.forEach( p => {\n\n\t\t\t\t\t\tallIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tallIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\treturn allIntersections;\n\n\t\t}\n\n\t\tfunction isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {\n\n\t\t\tif ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {\n\n\t\t\t\t_fillRule = 'nonzero';\n\n\t\t\t}\n\n\t\t\tconst centerBoundingBox = new Vector2();\n\t\t\tsimplePath.boundingBox.getCenter( centerBoundingBox );\n\n\t\t\tconst scanline = [ new Vector2( scanlineMinX, centerBoundingBox.y ), new Vector2( scanlineMaxX, centerBoundingBox.y ) ];\n\n\t\t\tconst scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );\n\n\t\t\tscanlineIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\tconst baseIntersections = [];\n\t\t\tconst otherIntersections = [];\n\n\t\t\tscanlineIntersections.forEach( i => {\n\n\t\t\t\tif ( i.identifier === simplePath.identifier ) {\n\n\t\t\t\t\tbaseIntersections.push( i );\n\n\t\t\t\t} else {\n\n\t\t\t\t\totherIntersections.push( i );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tconst firstXOfPath = baseIntersections[ 0 ].point.x;\n\n\t\t\t// build up the path hierarchy\n\t\t\tconst stack = [];\n\t\t\tlet i = 0;\n\n\t\t\twhile ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {\n\n\t\t\t\tif ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {\n\n\t\t\t\t\tstack.pop();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( otherIntersections[ i ].identifier );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tstack.push( simplePath.identifier );\n\n\t\t\tif ( _fillRule === 'evenodd' ) {\n\n\t\t\t\tconst isHole = stack.length % 2 === 0 ? true : false;\n\t\t\t\tconst isHoleFor = stack[ stack.length - 2 ];\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else if ( _fillRule === 'nonzero' ) {\n\n\t\t\t\t// check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n\t\t\t\tlet isHole = true;\n\t\t\t\tlet isHoleFor = null;\n\t\t\t\tlet lastCWValue = null;\n\n\t\t\t\tfor ( let i = 0; i < stack.length; i ++ ) {\n\n\t\t\t\t\tconst identifier = stack[ i ];\n\t\t\t\t\tif ( isHole ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = false;\n\t\t\t\t\t\tisHoleFor = identifier;\n\n\t\t\t\t\t} else if ( lastCWValue !== allPaths[ identifier ].isCW ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'fill-rule: \"' + _fillRule + '\" is currently not implemented.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check for self intersecting paths\n\t\t// TODO\n\n\t\t// check intersecting paths\n\t\t// TODO\n\n\t\t// prepare paths for hole detection\n\t\tlet identifier = 0;\n\n\t\tlet scanlineMinX = BIGNUMBER;\n\t\tlet scanlineMaxX = - BIGNUMBER;\n\n\t\tlet simplePaths = shapePath.subPaths.map( p => {\n\n\t\t\tconst points = p.getPoints();\n\t\t\tlet maxY = - BIGNUMBER;\n\t\t\tlet minY = BIGNUMBER;\n\t\t\tlet maxX = - BIGNUMBER;\n\t\t\tlet minX = BIGNUMBER;\n\n\t      \t//points.forEach(p => p.y *= -1);\n\n\t\t\tfor ( let i = 0; i < points.length; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\n\t\t\t\tif ( p.y > maxY ) {\n\n\t\t\t\t\tmaxY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.y < minY ) {\n\n\t\t\t\t\tminY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x > maxX ) {\n\n\t\t\t\t\tmaxX = p.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x < minX ) {\n\n\t\t\t\t\tminX = p.x;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\t\t\tif ( scanlineMaxX <= maxX ) {\n\n\t\t\t\tscanlineMaxX = maxX + 1;\n\n\t\t\t}\n\n\t\t\tif ( scanlineMinX >= minX ) {\n\n\t\t\t\tscanlineMinX = minX - 1;\n\n\t\t\t}\n\n\t\t\treturn { points: points, isCW: ShapeUtils.isClockWise( points ), identifier: identifier ++, boundingBox: new Box2( new Vector2( minX, minY ), new Vector2( maxX, maxY ) ) };\n\n\t\t} );\n\n\t\tsimplePaths = simplePaths.filter( sp => sp.points.length > 1 );\n\n\t\t// check if path is solid or a hole\n\t\tconst isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule ) );\n\n\n\t\tconst shapesToReturn = [];\n\t\tsimplePaths.forEach( p => {\n\n\t\t\tconst amIAHole = isAHole[ p.identifier ];\n\n\t\t\tif ( ! amIAHole.isHole ) {\n\n\t\t\t\tconst shape = new Shape( p.points );\n\t\t\t\tconst holes = isAHole.filter( h => h.isHole && h.for === p.identifier );\n\t\t\t\tholes.forEach( h => {\n\n\t\t\t\t\tconst path = simplePaths[ h.identifier ];\n\t\t\t\t\tshape.holes.push( new Path( path.points ) );\n\n\t\t\t\t} );\n\t\t\t\tshapesToReturn.push( shape );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn shapesToReturn;\n\n\t}\n\n\tstatic getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t\t// Param width: Stroke width\n\t\t// Param color: As returned by THREE.Color.getStyle()\n\t\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t\t// Returns style object\n\n\t\twidth = width !== undefined ? width : 1;\n\t\tcolor = color !== undefined ? color : '#000';\n\t\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\t\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\t\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\t\treturn {\n\t\t\tstrokeColor: color,\n\t\t\tstrokeWidth: width,\n\t\t\tstrokeLineJoin: lineJoin,\n\t\t\tstrokeLineCap: lineCap,\n\t\t\tstrokeMiterLimit: miterLimit\n\t\t};\n\n\t}\n\n\tstatic pointsToStroke( points, style, arcDivisions, minDistance ) {\n\n\t\t// Generates a stroke with some witdh around the given path.\n\t\t// The path can be open or closed (last point equals to first point)\n\t\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\treturn geometry;\n\n\t}\n\n\tstatic pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tconst tempV2_1 = new Vector2();\n\t\tconst tempV2_2 = new Vector2();\n\t\tconst tempV2_3 = new Vector2();\n\t\tconst tempV2_4 = new Vector2();\n\t\tconst tempV2_5 = new Vector2();\n\t\tconst tempV2_6 = new Vector2();\n\t\tconst tempV2_7 = new Vector2();\n\t\tconst lastPointL = new Vector2();\n\t\tconst lastPointR = new Vector2();\n\t\tconst point0L = new Vector2();\n\t\tconst point0R = new Vector2();\n\t\tconst currentPointL = new Vector2();\n\t\tconst currentPointR = new Vector2();\n\t\tconst nextPointL = new Vector2();\n\t\tconst nextPointR = new Vector2();\n\t\tconst innerPoint = new Vector2();\n\t\tconst outerPoint = new Vector2();\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tconst numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tconst isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tlet currentPoint;\n\t\tlet previousPoint = points[ 0 ];\n\t\tlet nextPoint;\n\n\t\tconst strokeWidth2 = style.strokeWidth / 2;\n\n\t\tconst deltaU = 1 / ( numPoints - 1 );\n\t\tlet u0 = 0, u1;\n\n\t\tlet innerSideModified;\n\t\tlet joinIsOnLeftSide;\n\t\tlet isMiter;\n\t\tlet initialJoinIsOnLeftSide = false;\n\n\t\tlet numVertices = 0;\n\t\tlet currentCoordinate = vertexOffset * 3;\n\t\tlet currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tconst normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tu1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tconst dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot !== 0 ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tconst miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tconst miterLength2 = tempV2_5.length();\n\t\t\t\t\tconst segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tconst segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconst miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tlet lastOuter = outerPoint;\n\t\t\tlet lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tlet angle = Math.PI;\n\t\t\tconst dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tconst vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'butt':\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Nothing to do here\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tlet dupPoints = false;\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tconst newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t}\n\n\n}\n\nexport { SVGLoader };\n","import Stats from \"stats-js\";\n\nconst stats = new Stats();\nstats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom\n\nexport function updateStats() {\n\tstats.update();\n}\n\nlet showStats = false;\nexport function toggleStats() {\n\tshowStats = !showStats;\n\tif (showStats) {\n\t\tdocument.body.appendChild(stats.dom);\n\t} else {\n\t\tstats.dom.remove();\n\t}\n}\n","!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):e.Stats=t()}(this,function(){\"use strict\";var c=function(){var n=0,l=document.createElement(\"div\");function e(e){return l.appendChild(e.dom),e}function t(e){for(var t=0;t<l.children.length;t++)l.children[t].style.display=t===e?\"block\":\"none\";n=e}l.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\",l.addEventListener(\"click\",function(e){e.preventDefault(),t(++n%l.children.length)},!1);var i=(performance||Date).now(),a=i,o=0,f=e(new c.Panel(\"FPS\",\"#0ff\",\"#002\")),r=e(new c.Panel(\"MS\",\"#0f0\",\"#020\"));if(self.performance&&self.performance.memory)var d=e(new c.Panel(\"MB\",\"#f08\",\"#201\"));return t(0),{REVISION:16,dom:l,addPanel:e,showPanel:t,begin:function(){i=(performance||Date).now()},end:function(){o++;var e=(performance||Date).now();if(r.update(e-i,200),a+1e3<=e&&(f.update(1e3*o/(e-a),100),a=e,o=0,d)){var t=performance.memory;d.update(t.usedJSHeapSize/1048576,t.jsHeapSizeLimit/1048576)}return e},update:function(){i=this.end()},domElement:l,setMode:t}};return c.Panel=function(n,l,i){var a=1/0,o=0,f=Math.round,r=f(window.devicePixelRatio||1),d=80*r,e=48*r,c=3*r,p=2*r,u=3*r,s=15*r,m=74*r,h=30*r,y=document.createElement(\"canvas\");y.width=d,y.height=e,y.style.cssText=\"width:80px;height:48px\";var v=y.getContext(\"2d\");return v.font=\"bold \"+9*r+\"px Helvetica,Arial,sans-serif\",v.textBaseline=\"top\",v.fillStyle=i,v.fillRect(0,0,d,e),v.fillStyle=l,v.fillText(n,c,p),v.fillRect(u,s,m,h),v.fillStyle=i,v.globalAlpha=.9,v.fillRect(u,s,m,h),{dom:y,update:function(e,t){a=Math.min(a,e),o=Math.max(o,e),v.fillStyle=i,v.globalAlpha=1,v.fillRect(0,0,d,s),v.fillStyle=l,v.fillText(f(e)+\" \"+n+\" (\"+f(a)+\"-\"+f(o)+\")\",c,p),v.drawImage(y,u+r,s,m-r,h,u,s,m-r,h),v.fillRect(u+m-r,s,r,h),v.fillStyle=i,v.globalAlpha=.9,v.fillRect(u+m-r,s,r,f((1-e/t)*h))}}},c});\n"],"names":["$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$eq1Fs","$eOHOW","$df9b5faaec02a911$export$959ae9097e74a233","Loader","constructor","manager","defaultDPI","defaultUnit","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","parseArcCommand","rx","ry","x_axis_rotation","large_arc_flag","sweep_flag","start","end","lineTo","x","y","Math","PI","abs","dx2","dy2","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","currentPath","absellipse","ux","uy","vx","vy","ang","acos","min","dot","parseStyle","node","style","Object","assign","stylesheetStyles","hasAttribute","classSelectors","getAttribute","split","filter","Boolean","map","i","trim","length","stylesheets","addStyle","svgName","jsName","adjustFunction","undefined","v","startsWith","warn","clamp","parseFloatWithUnits","positive","parseFloats","input","flags","stride","current","TypeError","RE","SEPARATOR","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","FLAGS","state","seenComma","number","exponent","result","throwSyntaxError","partial","SyntaxError","newNumber","push","Number","pow","Array","isArray","includes","test","units","unitConversion","string","scale","theUnit","String","n","u","endsWith","substring","parseFloat","paths","transformStack","tempTransform0","Matrix3","tempTransform1","tempTransform2","tempTransform3","tempV2","Vector2","tempV3","Vector3","currentTransform","xml","DOMParser","parseFromString","parseNode","nodeType","transform","getNodeTransform","nodeName","parseNodeTransform","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","substr","array","identity","angle","rotate","multiplyMatrices","scaleX","scaleY","set","tan","premultiply","copy","traverseChildNodes","parseCSSStylesheet","sheet","cssRules","stylesheet","type","selectorList","selectorText","j","parsePathNode","ShapePath","point","control","firstPoint","isFirstPoint","doSetFirstPoint","d","commands","match","l","a","numbers","command","charAt","data","jl","moveTo","bezierCurveTo","b","quadraticCurveTo","clone","autoClose","curves","currentPoint","parseRectNode","w","h","parsePolygonNode","index","replace","parsePolylineNode","parseCircleNode","r","subpath","Path","absarc","subPaths","parseEllipseNode","parseLineNode","x1","y1","x2","y2","usedNodeId","href","baseVal","usedNode","viewportElement","getElementById","fill","color","setStyle","transformPath","m","transfVec2","v2","applyMatrix3","isRotated","elements","subPath","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","aX","aY","xRadius","getTransformScaleX","te","yRadius","getTransformScaleY","userData","nodes","childNodes","pop","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","createShapes","shapePath","IntersectionLocationType","ORIGIN","DESTINATION","BETWEEN","LEFT","RIGHT","BEHIND","BEYOND","classifyResult","loc","t","classifyPoint","p","edgeStart","edgeEnd","ax","ay","bx","by","sa","EPSILON","identifier","scanlineMinX","scanlineMaxX","simplePaths","points","getPoints","maxY","minY","maxX","minX","isCW","ShapeUtils","isClockWise","boundingBox","Box2","sp","isAHole","isHoleTo","simplePath","allPaths","_fillRule","centerBoundingBox","getCenter","scanline","scanlineIntersections","getScanlineIntersections","center","allIntersections","forEach","containsPoint","intersections","getIntersections","path1","path2","intersectionsRaw","path1EdgeStart","path1EdgeEnd","index2","path2EdgeStart","path2EdgeEnd","intersection","findEdgeIntersection","a0","a1","b0","b1","x3","x4","y3","y4","nom1","denom","t1","t2","nom2","toPrecision","find","sort","i1","i2","baseIntersections","otherIntersections","firstXOfPath","stack","isHole","isHoleFor","for","lastCWValue","fillRule","shapesToReturn","amIAHole","shape","Shape","holes","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","BufferGeometry","setAttribute","Float32BufferAttribute","vertexOffset","nextPoint","innerSideModified","joinIsOnLeftSide","isMiter","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","removeDuplicatedPoints","dupPoints","distanceTo","newPoints","numPoints","isClosed","equals","previousPoint","strokeWidth2","deltaU","u0","u1","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","subVectors","normal1","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","position","il","rotateAround","addVectors","vl","$a07f7f9dd384c0a2$exports","c","document","createElement","appendChild","dom","children","display","cssText","addEventListener","preventDefault","performance","Date","now","o","f","Panel","memory","REVISION","addPanel","showPanel","begin","update","usedJSHeapSize","jsHeapSizeLimit","domElement","setMode","round","devicePixelRatio","height","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","drawImage","$a8fffecac97013f4$var$stats","$parcel$interopDefault","__esModule","default","$a8fffecac97013f4$var$showStats","$b67b0d3037fbc2ca$var$renderer","WebGLRenderer","antialias","alpha","setClearColor","setSize","innerWidth","innerHeight","body","$b67b0d3037fbc2ca$var$scene","Scene","$b67b0d3037fbc2ca$var$camera","PerspectiveCamera","z","OrbitControls","$b67b0d3037fbc2ca$var$loader","group","Group","extrudeMaterial","MeshStandardMaterial","frontGlowMaterial","MeshBasicMaterial","side","BackSide","depthTest","shapes","toShapes","extrudeGeometry","ExtrudeGeometry","depth","bevelEnabled","extrudeMesh","Mesh","ShapeBufferGeometry","mesh","rotateZ","xhr","$b67b0d3037fbc2ca$var$light","HemisphereLight","remove","$b67b0d3037fbc2ca$var$animate","requestAnimationFrame","render"],"version":3,"file":"svg.685dea4d.js.map"}