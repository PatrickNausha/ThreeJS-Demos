{"mappings":"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","sources":["<anon>","node_modules/three/examples/jsm/controls/OrbitControls.js"],"sourcesContent":["function $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire1287\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire1287\"] = parcelRequire;\n}\nparcelRequire.register(\"eOHOW\", function(module, exports) {\n\n$parcel$export(module.exports, \"OrbitControls\", function () { return $ac97ba1014cae2cd$export$8ff7788029dfdf52; });\n\nvar $eq1Fs = parcelRequire(\"eq1Fs\");\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\nconst $ac97ba1014cae2cd$var$_changeEvent = {\n    type: \"change\"\n};\nconst $ac97ba1014cae2cd$var$_startEvent = {\n    type: \"start\"\n};\nconst $ac97ba1014cae2cd$var$_endEvent = {\n    type: \"end\"\n};\nclass $ac97ba1014cae2cd$export$8ff7788029dfdf52 extends (0, $eq1Fs.EventDispatcher) {\n    constructor(object, domElement){\n        super();\n        if (domElement === undefined) console.warn('THREE.OrbitControls: The second parameter \"domElement\" is now mandatory.');\n        if (domElement === document) console.error('THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.');\n        this.object = object;\n        this.domElement = domElement;\n        this.domElement.style.touchAction = \"none\"; // disable touch scroll\n        // Set to false to disable this control\n        this.enabled = true;\n        // \"target\" sets the location of focus, where the object orbits around\n        this.target = new (0, $eq1Fs.Vector3)();\n        // How far you can dolly in and out ( PerspectiveCamera only )\n        this.minDistance = 0;\n        this.maxDistance = Infinity;\n        // How far you can zoom in and out ( OrthographicCamera only )\n        this.minZoom = 0;\n        this.maxZoom = Infinity;\n        // How far you can orbit vertically, upper and lower limits.\n        // Range is 0 to Math.PI radians.\n        this.minPolarAngle = 0; // radians\n        this.maxPolarAngle = Math.PI; // radians\n        // How far you can orbit horizontally, upper and lower limits.\n        // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n        this.minAzimuthAngle = -Infinity; // radians\n        this.maxAzimuthAngle = Infinity; // radians\n        // Set to true to enable damping (inertia)\n        // If damping is enabled, you must call controls.update() in your animation loop\n        this.enableDamping = false;\n        this.dampingFactor = 0.05;\n        // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n        // Set to false to disable zooming\n        this.enableZoom = true;\n        this.zoomSpeed = 1.0;\n        // Set to false to disable rotating\n        this.enableRotate = true;\n        this.rotateSpeed = 1.0;\n        // Set to false to disable panning\n        this.enablePan = true;\n        this.panSpeed = 1.0;\n        this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n        this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n        // Set to true to automatically rotate around the target\n        // If auto-rotate is enabled, you must call controls.update() in your animation loop\n        this.autoRotate = false;\n        this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n        // The four arrow keys\n        this.keys = {\n            LEFT: \"ArrowLeft\",\n            UP: \"ArrowUp\",\n            RIGHT: \"ArrowRight\",\n            BOTTOM: \"ArrowDown\"\n        };\n        // Mouse buttons\n        this.mouseButtons = {\n            LEFT: (0, $eq1Fs.MOUSE).ROTATE,\n            MIDDLE: (0, $eq1Fs.MOUSE).DOLLY,\n            RIGHT: (0, $eq1Fs.MOUSE).PAN\n        };\n        // Touch fingers\n        this.touches = {\n            ONE: (0, $eq1Fs.TOUCH).ROTATE,\n            TWO: (0, $eq1Fs.TOUCH).DOLLY_PAN\n        };\n        // for reset\n        this.target0 = this.target.clone();\n        this.position0 = this.object.position.clone();\n        this.zoom0 = this.object.zoom;\n        // the target DOM element for key events\n        this._domElementKeyEvents = null;\n        //\n        // public methods\n        //\n        this.getPolarAngle = function() {\n            return spherical.phi;\n        };\n        this.getAzimuthalAngle = function() {\n            return spherical.theta;\n        };\n        this.getDistance = function() {\n            return this.object.position.distanceTo(this.target);\n        };\n        this.listenToKeyEvents = function(domElement) {\n            domElement.addEventListener(\"keydown\", onKeyDown);\n            this._domElementKeyEvents = domElement;\n        };\n        this.saveState = function() {\n            scope.target0.copy(scope.target);\n            scope.position0.copy(scope.object.position);\n            scope.zoom0 = scope.object.zoom;\n        };\n        this.reset = function() {\n            scope.target.copy(scope.target0);\n            scope.object.position.copy(scope.position0);\n            scope.object.zoom = scope.zoom0;\n            scope.object.updateProjectionMatrix();\n            scope.dispatchEvent($ac97ba1014cae2cd$var$_changeEvent);\n            scope.update();\n            state = STATE.NONE;\n        };\n        // this method is exposed, but perhaps it would be better if we can make it private...\n        this.update = function() {\n            const offset = new (0, $eq1Fs.Vector3)();\n            // so camera.up is the orbit axis\n            const quat = new (0, $eq1Fs.Quaternion)().setFromUnitVectors(object.up, new (0, $eq1Fs.Vector3)(0, 1, 0));\n            const quatInverse = quat.clone().invert();\n            const lastPosition = new (0, $eq1Fs.Vector3)();\n            const lastQuaternion = new (0, $eq1Fs.Quaternion)();\n            const twoPI = 2 * Math.PI;\n            return function update() {\n                const position = scope.object.position;\n                offset.copy(position).sub(scope.target);\n                // rotate offset to \"y-axis-is-up\" space\n                offset.applyQuaternion(quat);\n                // angle from z-axis around y-axis\n                spherical.setFromVector3(offset);\n                if (scope.autoRotate && state === STATE.NONE) rotateLeft(getAutoRotationAngle());\n                if (scope.enableDamping) {\n                    spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n                    spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n                } else {\n                    spherical.theta += sphericalDelta.theta;\n                    spherical.phi += sphericalDelta.phi;\n                }\n                // restrict theta to be between desired limits\n                let min = scope.minAzimuthAngle;\n                let max = scope.maxAzimuthAngle;\n                if (isFinite(min) && isFinite(max)) {\n                    if (min < -Math.PI) min += twoPI;\n                    else if (min > Math.PI) min -= twoPI;\n                    if (max < -Math.PI) max += twoPI;\n                    else if (max > Math.PI) max -= twoPI;\n                    if (min <= max) spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n                    else spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);\n                }\n                // restrict phi to be between desired limits\n                spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n                spherical.makeSafe();\n                spherical.radius *= scale;\n                // restrict radius to be between desired limits\n                spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));\n                // move target to panned location\n                if (scope.enableDamping === true) scope.target.addScaledVector(panOffset, scope.dampingFactor);\n                else scope.target.add(panOffset);\n                offset.setFromSpherical(spherical);\n                // rotate offset back to \"camera-up-vector-is-up\" space\n                offset.applyQuaternion(quatInverse);\n                position.copy(scope.target).add(offset);\n                scope.object.lookAt(scope.target);\n                if (scope.enableDamping === true) {\n                    sphericalDelta.theta *= 1 - scope.dampingFactor;\n                    sphericalDelta.phi *= 1 - scope.dampingFactor;\n                    panOffset.multiplyScalar(1 - scope.dampingFactor);\n                } else {\n                    sphericalDelta.set(0, 0, 0);\n                    panOffset.set(0, 0, 0);\n                }\n                scale = 1;\n                // update condition is:\n                // min(camera displacement, camera rotation in radians)^2 > EPS\n                // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n                if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n                    scope.dispatchEvent($ac97ba1014cae2cd$var$_changeEvent);\n                    lastPosition.copy(scope.object.position);\n                    lastQuaternion.copy(scope.object.quaternion);\n                    zoomChanged = false;\n                    return true;\n                }\n                return false;\n            };\n        }();\n        this.dispose = function() {\n            scope.domElement.removeEventListener(\"contextmenu\", onContextMenu);\n            scope.domElement.removeEventListener(\"pointerdown\", onPointerDown);\n            scope.domElement.removeEventListener(\"pointercancel\", onPointerCancel);\n            scope.domElement.removeEventListener(\"wheel\", onMouseWheel);\n            scope.domElement.removeEventListener(\"pointermove\", onPointerMove);\n            scope.domElement.removeEventListener(\"pointerup\", onPointerUp);\n            if (scope._domElementKeyEvents !== null) scope._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n        //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n        };\n        //\n        // internals\n        //\n        const scope = this;\n        const STATE = {\n            NONE: -1,\n            ROTATE: 0,\n            DOLLY: 1,\n            PAN: 2,\n            TOUCH_ROTATE: 3,\n            TOUCH_PAN: 4,\n            TOUCH_DOLLY_PAN: 5,\n            TOUCH_DOLLY_ROTATE: 6\n        };\n        let state = STATE.NONE;\n        const EPS = 0.000001;\n        // current position in spherical coordinates\n        const spherical = new (0, $eq1Fs.Spherical)();\n        const sphericalDelta = new (0, $eq1Fs.Spherical)();\n        let scale = 1;\n        const panOffset = new (0, $eq1Fs.Vector3)();\n        let zoomChanged = false;\n        const rotateStart = new (0, $eq1Fs.Vector2)();\n        const rotateEnd = new (0, $eq1Fs.Vector2)();\n        const rotateDelta = new (0, $eq1Fs.Vector2)();\n        const panStart = new (0, $eq1Fs.Vector2)();\n        const panEnd = new (0, $eq1Fs.Vector2)();\n        const panDelta = new (0, $eq1Fs.Vector2)();\n        const dollyStart = new (0, $eq1Fs.Vector2)();\n        const dollyEnd = new (0, $eq1Fs.Vector2)();\n        const dollyDelta = new (0, $eq1Fs.Vector2)();\n        const pointers = [];\n        const pointerPositions = {};\n        function getAutoRotationAngle() {\n            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n        }\n        function getZoomScale() {\n            return Math.pow(0.95, scope.zoomSpeed);\n        }\n        function rotateLeft(angle) {\n            sphericalDelta.theta -= angle;\n        }\n        function rotateUp(angle) {\n            sphericalDelta.phi -= angle;\n        }\n        const panLeft = function() {\n            const v = new (0, $eq1Fs.Vector3)();\n            return function panLeft(distance, objectMatrix) {\n                v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n                v.multiplyScalar(-distance);\n                panOffset.add(v);\n            };\n        }();\n        const panUp = function() {\n            const v = new (0, $eq1Fs.Vector3)();\n            return function panUp(distance, objectMatrix) {\n                if (scope.screenSpacePanning === true) v.setFromMatrixColumn(objectMatrix, 1);\n                else {\n                    v.setFromMatrixColumn(objectMatrix, 0);\n                    v.crossVectors(scope.object.up, v);\n                }\n                v.multiplyScalar(distance);\n                panOffset.add(v);\n            };\n        }();\n        // deltaX and deltaY are in pixels; right and down are positive\n        const pan = function() {\n            const offset = new (0, $eq1Fs.Vector3)();\n            return function pan(deltaX, deltaY) {\n                const element = scope.domElement;\n                if (scope.object.isPerspectiveCamera) {\n                    // perspective\n                    const position = scope.object.position;\n                    offset.copy(position).sub(scope.target);\n                    let targetDistance = offset.length();\n                    // half of the fov is center to top of screen\n                    targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);\n                    // we use only clientHeight here so aspect ratio does not distort speed\n                    panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n                    panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n                } else if (scope.object.isOrthographicCamera) {\n                    // orthographic\n                    panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);\n                    panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);\n                } else {\n                    // camera neither orthographic nor perspective\n                    console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n                    scope.enablePan = false;\n                }\n            };\n        }();\n        function dollyOut(dollyScale) {\n            if (scope.object.isPerspectiveCamera) scale /= dollyScale;\n            else if (scope.object.isOrthographicCamera) {\n                scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));\n                scope.object.updateProjectionMatrix();\n                zoomChanged = true;\n            } else {\n                console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n                scope.enableZoom = false;\n            }\n        }\n        function dollyIn(dollyScale) {\n            if (scope.object.isPerspectiveCamera) scale *= dollyScale;\n            else if (scope.object.isOrthographicCamera) {\n                scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));\n                scope.object.updateProjectionMatrix();\n                zoomChanged = true;\n            } else {\n                console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n                scope.enableZoom = false;\n            }\n        }\n        //\n        // event callbacks - update the object state\n        //\n        function handleMouseDownRotate(event) {\n            rotateStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseDownDolly(event) {\n            dollyStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseDownPan(event) {\n            panStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseMoveRotate(event) {\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n            const element = scope.domElement;\n            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n            rotateStart.copy(rotateEnd);\n            scope.update();\n        }\n        function handleMouseMoveDolly(event) {\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n            if (dollyDelta.y > 0) dollyOut(getZoomScale());\n            else if (dollyDelta.y < 0) dollyIn(getZoomScale());\n            dollyStart.copy(dollyEnd);\n            scope.update();\n        }\n        function handleMouseMovePan(event) {\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n            pan(panDelta.x, panDelta.y);\n            panStart.copy(panEnd);\n            scope.update();\n        }\n        function handleMouseUp() {\n        // no-op\n        }\n        function handleMouseWheel(event) {\n            if (event.deltaY < 0) dollyIn(getZoomScale());\n            else if (event.deltaY > 0) dollyOut(getZoomScale());\n            scope.update();\n        }\n        function handleKeyDown(event) {\n            let needsUpdate = false;\n            switch(event.code){\n                case scope.keys.UP:\n                    pan(0, scope.keyPanSpeed);\n                    needsUpdate = true;\n                    break;\n                case scope.keys.BOTTOM:\n                    pan(0, -scope.keyPanSpeed);\n                    needsUpdate = true;\n                    break;\n                case scope.keys.LEFT:\n                    pan(scope.keyPanSpeed, 0);\n                    needsUpdate = true;\n                    break;\n                case scope.keys.RIGHT:\n                    pan(-scope.keyPanSpeed, 0);\n                    needsUpdate = true;\n                    break;\n            }\n            if (needsUpdate) {\n                // prevent the browser from scrolling on cursor keys\n                event.preventDefault();\n                scope.update();\n            }\n        }\n        function handleTouchStartRotate() {\n            if (pointers.length === 1) rotateStart.set(pointers[0].pageX, pointers[0].pageY);\n            else {\n                const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n                const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n                rotateStart.set(x, y);\n            }\n        }\n        function handleTouchStartPan() {\n            if (pointers.length === 1) panStart.set(pointers[0].pageX, pointers[0].pageY);\n            else {\n                const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n                const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n                panStart.set(x, y);\n            }\n        }\n        function handleTouchStartDolly() {\n            const dx = pointers[0].pageX - pointers[1].pageX;\n            const dy = pointers[0].pageY - pointers[1].pageY;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            dollyStart.set(0, distance);\n        }\n        function handleTouchStartDollyPan() {\n            if (scope.enableZoom) handleTouchStartDolly();\n            if (scope.enablePan) handleTouchStartPan();\n        }\n        function handleTouchStartDollyRotate() {\n            if (scope.enableZoom) handleTouchStartDolly();\n            if (scope.enableRotate) handleTouchStartRotate();\n        }\n        function handleTouchMoveRotate(event) {\n            if (pointers.length == 1) rotateEnd.set(event.pageX, event.pageY);\n            else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                rotateEnd.set(x, y);\n            }\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n            const element = scope.domElement;\n            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n            rotateStart.copy(rotateEnd);\n        }\n        function handleTouchMovePan(event) {\n            if (pointers.length === 1) panEnd.set(event.pageX, event.pageY);\n            else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                panEnd.set(x, y);\n            }\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n            pan(panDelta.x, panDelta.y);\n            panStart.copy(panEnd);\n        }\n        function handleTouchMoveDolly(event) {\n            const position = getSecondPointerPosition(event);\n            const dx = event.pageX - position.x;\n            const dy = event.pageY - position.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            dollyEnd.set(0, distance);\n            dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n            dollyOut(dollyDelta.y);\n            dollyStart.copy(dollyEnd);\n        }\n        function handleTouchMoveDollyPan(event) {\n            if (scope.enableZoom) handleTouchMoveDolly(event);\n            if (scope.enablePan) handleTouchMovePan(event);\n        }\n        function handleTouchMoveDollyRotate(event) {\n            if (scope.enableZoom) handleTouchMoveDolly(event);\n            if (scope.enableRotate) handleTouchMoveRotate(event);\n        }\n        function handleTouchEnd() {\n        // no-op\n        }\n        //\n        // event handlers - FSM: listen for events and reset state\n        //\n        function onPointerDown(event) {\n            if (scope.enabled === false) return;\n            if (pointers.length === 0) {\n                scope.domElement.setPointerCapture(event.pointerId);\n                scope.domElement.addEventListener(\"pointermove\", onPointerMove);\n                scope.domElement.addEventListener(\"pointerup\", onPointerUp);\n            }\n            //\n            addPointer(event);\n            if (event.pointerType === \"touch\") onTouchStart(event);\n            else onMouseDown(event);\n        }\n        function onPointerMove(event) {\n            if (scope.enabled === false) return;\n            if (event.pointerType === \"touch\") onTouchMove(event);\n            else onMouseMove(event);\n        }\n        function onPointerUp(event) {\n            if (scope.enabled === false) return;\n            if (event.pointerType === \"touch\") onTouchEnd();\n            else onMouseUp(event);\n            removePointer(event);\n            //\n            if (pointers.length === 0) {\n                scope.domElement.releasePointerCapture(event.pointerId);\n                scope.domElement.removeEventListener(\"pointermove\", onPointerMove);\n                scope.domElement.removeEventListener(\"pointerup\", onPointerUp);\n            }\n        }\n        function onPointerCancel(event) {\n            removePointer(event);\n        }\n        function onMouseDown(event) {\n            let mouseAction;\n            switch(event.button){\n                case 0:\n                    mouseAction = scope.mouseButtons.LEFT;\n                    break;\n                case 1:\n                    mouseAction = scope.mouseButtons.MIDDLE;\n                    break;\n                case 2:\n                    mouseAction = scope.mouseButtons.RIGHT;\n                    break;\n                default:\n                    mouseAction = -1;\n            }\n            switch(mouseAction){\n                case (0, $eq1Fs.MOUSE).DOLLY:\n                    if (scope.enableZoom === false) return;\n                    handleMouseDownDolly(event);\n                    state = STATE.DOLLY;\n                    break;\n                case (0, $eq1Fs.MOUSE).ROTATE:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        if (scope.enablePan === false) return;\n                        handleMouseDownPan(event);\n                        state = STATE.PAN;\n                    } else {\n                        if (scope.enableRotate === false) return;\n                        handleMouseDownRotate(event);\n                        state = STATE.ROTATE;\n                    }\n                    break;\n                case (0, $eq1Fs.MOUSE).PAN:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        if (scope.enableRotate === false) return;\n                        handleMouseDownRotate(event);\n                        state = STATE.ROTATE;\n                    } else {\n                        if (scope.enablePan === false) return;\n                        handleMouseDownPan(event);\n                        state = STATE.PAN;\n                    }\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n            if (state !== STATE.NONE) scope.dispatchEvent($ac97ba1014cae2cd$var$_startEvent);\n        }\n        function onMouseMove(event) {\n            if (scope.enabled === false) return;\n            switch(state){\n                case STATE.ROTATE:\n                    if (scope.enableRotate === false) return;\n                    handleMouseMoveRotate(event);\n                    break;\n                case STATE.DOLLY:\n                    if (scope.enableZoom === false) return;\n                    handleMouseMoveDolly(event);\n                    break;\n                case STATE.PAN:\n                    if (scope.enablePan === false) return;\n                    handleMouseMovePan(event);\n                    break;\n            }\n        }\n        function onMouseUp(event) {\n            handleMouseUp(event);\n            scope.dispatchEvent($ac97ba1014cae2cd$var$_endEvent);\n            state = STATE.NONE;\n        }\n        function onMouseWheel(event) {\n            if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;\n            event.preventDefault();\n            scope.dispatchEvent($ac97ba1014cae2cd$var$_startEvent);\n            handleMouseWheel(event);\n            scope.dispatchEvent($ac97ba1014cae2cd$var$_endEvent);\n        }\n        function onKeyDown(event) {\n            if (scope.enabled === false || scope.enablePan === false) return;\n            handleKeyDown(event);\n        }\n        function onTouchStart(event) {\n            trackPointer(event);\n            switch(pointers.length){\n                case 1:\n                    switch(scope.touches.ONE){\n                        case (0, $eq1Fs.TOUCH).ROTATE:\n                            if (scope.enableRotate === false) return;\n                            handleTouchStartRotate();\n                            state = STATE.TOUCH_ROTATE;\n                            break;\n                        case (0, $eq1Fs.TOUCH).PAN:\n                            if (scope.enablePan === false) return;\n                            handleTouchStartPan();\n                            state = STATE.TOUCH_PAN;\n                            break;\n                        default:\n                            state = STATE.NONE;\n                    }\n                    break;\n                case 2:\n                    switch(scope.touches.TWO){\n                        case (0, $eq1Fs.TOUCH).DOLLY_PAN:\n                            if (scope.enableZoom === false && scope.enablePan === false) return;\n                            handleTouchStartDollyPan();\n                            state = STATE.TOUCH_DOLLY_PAN;\n                            break;\n                        case (0, $eq1Fs.TOUCH).DOLLY_ROTATE:\n                            if (scope.enableZoom === false && scope.enableRotate === false) return;\n                            handleTouchStartDollyRotate();\n                            state = STATE.TOUCH_DOLLY_ROTATE;\n                            break;\n                        default:\n                            state = STATE.NONE;\n                    }\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n            if (state !== STATE.NONE) scope.dispatchEvent($ac97ba1014cae2cd$var$_startEvent);\n        }\n        function onTouchMove(event) {\n            trackPointer(event);\n            switch(state){\n                case STATE.TOUCH_ROTATE:\n                    if (scope.enableRotate === false) return;\n                    handleTouchMoveRotate(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_PAN:\n                    if (scope.enablePan === false) return;\n                    handleTouchMovePan(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_DOLLY_PAN:\n                    if (scope.enableZoom === false && scope.enablePan === false) return;\n                    handleTouchMoveDollyPan(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_DOLLY_ROTATE:\n                    if (scope.enableZoom === false && scope.enableRotate === false) return;\n                    handleTouchMoveDollyRotate(event);\n                    scope.update();\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n        }\n        function onTouchEnd(event) {\n            handleTouchEnd(event);\n            scope.dispatchEvent($ac97ba1014cae2cd$var$_endEvent);\n            state = STATE.NONE;\n        }\n        function onContextMenu(event) {\n            if (scope.enabled === false) return;\n            event.preventDefault();\n        }\n        function addPointer(event) {\n            pointers.push(event);\n        }\n        function removePointer(event) {\n            delete pointerPositions[event.pointerId];\n            for(let i = 0; i < pointers.length; i++)if (pointers[i].pointerId == event.pointerId) {\n                pointers.splice(i, 1);\n                return;\n            }\n        }\n        function trackPointer(event) {\n            let position = pointerPositions[event.pointerId];\n            if (position === undefined) {\n                position = new (0, $eq1Fs.Vector2)();\n                pointerPositions[event.pointerId] = position;\n            }\n            position.set(event.pageX, event.pageY);\n        }\n        function getSecondPointerPosition(event) {\n            const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];\n            return pointerPositions[pointer.pointerId];\n        }\n        //\n        scope.domElement.addEventListener(\"contextmenu\", onContextMenu);\n        scope.domElement.addEventListener(\"pointerdown\", onPointerDown);\n        scope.domElement.addEventListener(\"pointercancel\", onPointerCancel);\n        scope.domElement.addEventListener(\"wheel\", onMouseWheel, {\n            passive: false\n        });\n        // force an update at start\n        this.update();\n    }\n}\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\nclass $ac97ba1014cae2cd$export$7628ccdac312035f extends $ac97ba1014cae2cd$export$8ff7788029dfdf52 {\n    constructor(object, domElement){\n        super(object, domElement);\n        this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up\n        this.mouseButtons.LEFT = (0, $eq1Fs.MOUSE).PAN;\n        this.mouseButtons.RIGHT = (0, $eq1Fs.MOUSE).ROTATE;\n        this.touches.ONE = (0, $eq1Fs.TOUCH).PAN;\n        this.touches.TWO = (0, $eq1Fs.TOUCH).DOLLY_ROTATE;\n    }\n}\n\n});\n\n\n//# sourceMappingURL=shadows.4b967d90.js.map\n","import {\n\tEventDispatcher,\n\tMOUSE,\n\tQuaternion,\n\tSpherical,\n\tTOUCH,\n\tVector2,\n\tVector3\n} from 'three';\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\n\nclass OrbitControls extends EventDispatcher {\n\n\tconstructor( object, domElement ) {\n\n\t\tsuper();\n\n\t\tif ( domElement === undefined ) console.warn( 'THREE.OrbitControls: The second parameter \"domElement\" is now mandatory.' );\n\t\tif ( domElement === document ) console.error( 'THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.' );\n\n\t\tthis.object = object;\n\t\tthis.domElement = domElement;\n\t\tthis.domElement.style.touchAction = 'none'; // disable touch scroll\n\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\n\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\tthis.target = new Vector3();\n\n\t\t// How far you can dolly in and out ( PerspectiveCamera only )\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\n\t\t// How far you can zoom in and out ( OrthographicCamera only )\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t\t// Set to true to enable damping (inertia)\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.05;\n\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t\t// Set to false to disable zooming\n\t\tthis.enableZoom = true;\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t// Set to false to disable rotating\n\t\tthis.enableRotate = true;\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t// Set to false to disable panning\n\t\tthis.enablePan = true;\n\t\tthis.panSpeed = 1.0;\n\t\tthis.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t\t// Set to true to automatically rotate around the target\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };\n\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };\n\n\t\t// Touch fingers\n\t\tthis.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };\n\n\t\t// for reset\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t// the target DOM element for key events\n\t\tthis._domElementKeyEvents = null;\n\n\t\t//\n\t\t// public methods\n\t\t//\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn spherical.phi;\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn spherical.theta;\n\n\t\t};\n\n\t\tthis.getDistance = function () {\n\n\t\t\treturn this.object.position.distanceTo( this.target );\n\n\t\t};\n\n\t\tthis.listenToKeyEvents = function ( domElement ) {\n\n\t\t\tdomElement.addEventListener( 'keydown', onKeyDown );\n\t\t\tthis._domElementKeyEvents = domElement;\n\n\t\t};\n\n\t\tthis.saveState = function () {\n\n\t\t\tscope.target0.copy( scope.target );\n\t\t\tscope.position0.copy( scope.object.position );\n\t\t\tscope.zoom0 = scope.object.zoom;\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tscope.target.copy( scope.target0 );\n\t\t\tscope.object.position.copy( scope.position0 );\n\t\t\tscope.object.zoom = scope.zoom0;\n\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\tscope.update();\n\n\t\t\tstate = STATE.NONE;\n\n\t\t};\n\n\t\t// this method is exposed, but perhaps it would be better if we can make it private...\n\t\tthis.update = function () {\n\n\t\t\tconst offset = new Vector3();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tconst quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );\n\t\t\tconst quatInverse = quat.clone().invert();\n\n\t\t\tconst lastPosition = new Vector3();\n\t\t\tconst lastQuaternion = new Quaternion();\n\n\t\t\tconst twoPI = 2 * Math.PI;\n\n\t\t\treturn function update() {\n\n\t\t\t\tconst position = scope.object.position;\n\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t\t// angle from z-axis around y-axis\n\t\t\t\tspherical.setFromVector3( offset );\n\n\t\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\t\trotateLeft( getAutoRotationAngle() );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.enableDamping ) {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta * scope.dampingFactor;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi * scope.dampingFactor;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t\t}\n\n\t\t\t\t// restrict theta to be between desired limits\n\n\t\t\t\tlet min = scope.minAzimuthAngle;\n\t\t\t\tlet max = scope.maxAzimuthAngle;\n\n\t\t\t\tif ( isFinite( min ) && isFinite( max ) ) {\n\n\t\t\t\t\tif ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;\n\n\t\t\t\t\tif ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;\n\n\t\t\t\t\tif ( min <= max ) {\n\n\t\t\t\t\t\tspherical.theta = Math.max( min, Math.min( max, spherical.theta ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tspherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?\n\t\t\t\t\t\t\tMath.max( min, spherical.theta ) :\n\t\t\t\t\t\t\tMath.min( max, spherical.theta );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n\t\t\t\tspherical.makeSafe();\n\n\n\t\t\t\tspherical.radius *= scale;\n\n\t\t\t\t// restrict radius to be between desired limits\n\t\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\n\n\t\t\t\t// move target to panned location\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tscope.target.addScaledVector( panOffset, scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscope.target.add( panOffset );\n\n\t\t\t\t}\n\n\t\t\t\toffset.setFromSpherical( spherical );\n\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\t\tposition.copy( scope.target ).add( offset );\n\n\t\t\t\tscope.object.lookAt( scope.target );\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n\t\t\t\t\tpanOffset.multiplyScalar( 1 - scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\n\t\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tscale = 1;\n\n\t\t\t\t// update condition is:\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\n\n\t\t\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\t\tzoomChanged = false;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}();\n\n\t\tthis.dispose = function () {\n\n\t\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu );\n\n\t\t\tscope.domElement.removeEventListener( 'pointerdown', onPointerDown );\n\t\t\tscope.domElement.removeEventListener( 'pointercancel', onPointerCancel );\n\t\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel );\n\n\t\t\tscope.domElement.removeEventListener( 'pointermove', onPointerMove );\n\t\t\tscope.domElement.removeEventListener( 'pointerup', onPointerUp );\n\n\n\t\t\tif ( scope._domElementKeyEvents !== null ) {\n\n\t\t\t\tscope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );\n\n\t\t\t}\n\n\t\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t\t};\n\n\t\t//\n\t\t// internals\n\t\t//\n\n\t\tconst scope = this;\n\n\t\tconst STATE = {\n\t\t\tNONE: - 1,\n\t\t\tROTATE: 0,\n\t\t\tDOLLY: 1,\n\t\t\tPAN: 2,\n\t\t\tTOUCH_ROTATE: 3,\n\t\t\tTOUCH_PAN: 4,\n\t\t\tTOUCH_DOLLY_PAN: 5,\n\t\t\tTOUCH_DOLLY_ROTATE: 6\n\t\t};\n\n\t\tlet state = STATE.NONE;\n\n\t\tconst EPS = 0.000001;\n\n\t\t// current position in spherical coordinates\n\t\tconst spherical = new Spherical();\n\t\tconst sphericalDelta = new Spherical();\n\n\t\tlet scale = 1;\n\t\tconst panOffset = new Vector3();\n\t\tlet zoomChanged = false;\n\n\t\tconst rotateStart = new Vector2();\n\t\tconst rotateEnd = new Vector2();\n\t\tconst rotateDelta = new Vector2();\n\n\t\tconst panStart = new Vector2();\n\t\tconst panEnd = new Vector2();\n\t\tconst panDelta = new Vector2();\n\n\t\tconst dollyStart = new Vector2();\n\t\tconst dollyEnd = new Vector2();\n\t\tconst dollyDelta = new Vector2();\n\n\t\tconst pointers = [];\n\t\tconst pointerPositions = {};\n\n\t\tfunction getAutoRotationAngle() {\n\n\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t\t}\n\n\t\tfunction getZoomScale() {\n\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t\t}\n\n\t\tfunction rotateLeft( angle ) {\n\n\t\t\tsphericalDelta.theta -= angle;\n\n\t\t}\n\n\t\tfunction rotateUp( angle ) {\n\n\t\t\tsphericalDelta.phi -= angle;\n\n\t\t}\n\n\t\tconst panLeft = function () {\n\n\t\t\tconst v = new Vector3();\n\n\t\t\treturn function panLeft( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\t\tv.multiplyScalar( - distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\tconst panUp = function () {\n\n\t\t\tconst v = new Vector3();\n\n\t\t\treturn function panUp( distance, objectMatrix ) {\n\n\t\t\t\tif ( scope.screenSpacePanning === true ) {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 );\n\t\t\t\t\tv.crossVectors( scope.object.up, v );\n\n\t\t\t\t}\n\n\t\t\t\tv.multiplyScalar( distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// deltaX and deltaY are in pixels; right and down are positive\n\t\tconst pan = function () {\n\n\t\t\tconst offset = new Vector3();\n\n\t\t\treturn function pan( deltaX, deltaY ) {\n\n\t\t\t\tconst element = scope.domElement;\n\n\t\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t// perspective\n\t\t\t\t\tconst position = scope.object.position;\n\t\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\t\tlet targetDistance = offset.length();\n\n\t\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\n\t\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\t// orthographic\n\t\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\t\tscope.enablePan = false;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}();\n\n\t\tfunction dollyOut( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\tscale /= dollyScale;\n\n\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction dollyIn( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\tscale *= dollyScale;\n\n\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\t\t// event callbacks - update the object state\n\t\t//\n\n\t\tfunction handleMouseDownRotate( event ) {\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownDolly( event ) {\n\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownPan( event ) {\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseMoveRotate( event ) {\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMoveDolly( event ) {\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMovePan( event ) {\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseUp( /*event*/ ) {\n\n\t\t\t// no-op\n\n\t\t}\n\n\t\tfunction handleMouseWheel( event ) {\n\n\t\t\tif ( event.deltaY < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleKeyDown( event ) {\n\n\t\t\tlet needsUpdate = false;\n\n\t\t\tswitch ( event.code ) {\n\n\t\t\t\tcase scope.keys.UP:\n\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t// prevent the browser from scrolling on cursor keys\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tscope.update();\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tfunction handleTouchStartRotate() {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\trotateStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );\n\t\t\t\tconst y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );\n\n\t\t\t\trotateStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartPan() {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\tpanStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );\n\t\t\t\tconst y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );\n\n\t\t\t\tpanStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartDolly() {\n\n\t\t\tconst dx = pointers[ 0 ].pageX - pointers[ 1 ].pageX;\n\t\t\tconst dy = pointers[ 0 ].pageY - pointers[ 1 ].pageY;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyStart.set( 0, distance );\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyPan() {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly();\n\n\t\t\tif ( scope.enablePan ) handleTouchStartPan();\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyRotate() {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly();\n\n\t\t\tif ( scope.enableRotate ) handleTouchStartRotate();\n\n\t\t}\n\n\t\tfunction handleTouchMoveRotate( event ) {\n\n\t\t\tif ( pointers.length == 1 ) {\n\n\t\t\t\trotateEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\trotateEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMovePan( event ) {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\tpanEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\tpanEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDolly( event ) {\n\n\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\tconst dx = event.pageX - position.x;\n\t\t\tconst dy = event.pageY - position.y;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyEnd.set( 0, distance );\n\n\t\t\tdollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );\n\n\t\t\tdollyOut( dollyDelta.y );\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyPan( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enablePan ) handleTouchMovePan( event );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyRotate( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enableRotate ) handleTouchMoveRotate( event );\n\n\t\t}\n\n\t\tfunction handleTouchEnd( /*event*/ ) {\n\n\t\t\t// no-op\n\n\t\t}\n\n\t\t//\n\t\t// event handlers - FSM: listen for events and reset state\n\t\t//\n\n\t\tfunction onPointerDown( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( pointers.length === 0 ) {\n\n\t\t\t\tscope.domElement.setPointerCapture( event.pointerId );\n\n\t\t\t\tscope.domElement.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tscope.domElement.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\taddPointer( event );\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchStart( event );\n\n\t\t\t} else {\n\n\t\t\t\tonMouseDown( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchMove( event );\n\n\t\t\t} else {\n\n\t\t\t\tonMouseMove( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerUp( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchEnd();\n\n\t\t\t} else {\n\n\t\t\t\tonMouseUp( event );\n\n\t\t\t}\n\n\t\t\tremovePointer( event );\n\n\t\t\t//\n\n\t\t\tif ( pointers.length === 0 ) {\n\n\t\t\t\tscope.domElement.releasePointerCapture( event.pointerId );\n\n\t\t\t\tscope.domElement.removeEventListener( 'pointermove', onPointerMove );\n\t\t\t\tscope.domElement.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerCancel( event ) {\n\n\t\t\tremovePointer( event );\n\n\t\t}\n\n\t\tfunction onMouseDown( event ) {\n\n\t\t\tlet mouseAction;\n\n\t\t\tswitch ( event.button ) {\n\n\t\t\t\tcase 0:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.LEFT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.MIDDLE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.RIGHT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tmouseAction = - 1;\n\n\t\t\t}\n\n\t\t\tswitch ( mouseAction ) {\n\n\t\t\t\tcase MOUSE.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseDownDolly( event );\n\n\t\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MOUSE.ROTATE:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MOUSE.PAN:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleMouseMoveRotate( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseMoveDolly( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleMouseMovePan( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseUp( event ) {\n\n\t\t\thandleMouseUp( event );\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onMouseWheel( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\thandleMouseWheel( event );\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enablePan === false ) return;\n\n\t\t\thandleKeyDown( event );\n\n\t\t}\n\n\t\tfunction onTouchStart( event ) {\n\n\t\t\ttrackPointer( event );\n\n\t\t\tswitch ( pointers.length ) {\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tswitch ( scope.touches.ONE ) {\n\n\t\t\t\t\t\tcase TOUCH.ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartRotate();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TOUCH.PAN:\n\n\t\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartPan();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tswitch ( scope.touches.TWO ) {\n\n\t\t\t\t\t\tcase TOUCH.DOLLY_PAN:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyPan();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TOUCH.DOLLY_ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyRotate();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchMove( event ) {\n\n\t\t\ttrackPointer( event );\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.TOUCH_ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMovePan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_PAN:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyPan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_ROTATE:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchEnd( event ) {\n\n\t\t\thandleTouchEnd( event );\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onContextMenu( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t}\n\n\t\tfunction addPointer( event ) {\n\n\t\t\tpointers.push( event );\n\n\t\t}\n\n\t\tfunction removePointer( event ) {\n\n\t\t\tdelete pointerPositions[ event.pointerId ];\n\n\t\t\tfor ( let i = 0; i < pointers.length; i ++ ) {\n\n\t\t\t\tif ( pointers[ i ].pointerId == event.pointerId ) {\n\n\t\t\t\t\tpointers.splice( i, 1 );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction trackPointer( event ) {\n\n\t\t\tlet position = pointerPositions[ event.pointerId ];\n\n\t\t\tif ( position === undefined ) {\n\n\t\t\t\tposition = new Vector2();\n\t\t\t\tpointerPositions[ event.pointerId ] = position;\n\n\t\t\t}\n\n\t\t\tposition.set( event.pageX, event.pageY );\n\n\t\t}\n\n\t\tfunction getSecondPointerPosition( event ) {\n\n\t\t\tconst pointer = ( event.pointerId === pointers[ 0 ].pointerId ) ? pointers[ 1 ] : pointers[ 0 ];\n\n\t\t\treturn pointerPositions[ pointer.pointerId ];\n\n\t\t}\n\n\t\t//\n\n\t\tscope.domElement.addEventListener( 'contextmenu', onContextMenu );\n\n\t\tscope.domElement.addEventListener( 'pointerdown', onPointerDown );\n\t\tscope.domElement.addEventListener( 'pointercancel', onPointerCancel );\n\t\tscope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );\n\n\t\t// force an update at start\n\n\t\tthis.update();\n\n\t}\n\n}\n\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nclass MapControls extends OrbitControls {\n\n\tconstructor( object, domElement ) {\n\n\t\tsuper( object, domElement );\n\n\t\tthis.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up\n\n\t\tthis.mouseButtons.LEFT = MOUSE.PAN;\n\t\tthis.mouseButtons.RIGHT = MOUSE.ROTATE;\n\n\t\tthis.touches.ONE = TOUCH.PAN;\n\t\tthis.touches.TWO = TOUCH.DOLLY_ROTATE;\n\n\t}\n\n}\n\nexport { OrbitControls, MapControls };\n"],"names":["$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","Object","defineProperty","get","$ac97ba1014cae2cd$export$8ff7788029dfdf52","set","s","enumerable","configurable","$eq1Fs","$ac97ba1014cae2cd$var$_changeEvent","type","$ac97ba1014cae2cd$var$_startEvent","$ac97ba1014cae2cd$var$_endEvent","EventDispatcher","constructor","object","domElement","undefined","console","warn","document","error","style","touchAction","enabled","target","Vector3","minDistance","maxDistance","Infinity","minZoom","maxZoom","minPolarAngle","maxPolarAngle","Math","PI","minAzimuthAngle","maxAzimuthAngle","enableDamping","dampingFactor","enableZoom","zoomSpeed","enableRotate","rotateSpeed","enablePan","panSpeed","screenSpacePanning","keyPanSpeed","autoRotate","autoRotateSpeed","keys","LEFT","UP","RIGHT","BOTTOM","mouseButtons","MOUSE","ROTATE","MIDDLE","DOLLY","PAN","touches","ONE","TOUCH","TWO","DOLLY_PAN","target0","clone","position0","position","zoom0","zoom","_domElementKeyEvents","getPolarAngle","spherical","phi","getAzimuthalAngle","theta","getDistance","distanceTo","listenToKeyEvents","addEventListener","onKeyDown","saveState","scope","copy","reset","updateProjectionMatrix","dispatchEvent","update","state","STATE","NONE","offset","quat","Quaternion","setFromUnitVectors","up","quatInverse","invert","lastPosition","lastQuaternion","twoPI","sub","applyQuaternion","setFromVector3","rotateLeft","sphericalDelta","min","max","isFinite","makeSafe","radius","scale","addScaledVector","panOffset","add","setFromSpherical","lookAt","multiplyScalar","zoomChanged","distanceToSquared","EPS","dot","quaternion","dispose","removeEventListener","onContextMenu","onPointerDown","onPointerCancel","onMouseWheel","onPointerMove","onPointerUp","TOUCH_ROTATE","TOUCH_PAN","TOUCH_DOLLY_PAN","TOUCH_DOLLY_ROTATE","Spherical","rotateStart","Vector2","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","pointers","pointerPositions","getZoomScale","pow","angle","panLeft","v","distance","objectMatrix","setFromMatrixColumn","panUp","crossVectors","pan","deltaX","deltaY","element","isPerspectiveCamera","targetDistance","length","tan","fov","clientHeight","matrix","isOrthographicCamera","right","left","clientWidth","top","bottom","dollyOut","dollyScale","dollyIn","handleMouseDownRotate","event","clientX","clientY","handleMouseDownPan","handleTouchStartRotate","pageX","pageY","x","y","handleTouchStartPan","handleTouchStartDolly","dx","dy","sqrt","handleTouchMoveRotate","getSecondPointerPosition","subVectors","handleTouchMovePan","handleTouchMoveDolly","setPointerCapture","pointerId","push","pointerType","onTouchStart","trackPointer","DOLLY_ROTATE","onMouseDown","mouseAction","button","ctrlKey","metaKey","shiftKey","onTouchMove","onMouseMove","handleMouseMoveRotate","removePointer","releasePointerCapture","preventDefault","handleKeyDown","needsUpdate","i","splice","pointer","passive"],"version":3,"file":"shadows.4b967d90.js.map"}