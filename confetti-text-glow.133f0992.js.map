{"mappings":"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","sources":["node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js","node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tColor,\n\tLinearFilter,\n\tMeshBasicMaterial,\n\tRGBAFormat,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from '../postprocessing/Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nclass UnrealBloomPass extends Pass {\n\n\tconstructor( resolution, strength, radius, threshold ) {\n\n\t\tsuper();\n\n\t\tthis.strength = ( strength !== undefined ) ? strength : 1;\n\t\tthis.radius = radius;\n\t\tthis.threshold = threshold;\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\t// create color only once here, reuse it later inside the render function\n\t\tthis.clearColor = new Color( 0, 0, 0 );\n\n\t\t// render targets\n\t\tconst pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\n\t\tthis.renderTargetsHorizontal = [];\n\t\tthis.renderTargetsVertical = [];\n\t\tthis.nMips = 5;\n\t\tlet resx = Math.round( this.resolution.x / 2 );\n\t\tlet resy = Math.round( this.resolution.y / 2 );\n\n\t\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy, pars );\n\t\tthis.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n\t\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tconst renderTargetHorizonal = new WebGLRenderTarget( resx, resy, pars );\n\n\t\t\trenderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n\t\t\trenderTargetHorizonal.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsHorizontal.push( renderTargetHorizonal );\n\n\t\t\tconst renderTargetVertical = new WebGLRenderTarget( resx, resy, pars );\n\n\t\t\trenderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsVertical.push( renderTargetVertical );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// luminosity high pass material\n\n\t\tif ( LuminosityHighPassShader === undefined )\n\t\t\tconsole.error( 'THREE.UnrealBloomPass relies on LuminosityHighPassShader' );\n\n\t\tconst highPassShader = LuminosityHighPassShader;\n\t\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\n\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = threshold;\n\t\tthis.highPassUniforms[ 'smoothWidth' ].value = 0.01;\n\n\t\tthis.materialHighPassFilter = new ShaderMaterial( {\n\t\t\tuniforms: this.highPassUniforms,\n\t\t\tvertexShader: highPassShader.vertexShader,\n\t\t\tfragmentShader: highPassShader.fragmentShader,\n\t\t\tdefines: {}\n\t\t} );\n\n\t\t// Gaussian Blur Materials\n\t\tthis.separableBlurMaterials = [];\n\t\tconst kernelSizeArray = [ 3, 5, 7, 9, 11 ];\n\t\tresx = Math.round( this.resolution.x / 2 );\n\t\tresy = Math.round( this.resolution.y / 2 );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new Vector2( resx, resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// Composite material\n\t\tthis.compositeMaterial = this.getCompositeMaterial( this.nMips );\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;\n\t\tthis.compositeMaterial.needsUpdate = true;\n\n\t\tconst bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;\n\t\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\t// copy material\n\t\tif ( CopyShader === undefined ) {\n\n\t\t\tconsole.error( 'THREE.UnrealBloomPass relies on CopyShader' );\n\n\t\t}\n\n\t\tconst copyShader = CopyShader;\n\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\t\tthis.copyUniforms[ 'opacity' ].value = 1.0;\n\n\t\tthis.materialCopy = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis.basic = new MeshBasicMaterial();\n\n\t\tthis.fsQuad = new FullScreenQuad( null );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {\n\n\t\t\tthis.renderTargetsVertical[ i ].dispose();\n\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tlet resx = Math.round( width / 2 );\n\t\tlet resy = Math.round( height / 2 );\n\n\t\tthis.renderTargetBright.setSize( resx, resy );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new Vector2( resx, resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\trenderer.getClearColor( this._oldClearColor );\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor( this.clearColor, 0 );\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t// Render input to screen\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.fsQuad.material = this.basic;\n\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;\n\t\tthis.fsQuad.material = this.materialHighPassFilter;\n\n\t\trenderer.setRenderTarget( this.renderTargetBright );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tlet inputRenderTarget = this.renderTargetBright;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.fsQuad.material = this.separableBlurMaterials[ i ];\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\n\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis.fsQuad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis.fsQuad.material = this.materialCopy;\n\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n\tgetSeperableBlurMaterial( kernelRadius ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'KERNEL_RADIUS': kernelRadius,\n\t\t\t\t'SIGMA': kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetCompositeMaterial( nMips ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'NUM_MIPS': nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'blurTexture1': { value: null },\n\t\t\t\t'blurTexture2': { value: null },\n\t\t\t\t'blurTexture3': { value: null },\n\t\t\t\t'blurTexture4': { value: null },\n\t\t\t\t'blurTexture5': { value: null },\n\t\t\t\t'dirtTexture': { value: null },\n\t\t\t\t'bloomStrength': { value: 1.0 },\n\t\t\t\t'bloomFactors': { value: null },\n\t\t\t\t'bloomTintColors': { value: null },\n\t\t\t\t'bloomRadius': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform sampler2D dirtTexture;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n}\n\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { UnrealBloomPass };\n","import {\n\tColor\n} from 'three';\n\n/**\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nconst LuminosityHighPassShader = {\n\n\tshaderID: 'luminosityHighPass',\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'luminosityThreshold': { value: 1.0 },\n\t\t'smoothWidth': { value: 1.0 },\n\t\t'defaultColor': { value: new Color( 0x000000 ) },\n\t\t'defaultOpacity': { value: 0.0 }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}`\n\n};\n\nexport { LuminosityHighPassShader };\n"],"names":["$ilwiq","parcelRequire","$ca010d9f34e35dc3$export$d4d608c865617544","$RPVlj","Pass","constructor","resolution","strength","radius","threshold","super","this","undefined","Vector2","x","y","clearColor","Color","pars","minFilter","LinearFilter","magFilter","format","RGBAFormat","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","WebGLRenderTarget","texture","name","generateMipmaps","i","renderTargetHorizonal","push","renderTargetVertical","$dKM1y","LuminosityHighPassShader","console","error","highPassShader","highPassUniforms","UniformsUtils","clone","uniforms","value","materialHighPassFilter","ShaderMaterial","vertexShader","fragmentShader","defines","separableBlurMaterials","kernelSizeArray","i1","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","needsUpdate","bloomTintColors","Vector3","$45fwF","CopyShader","copyShader","copyUniforms","materialCopy","blending","AdditiveBlending","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","basic","MeshBasicMaterial","fsQuad","FullScreenQuad","dispose","length","i2","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","renderToScreen","material","map","setRenderTarget","clear","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius","KERNEL_RADIUS","SIGMA","colorTexture","texSize","direction","NUM_MIPS","blurTexture1","blurTexture2","blurTexture3","blurTexture4","blurTexture5","dirtTexture","bloomStrength","bloomFactors","bloomRadius","$a034d2d59dd75b4e$export$30029d01c9072e8b","shaderID","tDiffuse","luminosityThreshold","smoothWidth","defaultColor","defaultOpacity"],"version":3,"file":"confetti-text-glow.133f0992.js.map"}