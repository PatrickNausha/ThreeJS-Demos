{"mappings":"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","sources":["src/svg-demo.js","node_modules/three/examples/jsm/loaders/SVGLoader.js","node_modules/stats-js/build/stats.min.js","src/debug-stats.js"],"sourcesContent":["import {\n\tScene,\n\tPerspectiveCamera,\n\tWebGLRenderer,\n\tMeshStandardMaterial,\n\tHemisphereLight,\n\tMesh,\n\tGroup,\n\tMeshBasicMaterial,\n\tShapeBufferGeometry,\n\tExtrudeGeometry,\n\tBackSide,\n} from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls.js\";\nimport { SVGLoader } from \"three/examples/jsm/loaders/SVGLoader\";\nimport { updateStats, toggleStats } from \"./debug-stats\";\n\nconst renderer = new WebGLRenderer({ antialias: true, alpha: true });\nrenderer.setClearColor(0x000000, 0);\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n\n// In the beginning ...\nconst scene = new Scene();\n\n// Camera\nconst camera = new PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);\ncamera.position.z = -160;\nnew OrbitControls(camera, renderer.domElement);\n\nconst loader = new SVGLoader();\nloader.load(\n\t\"./assets/shine-like-stars-outlined-3.svg\",\n\tfunction ({ paths }) {\n\t\tconst group = new Group();\n\t\tfor (const path of paths) {\n\t\t\tconst extrudeMaterial = new MeshStandardMaterial({\n\t\t\t\tcolor: path.color,\n\t\t\t});\n\n\t\t\tconst frontGlowMaterial = new MeshBasicMaterial({\n\t\t\t\tcolor: path.color,\n\t\t\t\tside: BackSide, // Not sure why it comes out backward by default, but it does.\n\t\t\t\tdepthTest: false, // Hack: Since we're rendering the ShapeBufferGeometry directly on top of the ExtrudeGeometry, always render on top.\n\t\t\t});\n\n\t\t\tconst shapes = path.toShapes(true);\n\n\t\t\tconst { fill } = path.userData.style;\n\t\t\tif (fill && fill !== \"none\") {\n\t\t\t\tconsole.log(shapes.length);\n\t\t\t\tfor (const shape of shapes) {\n\t\t\t\t\tconst extrudeGeometry = new ExtrudeGeometry(shape, {\n\t\t\t\t\t\tdepth: 4,\n\t\t\t\t\t\tbevelEnabled: false,\n\t\t\t\t\t});\n\t\t\t\t\tconst extrudeMesh = new Mesh(extrudeGeometry, extrudeMaterial);\n\t\t\t\t\tgroup.add(extrudeMesh);\n\n\t\t\t\t\tconst geometry = new ShapeBufferGeometry(shape);\n\t\t\t\t\tconst mesh = new Mesh(geometry, frontGlowMaterial);\n\t\t\t\t\tgroup.add(mesh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgroup.rotateZ(Math.PI); // Not sure why SVG comes out flipped around.\n\t\tgroup.position.x = 200;\n\t\tgroup.position.y = 160;\n\t\tscene.add(group);\n\t},\n\tfunction (xhr) {\n\t\t// called when loading is in progresses\n\t},\n\tfunction (error) {\n\t\tconsole.error(error);\n\t}\n);\n\nconst light = new HemisphereLight(0xaaaaff, 0xffaaaa, 1);\nscene.add(light);\n\n// Show stats\ntoggleStats();\n\n// Main loop\nfunction animate() {\n\trequestAnimationFrame(animate);\n\trenderer.render(scene, camera);\n\tupdateStats();\n}\nanimate();\n","import {\n\tBox2,\n\tBufferGeometry,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tMatrix3,\n\tPath,\n\tShape,\n\tShapePath,\n\tShapeUtils,\n\tVector2,\n\tVector3\n} from 'three';\n\nclass SVGLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Default dots per inch\n\t\tthis.defaultDPI = 90;\n\n\t\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\t\tthis.defaultUnit = 'px';\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text ) {\n\n\t\tconst scope = this;\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tconst transform = getNodeTransform( node );\n\n\t\t\tlet traverseChildNodes = true;\n\n\t\t\tlet path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'style':\n\t\t\t\t\tparseCSSStylesheet( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'defs':\n\t\t\t\t\ttraverseChildNodes = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'use':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tconst usedNodeId = node.href.baseVal.substring( 1 );\n\t\t\t\t\tconst usedNode = node.viewportElement.getElementById( usedNodeId );\n\t\t\t\t\tif ( usedNode ) {\n\n\t\t\t\t\t\tparseNode( usedNode, style );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// console.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tif ( traverseChildNodes ) {\n\n\t\t\t\tconst nodes = node.childNodes;\n\n\t\t\t\tfor ( let i = 0; i < nodes.length; i ++ ) {\n\n\t\t\t\t\tparseNode( nodes[ i ], style );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tconst point = new Vector2();\n\t\t\tconst control = new Vector2();\n\n\t\t\tconst firstPoint = new Vector2();\n\t\t\tlet isFirstPoint = true;\n\t\t\tlet doSetFirstPoint = false;\n\n\t\t\tconst d = node.getAttribute( 'd' );\n\n\t\t\t// console.log( d );\n\n\t\t\tconst commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( let i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tconst command = commands[ i ];\n\n\t\t\t\tconst type = command.charAt( 0 );\n\t\t\t\tconst data = command.substr( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tlet numbers;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if start point == end point\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if no displacement\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCSSStylesheet( node ) {\n\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\n\n\t\t\tfor ( let i = 0; i < node.sheet.cssRules.length; i ++ ) {\n\n\t\t\t\tconst stylesheet = node.sheet.cssRules[ i ];\n\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\n\n\t\t\t\tconst selectorList = stylesheet.selectorText\n\t\t\t\t\t.split( /,/gm )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let j = 0; j < selectorList.length; j ++ ) {\n\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\n\t\t\t\t\t\tstylesheet.style\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tif ( rx == 0 || ry == 0 ) {\n\n\t\t\t\t// draw a line if either of the radii == 0\n\t\t\t\tpath.lineTo( end.x, end.y );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1', y1')\n\t\t\tconst dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tconst dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tconst x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tconst y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx', cy')\n\t\t\tlet rxs = rx * rx;\n\t\t\tlet rys = ry * ry;\n\t\t\tconst x1ps = x1p * x1p;\n\t\t\tconst y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tconst cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tconst s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tconst dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tconst pq = ( rxs * rys - dq ) / dq;\n\t\t\tlet q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tconst cxp = q * rx * y1p / ry;\n\t\t\tconst cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\n\t\t\tconst cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tconst cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute θ1 and Δθ\n\t\t\tconst theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tconst delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tconst dot = ux * vx + uy * vy;\n\t\t\tconst len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tlet ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || node.getAttribute( 'ry' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\tconst h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\t// Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n\t\t\t// https://spencermortensen.com/articles/bezier-circle/\n\t\t\tconst bci = 1 - 0.551915024494;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\t// top left\n\t\t\tpath.moveTo( x + rx, y );\n\n\t\t\t// top right\n\t\t\tpath.lineTo( x + w - rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry * bci,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom right\n\t\t\tpath.lineTo( x + w, y + h - ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx + w - rx,\n\t\t\t\t\ty + h\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom left\n\t\t\tpath.lineTo( x + rx, y + h );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// back to top left\n\t\t\tpath.lineTo( x, y + ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + ry * bci, x + rx * bci, y, x + rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tconst x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );\n\t\t\tconst y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );\n\t\t\tconst x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );\n\t\t\tconst y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tlet stylesheetStyles = {};\n\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\n\n\t\t\t\tconst classSelectors = node.getAttribute( 'class' )\n\t\t\t\t\t.split( /\\s/ )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let i = 0; i < classSelectors.length; i ++ ) {\n\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\n\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\n\n\t\t\t}\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\t\t\taddStyle( 'visibility', 'visibility' );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\t// from https://github.com/ppvg/svg-numbers (MIT License)\n\n\t\tfunction parseFloats( input, flags, stride ) {\n\n\t\t\tif ( typeof input !== 'string' ) {\n\n\t\t\t\tthrow new TypeError( 'Invalid input: ' + typeof input );\n\n\t\t\t}\n\n\t\t\t// Character groups\n\t\t\tconst RE = {\n\t\t\t\tSEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n\t\t\t\tWHITESPACE: /[ \\t\\r\\n]/,\n\t\t\t\tDIGIT: /[\\d]/,\n\t\t\t\tSIGN: /[-+]/,\n\t\t\t\tPOINT: /\\./,\n\t\t\t\tCOMMA: /,/,\n\t\t\t\tEXP: /e/i,\n\t\t\t\tFLAGS: /[01]/\n\t\t\t};\n\n\t\t\t// States\n\t\t\tconst SEP = 0;\n\t\t\tconst INT = 1;\n\t\t\tconst FLOAT = 2;\n\t\t\tconst EXP = 3;\n\n\t\t\tlet state = SEP;\n\t\t\tlet seenComma = true;\n\t\t\tlet number = '', exponent = '';\n\t\t\tconst result = [];\n\n\t\t\tfunction throwSyntaxError( current, i, partial ) {\n\n\t\t\t\tconst error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' );\n\t\t\t\terror.partial = partial;\n\t\t\t\tthrow error;\n\n\t\t\t}\n\n\t\t\tfunction newNumber() {\n\n\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\tif ( exponent === '' ) result.push( Number( number ) );\n\t\t\t\t\telse result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tnumber = '';\n\t\t\t\texponent = '';\n\n\t\t\t}\n\n\t\t\tlet current;\n\t\t\tconst length = input.length;\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tcurrent = input[ i ];\n\n\t\t\t\t// check for flags\n\t\t\t\tif ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {\n\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// parse until next number\n\t\t\t\tif ( state === SEP ) {\n\n\t\t\t\t\t// eat whitespace\n\t\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// start new number\n\t\t\t\t\tif ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tstate = INT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double commas (e.g. \"1, , 2\")\n\t\t\t\t\tif ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\t\tif ( seenComma ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tseenComma = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse integer part\n\t\t\t\tif ( state === INT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\t\t\t\t\tif ( RE.SIGN.test( current )\n\t\t\t\t\t\t\t&& number.length === 1\n\t\t\t\t\t\t\t&& RE.SIGN.test( number[ 0 ] ) ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse decimal part\n\t\t\t\tif ( state === FLOAT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double decimal points (e.g. \"1..2\")\n\t\t\t\t\tif ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse exponent part\n\t\t\t\tif ( state === EXP ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tif ( exponent === '' ) {\n\n\t\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// end of number\n\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = false;\n\n\t\t\t\t} else if ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = true;\n\n\t\t\t\t} else if ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else if ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add the last number found (if any)\n\t\t\tnewNumber();\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// Units\n\n\t\tconst units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\tconst unitConversion = {\n\n\t\t\t'mm': {\n\t\t\t\t'mm': 1,\n\t\t\t\t'cm': 0.1,\n\t\t\t\t'in': 1 / 25.4,\n\t\t\t\t'pt': 72 / 25.4,\n\t\t\t\t'pc': 6 / 25.4,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'cm': {\n\t\t\t\t'mm': 10,\n\t\t\t\t'cm': 1,\n\t\t\t\t'in': 1 / 2.54,\n\t\t\t\t'pt': 72 / 2.54,\n\t\t\t\t'pc': 6 / 2.54,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'in': {\n\t\t\t\t'mm': 25.4,\n\t\t\t\t'cm': 2.54,\n\t\t\t\t'in': 1,\n\t\t\t\t'pt': 72,\n\t\t\t\t'pc': 6,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pt': {\n\t\t\t\t'mm': 25.4 / 72,\n\t\t\t\t'cm': 2.54 / 72,\n\t\t\t\t'in': 1 / 72,\n\t\t\t\t'pt': 1,\n\t\t\t\t'pc': 6 / 72,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pc': {\n\t\t\t\t'mm': 25.4 / 6,\n\t\t\t\t'cm': 2.54 / 6,\n\t\t\t\t'in': 1 / 6,\n\t\t\t\t'pt': 72 / 6,\n\t\t\t\t'pc': 1,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'px': {\n\t\t\t\t'px': 1\n\t\t\t}\n\n\t\t};\n\n\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\tlet theUnit = 'px';\n\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\tfor ( let i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\tconst u = units[ i ];\n\n\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet scale = undefined;\n\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\n\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t} else {\n\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn scale * parseFloat( string );\n\n\t\t}\n\n\t\t// Transforms\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tconst transform = new Matrix3();\n\t\t\tconst currentTransform = tempTransform0;\n\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\n\n\t\t\t\tconst tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\n\t\t\t\tconst ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\n\n\t\t\t\ttransform.translate( tx, ty );\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\tconst transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tconst transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tconst openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tconst closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tconst transformType = transformText.substr( 0, openParPos );\n\n\t\t\t\t\t\tconst array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase 'translate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet ty = tx;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'rotate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tlet angle = 0;\n\t\t\t\t\t\t\t\t\tlet cx = 0;\n\t\t\t\t\t\t\t\t\tlet cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'scale':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewX':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewY':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'matrix':\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tconst isRotated = isTransformRotated( m );\n\n\t\t\tconst subPaths = path.subPaths;\n\n\t\t\tfor ( let i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tconst subPath = subPaths[ i ];\n\t\t\t\tconst curves = subPath.curves;\n\n\t\t\t\tfor ( let j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tconst curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformRotated( m ) {\n\n\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t//\n\n\t\tconst paths = [];\n\t\tconst stylesheets = {};\n\n\t\tconst transformStack = [];\n\n\t\tconst tempTransform0 = new Matrix3();\n\t\tconst tempTransform1 = new Matrix3();\n\t\tconst tempTransform2 = new Matrix3();\n\t\tconst tempTransform3 = new Matrix3();\n\t\tconst tempV2 = new Vector2();\n\t\tconst tempV3 = new Vector3();\n\n\t\tconst currentTransform = new Matrix3();\n\n\t\tconst xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tconst data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\t\treturn data;\n\n\t}\n\n\tstatic createShapes( shapePath ) {\n\n\t\t// Param shapePath: a shapepath as returned by the parse function of this class\n\t\t// Returns Shape object\n\n\t\tconst BIGNUMBER = 999999999;\n\n\t\tconst IntersectionLocationType = {\n\t\t\tORIGIN: 0,\n\t\t\tDESTINATION: 1,\n\t\t\tBETWEEN: 2,\n\t\t\tLEFT: 3,\n\t\t\tRIGHT: 4,\n\t\t\tBEHIND: 5,\n\t\t\tBEYOND: 6\n\t\t};\n\n\t\tconst classifyResult = {\n\t\t\tloc: IntersectionLocationType.ORIGIN,\n\t\t\tt: 0\n\t\t};\n\n\t\tfunction findEdgeIntersection( a0, a1, b0, b1 ) {\n\n\t\t\tconst x1 = a0.x;\n\t\t\tconst x2 = a1.x;\n\t\t\tconst x3 = b0.x;\n\t\t\tconst x4 = b1.x;\n\t\t\tconst y1 = a0.y;\n\t\t\tconst y2 = a1.y;\n\t\t\tconst y3 = b0.y;\n\t\t\tconst y4 = b1.y;\n\t\t\tconst nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );\n\t\t\tconst nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );\n\t\t\tconst denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );\n\t\t\tconst t1 = nom1 / denom;\n\t\t\tconst t2 = nom2 / denom;\n\n\t\t\tif ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {\n\n\t\t\t\t//1. lines are parallel or edges don't intersect\n\n\t\t\t\treturn null;\n\n\t\t\t} else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {\n\n\t\t\t\t//2. lines are colinear\n\n\t\t\t\t//check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\t\t\t\t\t//find position of this endpoints relatively to edge1\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t} else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {\n\n\t\t\t\t\t\tconst x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\tconst y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\treturn { x: x, y: y, t: classifyResult.t, };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t} else {\n\n\t\t\t\t//3. edges intersect\n\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\tconst y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\treturn { x: x, y: y, t: t1 };\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction classifyPoint( p, edgeStart, edgeEnd ) {\n\n\t\t\tconst ax = edgeEnd.x - edgeStart.x;\n\t\t\tconst ay = edgeEnd.y - edgeStart.y;\n\t\t\tconst bx = p.x - edgeStart.x;\n\t\t\tconst by = p.y - edgeStart.y;\n\t\t\tconst sa = ax * by - bx * ay;\n\n\t\t\tif ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.ORIGIN;\n\t\t\t\tclassifyResult.t = 0;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.DESTINATION;\n\t\t\t\tclassifyResult.t = 1;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa < - Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.LEFT;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa > Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.RIGHT;\n\t\t\t\treturn;\n\n\n\t\t\t}\n\n\t\t\tif ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEHIND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEYOND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet t;\n\n\t\t\tif ( ax !== 0 ) {\n\n\t\t\t\tt = bx / ax;\n\n\t\t\t} else {\n\n\t\t\t\tt = by / ay;\n\n\t\t\t}\n\n\t\t\tclassifyResult.loc = IntersectionLocationType.BETWEEN;\n\t\t\tclassifyResult.t = t;\n\n\t\t}\n\n\t\tfunction getIntersections( path1, path2 ) {\n\n\t\t\tconst intersectionsRaw = [];\n\t\t\tconst intersections = [];\n\n\t\t\tfor ( let index = 1; index < path1.length; index ++ ) {\n\n\t\t\t\tconst path1EdgeStart = path1[ index - 1 ];\n\t\t\t\tconst path1EdgeEnd = path1[ index ];\n\n\t\t\t\tfor ( let index2 = 1; index2 < path2.length; index2 ++ ) {\n\n\t\t\t\t\tconst path2EdgeStart = path2[ index2 - 1 ];\n\t\t\t\t\tconst path2EdgeEnd = path2[ index2 ];\n\n\t\t\t\t\tconst intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );\n\n\t\t\t\t\tif ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {\n\n\t\t\t\t\t\tintersectionsRaw.push( intersection );\n\t\t\t\t\t\tintersections.push( new Vector2( intersection.x, intersection.y ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn intersections;\n\n\t\t}\n\n\t\tfunction getScanlineIntersections( scanline, boundingBox, paths ) {\n\n\t\t\tconst center = new Vector2();\n\t\t\tboundingBox.getCenter( center );\n\n\t\t\tconst allIntersections = [];\n\n\t\t\tpaths.forEach( path => {\n\n\t\t\t\t// check if the center of the bounding box is in the bounding box of the paths.\n\t\t\t\t// this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n\t\t\t\t// if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n\t\t\t\tif ( path.boundingBox.containsPoint( center ) ) {\n\n\t\t\t\t\tconst intersections = getIntersections( scanline, path.points );\n\n\t\t\t\t\tintersections.forEach( p => {\n\n\t\t\t\t\t\tallIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tallIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\treturn allIntersections;\n\n\t\t}\n\n\t\tfunction isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {\n\n\t\t\tif ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {\n\n\t\t\t\t_fillRule = 'nonzero';\n\n\t\t\t}\n\n\t\t\tconst centerBoundingBox = new Vector2();\n\t\t\tsimplePath.boundingBox.getCenter( centerBoundingBox );\n\n\t\t\tconst scanline = [ new Vector2( scanlineMinX, centerBoundingBox.y ), new Vector2( scanlineMaxX, centerBoundingBox.y ) ];\n\n\t\t\tconst scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );\n\n\t\t\tscanlineIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\tconst baseIntersections = [];\n\t\t\tconst otherIntersections = [];\n\n\t\t\tscanlineIntersections.forEach( i => {\n\n\t\t\t\tif ( i.identifier === simplePath.identifier ) {\n\n\t\t\t\t\tbaseIntersections.push( i );\n\n\t\t\t\t} else {\n\n\t\t\t\t\totherIntersections.push( i );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tconst firstXOfPath = baseIntersections[ 0 ].point.x;\n\n\t\t\t// build up the path hierarchy\n\t\t\tconst stack = [];\n\t\t\tlet i = 0;\n\n\t\t\twhile ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {\n\n\t\t\t\tif ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {\n\n\t\t\t\t\tstack.pop();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( otherIntersections[ i ].identifier );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tstack.push( simplePath.identifier );\n\n\t\t\tif ( _fillRule === 'evenodd' ) {\n\n\t\t\t\tconst isHole = stack.length % 2 === 0 ? true : false;\n\t\t\t\tconst isHoleFor = stack[ stack.length - 2 ];\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else if ( _fillRule === 'nonzero' ) {\n\n\t\t\t\t// check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n\t\t\t\tlet isHole = true;\n\t\t\t\tlet isHoleFor = null;\n\t\t\t\tlet lastCWValue = null;\n\n\t\t\t\tfor ( let i = 0; i < stack.length; i ++ ) {\n\n\t\t\t\t\tconst identifier = stack[ i ];\n\t\t\t\t\tif ( isHole ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = false;\n\t\t\t\t\t\tisHoleFor = identifier;\n\n\t\t\t\t\t} else if ( lastCWValue !== allPaths[ identifier ].isCW ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'fill-rule: \"' + _fillRule + '\" is currently not implemented.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check for self intersecting paths\n\t\t// TODO\n\n\t\t// check intersecting paths\n\t\t// TODO\n\n\t\t// prepare paths for hole detection\n\t\tlet identifier = 0;\n\n\t\tlet scanlineMinX = BIGNUMBER;\n\t\tlet scanlineMaxX = - BIGNUMBER;\n\n\t\tlet simplePaths = shapePath.subPaths.map( p => {\n\n\t\t\tconst points = p.getPoints();\n\t\t\tlet maxY = - BIGNUMBER;\n\t\t\tlet minY = BIGNUMBER;\n\t\t\tlet maxX = - BIGNUMBER;\n\t\t\tlet minX = BIGNUMBER;\n\n\t      \t//points.forEach(p => p.y *= -1);\n\n\t\t\tfor ( let i = 0; i < points.length; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\n\t\t\t\tif ( p.y > maxY ) {\n\n\t\t\t\t\tmaxY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.y < minY ) {\n\n\t\t\t\t\tminY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x > maxX ) {\n\n\t\t\t\t\tmaxX = p.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x < minX ) {\n\n\t\t\t\t\tminX = p.x;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\t\t\tif ( scanlineMaxX <= maxX ) {\n\n\t\t\t\tscanlineMaxX = maxX + 1;\n\n\t\t\t}\n\n\t\t\tif ( scanlineMinX >= minX ) {\n\n\t\t\t\tscanlineMinX = minX - 1;\n\n\t\t\t}\n\n\t\t\treturn { points: points, isCW: ShapeUtils.isClockWise( points ), identifier: identifier ++, boundingBox: new Box2( new Vector2( minX, minY ), new Vector2( maxX, maxY ) ) };\n\n\t\t} );\n\n\t\tsimplePaths = simplePaths.filter( sp => sp.points.length > 1 );\n\n\t\t// check if path is solid or a hole\n\t\tconst isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule ) );\n\n\n\t\tconst shapesToReturn = [];\n\t\tsimplePaths.forEach( p => {\n\n\t\t\tconst amIAHole = isAHole[ p.identifier ];\n\n\t\t\tif ( ! amIAHole.isHole ) {\n\n\t\t\t\tconst shape = new Shape( p.points );\n\t\t\t\tconst holes = isAHole.filter( h => h.isHole && h.for === p.identifier );\n\t\t\t\tholes.forEach( h => {\n\n\t\t\t\t\tconst path = simplePaths[ h.identifier ];\n\t\t\t\t\tshape.holes.push( new Path( path.points ) );\n\n\t\t\t\t} );\n\t\t\t\tshapesToReturn.push( shape );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn shapesToReturn;\n\n\t}\n\n\tstatic getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t\t// Param width: Stroke width\n\t\t// Param color: As returned by THREE.Color.getStyle()\n\t\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t\t// Returns style object\n\n\t\twidth = width !== undefined ? width : 1;\n\t\tcolor = color !== undefined ? color : '#000';\n\t\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\t\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\t\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\t\treturn {\n\t\t\tstrokeColor: color,\n\t\t\tstrokeWidth: width,\n\t\t\tstrokeLineJoin: lineJoin,\n\t\t\tstrokeLineCap: lineCap,\n\t\t\tstrokeMiterLimit: miterLimit\n\t\t};\n\n\t}\n\n\tstatic pointsToStroke( points, style, arcDivisions, minDistance ) {\n\n\t\t// Generates a stroke with some witdh around the given path.\n\t\t// The path can be open or closed (last point equals to first point)\n\t\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\treturn geometry;\n\n\t}\n\n\tstatic pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tconst tempV2_1 = new Vector2();\n\t\tconst tempV2_2 = new Vector2();\n\t\tconst tempV2_3 = new Vector2();\n\t\tconst tempV2_4 = new Vector2();\n\t\tconst tempV2_5 = new Vector2();\n\t\tconst tempV2_6 = new Vector2();\n\t\tconst tempV2_7 = new Vector2();\n\t\tconst lastPointL = new Vector2();\n\t\tconst lastPointR = new Vector2();\n\t\tconst point0L = new Vector2();\n\t\tconst point0R = new Vector2();\n\t\tconst currentPointL = new Vector2();\n\t\tconst currentPointR = new Vector2();\n\t\tconst nextPointL = new Vector2();\n\t\tconst nextPointR = new Vector2();\n\t\tconst innerPoint = new Vector2();\n\t\tconst outerPoint = new Vector2();\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tconst numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tconst isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tlet currentPoint;\n\t\tlet previousPoint = points[ 0 ];\n\t\tlet nextPoint;\n\n\t\tconst strokeWidth2 = style.strokeWidth / 2;\n\n\t\tconst deltaU = 1 / ( numPoints - 1 );\n\t\tlet u0 = 0, u1;\n\n\t\tlet innerSideModified;\n\t\tlet joinIsOnLeftSide;\n\t\tlet isMiter;\n\t\tlet initialJoinIsOnLeftSide = false;\n\n\t\tlet numVertices = 0;\n\t\tlet currentCoordinate = vertexOffset * 3;\n\t\tlet currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tconst normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tu1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tconst dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot !== 0 ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tconst miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tconst miterLength2 = tempV2_5.length();\n\t\t\t\t\tconst segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tconst segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconst miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tlet lastOuter = outerPoint;\n\t\t\tlet lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tlet angle = Math.PI;\n\t\t\tconst dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tconst vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'butt':\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Nothing to do here\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tlet dupPoints = false;\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tconst newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t}\n\n\n}\n\nexport { SVGLoader };\n","!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):e.Stats=t()}(this,function(){\"use strict\";var c=function(){var n=0,l=document.createElement(\"div\");function e(e){return l.appendChild(e.dom),e}function t(e){for(var t=0;t<l.children.length;t++)l.children[t].style.display=t===e?\"block\":\"none\";n=e}l.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\",l.addEventListener(\"click\",function(e){e.preventDefault(),t(++n%l.children.length)},!1);var i=(performance||Date).now(),a=i,o=0,f=e(new c.Panel(\"FPS\",\"#0ff\",\"#002\")),r=e(new c.Panel(\"MS\",\"#0f0\",\"#020\"));if(self.performance&&self.performance.memory)var d=e(new c.Panel(\"MB\",\"#f08\",\"#201\"));return t(0),{REVISION:16,dom:l,addPanel:e,showPanel:t,begin:function(){i=(performance||Date).now()},end:function(){o++;var e=(performance||Date).now();if(r.update(e-i,200),a+1e3<=e&&(f.update(1e3*o/(e-a),100),a=e,o=0,d)){var t=performance.memory;d.update(t.usedJSHeapSize/1048576,t.jsHeapSizeLimit/1048576)}return e},update:function(){i=this.end()},domElement:l,setMode:t}};return c.Panel=function(n,l,i){var a=1/0,o=0,f=Math.round,r=f(window.devicePixelRatio||1),d=80*r,e=48*r,c=3*r,p=2*r,u=3*r,s=15*r,m=74*r,h=30*r,y=document.createElement(\"canvas\");y.width=d,y.height=e,y.style.cssText=\"width:80px;height:48px\";var v=y.getContext(\"2d\");return v.font=\"bold \"+9*r+\"px Helvetica,Arial,sans-serif\",v.textBaseline=\"top\",v.fillStyle=i,v.fillRect(0,0,d,e),v.fillStyle=l,v.fillText(n,c,p),v.fillRect(u,s,m,h),v.fillStyle=i,v.globalAlpha=.9,v.fillRect(u,s,m,h),{dom:y,update:function(e,t){a=Math.min(a,e),o=Math.max(o,e),v.fillStyle=i,v.globalAlpha=1,v.fillRect(0,0,d,s),v.fillStyle=l,v.fillText(f(e)+\" \"+n+\" (\"+f(a)+\"-\"+f(o)+\")\",c,p),v.drawImage(y,u+r,s,m-r,h,u,s,m-r,h),v.fillRect(u+m-r,s,r,h),v.fillStyle=i,v.globalAlpha=.9,v.fillRect(u+m-r,s,r,f((1-e/t)*h))}}},c});\n","import Stats from \"stats-js\";\n\nconst stats = new Stats();\nstats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom\n\nexport function updateStats() {\n\tstats.update();\n}\n\nlet showStats = false;\nexport function toggleStats() {\n\tshowStats = !showStats;\n\tif (showStats) {\n\t\tdocument.body.appendChild(stats.dom);\n\t} else {\n\t\tstats.dom.remove();\n\t}\n}\n"],"names":["$ilwiq","parcelRequire","$dddb64fc98360932$export$959ae9097e74a233","Loader","constructor","manager","super","this","defaultDPI","defaultUnit","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","parseArcCommand","rx","ry","x_axis_rotation","large_arc_flag","sweep_flag","start","end","lineTo","x","y","Math","PI","abs","dx2","dy2","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","currentPath","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseStyle","node","style","Object","assign","stylesheetStyles","hasAttribute","classSelectors","getAttribute","split","filter","Boolean","map","i","trim","i2","length","stylesheets","addStyle","svgName","jsName","adjustFunction","undefined","v","startsWith","warn","clamp","parseFloatWithUnits","positive","getReflection","a","b","parseFloats","input","flags","stride","TypeError","RE","SEPARATOR","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","FLAGS","state","seenComma","number","exponent","result","throwSyntaxError","current","partial","SyntaxError","newNumber","push","Number","pow","current1","i4","Array","isArray","includes","test","units","unitConversion","mm","cm","in","pt","pc","px","string","scale","theUnit","String","n","u","endsWith","substring","parseFloat","getTransformScaleX","m","te","elements","getTransformScaleY","paths","transformStack","tempTransform0","Matrix3","tempTransform1","tempTransform2","tempTransform3","tempV2","Vector2","tempV3","Vector3","currentTransform1","xml","DOMParser","parseFromString","parseNode","nodeType","transform","nodeName","currentTransform","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","substr","array","identity","angle","rotate","multiplyMatrices","scaleX","scaleY","set","tan","premultiply","parseNodeTransform","copy","getNodeTransform","traverseChildNodes","sheet","cssRules","i1","stylesheet","type","selectorList","selectorText","j","parseCSSStylesheet","ShapePath","point","control","firstPoint","isFirstPoint","doSetFirstPoint","commands","match","l","command","charAt","data","numbers","jl","moveTo","j1","jl1","j2","jl2","j3","jl3","j4","jl4","bezierCurveTo","j5","jl5","j6","jl6","quadraticCurveTo","j7","jl7","j8","jl8","clone","j9","jl9","j10","jl10","j11","jl11","j12","jl12","j13","jl13","j14","jl14","j15","jl15","j16","jl16","j17","jl17","autoClose","curves","currentPoint","parsePathNode","w","h","bci","parseRectNode","iterator","index","regex","replace","parsePolygonNode","parsePolylineNode","r","subpath","Path","absarc","subPaths","parseCircleNode","parseEllipseNode","x1","y1","x2","y2","parseLineNode","usedNodeId","href","baseVal","usedNode","viewportElement","getElementById","fill","color","setStyle","transfVec2","v2","applyMatrix3","isRotated","isTransformRotated","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","aX","aY","xRadius","yRadius","transformPath","userData","nodes","childNodes","pop","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","static","shapePath","BIGNUMBER","IntersectionLocationType","classifyResult","loc","t","findEdgeIntersection","a0","a1","b0","b1","x3","x4","y3","y4","nom1","denom","t1","t2","classifyPoint","toPrecision","p","edgeStart","edgeEnd","ax","ay","bx","by","sa","EPSILON","getScanlineIntersections","scanline","boundingBox","center","getCenter","allIntersections","forEach","containsPoint","path1","path2","intersectionsRaw","intersections","path1EdgeStart","path1EdgeEnd","index2","intersection","find","getIntersections","points","identifier","isCW","sort","identifier1","scanlineMinX1","scanlineMaxX1","simplePaths","getPoints","maxY","minY","maxX","minX","ShapeUtils","isClockWise","Box2","sp","isAHole","simplePath","allPaths","scanlineMinX","scanlineMaxX","_fillRule","centerBoundingBox","scanlineIntersections","baseIntersections","otherIntersections","firstXOfPath","stack","i5","isHole","isHoleFor","for","lastCWValue","isHoleTo","fillRule","shapesToReturn","shape","Shape","holes","width","lineJoin","lineCap","miterLimit","strokeColor","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","BufferGeometry","setAttribute","Float32BufferAttribute","points1","vertexOffset","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","numPoints","dupPoints","distanceTo","newPoints","i6","n1","removeDuplicatedPoints","isClosed","equals","nextPoint","previousPoint","strokeWidth2","deltaU","u1","innerSideModified1","joinIsOnLeftSide1","isMiter","u0","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","position","il","rotateAround","joinIsOnLeftSide","innerSideModified","addVectors","vl","c1","document","createElement","e1","appendChild","dom","children","display","cssText","addEventListener","preventDefault","performance","Date","now","o","f","Panel","self","memory","d","REVISION","addPanel","showPanel","begin","update","usedJSHeapSize","jsHeapSizeLimit","domElement","setMode","round","window","devicePixelRatio","e2","c","height","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","drawImage","$4e8ca3b77ae34b4b$var$stats","$parcel$interopDefault","$4e8ca3b77ae34b4b$var$showStats","$d79d17895d029fdf$var$renderer","WebGLRenderer","antialias","alpha","setClearColor","setSize","innerWidth","innerHeight","body","$d79d17895d029fdf$var$scene","Scene","$d79d17895d029fdf$var$camera","PerspectiveCamera","z","$5Rd1x","OrbitControls","group","Group","extrudeMaterial","MeshStandardMaterial","frontGlowMaterial","MeshBasicMaterial","side","BackSide","depthTest","shapes","toShapes","log","extrudeGeometry","ExtrudeGeometry","depth","bevelEnabled","extrudeMesh","Mesh","ShapeBufferGeometry","mesh","rotateZ","xhr","$d79d17895d029fdf$var$light","HemisphereLight","remove","$d79d17895d029fdf$var$animate","requestAnimationFrame","render"],"version":3,"file":"svg.98dc37e6.js.map"}