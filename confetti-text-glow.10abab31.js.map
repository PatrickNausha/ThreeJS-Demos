{"mappings":"C,A,W,S,E,C,C,C,C,C,C,C,E,O,e,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,Q,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,K,E,Q,E,E,S,E,O,C,I,E,A,M,uB,E,I,O,E,K,mB,C,C,E,S,S,C,C,C,E,C,C,E,C,C,E,E,kB,G,E,S,Q,S,C,C,C,E,E,E,Q,iB,W,O,C,G,I,E,E,S,E,E,S,E,E,S,E,E,QCgBA,OAAM,EAEL,YAAa,CAAQ,CAAE,CAAY,CAAG,CAIrC,GAFA,IAAI,CAAC,SAAW,EAEX,AAAiB,KAAA,IAAjB,EAA6B,CAEjC,IAAM,EAAa,CAClB,UAAW,EAAA,aACX,UAAW,EAAA,aACX,OAAQ,EAAA,UACT,EAEM,EAAO,EAAS,QAAS,IAAI,EAAA,QACnC,CAAA,IAAI,CAAC,YAAc,EAAS,gBAC5B,IAAI,CAAC,OAAS,EAAK,MACnB,IAAI,CAAC,QAAU,EAAK,OAGpB,AADA,CAAA,EAAe,IAAI,EAAA,kBAAmB,IAAI,CAAC,OAAS,IAAI,CAAC,YAAa,IAAI,CAAC,QAAU,IAAI,CAAC,YAAa,EAAvG,EACa,QAAQ,KAAO,oBAE7B,MAEC,IAAI,CAAC,YAAc,EACnB,IAAI,CAAC,OAAS,EAAa,MAC3B,IAAI,CAAC,QAAU,EAAa,MAI7B,CAAA,IAAI,CAAC,cAAgB,EACrB,IAAI,CAAC,cAAgB,EAAa,QAClC,IAAI,CAAC,cAAc,QAAQ,KAAO,qBAElC,IAAI,CAAC,YAAc,IAAI,CAAC,cACxB,IAAI,CAAC,WAAa,IAAI,CAAC,cAEvB,IAAI,CAAC,eAAiB,CAAA,EAEtB,IAAI,CAAC,OAAS,EAAE,CAII,KAAA,IAAf,EAAA,YAEJ,QAAQ,MAAO,6CAII,KAAA,IAAf,EAAA,YAEJ,QAAQ,MAAO,6CAIhB,IAAI,CAAC,SAAW,IAAI,EAAA,WAAY,EAAA,YAEhC,IAAI,CAAC,MAAQ,IAAI,EAAA,KAElB,CAEA,aAAc,CAEb,I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","sources":["<anon>","node_modules/three/examples/jsm/postprocessing/EffectComposer.js","node_modules/three/examples/jsm/shaders/CopyShader.js","node_modules/three/examples/jsm/postprocessing/ShaderPass.js","node_modules/three/examples/jsm/postprocessing/Pass.js","node_modules/three/examples/jsm/postprocessing/MaskPass.js","node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js","node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js","node_modules/three/examples/jsm/postprocessing/RenderPass.js"],"sourcesContent":["(function () {\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire1287\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire1287\"] = parcelRequire;\n}\nparcelRequire.register(\"8MWs4\", function(module, exports) {\n\n$parcel$export(module.exports, \"EffectComposer\", function () { return $666025b2fd847a1f$export$7fe01e6ab8aa748c; });\n\nvar $6OvZu = parcelRequire(\"6OvZu\");\n\nvar $2wkXx = parcelRequire(\"2wkXx\");\n\nvar $gy7bn = parcelRequire(\"gy7bn\");\n\nvar $im5gf = parcelRequire(\"im5gf\");\nclass $666025b2fd847a1f$export$7fe01e6ab8aa748c {\n    constructor(renderer, renderTarget){\n        this.renderer = renderer;\n        if (renderTarget === undefined) {\n            const parameters = {\n                minFilter: (0, $6OvZu.LinearFilter),\n                magFilter: (0, $6OvZu.LinearFilter),\n                format: (0, $6OvZu.RGBAFormat)\n            };\n            const size = renderer.getSize(new (0, $6OvZu.Vector2)());\n            this._pixelRatio = renderer.getPixelRatio();\n            this._width = size.width;\n            this._height = size.height;\n            renderTarget = new (0, $6OvZu.WebGLRenderTarget)(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);\n            renderTarget.texture.name = \"EffectComposer.rt1\";\n        } else {\n            this._pixelRatio = 1;\n            this._width = renderTarget.width;\n            this._height = renderTarget.height;\n        }\n        this.renderTarget1 = renderTarget;\n        this.renderTarget2 = renderTarget.clone();\n        this.renderTarget2.texture.name = \"EffectComposer.rt2\";\n        this.writeBuffer = this.renderTarget1;\n        this.readBuffer = this.renderTarget2;\n        this.renderToScreen = true;\n        this.passes = [];\n        // dependencies\n        if ((0, $2wkXx.CopyShader) === undefined) console.error(\"THREE.EffectComposer relies on CopyShader\");\n        if ((0, $gy7bn.ShaderPass) === undefined) console.error(\"THREE.EffectComposer relies on ShaderPass\");\n        this.copyPass = new (0, $gy7bn.ShaderPass)((0, $2wkXx.CopyShader));\n        this.clock = new (0, $6OvZu.Clock)();\n    }\n    swapBuffers() {\n        const tmp = this.readBuffer;\n        this.readBuffer = this.writeBuffer;\n        this.writeBuffer = tmp;\n    }\n    addPass(pass) {\n        this.passes.push(pass);\n        pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);\n    }\n    insertPass(pass, index) {\n        this.passes.splice(index, 0, pass);\n        pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);\n    }\n    removePass(pass) {\n        const index = this.passes.indexOf(pass);\n        if (index !== -1) this.passes.splice(index, 1);\n    }\n    isLastEnabledPass(passIndex) {\n        for(let i = passIndex + 1; i < this.passes.length; i++){\n            if (this.passes[i].enabled) return false;\n        }\n        return true;\n    }\n    render(deltaTime) {\n        // deltaTime value is in seconds\n        if (deltaTime === undefined) deltaTime = this.clock.getDelta();\n        const currentRenderTarget = this.renderer.getRenderTarget();\n        let maskActive = false;\n        for(let i = 0, il = this.passes.length; i < il; i++){\n            const pass = this.passes[i];\n            if (pass.enabled === false) continue;\n            pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);\n            pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);\n            if (pass.needsSwap) {\n                if (maskActive) {\n                    const context = this.renderer.getContext();\n                    const stencil = this.renderer.state.buffers.stencil;\n                    //context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n                    stencil.setFunc(context.NOTEQUAL, 1, 0xffffffff);\n                    this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);\n                    //context.stencilFunc( context.EQUAL, 1, 0xffffffff );\n                    stencil.setFunc(context.EQUAL, 1, 0xffffffff);\n                }\n                this.swapBuffers();\n            }\n            if ((0, $im5gf.MaskPass) !== undefined) {\n                if (pass instanceof (0, $im5gf.MaskPass)) maskActive = true;\n                else if (pass instanceof (0, $im5gf.ClearMaskPass)) maskActive = false;\n            }\n        }\n        this.renderer.setRenderTarget(currentRenderTarget);\n    }\n    reset(renderTarget) {\n        if (renderTarget === undefined) {\n            const size = this.renderer.getSize(new (0, $6OvZu.Vector2)());\n            this._pixelRatio = this.renderer.getPixelRatio();\n            this._width = size.width;\n            this._height = size.height;\n            renderTarget = this.renderTarget1.clone();\n            renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);\n        }\n        this.renderTarget1.dispose();\n        this.renderTarget2.dispose();\n        this.renderTarget1 = renderTarget;\n        this.renderTarget2 = renderTarget.clone();\n        this.writeBuffer = this.renderTarget1;\n        this.readBuffer = this.renderTarget2;\n    }\n    setSize(width, height) {\n        this._width = width;\n        this._height = height;\n        const effectiveWidth = this._width * this._pixelRatio;\n        const effectiveHeight = this._height * this._pixelRatio;\n        this.renderTarget1.setSize(effectiveWidth, effectiveHeight);\n        this.renderTarget2.setSize(effectiveWidth, effectiveHeight);\n        for(let i = 0; i < this.passes.length; i++)this.passes[i].setSize(effectiveWidth, effectiveHeight);\n    }\n    setPixelRatio(pixelRatio) {\n        this._pixelRatio = pixelRatio;\n        this.setSize(this._width, this._height);\n    }\n}\nclass $666025b2fd847a1f$export$802bc10488da99c7 {\n    constructor(){\n        // if set to true, the pass is processed by the composer\n        this.enabled = true;\n        // if set to true, the pass indicates to swap read and write buffer after rendering\n        this.needsSwap = true;\n        // if set to true, the pass clears its buffer before rendering\n        this.clear = false;\n        // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n        this.renderToScreen = false;\n    }\n    setSize() {}\n    render() {\n        console.error(\"THREE.Pass: .render() must be implemented in derived pass.\");\n    }\n}\n// Helper for passes that need to fill the viewport with a single quad.\nconst $666025b2fd847a1f$var$_camera = new (0, $6OvZu.OrthographicCamera)(-1, 1, 1, -1, 0, 1);\n// https://github.com/mrdoob/three.js/pull/21358\nconst $666025b2fd847a1f$var$_geometry = new (0, $6OvZu.BufferGeometry)();\n$666025b2fd847a1f$var$_geometry.setAttribute(\"position\", new (0, $6OvZu.Float32BufferAttribute)([\n    -1,\n    3,\n    0,\n    -1,\n    -1,\n    0,\n    3,\n    -1,\n    0\n], 3));\n$666025b2fd847a1f$var$_geometry.setAttribute(\"uv\", new (0, $6OvZu.Float32BufferAttribute)([\n    0,\n    2,\n    0,\n    0,\n    2,\n    0\n], 2));\nclass $666025b2fd847a1f$export$3983474c8e6e978b {\n    constructor(material){\n        this._mesh = new (0, $6OvZu.Mesh)($666025b2fd847a1f$var$_geometry, material);\n    }\n    dispose() {\n        this._mesh.geometry.dispose();\n    }\n    render(renderer) {\n        renderer.render(this._mesh, $666025b2fd847a1f$var$_camera);\n    }\n    get material() {\n        return this._mesh.material;\n    }\n    set material(value) {\n        this._mesh.material = value;\n    }\n}\n\n});\nparcelRequire.register(\"2wkXx\", function(module, exports) {\n\n$parcel$export(module.exports, \"CopyShader\", function () { return $1d5ed4039cd88450$export$57f84a24a9a6130d; });\n/**\n * Full-screen textured quad shader\n */ var $1d5ed4039cd88450$export$57f84a24a9a6130d = {\n    uniforms: {\n        \"tDiffuse\": {\n            value: null\n        },\n        \"opacity\": {\n            value: 1.0\n        }\n    },\n    vertexShader: /* glsl */ `\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n    fragmentShader: /* glsl */ `\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}`\n};\n\n});\n\nparcelRequire.register(\"gy7bn\", function(module, exports) {\n\n$parcel$export(module.exports, \"ShaderPass\", function () { return $c0c564a2ac95bcdc$export$c55093fd4f9e42f0; });\n\nvar $6OvZu = parcelRequire(\"6OvZu\");\n\nvar $MIC3f = parcelRequire(\"MIC3f\");\nclass $c0c564a2ac95bcdc$export$c55093fd4f9e42f0 extends (0, $MIC3f.Pass) {\n    constructor(shader, textureID){\n        super();\n        this.textureID = textureID !== undefined ? textureID : \"tDiffuse\";\n        if (shader instanceof (0, $6OvZu.ShaderMaterial)) {\n            this.uniforms = shader.uniforms;\n            this.material = shader;\n        } else if (shader) {\n            this.uniforms = (0, $6OvZu.UniformsUtils).clone(shader.uniforms);\n            this.material = new (0, $6OvZu.ShaderMaterial)({\n                defines: Object.assign({}, shader.defines),\n                uniforms: this.uniforms,\n                vertexShader: shader.vertexShader,\n                fragmentShader: shader.fragmentShader\n            });\n        }\n        this.fsQuad = new (0, $MIC3f.FullScreenQuad)(this.material);\n    }\n    render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n        if (this.uniforms[this.textureID]) this.uniforms[this.textureID].value = readBuffer.texture;\n        this.fsQuad.material = this.material;\n        if (this.renderToScreen) {\n            renderer.setRenderTarget(null);\n            this.fsQuad.render(renderer);\n        } else {\n            renderer.setRenderTarget(writeBuffer);\n            // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n            if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n            this.fsQuad.render(renderer);\n        }\n    }\n}\n\n});\nparcelRequire.register(\"MIC3f\", function(module, exports) {\n\n$parcel$export(module.exports, \"Pass\", function () { return $092716f80203f221$export$802bc10488da99c7; });\n$parcel$export(module.exports, \"FullScreenQuad\", function () { return $092716f80203f221$export$3983474c8e6e978b; });\n\nvar $6OvZu = parcelRequire(\"6OvZu\");\nclass $092716f80203f221$export$802bc10488da99c7 {\n    constructor(){\n        // if set to true, the pass is processed by the composer\n        this.enabled = true;\n        // if set to true, the pass indicates to swap read and write buffer after rendering\n        this.needsSwap = true;\n        // if set to true, the pass clears its buffer before rendering\n        this.clear = false;\n        // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n        this.renderToScreen = false;\n    }\n    setSize() {}\n    render() {\n        console.error(\"THREE.Pass: .render() must be implemented in derived pass.\");\n    }\n}\n// Helper for passes that need to fill the viewport with a single quad.\nconst $092716f80203f221$var$_camera = new (0, $6OvZu.OrthographicCamera)(-1, 1, 1, -1, 0, 1);\n// https://github.com/mrdoob/three.js/pull/21358\nconst $092716f80203f221$var$_geometry = new (0, $6OvZu.BufferGeometry)();\n$092716f80203f221$var$_geometry.setAttribute(\"position\", new (0, $6OvZu.Float32BufferAttribute)([\n    -1,\n    3,\n    0,\n    -1,\n    -1,\n    0,\n    3,\n    -1,\n    0\n], 3));\n$092716f80203f221$var$_geometry.setAttribute(\"uv\", new (0, $6OvZu.Float32BufferAttribute)([\n    0,\n    2,\n    0,\n    0,\n    2,\n    0\n], 2));\nclass $092716f80203f221$export$3983474c8e6e978b {\n    constructor(material){\n        this._mesh = new (0, $6OvZu.Mesh)($092716f80203f221$var$_geometry, material);\n    }\n    dispose() {\n        this._mesh.geometry.dispose();\n    }\n    render(renderer) {\n        renderer.render(this._mesh, $092716f80203f221$var$_camera);\n    }\n    get material() {\n        return this._mesh.material;\n    }\n    set material(value) {\n        this._mesh.material = value;\n    }\n}\n\n});\n\n\nparcelRequire.register(\"im5gf\", function(module, exports) {\n\n$parcel$export(module.exports, \"MaskPass\", function () { return $d5ce5cd3f9e337b1$export$bb424a4005d6dde0; });\n$parcel$export(module.exports, \"ClearMaskPass\", function () { return $d5ce5cd3f9e337b1$export$8d8650aed29c6251; });\n\nvar $MIC3f = parcelRequire(\"MIC3f\");\nclass $d5ce5cd3f9e337b1$export$bb424a4005d6dde0 extends (0, $MIC3f.Pass) {\n    constructor(scene, camera){\n        super();\n        this.scene = scene;\n        this.camera = camera;\n        this.clear = true;\n        this.needsSwap = false;\n        this.inverse = false;\n    }\n    render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n        const context = renderer.getContext();\n        const state = renderer.state;\n        // don't update color or depth\n        state.buffers.color.setMask(false);\n        state.buffers.depth.setMask(false);\n        // lock buffers\n        state.buffers.color.setLocked(true);\n        state.buffers.depth.setLocked(true);\n        // set up stencil\n        let writeValue, clearValue;\n        if (this.inverse) {\n            writeValue = 0;\n            clearValue = 1;\n        } else {\n            writeValue = 1;\n            clearValue = 0;\n        }\n        state.buffers.stencil.setTest(true);\n        state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);\n        state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);\n        state.buffers.stencil.setClear(clearValue);\n        state.buffers.stencil.setLocked(true);\n        // draw into the stencil buffer\n        renderer.setRenderTarget(readBuffer);\n        if (this.clear) renderer.clear();\n        renderer.render(this.scene, this.camera);\n        renderer.setRenderTarget(writeBuffer);\n        if (this.clear) renderer.clear();\n        renderer.render(this.scene, this.camera);\n        // unlock color and depth buffer for subsequent rendering\n        state.buffers.color.setLocked(false);\n        state.buffers.depth.setLocked(false);\n        // only render where stencil is set to 1\n        state.buffers.stencil.setLocked(false);\n        state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1\n        state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);\n        state.buffers.stencil.setLocked(true);\n    }\n}\nclass $d5ce5cd3f9e337b1$export$8d8650aed29c6251 extends (0, $MIC3f.Pass) {\n    constructor(){\n        super();\n        this.needsSwap = false;\n    }\n    render(renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n        renderer.state.buffers.stencil.setLocked(false);\n        renderer.state.buffers.stencil.setTest(false);\n    }\n}\n\n});\n\n\nparcelRequire.register(\"8aNI6\", function(module, exports) {\n\n$parcel$export(module.exports, \"UnrealBloomPass\", function () { return $5f35d15544f4e7ae$export$d4d608c865617544; });\n\nvar $6OvZu = parcelRequire(\"6OvZu\");\n\nvar $MIC3f = parcelRequire(\"MIC3f\");\n\nvar $2wkXx = parcelRequire(\"2wkXx\");\n\nvar $d7LYa = parcelRequire(\"d7LYa\");\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */ class $5f35d15544f4e7ae$export$d4d608c865617544 extends (0, $MIC3f.Pass) {\n    constructor(resolution, strength, radius, threshold){\n        super();\n        this.strength = strength !== undefined ? strength : 1;\n        this.radius = radius;\n        this.threshold = threshold;\n        this.resolution = resolution !== undefined ? new (0, $6OvZu.Vector2)(resolution.x, resolution.y) : new (0, $6OvZu.Vector2)(256, 256);\n        // create color only once here, reuse it later inside the render function\n        this.clearColor = new (0, $6OvZu.Color)(0, 0, 0);\n        // render targets\n        const pars = {\n            minFilter: (0, $6OvZu.LinearFilter),\n            magFilter: (0, $6OvZu.LinearFilter),\n            format: (0, $6OvZu.RGBAFormat)\n        };\n        this.renderTargetsHorizontal = [];\n        this.renderTargetsVertical = [];\n        this.nMips = 5;\n        let resx = Math.round(this.resolution.x / 2);\n        let resy = Math.round(this.resolution.y / 2);\n        this.renderTargetBright = new (0, $6OvZu.WebGLRenderTarget)(resx, resy, pars);\n        this.renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n        this.renderTargetBright.texture.generateMipmaps = false;\n        for(let i = 0; i < this.nMips; i++){\n            const renderTargetHorizonal = new (0, $6OvZu.WebGLRenderTarget)(resx, resy, pars);\n            renderTargetHorizonal.texture.name = \"UnrealBloomPass.h\" + i;\n            renderTargetHorizonal.texture.generateMipmaps = false;\n            this.renderTargetsHorizontal.push(renderTargetHorizonal);\n            const renderTargetVertical = new (0, $6OvZu.WebGLRenderTarget)(resx, resy, pars);\n            renderTargetVertical.texture.name = \"UnrealBloomPass.v\" + i;\n            renderTargetVertical.texture.generateMipmaps = false;\n            this.renderTargetsVertical.push(renderTargetVertical);\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n        // luminosity high pass material\n        if ((0, $d7LYa.LuminosityHighPassShader) === undefined) console.error(\"THREE.UnrealBloomPass relies on LuminosityHighPassShader\");\n        const highPassShader = (0, $d7LYa.LuminosityHighPassShader);\n        this.highPassUniforms = (0, $6OvZu.UniformsUtils).clone(highPassShader.uniforms);\n        this.highPassUniforms[\"luminosityThreshold\"].value = threshold;\n        this.highPassUniforms[\"smoothWidth\"].value = 0.01;\n        this.materialHighPassFilter = new (0, $6OvZu.ShaderMaterial)({\n            uniforms: this.highPassUniforms,\n            vertexShader: highPassShader.vertexShader,\n            fragmentShader: highPassShader.fragmentShader,\n            defines: {}\n        });\n        // Gaussian Blur Materials\n        this.separableBlurMaterials = [];\n        const kernelSizeArray = [\n            3,\n            5,\n            7,\n            9,\n            11\n        ];\n        resx = Math.round(this.resolution.x / 2);\n        resy = Math.round(this.resolution.y / 2);\n        for(let i = 0; i < this.nMips; i++){\n            this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n            this.separableBlurMaterials[i].uniforms[\"texSize\"].value = new (0, $6OvZu.Vector2)(resx, resy);\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n        // Composite material\n        this.compositeMaterial = this.getCompositeMaterial(this.nMips);\n        this.compositeMaterial.uniforms[\"blurTexture1\"].value = this.renderTargetsVertical[0].texture;\n        this.compositeMaterial.uniforms[\"blurTexture2\"].value = this.renderTargetsVertical[1].texture;\n        this.compositeMaterial.uniforms[\"blurTexture3\"].value = this.renderTargetsVertical[2].texture;\n        this.compositeMaterial.uniforms[\"blurTexture4\"].value = this.renderTargetsVertical[3].texture;\n        this.compositeMaterial.uniforms[\"blurTexture5\"].value = this.renderTargetsVertical[4].texture;\n        this.compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n        this.compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n        this.compositeMaterial.needsUpdate = true;\n        const bloomFactors = [\n            1.0,\n            0.8,\n            0.6,\n            0.4,\n            0.2\n        ];\n        this.compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n        this.bloomTintColors = [\n            new (0, $6OvZu.Vector3)(1, 1, 1),\n            new (0, $6OvZu.Vector3)(1, 1, 1),\n            new (0, $6OvZu.Vector3)(1, 1, 1),\n            new (0, $6OvZu.Vector3)(1, 1, 1),\n            new (0, $6OvZu.Vector3)(1, 1, 1)\n        ];\n        this.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n        // copy material\n        if ((0, $2wkXx.CopyShader) === undefined) console.error(\"THREE.UnrealBloomPass relies on CopyShader\");\n        const copyShader = (0, $2wkXx.CopyShader);\n        this.copyUniforms = (0, $6OvZu.UniformsUtils).clone(copyShader.uniforms);\n        this.copyUniforms[\"opacity\"].value = 1.0;\n        this.materialCopy = new (0, $6OvZu.ShaderMaterial)({\n            uniforms: this.copyUniforms,\n            vertexShader: copyShader.vertexShader,\n            fragmentShader: copyShader.fragmentShader,\n            blending: (0, $6OvZu.AdditiveBlending),\n            depthTest: false,\n            depthWrite: false,\n            transparent: true\n        });\n        this.enabled = true;\n        this.needsSwap = false;\n        this._oldClearColor = new (0, $6OvZu.Color)();\n        this.oldClearAlpha = 1;\n        this.basic = new (0, $6OvZu.MeshBasicMaterial)();\n        this.fsQuad = new (0, $MIC3f.FullScreenQuad)(null);\n    }\n    dispose() {\n        for(let i = 0; i < this.renderTargetsHorizontal.length; i++)this.renderTargetsHorizontal[i].dispose();\n        for(let i = 0; i < this.renderTargetsVertical.length; i++)this.renderTargetsVertical[i].dispose();\n        this.renderTargetBright.dispose();\n    }\n    setSize(width, height) {\n        let resx = Math.round(width / 2);\n        let resy = Math.round(height / 2);\n        this.renderTargetBright.setSize(resx, resy);\n        for(let i = 0; i < this.nMips; i++){\n            this.renderTargetsHorizontal[i].setSize(resx, resy);\n            this.renderTargetsVertical[i].setSize(resx, resy);\n            this.separableBlurMaterials[i].uniforms[\"texSize\"].value = new (0, $6OvZu.Vector2)(resx, resy);\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n    }\n    render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n        renderer.getClearColor(this._oldClearColor);\n        this.oldClearAlpha = renderer.getClearAlpha();\n        const oldAutoClear = renderer.autoClear;\n        renderer.autoClear = false;\n        renderer.setClearColor(this.clearColor, 0);\n        if (maskActive) renderer.state.buffers.stencil.setTest(false);\n        // Render input to screen\n        if (this.renderToScreen) {\n            this.fsQuad.material = this.basic;\n            this.basic.map = readBuffer.texture;\n            renderer.setRenderTarget(null);\n            renderer.clear();\n            this.fsQuad.render(renderer);\n        }\n        // 1. Extract Bright Areas\n        this.highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n        this.highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n        this.fsQuad.material = this.materialHighPassFilter;\n        renderer.setRenderTarget(this.renderTargetBright);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        // 2. Blur All the mips progressively\n        let inputRenderTarget = this.renderTargetBright;\n        for(let i = 0; i < this.nMips; i++){\n            this.fsQuad.material = this.separableBlurMaterials[i];\n            this.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = inputRenderTarget.texture;\n            this.separableBlurMaterials[i].uniforms[\"direction\"].value = $5f35d15544f4e7ae$export$d4d608c865617544.BlurDirectionX;\n            renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n            renderer.clear();\n            this.fsQuad.render(renderer);\n            this.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = this.renderTargetsHorizontal[i].texture;\n            this.separableBlurMaterials[i].uniforms[\"direction\"].value = $5f35d15544f4e7ae$export$d4d608c865617544.BlurDirectionY;\n            renderer.setRenderTarget(this.renderTargetsVertical[i]);\n            renderer.clear();\n            this.fsQuad.render(renderer);\n            inputRenderTarget = this.renderTargetsVertical[i];\n        }\n        // Composite All the mips\n        this.fsQuad.material = this.compositeMaterial;\n        this.compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n        this.compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n        this.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n        renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        // Blend it additively over the input texture\n        this.fsQuad.material = this.materialCopy;\n        this.copyUniforms[\"tDiffuse\"].value = this.renderTargetsHorizontal[0].texture;\n        if (maskActive) renderer.state.buffers.stencil.setTest(true);\n        if (this.renderToScreen) {\n            renderer.setRenderTarget(null);\n            this.fsQuad.render(renderer);\n        } else {\n            renderer.setRenderTarget(readBuffer);\n            this.fsQuad.render(renderer);\n        }\n        // Restore renderer settings\n        renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n        renderer.autoClear = oldAutoClear;\n    }\n    getSeperableBlurMaterial(kernelRadius) {\n        return new (0, $6OvZu.ShaderMaterial)({\n            defines: {\n                \"KERNEL_RADIUS\": kernelRadius,\n                \"SIGMA\": kernelRadius\n            },\n            uniforms: {\n                \"colorTexture\": {\n                    value: null\n                },\n                \"texSize\": {\n                    value: new (0, $6OvZu.Vector2)(0.5, 0.5)\n                },\n                \"direction\": {\n                    value: new (0, $6OvZu.Vector2)(0.5, 0.5)\n                }\n            },\n            vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n            fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n        });\n    }\n    getCompositeMaterial(nMips) {\n        return new (0, $6OvZu.ShaderMaterial)({\n            defines: {\n                \"NUM_MIPS\": nMips\n            },\n            uniforms: {\n                \"blurTexture1\": {\n                    value: null\n                },\n                \"blurTexture2\": {\n                    value: null\n                },\n                \"blurTexture3\": {\n                    value: null\n                },\n                \"blurTexture4\": {\n                    value: null\n                },\n                \"blurTexture5\": {\n                    value: null\n                },\n                \"dirtTexture\": {\n                    value: null\n                },\n                \"bloomStrength\": {\n                    value: 1.0\n                },\n                \"bloomFactors\": {\n                    value: null\n                },\n                \"bloomTintColors\": {\n                    value: null\n                },\n                \"bloomRadius\": {\n                    value: 0.0\n                }\n            },\n            vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n            fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform sampler2D dirtTexture;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n        });\n    }\n}\n$5f35d15544f4e7ae$export$d4d608c865617544.BlurDirectionX = new (0, $6OvZu.Vector2)(1.0, 0.0);\n$5f35d15544f4e7ae$export$d4d608c865617544.BlurDirectionY = new (0, $6OvZu.Vector2)(0.0, 1.0);\n\n});\nparcelRequire.register(\"d7LYa\", function(module, exports) {\n\n$parcel$export(module.exports, \"LuminosityHighPassShader\", function () { return $98e1238da1fefc22$export$30029d01c9072e8b; });\n\nvar $6OvZu = parcelRequire(\"6OvZu\");\n/**\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */ const $98e1238da1fefc22$export$30029d01c9072e8b = {\n    shaderID: \"luminosityHighPass\",\n    uniforms: {\n        \"tDiffuse\": {\n            value: null\n        },\n        \"luminosityThreshold\": {\n            value: 1.0\n        },\n        \"smoothWidth\": {\n            value: 1.0\n        },\n        \"defaultColor\": {\n            value: new (0, $6OvZu.Color)(0x000000)\n        },\n        \"defaultOpacity\": {\n            value: 0.0\n        }\n    },\n    vertexShader: /* glsl */ `\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n    fragmentShader: /* glsl */ `\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}`\n};\n\n});\n\n\nparcelRequire.register(\"8uPQJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"RenderPass\", function () { return $62f95850d7531858$export$f63ea822f020b5b0; });\n\nvar $6OvZu = parcelRequire(\"6OvZu\");\n\nvar $MIC3f = parcelRequire(\"MIC3f\");\nclass $62f95850d7531858$export$f63ea822f020b5b0 extends (0, $MIC3f.Pass) {\n    constructor(scene, camera, overrideMaterial, clearColor, clearAlpha){\n        super();\n        this.scene = scene;\n        this.camera = camera;\n        this.overrideMaterial = overrideMaterial;\n        this.clearColor = clearColor;\n        this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n        this.clear = true;\n        this.clearDepth = false;\n        this.needsSwap = false;\n        this._oldClearColor = new (0, $6OvZu.Color)();\n    }\n    render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n        const oldAutoClear = renderer.autoClear;\n        renderer.autoClear = false;\n        let oldClearAlpha, oldOverrideMaterial;\n        if (this.overrideMaterial !== undefined) {\n            oldOverrideMaterial = this.scene.overrideMaterial;\n            this.scene.overrideMaterial = this.overrideMaterial;\n        }\n        if (this.clearColor) {\n            renderer.getClearColor(this._oldClearColor);\n            oldClearAlpha = renderer.getClearAlpha();\n            renderer.setClearColor(this.clearColor, this.clearAlpha);\n        }\n        if (this.clearDepth) renderer.clearDepth();\n        renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n        // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n        if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n        renderer.render(this.scene, this.camera);\n        if (this.clearColor) renderer.setClearColor(this._oldClearColor, oldClearAlpha);\n        if (this.overrideMaterial !== undefined) this.scene.overrideMaterial = oldOverrideMaterial;\n        renderer.autoClear = oldAutoClear;\n    }\n}\n\n});\n\n})();\n//# sourceMappingURL=confetti-text-glow.10abab31.js.map\n","import {\n\tBufferGeometry,\n\tClock,\n\tFloat32BufferAttribute,\n\tLinearFilter,\n\tMesh,\n\tOrthographicCamera,\n\tRGBAFormat,\n\tVector2,\n\tWebGLRenderTarget\n} from 'three';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { ShaderPass } from '../postprocessing/ShaderPass.js';\nimport { MaskPass } from '../postprocessing/MaskPass.js';\nimport { ClearMaskPass } from '../postprocessing/MaskPass.js';\n\nclass EffectComposer {\n\n\tconstructor( renderer, renderTarget ) {\n\n\t\tthis.renderer = renderer;\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\tconst parameters = {\n\t\t\t\tminFilter: LinearFilter,\n\t\t\t\tmagFilter: LinearFilter,\n\t\t\t\tformat: RGBAFormat\n\t\t\t};\n\n\t\t\tconst size = renderer.getSize( new Vector2() );\n\t\t\tthis._pixelRatio = renderer.getPixelRatio();\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = new WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, parameters );\n\t\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\n\t\t} else {\n\n\t\t\tthis._pixelRatio = 1;\n\t\t\tthis._width = renderTarget.width;\n\t\t\tthis._height = renderTarget.height;\n\n\t\t}\n\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\t\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t\tthis.renderToScreen = true;\n\n\t\tthis.passes = [];\n\n\t\t// dependencies\n\n\t\tif ( CopyShader === undefined ) {\n\n\t\t\tconsole.error( 'THREE.EffectComposer relies on CopyShader' );\n\n\t\t}\n\n\t\tif ( ShaderPass === undefined ) {\n\n\t\t\tconsole.error( 'THREE.EffectComposer relies on ShaderPass' );\n\n\t\t}\n\n\t\tthis.copyPass = new ShaderPass( CopyShader );\n\n\t\tthis.clock = new Clock();\n\n\t}\n\n\tswapBuffers() {\n\n\t\tconst tmp = this.readBuffer;\n\t\tthis.readBuffer = this.writeBuffer;\n\t\tthis.writeBuffer = tmp;\n\n\t}\n\n\taddPass( pass ) {\n\n\t\tthis.passes.push( pass );\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t}\n\n\tinsertPass( pass, index ) {\n\n\t\tthis.passes.splice( index, 0, pass );\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t}\n\n\tremovePass( pass ) {\n\n\t\tconst index = this.passes.indexOf( pass );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.passes.splice( index, 1 );\n\n\t\t}\n\n\t}\n\n\tisLastEnabledPass( passIndex ) {\n\n\t\tfor ( let i = passIndex + 1; i < this.passes.length; i ++ ) {\n\n\t\t\tif ( this.passes[ i ].enabled ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\trender( deltaTime ) {\n\n\t\t// deltaTime value is in seconds\n\n\t\tif ( deltaTime === undefined ) {\n\n\t\t\tdeltaTime = this.clock.getDelta();\n\n\t\t}\n\n\t\tconst currentRenderTarget = this.renderer.getRenderTarget();\n\n\t\tlet maskActive = false;\n\n\t\tfor ( let i = 0, il = this.passes.length; i < il; i ++ ) {\n\n\t\t\tconst pass = this.passes[ i ];\n\n\t\t\tif ( pass.enabled === false ) continue;\n\n\t\t\tpass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );\n\n\t\t\tif ( pass.needsSwap ) {\n\n\t\t\t\tif ( maskActive ) {\n\n\t\t\t\t\tconst context = this.renderer.getContext();\n\t\t\t\t\tconst stencil = this.renderer.state.buffers.stencil;\n\n\t\t\t\t\t//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );\n\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );\n\n\t\t\t\t\t//context.stencilFunc( context.EQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.EQUAL, 1, 0xffffffff );\n\n\t\t\t\t}\n\n\t\t\t\tthis.swapBuffers();\n\n\t\t\t}\n\n\t\t\tif ( MaskPass !== undefined ) {\n\n\t\t\t\tif ( pass instanceof MaskPass ) {\n\n\t\t\t\t\tmaskActive = true;\n\n\t\t\t\t} else if ( pass instanceof ClearMaskPass ) {\n\n\t\t\t\t\tmaskActive = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.renderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n\treset( renderTarget ) {\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\tconst size = this.renderer.getSize( new Vector2() );\n\t\t\tthis._pixelRatio = this.renderer.getPixelRatio();\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\trenderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t\t}\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tconst effectiveWidth = this._width * this._pixelRatio;\n\t\tconst effectiveHeight = this._height * this._pixelRatio;\n\n\t\tthis.renderTarget1.setSize( effectiveWidth, effectiveHeight );\n\t\tthis.renderTarget2.setSize( effectiveWidth, effectiveHeight );\n\n\t\tfor ( let i = 0; i < this.passes.length; i ++ ) {\n\n\t\t\tthis.passes[ i ].setSize( effectiveWidth, effectiveHeight );\n\n\t\t}\n\n\t}\n\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this._width, this._height );\n\n\t}\n\n}\n\n\nclass Pass {\n\n\tconstructor() {\n\n\t\t// if set to true, the pass is processed by the composer\n\t\tthis.enabled = true;\n\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\t\tthis.needsSwap = true;\n\n\t\t// if set to true, the pass clears its buffer before rendering\n\t\tthis.clear = false;\n\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\tsetSize( /* width, height */ ) {}\n\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nconst _geometry = new BufferGeometry();\n_geometry.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n_geometry.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\nclass FullScreenQuad {\n\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { EffectComposer, Pass, FullScreenQuad };\n","/**\n * Full-screen textured quad shader\n */\n\nvar CopyShader = {\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'opacity': { value: 1.0 }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}`\n\n};\n\nexport { CopyShader };\n","import {\n\tShaderMaterial,\n\tUniformsUtils\n} from 'three';\nimport { Pass, FullScreenQuad } from '../postprocessing/Pass.js';\n\nclass ShaderPass extends Pass {\n\n\tconstructor( shader, textureID ) {\n\n\t\tsuper();\n\n\t\tthis.textureID = ( textureID !== undefined ) ? textureID : 'tDiffuse';\n\n\t\tif ( shader instanceof ShaderMaterial ) {\n\n\t\t\tthis.uniforms = shader.uniforms;\n\n\t\t\tthis.material = shader;\n\n\t\t} else if ( shader ) {\n\n\t\t\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\n\n\t\t\tthis.material = new ShaderMaterial( {\n\n\t\t\t\tdefines: Object.assign( {}, shader.defines ),\n\t\t\t\tuniforms: this.uniforms,\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t\t} );\n\n\t\t}\n\n\t\tthis.fsQuad = new FullScreenQuad( this.material );\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\n\n\t\t}\n\n\t\tthis.fsQuad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n}\n\nexport { ShaderPass };\n","import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tOrthographicCamera,\n\tMesh\n} from 'three';\n\nclass Pass {\n\n\tconstructor() {\n\n\t\t// if set to true, the pass is processed by the composer\n\t\tthis.enabled = true;\n\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\t\tthis.needsSwap = true;\n\n\t\t// if set to true, the pass clears its buffer before rendering\n\t\tthis.clear = false;\n\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\tsetSize( /* width, height */ ) {}\n\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nconst _geometry = new BufferGeometry();\n_geometry.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n_geometry.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\nclass FullScreenQuad {\n\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { Pass, FullScreenQuad };\n","import { Pass } from '../postprocessing/Pass.js';\n\nclass MaskPass extends Pass {\n\n\tconstructor( scene, camera ) {\n\n\t\tsuper();\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.clear = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis.inverse = false;\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tconst context = renderer.getContext();\n\t\tconst state = renderer.state;\n\n\t\t// don't update color or depth\n\n\t\tstate.buffers.color.setMask( false );\n\t\tstate.buffers.depth.setMask( false );\n\n\t\t// lock buffers\n\n\t\tstate.buffers.color.setLocked( true );\n\t\tstate.buffers.depth.setLocked( true );\n\n\t\t// set up stencil\n\n\t\tlet writeValue, clearValue;\n\n\t\tif ( this.inverse ) {\n\n\t\t\twriteValue = 0;\n\t\t\tclearValue = 1;\n\n\t\t} else {\n\n\t\t\twriteValue = 1;\n\t\t\tclearValue = 0;\n\n\t\t}\n\n\t\tstate.buffers.stencil.setTest( true );\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\n\t\tstate.buffers.stencil.setClear( clearValue );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t\t// draw into the stencil buffer\n\n\t\trenderer.setRenderTarget( readBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\trenderer.setRenderTarget( writeBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\t// unlock color and depth buffer for subsequent rendering\n\n\t\tstate.buffers.color.setLocked( false );\n\t\tstate.buffers.depth.setLocked( false );\n\n\t\t// only render where stencil is set to 1\n\n\t\tstate.buffers.stencil.setLocked( false );\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t}\n\n}\n\nclass ClearMaskPass extends Pass {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.needsSwap = false;\n\n\t}\n\n\trender( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\trenderer.state.buffers.stencil.setLocked( false );\n\t\trenderer.state.buffers.stencil.setTest( false );\n\n\t}\n\n}\n\nexport { MaskPass, ClearMaskPass };\n","import {\n\tAdditiveBlending,\n\tColor,\n\tLinearFilter,\n\tMeshBasicMaterial,\n\tRGBAFormat,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from '../postprocessing/Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nclass UnrealBloomPass extends Pass {\n\n\tconstructor( resolution, strength, radius, threshold ) {\n\n\t\tsuper();\n\n\t\tthis.strength = ( strength !== undefined ) ? strength : 1;\n\t\tthis.radius = radius;\n\t\tthis.threshold = threshold;\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\t// create color only once here, reuse it later inside the render function\n\t\tthis.clearColor = new Color( 0, 0, 0 );\n\n\t\t// render targets\n\t\tconst pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\n\t\tthis.renderTargetsHorizontal = [];\n\t\tthis.renderTargetsVertical = [];\n\t\tthis.nMips = 5;\n\t\tlet resx = Math.round( this.resolution.x / 2 );\n\t\tlet resy = Math.round( this.resolution.y / 2 );\n\n\t\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy, pars );\n\t\tthis.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n\t\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tconst renderTargetHorizonal = new WebGLRenderTarget( resx, resy, pars );\n\n\t\t\trenderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n\t\t\trenderTargetHorizonal.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsHorizontal.push( renderTargetHorizonal );\n\n\t\t\tconst renderTargetVertical = new WebGLRenderTarget( resx, resy, pars );\n\n\t\t\trenderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsVertical.push( renderTargetVertical );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// luminosity high pass material\n\n\t\tif ( LuminosityHighPassShader === undefined )\n\t\t\tconsole.error( 'THREE.UnrealBloomPass relies on LuminosityHighPassShader' );\n\n\t\tconst highPassShader = LuminosityHighPassShader;\n\t\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\n\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = threshold;\n\t\tthis.highPassUniforms[ 'smoothWidth' ].value = 0.01;\n\n\t\tthis.materialHighPassFilter = new ShaderMaterial( {\n\t\t\tuniforms: this.highPassUniforms,\n\t\t\tvertexShader: highPassShader.vertexShader,\n\t\t\tfragmentShader: highPassShader.fragmentShader,\n\t\t\tdefines: {}\n\t\t} );\n\n\t\t// Gaussian Blur Materials\n\t\tthis.separableBlurMaterials = [];\n\t\tconst kernelSizeArray = [ 3, 5, 7, 9, 11 ];\n\t\tresx = Math.round( this.resolution.x / 2 );\n\t\tresy = Math.round( this.resolution.y / 2 );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new Vector2( resx, resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// Composite material\n\t\tthis.compositeMaterial = this.getCompositeMaterial( this.nMips );\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;\n\t\tthis.compositeMaterial.needsUpdate = true;\n\n\t\tconst bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;\n\t\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\t// copy material\n\t\tif ( CopyShader === undefined ) {\n\n\t\t\tconsole.error( 'THREE.UnrealBloomPass relies on CopyShader' );\n\n\t\t}\n\n\t\tconst copyShader = CopyShader;\n\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\t\tthis.copyUniforms[ 'opacity' ].value = 1.0;\n\n\t\tthis.materialCopy = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis.basic = new MeshBasicMaterial();\n\n\t\tthis.fsQuad = new FullScreenQuad( null );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {\n\n\t\t\tthis.renderTargetsVertical[ i ].dispose();\n\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tlet resx = Math.round( width / 2 );\n\t\tlet resy = Math.round( height / 2 );\n\n\t\tthis.renderTargetBright.setSize( resx, resy );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new Vector2( resx, resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\trenderer.getClearColor( this._oldClearColor );\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor( this.clearColor, 0 );\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t// Render input to screen\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.fsQuad.material = this.basic;\n\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;\n\t\tthis.fsQuad.material = this.materialHighPassFilter;\n\n\t\trenderer.setRenderTarget( this.renderTargetBright );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tlet inputRenderTarget = this.renderTargetBright;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.fsQuad.material = this.separableBlurMaterials[ i ];\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\n\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis.fsQuad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis.fsQuad.material = this.materialCopy;\n\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n\tgetSeperableBlurMaterial( kernelRadius ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'KERNEL_RADIUS': kernelRadius,\n\t\t\t\t'SIGMA': kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetCompositeMaterial( nMips ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'NUM_MIPS': nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'blurTexture1': { value: null },\n\t\t\t\t'blurTexture2': { value: null },\n\t\t\t\t'blurTexture3': { value: null },\n\t\t\t\t'blurTexture4': { value: null },\n\t\t\t\t'blurTexture5': { value: null },\n\t\t\t\t'dirtTexture': { value: null },\n\t\t\t\t'bloomStrength': { value: 1.0 },\n\t\t\t\t'bloomFactors': { value: null },\n\t\t\t\t'bloomTintColors': { value: null },\n\t\t\t\t'bloomRadius': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform sampler2D dirtTexture;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n}\n\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { UnrealBloomPass };\n","import {\n\tColor\n} from 'three';\n\n/**\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nconst LuminosityHighPassShader = {\n\n\tshaderID: 'luminosityHighPass',\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'luminosityThreshold': { value: 1.0 },\n\t\t'smoothWidth': { value: 1.0 },\n\t\t'defaultColor': { value: new Color( 0x000000 ) },\n\t\t'defaultOpacity': { value: 0.0 }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}`\n\n};\n\nexport { LuminosityHighPassShader };\n","import {\n\tColor\n} from 'three';\nimport { Pass } from '../postprocessing/Pass.js';\n\nclass RenderPass extends Pass {\n\n\tconstructor( scene, camera, overrideMaterial, clearColor, clearAlpha ) {\n\n\t\tsuper();\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.overrideMaterial = overrideMaterial;\n\n\t\tthis.clearColor = clearColor;\n\t\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\n\n\t\tthis.clear = true;\n\t\tthis.clearDepth = false;\n\t\tthis.needsSwap = false;\n\t\tthis._oldClearColor = new Color();\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tlet oldClearAlpha, oldOverrideMaterial;\n\n\t\tif ( this.overrideMaterial !== undefined ) {\n\n\t\t\toldOverrideMaterial = this.scene.overrideMaterial;\n\n\t\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\t}\n\n\t\tif ( this.clearColor ) {\n\n\t\t\trenderer.getClearColor( this._oldClearColor );\n\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\n\n\t\t}\n\n\t\tif ( this.clearDepth ) {\n\n\t\t\trenderer.clearDepth();\n\n\t\t}\n\n\t\trenderer.setRenderTarget( this.renderToScreen ? null : readBuffer );\n\n\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\trenderer.render( this.scene, this.camera );\n\n\t\tif ( this.clearColor ) {\n\n\t\t\trenderer.setClearColor( this._oldClearColor, oldClearAlpha );\n\n\t\t}\n\n\t\tif ( this.overrideMaterial !== undefined ) {\n\n\t\t\tthis.scene.overrideMaterial = oldOverrideMaterial;\n\n\t\t}\n\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n}\n\nexport { RenderPass };\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$666025b2fd847a1f$export$7fe01e6ab8aa748c","$6OvZu","$2wkXx","$gy7bn","$im5gf","constructor","renderer","renderTarget","undefined","parameters","minFilter","LinearFilter","magFilter","format","RGBAFormat","size","getSize","Vector2","_pixelRatio","getPixelRatio","_width","width","_height","height","WebGLRenderTarget","texture","name","renderTarget1","renderTarget2","clone","writeBuffer","readBuffer","renderToScreen","passes","CopyShader","console","error","ShaderPass","copyPass","clock","Clock","swapBuffers","tmp","addPass","pass","push","setSize","insertPass","index","splice","removePass","indexOf","isLastEnabledPass","passIndex","i","length","enabled","render","deltaTime","getDelta","currentRenderTarget","getRenderTarget","maskActive","il","needsSwap","context","getContext","stencil","state","buffers","setFunc","NOTEQUAL","EQUAL","MaskPass","ClearMaskPass","setRenderTarget","reset","dispose","effectiveWidth","effectiveHeight","setPixelRatio","pixelRatio","OrthographicCamera","$666025b2fd847a1f$var$_geometry","BufferGeometry","setAttribute","Float32BufferAttribute","$1d5ed4039cd88450$export$57f84a24a9a6130d","uniforms","value","vertexShader","fragmentShader","$c0c564a2ac95bcdc$export$c55093fd4f9e42f0","$MIC3f","Pass","shader","textureID","ShaderMaterial","material","UniformsUtils","defines","assign","fsQuad","FullScreenQuad","clear","autoClearColor","autoClearDepth","autoClearStencil","$092716f80203f221$export$802bc10488da99c7","$092716f80203f221$export$3983474c8e6e978b","$092716f80203f221$var$_camera","$092716f80203f221$var$_geometry","_mesh","Mesh","geometry","$d5ce5cd3f9e337b1$export$bb424a4005d6dde0","$d5ce5cd3f9e337b1$export$8d8650aed29c6251","scene","camera","inverse","writeValue","clearValue","color","setMask","depth","setLocked","setTest","setOp","REPLACE","ALWAYS","setClear","KEEP","$5f35d15544f4e7ae$export$d4d608c865617544","$d7LYa","resolution","strength","radius","threshold","x","y","clearColor","Color","pars","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","generateMipmaps","renderTargetHorizonal","renderTargetVertical","LuminosityHighPassShader","highPassShader","highPassUniforms","materialHighPassFilter","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","needsUpdate","bloomTintColors","Vector3","copyShader","copyUniforms","materialCopy","blending","AdditiveBlending","depthTest","depthWrite","transparent","_oldClearColor","oldClearAlpha","basic","MeshBasicMaterial","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","map","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius","$98e1238da1fefc22$export$30029d01c9072e8b","shaderID","$62f95850d7531858$export$f63ea822f020b5b0","overrideMaterial","clearAlpha","clearDepth","oldOverrideMaterial"],"version":3,"file":"confetti-text-glow.10abab31.js.map"}